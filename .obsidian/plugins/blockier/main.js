/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BlockierPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var import_view = require("@codemirror/view");

// src/regex.ts
var BLOCKS = {
  CHECKBOX: /- \[.]/.source,
  BULLET: /-|\*|\+/.source,
  NUMBER: /[0-9]+[.)]/.source,
  HEADING: /#{1,6}/.source,
  QUOTE: />/.source
};
var ANY_BLOCK = new RegExp(
  `${BLOCKS.CHECKBOX}|${BLOCKS.BULLET}|${BLOCKS.NUMBER}|${BLOCKS.HEADING}|${BLOCKS.QUOTE}`
);
var LINE_START_BLOCK = new RegExp(`^\\s*(?:${ANY_BLOCK.source}) `);
var OVERRIDABLE_BLOCK = new RegExp(`${BLOCKS.CHECKBOX}|${BLOCKS.BULLET}|${BLOCKS.NUMBER}`);
var OVERRIDING_BLOCK = new RegExp(`${BLOCKS.BULLET}|${BLOCKS.NUMBER}`);
var IS_OVERRIDING = new RegExp(
  `^(?<whitespace>\\s*)(?<existing>${OVERRIDABLE_BLOCK.source}) (?<new>${OVERRIDING_BLOCK.source})`
);

// src/replace.ts
function tryReplace(editor) {
  const lineNum = editor.getCursor().line;
  const ch = editor.getCursor().ch;
  const line = editor.getLine(lineNum);
  const match = line.match(IS_OVERRIDING);
  if ((match == null ? void 0 : match[0].length) !== ch)
    return;
  const groups = match.groups;
  if (groups.new === groups.existing)
    return;
  const leftPos = {
    line: lineNum,
    ch: groups.whitespace.length
  };
  const rightPos = {
    line: lineNum,
    ch: match[0].length
  };
  editor.replaceRange(groups.new, leftPos, rightPos);
}

// src/select.ts
function runSelectBlock(editor, avoidPrefixes) {
  const selections = editor.listSelections();
  const newSelections = selections.map((sel) => selectLine(editor, sel, avoidPrefixes));
  editor.setSelections(newSelections);
}
function selectLine(editor, selection, avoidPrefixes) {
  var _a, _b;
  const [start, end] = orderPositions(selection.anchor, selection.head);
  if (start.line !== end.line || !avoidPrefixes) {
    return {
      anchor: {
        ch: 0,
        line: start.line
      },
      head: {
        ch: editor.getLine(end.line).length,
        line: end.line
      }
    };
  } else {
    const lineNum = start.line;
    const line = editor.getLine(lineNum);
    const paragraphStart = (_b = (_a = line.match(LINE_START_BLOCK)) == null ? void 0 : _a[0].length) != null ? _b : 0;
    return {
      anchor: {
        ch: paragraphStart,
        line: lineNum
      },
      head: {
        ch: line.length,
        line: lineNum
      }
    };
  }
}
function orderPositions(anchor, head) {
  if (anchor.line < head.line) {
    return [anchor, head];
  } else if (anchor.line > head.line) {
    return [head, anchor];
  } else if (anchor.ch < head.ch) {
    return [anchor, head];
  } else {
    return [head, anchor];
  }
}

// src/suggest.ts
var import_obsidian = require("obsidian");
var BracketSuggest = class extends import_obsidian.EditorSuggest {
  constructor(app, plugin, opts) {
    super(app);
    this.app = app;
    this.plugin = plugin;
    this.opts = opts;
  }
  onTrigger(cursor, editor) {
    const line = editor.getLine(cursor.line);
    const match = line.slice(0, cursor.ch).match(this.opts.triggerRegex);
    if (match) {
      const query = match[1];
      return {
        start: offsetCh(cursor, -query.length),
        end: cursor,
        query
      };
    }
    return null;
  }
  getSuggestions(context) {
    const suggestions = this.opts.suggestions;
    if (context.query === "")
      return suggestions;
    const queriedSuggestionIndex = suggestions.findIndex(
      (str) => str.startsWith(context.query)
    );
    if (queriedSuggestionIndex === -1)
      return suggestions;
    const newSuggestions = [suggestions[queriedSuggestionIndex]];
    newSuggestions.push(...suggestions.slice(0, queriedSuggestionIndex));
    newSuggestions.push(...suggestions.slice(queriedSuggestionIndex + 1));
    return newSuggestions;
  }
  renderSuggestion(value, el) {
    const div = el.createDiv();
    div.classList.add("markdown-rendered", "markdown-preview-view", this.opts.suggestionClass);
    import_obsidian.MarkdownRenderer.render(this.app, this.opts.renderMarkdown(value), div, "", this.plugin);
  }
  selectSuggestion(value) {
    if (!this.context)
      return;
    const context = this.context;
    const cursor = context.editor.getCursor();
    context.editor.replaceRange(value + "] ", context.start, context.end);
    const offsetAmount = context.editor.getLine(cursor.line).indexOf("]") + 2 - cursor.ch;
    const newCursor = offsetCh(cursor, offsetAmount);
    context.editor.setCursor(newCursor);
    const next2Char = context.editor.getRange(newCursor, offsetCh(newCursor, 2));
    if (next2Char === "] ") {
      context.editor.replaceRange("", newCursor, offsetCh(newCursor, 2));
    } else if (next2Char[0] === "]") {
      context.editor.replaceRange("", newCursor, offsetCh(newCursor, 1));
    }
  }
};
var CheckboxSuggest = class extends BracketSuggest {
  constructor(app, plugin, characters) {
    super(app, plugin, {
      suggestions: characters.split(""),
      triggerRegex: /^\s*- \[(.?)$/,
      suggestionClass: "blockier-checkbox-suggestion",
      renderMarkdown: (suggestion) => `- [${suggestion}] \`${suggestion}\``
    });
  }
};
var CalloutSuggest = class extends BracketSuggest {
  constructor(app, plugin, csv) {
    super(app, plugin, {
      suggestions: csv.split(",").map((str) => str.trim()),
      // allow 0/1 space before the `[!` - https://github.com/blorbb/obsidian-blockier/issues/5
      triggerRegex: /^\s*> ?\[!(\w*)$/,
      suggestionClass: "blockier-callout-suggestion",
      renderMarkdown: (suggestion) => `> [!${suggestion}]`
    });
  }
};
function offsetCh(position, chs) {
  return {
    ...position,
    ch: position.ch + chs
  };
}

// src/main.ts
var DEFAULT_SETTINGS = {
  replaceBlocks: true,
  selectAllAvoidsPrefixes: true,
  showCheckboxSuggestions: false,
  checkboxVariants: ' x><!-/?*nliISpcb"0123456789',
  showCalloutSuggestions: true,
  calloutSuggestions: "note, summary, info, todo, tip, check, help, warning, fail, error, bug, example, quote",
  enableSelectBlockEE: true
};
var BlockierPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    this.addCommand({
      id: "select-block",
      name: "Select block",
      editorCallback: (editor) => {
        runSelectBlock(editor, this.settings.selectAllAvoidsPrefixes);
      }
    });
    this.registerEditorExtension(
      import_view.keymap.of([
        {
          key: "Space",
          run: () => {
            const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
            if (this.settings.replaceBlocks && view) {
              tryReplace(view.editor);
            }
            return false;
          }
        }
      ])
    );
    if (this.settings.enableSelectBlockEE) {
      this.registerEditorExtension(
        import_view.keymap.of([
          {
            key: "c-a",
            // ctrl a
            mac: "m-a",
            // cmd a
            run: () => {
              var _a;
              const editor = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor;
              if (editor) {
                runSelectBlock(editor, this.settings.selectAllAvoidsPrefixes);
              }
              return true;
            }
          }
        ])
      );
    }
    if (this.settings.showCheckboxSuggestions) {
      this.registerEditorSuggest(
        new CheckboxSuggest(this.app, this, this.settings.checkboxVariants)
      );
    }
    if (this.settings.showCalloutSuggestions) {
      this.registerEditorSuggest(
        new CalloutSuggest(this.app, this, this.settings.calloutSuggestions)
      );
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Replace blocks").setDesc(
      "Replaces the block type if you enter the prefix at the start of the paragraph."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.replaceBlocks).onChange(async (value) => {
        this.plugin.settings.replaceBlocks = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Use ctrl/cmd-A for select block").setDesc(
      "Whether to override ctrl/cmd-A for the select block command. Disable this and set a hotkey in hotkey settings if you prefer a different hotkey."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableSelectBlockEE).onChange(async (value) => {
        this.plugin.settings.enableSelectBlockEE = value;
        await this.plugin.saveSettings();
        new import_obsidian2.Notice("Reload required!");
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Only select paragraphs").setDesc("Whether the Select block command will avoid selecting block prefixes.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.selectAllAvoidsPrefixes).onChange(async (value) => {
        this.plugin.settings.selectAllAvoidsPrefixes = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Show checkbox suggestions").setDesc(
      "Whether to show suggestions of checkbox variants supported by your theme. Reload required."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showCheckboxSuggestions).onChange(async (value) => {
        this.plugin.settings.showCheckboxSuggestions = value;
        await this.plugin.saveSettings();
        new import_obsidian2.Notice("Reload required!");
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Checkbox suggestion variants").setDesc(
      "Which checkboxes to be shown in the suggestion. These should be supported by your theme. Each character will be one suggestion."
    ).addText(
      (text) => text.setValue(this.plugin.settings.checkboxVariants).onChange(async (value) => {
        this.plugin.settings.checkboxVariants = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Show callout suggestions").setDesc(
      "Whether to show suggestions of callout variants supported by your theme. Reload required."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showCalloutSuggestions).onChange(async (value) => {
        this.plugin.settings.showCalloutSuggestions = value;
        await this.plugin.saveSettings();
        new import_obsidian2.Notice("Reload required!");
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Callout suggestion variants").setDesc("Which callouts to be shown in the suggestion. Separate by commas.").addTextArea(
      (text) => text.setValue(this.plugin.settings.calloutSuggestions).onChange(async (value) => {
        this.plugin.settings.calloutSuggestions = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
