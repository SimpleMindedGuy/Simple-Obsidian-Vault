/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => LatexEnvironments
});
var import_obsidian3 = __toModule(require("obsidian"));

// src/settings.ts
var LatexEnvironmentsSettings = class {
  constructor() {
    this.defaultEnvironment = "multline";
    this.customEnvironments = [];
  }
};
function ensureSettings(loaded) {
  var _a, _b;
  const settings = new LatexEnvironmentsSettings();
  settings.defaultEnvironment = (_a = loaded.defaultEnvironment) != null ? _a : settings.defaultEnvironment;
  settings.customEnvironments = (_b = loaded.customEnvironments) != null ? _b : settings.customEnvironments;
  return settings;
}

// src/envmodal.ts
var import_obsidian = __toModule(require("obsidian"));

// src/environmentNames.ts
var DISPLAY_EQUATIONS = [
  "equation",
  "equation*",
  "gather",
  "gather*",
  "multline",
  "multline*",
  "split",
  "align",
  "align*",
  "flalign",
  "flalign*",
  "alignat",
  "alignat*"
];
var MATRICES = [
  "matrix",
  "pmatrix",
  "bmatrix",
  "Bmatrix",
  "vmatrix",
  "Vmatrix",
  "smallmatrix"
];
var SUB_ENVIRONMENTS = ["multlined", "gathered", "aligned", "cases"];
var DEFAULT_ENVIRONMENTS = [
  ...DISPLAY_EQUATIONS,
  ...MATRICES,
  ...SUB_ENVIRONMENTS
];

// src/envmodal.ts
var EnvModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, settings, name, callback) {
    super(app);
    this.settings = settings;
    this.name = name;
    this.callback = callback;
    this.matched = false;
    this.setInstructions([
      { command: "\u2191\u2193", purpose: "to navigate" },
      { command: "\u21B5", purpose: "to select" },
      { command: "esc", purpose: "to dismiss" }
    ]);
    this.setPlaceholder("environment name");
  }
  getItems() {
    return Array.from(new Set([this.settings.defaultEnvironment].concat(this.settings.customEnvironments, DEFAULT_ENVIRONMENTS)));
  }
  getItemText(item) {
    this.matched = true;
    return item;
  }
  onNoSuggestion() {
    this.matched = false;
  }
  onChooseItem(item, _evt) {
    if (this.matched) {
      this.callback(item);
    } else {
      this.callback(this.inputEl.value);
    }
  }
  static callback(app, settings, defaultName, call) {
    new EnvModal(app, settings, defaultName, call).open();
  }
};

// src/latexEnvironmentsSettingsTab.ts
var import_obsidian2 = __toModule(require("obsidian"));
var LatexEnvironmentsSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for latex environments" });
    new import_obsidian2.Setting(containerEl).setName("Default environment").setDesc("The default environment to insert").addText((text) => text.setPlaceholder("environment").setValue(this.plugin.settings.defaultEnvironment).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.defaultEnvironment = value;
      yield this.plugin.saveData(this.plugin.settings);
    })));
    new import_obsidian2.Setting(containerEl).setName("Extra environments").setDesc("Environment names to be suggested for completion (one per line)").addTextArea((area) => {
      area.setValue(this.plugin.settings.customEnvironments.join("\n")).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.customEnvironments = value.split("\n").map((x) => x.trim()).filter((x) => x.length > 0);
        yield this.plugin.saveData(this.plugin.settings);
      }));
    });
  }
};

// src/actions/action.ts
var Action = class {
  constructor(doc) {
    this.doc = doc;
  }
  suggestName() {
    return void 0;
  }
  get needsName() {
    return true;
  }
};

// src/environment.ts
function newEnvironment(name, cursor, contents = "") {
  return {
    replaceSelection: `\\begin{${name}}${padContents(contents, true)}\\end{${name}}`,
    selection: {
      from: {
        ch: 0,
        line: cursor.line + 1
      }
    }
  };
}
function wrapSelection(name, cursor, contents = "") {
  return {
    replaceSelection: `\\begin{${name}}${padContents(contents)}\\end{${name}}`,
    selection: {
      from: {
        ch: 0,
        line: cursor.line + 1
      }
    }
  };
}
function wrapBlock(name, doc, block) {
  const blockText = block.text.slice(block.startPosition, block.endPosition);
  let cursor = doc.getCursor();
  const start = doc.offsetToPos(block.startPosition);
  if (cursor.line === start.line) {
    cursor = {
      line: cursor.line + 1,
      ch: 0
    };
  }
  return {
    changes: [
      {
        from: doc.offsetToPos(block.startPosition),
        to: doc.offsetToPos(block.endPosition),
        text: `\\begin{${name}}${padContents(blockText)}\\end{${name}}`
      }
    ],
    selection: { from: cursor }
  };
}
function unwrapEnvironment(environment, doc) {
  let cursor = doc.getCursor();
  if (justWhitespace(environment.contents.split("\n", 1)[0])) {
    cursor = {
      line: cursor.line - 1,
      ch: cursor.ch + doc.offsetToPos(environment.begin.from).ch
    };
  }
  return {
    changes: [
      {
        text: trim(environment.contents),
        from: doc.offsetToPos(environment.begin.from),
        to: doc.offsetToPos(environment.end.to)
      }
    ],
    selection: { from: cursor }
  };
}
function changeEnvironment(environment, doc, name) {
  const change = {
    text: `\\begin{${name}}${environment.contents}\\end{${name}}`,
    from: doc.offsetToPos(environment.begin.from),
    to: doc.offsetToPos(environment.end.to)
  };
  return {
    changes: [change],
    selection: { from: doc.getCursor() }
  };
}
function padContents(contents, padEmpty = false) {
  const lines = contents.split("\n");
  return `${getPad(lines[0], padEmpty)}${contents}${getPad(lines[lines.length - 1], padEmpty)}`;
}
function justWhitespace(text) {
  return text.match(/^[ \t]*$/) != null;
}
function getPad(text, padEmpty = false) {
  if (text.length === 0 && padEmpty)
    return "\n";
  if (text.length === 0 || justWhitespace(text))
    return "";
  return "\n";
}
function trim(text) {
  if (text.length === 0)
    return text;
  const start = text.startsWith("\n") ? 1 : 0;
  const end = text.endsWith("\n") ? text.length - 1 : text.length;
  return text.slice(start, end);
}

// src/search.ts
var SearchCursor = class {
  constructor(text, regex, _originalCaret) {
    this.text = text;
    this._originalCaret = _originalCaret;
    if (regex instanceof RegExp) {
      this.regex = regex;
    } else {
      this.regex = new RegExp(regex);
    }
    this.reset();
  }
  reset() {
    this._from = this._originalCaret;
    this._to = this._originalCaret;
    this._caret = this._originalCaret;
  }
  findNext() {
    const text = this.text.slice(this._caret);
    const match = text.match(this.regex);
    if ((match == null ? void 0 : match.index) == null) {
      return void 0;
    }
    this._from = this._caret + match.index;
    this._to = this._caret + match.index + match[0].length;
    this._caret = this._to;
    return match;
  }
  findPrevious() {
    const reverseRegex = new RegExp(`(?<full>${this.regex.source})(?![\\s\\S]*\\k<full>)`, this.regex.flags);
    const text = this.text.slice(0, this._caret);
    const lastMatch = text.match(reverseRegex);
    if ((lastMatch == null ? void 0 : lastMatch.index) == null || (lastMatch == null ? void 0 : lastMatch.groups) == null) {
      return void 0;
    }
    this._from = lastMatch.index;
    this._to = lastMatch.index + lastMatch.groups.full.length;
    this._caret = this._from;
    return lastMatch;
  }
  to() {
    return this._to;
  }
  from() {
    return this._from;
  }
};

// src/mathblock.ts
var MathBlock = class {
  constructor(text, cursor) {
    this.text = text;
    const searchCursor = new SearchCursor(text, "\\$\\$", cursor);
    this.startPosition = searchCursor.findPrevious() != null ? searchCursor.to() : 0;
    searchCursor.reset();
    this.endPosition = searchCursor.findNext() != null ? searchCursor.from() : text.length;
  }
  getEnclosingEnvironment(cursor) {
    const beginEnds = new BeginEnds(this.text, this.startPosition, this.endPosition);
    const environments = Array.from(beginEnds);
    if (beginEnds.isOpen) {
      throw new Error("unclosed environments in block");
    }
    const start = environments.filter((env) => env.type === "begin" && env.from < cursor).pop();
    if (start === void 0) {
      return void 0;
    }
    const after = environments.filter((env) => env.from > start.to);
    let open = 1;
    let end;
    for (const env of after) {
      if (env.type === "begin") {
        open++;
      } else {
        open--;
        if (open === 0) {
          end = env;
          break;
        }
      }
    }
    if (end === void 0) {
      throw new Error("current environment is never closed");
    }
    if (end.to < cursor) {
      return void 0;
    }
    return {
      name: start.name,
      begin: start,
      end,
      contents: this.text.slice(start.to, end.from)
    };
  }
  static isMathMode(_cursor, _editor) {
    return true;
  }
};
var BeginEnds = class {
  constructor(text, start, end) {
    this.text = text;
    this.start = start;
    this.end = end;
    this.openEnvs = [];
    this.search = this.getEnvCursor(this.start);
  }
  reset() {
    this.search = this.getEnvCursor(this.start);
  }
  getEnvCursor(start) {
    return new SearchCursor(this.text, /\\(?<beginEnd>begin|end){\s*(?<name>[^}]+)\s*}/m, start);
  }
  get isOpen() {
    return this.openEnvs.length > 0;
  }
  [Symbol.iterator]() {
    this.reset();
    return this;
  }
  next() {
    const match = this.search.findNext();
    const to = this.search.to();
    if ((match == null ? void 0 : match.groups) == null || to > this.end) {
      return { done: true, value: null };
    }
    switch (match.groups.beginEnd) {
      case "begin": {
        const current = {
          name: match.groups.name,
          type: "begin",
          from: this.search.from(),
          to: this.search.to()
        };
        this.openEnvs.push(current);
        return {
          done: false,
          value: current
        };
      }
      case "end": {
        const current = this.openEnvs.pop();
        if (current === void 0) {
          throw new Error("closing environment which was never opened");
        }
        if (current.name !== match.groups.name) {
          throw new Error("environment not closed properly");
        }
        return {
          done: false,
          value: {
            name: match.groups.name,
            type: "end",
            from: this.search.from(),
            to: this.search.to()
          }
        };
      }
    }
    throw new Error(`regex returned unexpected result ${match[1]}`);
  }
};

// src/actions/wrapAction.ts
var WrapAction = class extends Action {
  prepare() {
    return this;
  }
  transaction(envName) {
    if (this.doc.somethingSelected()) {
      return wrapSelection(envName, this.doc.getCursor(), this.doc.getSelection());
    }
    const block = new MathBlock(this.doc.getValue(), this.doc.posToOffset(this.doc.getCursor()));
    return wrapBlock(envName, this.doc, block);
  }
};

// src/actions/insertAction.ts
var InsertAction = class extends Action {
  prepare() {
    if (this.doc.somethingSelected()) {
      return new WrapAction(this.doc).prepare();
    }
    return this;
  }
  transaction(envName) {
    return newEnvironment(envName, this.doc.getCursor());
  }
};

// src/actions/changeAction.ts
var ChangeAction = class extends Action {
  suggestName() {
    return this.name;
  }
  prepare() {
    const cursor = this.doc.posToOffset(this.doc.getCursor());
    const block = new MathBlock(this.doc.getValue(), cursor);
    this.current = block.getEnclosingEnvironment(cursor);
    if (this.current === void 0 || this.doc.somethingSelected()) {
      return new WrapAction(this.doc);
    }
    this.name = this.current.name;
    return this;
  }
  transaction(envName) {
    if (this.current !== void 0) {
      return changeEnvironment(this.current, this.doc, envName);
    }
    return {};
  }
};

// src/actions/deleteAction.ts
var DeleteAction = class extends Action {
  get needsName() {
    return false;
  }
  prepare() {
    const cursor = this.doc.getCursor();
    const block = new MathBlock(this.doc.getValue(), this.doc.posToOffset(cursor));
    this.current = block.getEnclosingEnvironment(this.doc.posToOffset(cursor));
    return this;
  }
  transaction(_envName) {
    if (this.current !== void 0) {
      return unwrapEnvironment(this.current, this.doc);
    }
    return {};
  }
};

// src/main.ts
var LatexEnvironments = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.settings = new LatexEnvironmentsSettings();
  }
  onload() {
    return __async(this, null, function* () {
      const settings = yield this.loadData();
      if (settings !== null) {
        this.settings = ensureSettings(settings);
      }
      this.addCommand({
        id: "insert-latex-env",
        name: "Insert LaTeX environment",
        editorCallback: this.mathModeCallback(InsertAction)
      });
      this.addCommand({
        id: "change-latex-env",
        name: "Change LaTeX environment",
        editorCallback: this.mathModeCallback(ChangeAction)
      });
      this.addCommand({
        id: "delete-latex-env",
        name: "Delete LaTeX environment",
        editorCallback: this.mathModeCallback(DeleteAction)
      });
      this.addSettingTab(new LatexEnvironmentsSettingTab(this.app, this));
    });
  }
  mathModeCallback(ActionType) {
    return (editor, _view) => {
      try {
        const action = new ActionType(editor).prepare();
        this.withPromptName(editor, action);
      } catch (e) {
        new import_obsidian3.Notice(e.message);
      }
    };
  }
  withPromptName(editor, action) {
    const call = (envName) => {
      editor.transaction(action.transaction(envName));
      editor.focus();
    };
    if (action.needsName) {
      const suggested = action.suggestName();
      EnvModal.callback(this.app, this.settings, suggested !== void 0 ? suggested : this.settings.defaultEnvironment, call);
    } else {
      call("*");
    }
  }
};
