/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RtlPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// EditorPlugin.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var import_obsidian = require("obsidian");
function getEditorPlugin(rtlPlugin) {
  return import_view.ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorationRegions = [];
      this.direction = "auto";
      this.rtlDec = import_view.Decoration.line({
        attributes: { dir: "rtl" }
      });
      this.ltrDec = import_view.Decoration.line({
        attributes: { dir: "ltr" }
      });
      this.emptyDirDec = import_view.Decoration.line({
        attributes: { dir: "auto" }
      });
      this.decorations = this.buildDecorations(view);
      this.rtlPlugin = rtlPlugin;
      this.view = view;
      const editorInfo = this.view.state.field(import_obsidian.editorInfoField);
      if (editorInfo && editorInfo instanceof import_obsidian.MarkdownView && editorInfo.editMode) {
        this.rtlPlugin.adjustDirectionToView(editorInfo, this);
      }
      this.rtlPlugin.handleIframeEditor(this.view.dom, this.view, editorInfo.file, this);
    }
    update(vu) {
      if (vu.viewportChanged || vu.docChanged) {
        this.decorations = this.buildDecorations(vu.view);
      }
    }
    buildDecorations(view) {
      const builder = new import_state.RangeSetBuilder();
      if (view == null || view.state == null)
        return builder.finish();
      const viewport = view.viewport;
      if (!viewport)
        return builder.finish();
      let decoration = this.emptyDirDec;
      if (this.direction != "auto") {
        decoration = this.direction === "ltr" ? this.ltrDec : this.rtlDec;
      }
      for (let pos = viewport.from; pos <= viewport.to; ) {
        const line = view.state.doc.lineAt(pos);
        builder.add(line.from, line.from, decoration);
        pos = line.to + 1;
      }
      return builder.finish();
    }
    destroy() {
    }
    setDirection(direction, view) {
      this.direction = direction;
      this.decorations = this.buildDecorations(view);
    }
  }, { decorations: (v) => v.decorations });
}

// MarkdownPostProcessor.ts
function detectExport(el, ctx, setPreviewDirection) {
  var _a;
  if ((el == null ? void 0 : el.classList) && ((_a = el.classList) == null ? void 0 : _a.contains("markdown-preview-view"))) {
    setPreviewDirection(ctx.sourcePath, el);
  }
}
var autoDirectionPostProcessor = (el, ctx, setPreviewDirection) => {
  detectExport(el, ctx, setPreviewDirection);
};

// main.ts
var import_state2 = require("@codemirror/state");

// direction.util.ts
var LTR_CLASS = "is-ltr";
var RTL_CLASS = "is-rtl";
var AUTO_CLASS = "is-auto";

// settingsTab.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  fileDirections: {},
  defaultDirection: "auto",
  rememberPerFile: true,
  setNoteTitleDirection: true,
  setYamlDirection: false,
  statusBar: true
};
var RtlSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.settings = plugin.settings;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "RTL Settings" });
    new import_obsidian2.Setting(containerEl).setName("Remember text direction per file").setDesc("Store and remember the text direction used for each file individually.").addToggle((toggle) => toggle.setValue(this.settings.rememberPerFile).onChange((value) => {
      this.settings.rememberPerFile = value;
      this.plugin.saveSettings();
      this.plugin.adjustDirectionToActiveView();
    }));
    new import_obsidian2.Setting(containerEl).setName("Default text direction").setDesc("What should be the default text direction in Obsidian?").addDropdown((dropdown) => dropdown.addOption("ltr", "LTR").addOption("rtl", "RTL").addOption("auto", "Auto").setValue(this.settings.defaultDirection).onChange((value) => {
      this.settings.defaultDirection = value;
      this.app.vault.setConfig("rightToLeft", value == "rtl");
      this.plugin.saveSettings();
      this.plugin.adjustDirectionToActiveView();
    }));
    new import_obsidian2.Setting(containerEl).setName("Set note title direction").setDesc("In RTL notes, also set the direction of the note title.").addToggle((toggle) => toggle.setValue(this.settings.setNoteTitleDirection).onChange((value) => {
      this.settings.setNoteTitleDirection = value;
      this.plugin.saveSettings();
      this.plugin.adjustDirectionToActiveView();
    }));
    new import_obsidian2.Setting(containerEl).setName("Set YAML direction in Preview").setDesc("For RTL notes, preview YAML blocks as RTL. (When turning off, restart of Obsidian is required.)").addToggle((toggle) => {
      var _a;
      return toggle.setValue((_a = this.settings.setYamlDirection) != null ? _a : false).onChange((value) => {
        this.settings.setYamlDirection = value;
        this.plugin.saveSettings();
        this.plugin.adjustDirectionToActiveView();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Show status bar item").setDesc("Show a clickable status bar item showing the current direction.").addToggle((toggle) => {
      var _a;
      return toggle.setValue((_a = this.settings.statusBar) != null ? _a : true).onChange((value) => {
        this.settings.statusBar = value;
        this.plugin.saveSettings();
        this.plugin.adjustDirectionToActiveView();
      });
    });
  }
};

// main.ts
var RtlPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.settings = null;
    this.statusBarItem = null;
    this.statusBarText = null;
  }
  async onload() {
    this.addCommand({
      id: "switch-text-direction",
      name: "Switch Text Direction (LTR->RTL->auto)",
      icon: "arrow-left-right",
      callback: () => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!view || !(view == null ? void 0 : view.editor))
          return;
        this.switchDocumentDirection(view.editor, view);
      }
    });
    await this.convertLegacySettings();
    await this.loadSettings();
    this.editorPlugin = getEditorPlugin(this);
    this.registerEditorExtension(import_state2.Prec.lowest(this.editorPlugin));
    this.registerMarkdownPostProcessor((el, ctx) => {
      autoDirectionPostProcessor(el, ctx, (path, markdownPreviewElement) => this.setPreviewDirectionByFileSettings(path, markdownPreviewElement));
    });
    this.addSettingTab(new RtlSettingsTab(this.app, this));
    this.app.workspace.on("active-leaf-change", async (leaf) => {
    });
    this.app.workspace.on("file-open", async (file, ctx) => {
    });
    this.registerEvent(this.app.vault.on("delete", (file) => {
      if (file && file.path && file.path in this.settings.fileDirections) {
        delete this.settings.fileDirections[file.path];
        this.saveSettings();
      }
    }));
    this.registerEvent(this.app.vault.on("rename", (file, oldPath) => {
      if (file && file.path && oldPath in this.settings.fileDirections) {
        this.settings.fileDirections[file.path] = this.settings.fileDirections[oldPath];
        delete this.settings.fileDirections[oldPath];
        this.saveSettings();
      }
    }));
    this.statusBarItem = this.addStatusBarItem();
    const languageIcon = (0, import_obsidian3.getIcon)("arrow-left-right");
    this.statusBarItem.appendChild(languageIcon);
    this.statusBarText = this.statusBarItem.createEl("span");
    this.statusBarText.style.marginLeft = "5px";
    this.statusBarItem.title = "Text direction";
    this.statusBarItem.addClass("mod-clickable");
    this.statusBarItem.addEventListener("click", (_ev) => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      if (!view || !(view == null ? void 0 : view.editor))
        return;
      this.switchDocumentDirection(view.editor, view);
    });
  }
  onunload() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (view && (view == null ? void 0 : view.editor)) {
      const editorView = view.editor.cm;
      this.adjustEditorPlugin(editorView, "auto");
    }
    console.log("unloading RTL plugin");
  }
  adjustDirectionToActiveView() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!view)
      return;
    this.adjustDirectionToView(view);
  }
  adjustDirectionToView(view, editorPlugin) {
    if (!view)
      return;
    const file = view == null ? void 0 : view.file;
    const editor = view == null ? void 0 : view.editor;
    const editorView = editor == null ? void 0 : editor.cm;
    if (file && file.path && editorView) {
      const [requiredDirection, _usedDefault] = this.getRequiredFileDirection(file);
      this.setMarkdownViewDirection(view, editor, editorView, requiredDirection, editorPlugin);
    }
  }
  getRequiredFileDirection(file) {
    if (!file) {
      return [this.settings.defaultDirection, true];
    }
    if (!(file instanceof import_obsidian3.TFile))
      return null;
    let requiredDirection = null;
    const frontMatterDirection = this.getFrontMatterDirection(file);
    let usedDefault = false;
    if (frontMatterDirection) {
      if (frontMatterDirection == "rtl" || frontMatterDirection == "ltr" || frontMatterDirection == "auto")
        requiredDirection = frontMatterDirection;
      else
        console.log("Front matter direction in file", file.path, "is unknown:", frontMatterDirection);
    } else if (this.settings.rememberPerFile && file.path in this.settings.fileDirections) {
      requiredDirection = this.settings.fileDirections[file.path];
    } else {
      requiredDirection = this.settings.defaultDirection;
      usedDefault = true;
    }
    return [requiredDirection, usedDefault];
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async convertLegacySettings() {
    const legacySettingsPath = ".obsidian/rtl.json";
    if (await this.app.vault.adapter.exists(legacySettingsPath)) {
      const legacyContent = await this.app.vault.adapter.read(legacySettingsPath);
      if (legacyContent) {
        this.settings = JSON.parse(legacyContent);
      }
      this.app.vault.adapter.remove(legacySettingsPath);
      new import_obsidian3.Notice("RTL Plugin: legacy settings were converted to the new format");
      this.saveSettings();
    }
  }
  updateStatusBar() {
    let hide = true;
    let usedDefault = false;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (view && (view == null ? void 0 : view.editor)) {
      const direction = this.getDocumentDirection(view.editor, view);
      if (view.file && view.file.path)
        [, usedDefault] = this.getRequiredFileDirection(view.file);
      if (this.settings.statusBar) {
        let directionString = direction === "auto" ? "auto" : direction === "ltr" ? "LTR" : "RTL";
        let statusString = "";
        if (usedDefault)
          statusString = `Default (${direction})`;
        else {
          if (direction === "auto")
            statusString = "Auto";
          else
            statusString = directionString;
        }
        this.statusBarText.textContent = statusString;
        this.statusBarItem.style.display = null;
        hide = false;
      }
    }
    if (hide)
      this.hideStatusBar();
  }
  hideStatusBar() {
    this.statusBarItem.style.display = "none";
  }
  handleIframeEditor(editorDiv, editorView, file, editorPlugin) {
    const isInIframe = editorDiv.closest(".mod-inside-iframe");
    if (isInIframe) {
      if (editorDiv instanceof HTMLDivElement) {
        const [requiredDirection, _] = this.getRequiredFileDirection(file);
        this.adjustEditorPlugin(editorView, requiredDirection, editorPlugin);
        this.setDocumentDirectionForEditorDiv(editorDiv, requiredDirection);
      }
    }
  }
  setMarkdownViewDirection(view, editor, editorView, newDirection, editorPlugin) {
    if (!view || !editor) {
      this.hideStatusBar();
      return;
    }
    let title = editorView.dom.querySelector(".inline-title");
    if (!title) {
      title = view.previewMode.containerEl.querySelector(".inline-title");
    }
    title == null ? void 0 : title.setAttribute("dir", newDirection === "auto" ? "auto" : "");
    this.adjustEditorPlugin(editorView, newDirection, editorPlugin);
    const editorDivs = view.contentEl.getElementsByClassName("cm-editor");
    for (const editorDiv of editorDivs) {
      if (editorDiv instanceof HTMLDivElement)
        this.setDocumentDirectionForEditorDiv(editorDiv, newDirection);
    }
    const markdownPreviews = view.contentEl.getElementsByClassName("markdown-preview-view");
    for (const preview of markdownPreviews) {
      if (preview instanceof HTMLDivElement)
        this.setDocumentDirectionForReadingDiv(preview, newDirection);
    }
    if (this.settings.setNoteTitleDirection) {
      const container = view.containerEl.parentElement;
      let header = container.getElementsByClassName("view-header-title-container");
      header[0].style.direction = newDirection;
    }
    editor.refresh();
  }
  adjustEditorPlugin(editorView, newDirection, editorPlugin) {
    let dispatchUpdate = false;
    if (!editorPlugin) {
      editorPlugin = editorView.plugin(this.editorPlugin);
      dispatchUpdate = true;
    }
    if (editorPlugin) {
      editorPlugin.setDirection(newDirection, editorView);
      if (dispatchUpdate)
        editorView.dispatch();
    }
  }
  setDocumentDirectionForEditorDiv(editorDiv, newDirection) {
    editorDiv.style.direction = newDirection === "auto" ? "" : newDirection;
    this.addDirectionClassToEl(editorDiv.parentElement, newDirection);
  }
  setDocumentDirectionForReadingDiv(readingDiv, newDirection) {
    readingDiv.style.direction = newDirection === "auto" ? "" : newDirection;
    this.addDirectionClassToEl(readingDiv, newDirection);
    readingDiv.classList.remove("rtl-yaml");
    if (newDirection !== "auto" && this.settings.setYamlDirection)
      readingDiv.classList.add("rtl-yaml");
  }
  setPreviewDirectionByFileSettings(path, markdownPreviewElement) {
    const file = this.app.vault.getAbstractFileByPath(path);
    const [requiredDirection, _] = this.getRequiredFileDirection(file);
    this.setDocumentDirectionForReadingDiv(markdownPreviewElement, requiredDirection);
  }
  addDirectionClassToEl(el, direction) {
    switch (direction) {
      case "ltr":
        el.classList.remove(RTL_CLASS);
        el.classList.remove(AUTO_CLASS);
        el.classList.add(LTR_CLASS);
        break;
      case "rtl":
        el.classList.remove(LTR_CLASS);
        el.classList.remove(AUTO_CLASS);
        el.classList.add(RTL_CLASS);
        break;
      default:
        el.classList.remove(LTR_CLASS);
        el.classList.remove(RTL_CLASS);
        el.classList.add(AUTO_CLASS);
    }
  }
  switchDocumentDirection(editor, view) {
    let newDirection = this.getDocumentDirection(editor, view);
    if (newDirection === null) {
      new import_obsidian3.Notice("Obsidian RTL can't set the direction of this document");
      return;
    }
    let displayName = "";
    switch (newDirection) {
      case "ltr":
        newDirection = "rtl";
        displayName = "RTL";
        break;
      case "rtl":
        newDirection = "auto";
        displayName = "Auto";
        break;
      case "auto":
        newDirection = "ltr";
        displayName = "LTR";
        break;
    }
    if (view instanceof import_obsidian3.MarkdownView) {
      const editorView = view.editor.cm;
      this.setMarkdownViewDirection(view, editor, editorView, newDirection);
      if (this.settings.rememberPerFile && view.file && view.file.path) {
        this.settings.fileDirections[view.file.path] = newDirection;
        this.saveSettings();
      }
      new import_obsidian3.Notice(`Document direction set to ${displayName}`, 2e3);
      this.updateStatusBar();
    } else {
      const canvasView = this.getCanvasContext(view);
      if (canvasView) {
        if (view.file)
          new import_obsidian3.Notice("To change a canvas card direction, open the document separately and reload the canvas.");
        else
          new import_obsidian3.Notice("Can't change the direction of a card without a file.");
      }
    }
  }
  getCanvasContext(ctx) {
    if (ctx instanceof import_obsidian3.MarkdownView)
      return null;
    const possibleCanvasContainer = ctx == null ? void 0 : ctx.containerEl;
    if (possibleCanvasContainer && possibleCanvasContainer.hasClass("canvas-node-content"))
      return possibleCanvasContainer;
  }
  getDocumentDirection(_editor, ctx) {
    let refElement = null;
    if (ctx instanceof import_obsidian3.MarkdownView) {
      refElement = ctx.contentEl;
    } else {
      refElement = this.getCanvasContext(ctx);
    }
    if (refElement === null)
      return null;
    const rtlEditors = refElement.getElementsByClassName(RTL_CLASS), autoEditors = refElement.getElementsByClassName(AUTO_CLASS);
    if (rtlEditors.length > 0)
      return "rtl";
    else if (autoEditors.length > 0)
      return "auto";
    else
      return "ltr";
  }
  getFrontMatterDirection(file) {
    const fileCache = this.app.metadataCache.getFileCache(file);
    const frontMatter = fileCache == null ? void 0 : fileCache.frontmatter;
    if (frontMatter && (frontMatter == null ? void 0 : frontMatter.direction)) {
      try {
        const direction = frontMatter.direction;
        return direction;
      } catch (error) {
      }
    }
  }
};
