/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __toBinary = /* @__PURE__ */ (() => {
  var table = new Uint8Array(128);
  for (var i = 0; i < 64; i++)
    table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
  return (base64) => {
    var n = base64.length, bytes = new Uint8Array((n - (base64[n - 1] == "=") - (base64[n - 2] == "=")) * 3 / 4 | 0);
    for (var i2 = 0, j = 0; i2 < n; ) {
      var c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];
      var c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];
      bytes[j++] = c0 << 2 | c1 >> 4;
      bytes[j++] = c1 << 4 | c2 >> 2;
      bytes[j++] = c2 << 6 | c3;
    }
    return bytes;
  };
})();

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TypingTransformer
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_state2 = require("@codemirror/state");
var import_view3 = require("@codemirror/view");

// wasm-binary:/home/runner/work/typing-transformer-obsidian/typing-transformer-obsidian/liberty-web/charliberty_bg.wasm
var charliberty_bg_exports = {};
__export(charliberty_bg_exports, {
  default: () => charliberty_bg_default
});
var charliberty_bg_default = __toBinary("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BCgCCEEBajYCCCAFKAIQIgEgAk0NICAFKAIIIgogCGoiAy0AAA0hIAEgA0EEaigCACIHTQ0FIAogB0EMbGpBCGooAgAiASADQQhqKAIAIgNJDSICQCADRQ0AIAMgBk8EQCADIAZGDQEMJAsgAyAJaiwAAEFASA0jCwJAIAFFDQAgASAGTwRAIAEgBkcNJAwBCyABIAlqLAAAQb9/TA0jCyADIAlqIQcgASADawwICyADIAlqLAAAQUBIDSELAkAgAUUNACABIAZPBEAgASAGRw0iDAELIAEgCWosAABBv39MDSELIAMgCWohByABIANrDAYLIAIgA0GslsAAEHoACyACIANBrJbAABB6AAsgDCADQfCZwAAQegALIAcgAUGwk8AAEHoACyAHIAFBsJPAABB6AAsgA0EIaigCACIBIApBCGooAgAiA0kNGgJAIANFDQAgAyAGTwRAIAMgBkYNAQwcCyADIAlqLAAAQUBIDRsLAkAgAUUNACABIAZPBEAgASAGRw0cDAELIAEgCWosAABBv39MDRsLIAMgCWohByABIANrCyEBIAQoAgQgBCgCCCIDayABSQRAIAQgAyABEFkgBCgCCCEDCyAEKAIAIANqIAcgARDfARogBCABIANqNgIIIAUoAhAiASACSwRAIAggBSgCCCIHaiIDLQAADRkgASADQQRqKAIAIgJNDQIgByACQQxsaiIBLQAARQ0DIAxBAWohAiABLQABIQcgBEHYAGogCSAGIANBCGooAgAgAUEIaigCABCnASAEKAJkIQ4gBSAFKAIAQX9qIgE2AgBBACEDIAENASAFQQxqKAIABEAgBSgCCBAaCyAFQQRqIgEgASgCAEF/aiIBNgIAIAENASAFEBoMAQsLIAIgAUHAk8AAEHoACyACIAFB8JnAABB6AAsMEwsgAyABQbCTwAAQegALDBMLDBELDA8LIAEgA0HwmcAAEHoACwwPCyACIANBwJPAABB6AAtB2JjAAEErQeiawAAQiwEACwwMCyABIANBrJbAABB6AAsACyAFQQEQ2QEACxCRAQALIAUgATYCAAsgBSABQX9qIgE2AgACQCABDQAgBUEMaigCAARAIAUoAggQGgsgBUEEaiIBIAEoAgBBf2oiATYCACABDQAgBRAaCyAAIAQpAwA3AgQgAEEANgIAIABBDGogBEEIaigCADYC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MCIMIAhGIg0bIgQgDktBACAEIA5rQQFGGw0BAkAgDUUEQCAMIAhPDQMgASAINgIwQQAhAiABQSxqQQA2AgAgAUEgakEANgIADAELIAogBU8EQCABQSBqIAU2AgALIAIgB0kNACABQSxqIAc2AgAgByECCyABQShqKAIAIAJGBH8gAUEkaiACEFggASgCLAUgAgsgASgCJGpBDjoAACABIAEoAixBAWo2AiwgAS0AWCECC0EAIQMgAkH/AXFBAkcNACABLQBZRQ0AIAFBFGooAgAiBSAGTQ0BIAFBDGoiBygCACICIAZBDGxqLQAADQIgAiAGQQxsakEEaiAFNgIAIAFBCGooAgAhBSABQRRqIgQoAgAiAiABQRBqKAIARgRAIAcgAhBQIAQoAgAhAgsgASgCDCACQQxsaiICIAU2AgggAiAGNgIEIAJBgRw7AQAgBCAEKAIAQQFqNgIACyAAIAE2AgQgACADNgIAIAlBEGokAA8LIAYgBUG0n8AAEHoAC0HEn8AAQShB7J/AABCLAQALtgkBDn8jAEEgayIGJAAgAUEIaigCACIFIAEoAjAiDUYEQCABQSxqKAIAIQkgAUEgaigCACEECyABQRRqKAIAIQgCfyABLQBYQQJHBEAgCCECIAUMAQsgCCECIAUgAS0AWUUNABogAUEQaigCACAIRgRAIAFBDGogCBBQIAFBFGooAgAhAgsgASgCDCACQQxsaiICIAU2AgggAkEANgIEIAJBADoAACABQRRqIgIgAigCAEEBaiICNgIAIAEoAjAhDSABQQhqKAIACyEDIAFBBGooAgAhByABQSxqKAIAIAFBIGooAgAgASgCACEPIAZBGGogARAzakEAIAUgDUYbIQ4gBigCHCEBAkACQAJAAkACQAJAAkACQCAGKAIYDQAgBkEQaiABEDMgBigCFCEBIAYoAhANASABQQRqKAIAIQcgAUEUaigCACECIAEoAgghAyABKAIAIQ8gBkEIaiABEDNBASEKIAYoAgwhASAGKAIIDQADQCABQQRqKAIAIQcgAUEUaigCACECIAEoAgghAyABKAIAIQ8gBiABEDMgBigCBCEBIAYoAgBFDQALCyABIAM2AgggASAHNgIEIAEgDzYCACABKAIUIAJPBEAgASACNgIUCyAKRQ0BCyABLQBYIgNBAUYNAQwCC0EBIQIgAS0A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AgAgAUEgakEANgIADAELIAcgCU8EQCABQSBqIAk2AgALIAogC0kNACABQSxqIAs2AgAgCyEKCyABQShqKAIAIApGBH8gAUEkaiAKEFggAUEsaigCAAUgCgsgASgCJGpBBToAACABQSxqIgIgAigCAEEBajYCACABLQBYIQILQQAhDSACQf8BcUECRw0BIAEtAFlFDQEgAUEUaigCACIFIARNDQIgECgCACAEQQxsaiICLQAADQMgAkEEaiAFNgIAIAFBCGooAgAhBSABQRRqIgMoAgAiAiABQRBqKAIARgRAIBAgAhBQIAMoAgAhAgsgASgCDCACQQxsaiICIAU2AgggAiAENgIEIAJBgQo7AQAgAygCAEEBaiEEQQALIQ0gAUEUaiAENgIACyAAIAE2AgQgACANNgIADwsgBCAFQbSfwAAQegALQcSfwABBKEHsn8AAEIsBAAv4CAEOfyMAQSBrIgckACABQQhqKAIAIgogASgCMCIERgRAIAFBLGooAgAhDiABQSBqKAIAIQgLIAFBFGooAgAhBQJAIAEtAFhBAkcEQCAFIQMMAQsgBSEDIAEtAFlFDQAgBSEEIAFBEGooAgAgBUYEQCABQQxqIAUQUCABQRRqKAIAIQQLIAEoAgwgBEEMbGoiAiAKNgIIIAJBADYCBCACQQA6AAAgAUEUaiICIAIoAgBBAWoiAzYCACABKAIwIQQLIAFBIGooAgAgAUEsaigCACABLQBZIgsEQCABQQA6AFkLaiAEIApGIQ8gAUEEaigCACEMIAEoAgAhDSABQQhqKAIAIgQhAgJAIARBAWoiBiAESQ0AIAQhAiAGIAxLDQAgBCANai0AAEEhRw0AIAFBCGogBjYCACAGIQILQQAgDxshBgJAAkACQAJAAkACQCACQX1LDQAgAkECaiIJIAxLDQAgAiANai8AAEHbtgFHDQAgAUEIaiAJNgIAIAdBGGogARAjIAcoAhwhASAHKAIYRQRAIAdBEGogARAjIAcoAhQhASAHKAIQRQRAA0AgB0EIaiABECMgBygCDCEBIAcoAghFDQALCyABQQhqKAIAIgJBfUsNASACQQJqIgkgASgCBEsNASABKAIAIAJqLwAAQd26AUcNASABQQhqIAk2AgAgCwRAIAEgCzoAWQsgAS0AWCICQQFGDQIMAwsgASAJNgIIIAEgDDYCBCABIA02AgAgASgCFCADSQ0AIAEgAzYCFAsgASAENgIIIAEgDDYCBCABIA02AgAgASgCFCADTwRAIAEgAzYCFAsgCwRAIAEgCzoAWQtBASEEIAEtAFgiAkEBRg0CAkAgAS0AWUUNACABQSxqKAIAIgsgAUEgaigCACIDakEAIAEoAjAiDCAKRiINGyIJIAZLQQAgCSAGa0EBRhsNAAJAIA1FBEAgDCAKTw0CIAEgCjYCMEEAIQMgAUEsakEANgIAIAFBIGpBADYCAAwBCyADIAhPBEAgAUEgaiAINgIAIAghAwsgCyAOSQ0AIAFBLGogDjYCAAsgAUEcaigCACADRgR/IAFBGGogAxBYIAEoAiAFIAMLIAEoAhhqQRA6AAAgASABKAIgQQFqNgIgIAEtAFghAgsgAkH/AXFBAkcNAiABLQBZRQ0CIAEoAhQgBUkNAiABIAU2AhQMAgsgAUEQIAogCCAOIAYQTyABLQBYIQILQQAhBCACQf8BcUECRw0AIAEtAFlFDQAgAUEUaigCACICIAVNDQEgAUEMaiIIKAIAIgMgBUEMbGotAAANAiADIAVBDGxqQQRqIAI2AgAgAUEIaigCACEGIAFBFGoiAigCACIDIAFBEGooAgBGBEAgCCADEFAgAigCACEDCyABKAIMIANBDGxqIgMgBjYCCCADIAU2AgQgA0GBIDsBACACIAIoAgBBAWo2AgALIAAgATYCBCAAIAQ2AgAgB0EgaiQADwsgBSACQbSfwAAQegALQcSfwABBKEHsn8AAEIsBAAv4CAENfyMAQSBrIgckACABQQhqKAIAIgkgASgCMCIERgRAIAFBLGooAgAhCCABQSBqKAIAIQULIAFBFGooAgAhBgJAIAEtAFhBAkcEQCAGIQIMAQsgBiECIAEtAFlFDQAgBiEEIAFBEGooAgAgBkYEQCABQQxqIAYQUCABQRRqKAIAIQQLIAEoAgwgBEEMbGoiAiAJNgIIIAJBADYCBCACQQA6AAAgAUEUaiICIAIoAgBBAWoiAjYCACABKAIwIQQLIAFBLGooAgAgAUEgaigCAGogAS0AWSIKBEAgAUEAOgBZC0EAIAQgCUYbIQwgAUEIaigCACELIAFBBGooAgAhBCABKAIAIQMgB0EYaiABEBkgBygCHCEBAkACQAJAAkACQCAHKAIYRQRAIAdBEGogARAtIAcoAhQhASAHKAIQRQRAA0AgB0EIaiABEC0gBygCDCEBIAcoAghFDQALCyAKBEAgASAKOgBZCyABLQBYIgJBAUYNAQwCCyABIAs2AgggASAENgIEIAEgAzYCACABKAIUIAJPBEAgASACNgIUCyAKBEAgASAKOgBZC0EBIQQgAS0AWCICQQFGDQICQCABLQBZRQ0AIAFBLGooAgAiDiABQSBqKAIAIgNqQQAgASgCMCINIAlGIgobIgsgDEtBACALIAxrQQFGGw0AAkAgCkUEQCANIAlPDQIgASAJNgIwQQAhAyABQSxqQQA2AgAgAUEgakEANgIADAELIAMgBU8EQCABQSBqIAU2AgAgBSEDCyAOIAhJDQAgAUEsaiAINgIACyABQRxqKAIAIANGBH8gAUEYaiADEFggASgCIAUgAwsgASgCGGpBEzoAACABIAEoAiBBAWo2AiAgAS0AWCECCyACQf8BcUECRw0CIAEtAFlFDQIgASgCFCAGSQ0CIAEgBjYCFAwCCyABLQBZRQRAQQAhBAwCC0EAIQQgAUEsaigCACICIAFBIGooAgAiDWpBACABKAIwIgogCUYiCxsiAyAMS0EAIAMgDGtBAUYbDQECQCALRQRAIAogCU8NAyABIAk2AjBBACECIAFBLGpBADYCACABQSBqQQA2AgAMAQsgDSAFTwRAIAFBIGogBTYCAAsgAiAISQ0AIAFBLGogCDYCACAIIQILIAFBKGooAgAgAkYEfyABQSRqIAIQWCABKAIsBSACCyABKAIkakETOgAAIAEgASgCLEEBajYCLCABLQBYIQILQQAhBCACQf8BcUECRw0AIAEtAFlFDQAgAUEUaigCACIFIAZNDQEgAUEMaiIIKAIAIgIgBkEMbGotAAANAiACIAZBDGxqQQRqIAU2AgAgAUEIaigCACEFIAFBFGoiAygCACICIAFBEGooAgBGBEAgCCACEFAgAygCACECCyABKAIMIAJBDGxqIgIgBTYCCCACIAY2AgQgAkGBJjsBACADIAMoAgBBAWo2AgALIAAgATYCBCAAIAQ2AgAgB0EgaiQADwsgBiAFQbSfwAAQegALQcSfwABBKEHsn8AAEIsBAAvaCAENfyMAQSBrIgckACABQQhqKAIAIgggASgCMCIDRgRAIAFBLGooAgAhDiABQSBqKAIAIQULIAFBFGooAgAh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aiAEIAUoAhgiAxEAACACKAIQIQggAkEIaiAEIAMRAAAgAigCDCEHIAIoAgghAyACIAU2AjQgAiAENgIwIAZBADYCACACQZClwAA2AmggAkIBNwJcIAJBsKXAADYCWCABIAJB2ABqEHsNAiAIQQBHIQoDQCACQQA6AEQgAiAKNgI8IAIgATYCOCACIAkgBSAIGyIFNgJAIAJBKzYCTCACIAJBMGo2AkggAiACQThqNgJUIAJBATYCbCACQgE3AlwgAkGQpcAANgJYIAIgAkHIAGo2AmggAkHUAGpBuKXAACACQdgAahAsDQMgA0UNAiACIAMgBygCGBEAACACKAIEIAIoAgAgAiAHNgI0IAIgAzYCMCACQQA2AmwgAkGQpcAANgJoIAJCATcCXCACQbClwAA2AlggCUEBaiEJIQMhByABIAJB2ABqEHtFDQALDAILIAMgASAAKAIMEQEAIQAMAQtBACEACyACQfAAaiQAIAALigQBBH8jAEHQAGsiAiQAIAFBBGohAwJAAkAgASgCAEUEQCABQQxqKAIAIQQgAygCACEDAkAgAUEYaigCACIFBEAgAUEQaigCACEBIARFDQEgAkEQaiABIAUgAkHIAGoQKCACQSBqIAMgBCACQcgAahAoIAJBDGpBATYCACACQQE2AgQgAiACQSBqNgIIIAIgAkEQajYCACACQcQAakECNgIAIAJCAjcCNCACQciAwAA2AjAgAiACNgJAIAAgAkEwahA0IAIoAiQEQCACKAIgEBoLIAIoAhRFDQMgAigCEBAaDAMLIAQEQCACIAMgBCACQcgAahAoIAJBATYCJCACIAI2AiAgAkHEAGpBATYCACACQgE3AjQgAkGggMAANgIwIAIgAkEgajYCQCAAIAJBMGoQNCACKAIERQ0DIAIoAgAQGgwDC0EVQQEQuwEiAUUNAyAAIAE2AgAgAEKVgICA0AI3AgQgAUGAgMAAKQAANwAAIAFBCGpBiIDAACkAADcAACABQQ1qQY2AwAApAAA3AAAMAgsgAiABIAUgAkHIAGoQKCACQQE2AiQgAiACNgIgIAJBxABqQQE2AgAgAkIBNwI0IAJBtIDAADYCMCACIAJBIGo2AkAgACACQTBqEDQgAigCBEUNASACKAIAEBoMAQsgACADEIABCyACQdAAaiQADwtBFUEBENkBAAvUAwEIfyABKAIEIQMgASgCACEHAkACQCABKAIIIgVFDQAgAyAFTQRAIAMgBUYNAQwCCyAFIAdqLAAAQb9/TA0BCyAFIAdqIQICQAJAAkACQCADIAVGIgkNAAJAIAIsAAAiBEF/SgRAIARB/wFxIQQMAQsgAi0AAUE/cSEIIARBH3EhBiAEQV9NBEAgBkEGdCAIciEEDAELIAItAAJBP3EgCEEGdHIhCCAEQXBJBEAgCCAGQQx0ciEEDAELIAZBEnRBgIDwAHEgAi0AA0E/cSAIQQZ0cnIiBEGAgMQARg0BCyAEQZ9/akEaSQ0BCyAFBEAgAyAFTQRAQQEhBCAJDQMMBAsgAiwAAEG/f0wNAwtBASEEIAkNAQJAIAIsAAAiA0F/SgRAIANB/wFxIQIMAQsgAi0AAUE/cSEGIANBH3EhByADQV9NBEAgB0EGdCAGciECDAELIAItAAJBP3EgBkEGdHIhBiADQXBJBEAgBiAHQQx0ciECDAELIAdBEnRBgIDwAHEgAi0AA0E/cSAGQQZ0cnIiAkGAgMQARg0CCyACQb9/akEZSw0BCyABIAVBAWo2AghBACEECyAAIAE2AgQgACAENgIADwsLIAcgAyAFIAMQmgEAC+IDAQh/IwBBIGsiBCQAIAFBFGooAgAhCSABKAIAIQUCQCABQQRqKAIAIgdBA3RFBEAMAQsgB0F/akH/////AXEiAkEBaiIDQQdxIQYCfyACQQdJBEBBACEDIAUMAQsgBUE8aiECIANB+P///wNxIQhBACEDA0AgAigCACACQXhqKAIAIAJBcGooAgAgAkFoaigCACACQWBqKAIAIAJBWGooAgAgAkFQaigCACACQUhqKAIAIANqampqampqaiEDIAJBQGshAiAIQXhqIggNAAsgAkFEagsgBkUNAEEEaiECA0AgAigCACADaiEDIAJBCGohAiAGQX9qIgYNAAsLAkACQAJAIAlFBEAgAyECDAELAkAgB0UNACAFKAIEDQAgA0EQSQ0CCyADIANqIgIgA0kNAQsgAkUNAAJAIAJBf0oEQCACQQEQuwEiA0UNAQwDCxCRAQALIAJBARDZAQALQQEhA0EAIQILIABBADYCCCAAIAI2AgQgACADNgIAIAQgADYCBCAEQRhqIAFBEGopAgA3AwAgBEEQaiABQQhqKQIANwMAIAQgASkCADcDCCAEQQRqQbSowAAgBEEIahAsRQRAIARBIGokAA8LQaSpwABBMyAEQQhqQcyowABB8KnAABBuAAukAwEGfwJAIAAoAgQiAUUNACAAKAIAIgQgAWohASAAKAIIIQUDQCABIARGDQECQCABQX9qIgAtAAAiAkEYdEEYdSIDQX9MBEAgA0E/cQJ/IAFBfmoiAi0AACIAQRh0QRh1IgNBv39KBEAgAiEBIABBH3EMAQsgA0E/cQJ/IAFBfWoiAi0AACIAQRh0QRh1IgNBv39KBEAgAiEBIABBD3EMAQsgA0E/cSABQXxqIgEtAABBB3FBBnRyC0EGdHILQQZ0ciICQYCAxABHDQEMAwsgACEBCyAFIAEgBGsiAE0NAAsgAkEKRgRAIABBAWoPCwNAIAEgBEYNASABQX9qIgAtAAAiAkEYdEEYdSIFQX9MBEAgBUE/cQJ/IAFBfmoiAC0AACICQRh0QRh1IgNBQE4EQCACQR9xDAELIANBP3ECfyABQX1qIgAtAAAiAkEYdEEYdSIDQUBOBEAgAkEPcQwBCyADQT9xIAFBfGoiAC0AAEEHcUEGdHILQQZ0cgtBBnRyIgJBgIDEAEYNAgsgACEBIAJBCkcNAAsgACAEa0EBaiEGCyAGC7gDAQt/IwBBEGsiCiQAIABCATcCACAAQQhqIgtBADYCACADQf8BcSENIABBBGohDkEBIQkDQCABIAhqIQ8CfyACIAhrIgxBCE8EQCAKQQhqIAMgDyAMEEEgCigCDCEFIAooAggMAQtBACEFQQAgDEUNABoDQEEBIA0gBSAPai0AAEYNARogDCAFQQFqIgVHDQALIAwhBUEAC0EBRgRAAkAgBSAIaiIFQQFqIgggBUkgCCACS3INACABIAVqLQAAIA1HDQAgDigCACAGayAFIAdrIgVJBEAgACAGIAUQWSAAKAIAIQkgCygCACEGCyAGIAlqIAEgB2ogBRDfARogCyAFIAZqIgU2AgAgDigCACAFa0ECTQRAIAAgBUEDEFkgCygCACEFCyALIAVBA2oiBjYCACAAKAIAIgkgBWoiByAELwAAOwAAIAdBAmogBEECai0AADoAACAIIQcMAgsgCCACTQ0BCwsgAEEEaigCACAGayACIAdrIgJJBEAgACAGIAIQWSAAKAIAIQkgAEEIaigCACEGCyAGIAlqIAEgB2ogAhDfARogAEEIaiACIAZqNgIAIApBEGokAAurBAIFfwF+QQEhAwJAIAEoAhgiBEEnIAFBHGooAgAoAhAiBREBAA0AQQIhAUEwIQICQAJ+AkACQAJAAkACQAJAAkAgACgCACIADigIAQEBAQEBAQECBAEBAwEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEFAAsgAEHcAEYNBAsgABA8RQ0EIABBAXJnQQJ2QQdzrUKAgICA0ACEDAULQfQAIQIMBQtB8gAhAgwEC0HuACECDAMLIAAhAgwCCyAAEF8EQEEBIQEgACECDAILIABBAXJnQQJ2QQdzrUKAgICA0ACECyEHQQMhASAAIQILA0AgASEGQQAhASACIQACQAJAAkACQAJAIAZBAWsOAwQCAAELAkACQAJAAkACQCAHQiCIp0H/AXFBAWsOBQAEAQIDBQsgB0L/////j2CDIQdB/QAhAEEDIQEMBwsgB0L/////j2CDQoCAgIAghCEHQfsAIQBBAyEBDAYLIAdC/////49gg0KAgICAMIQhB0H1ACEAQQMhAQwFCyAHQv////+PYINCgICAgMAAhCEHQdwAIQBBAyEBDAQLQTBB1wAgAiAHpyIBQQJ0dkEPcSIAQQpJGyAAaiEAIAFFDQIgB0J/fEL/////D4MgB0KAgICAcIOEIQdBAyEBDAMLIARBJyAFEQEAIQMMBAtB3AAhAEEBIQEMAQsgB0L/////j2CDQoCAgIAQhCEHQQMhAQsgBCAAIAURAQBFDQALCyADC6ADAQR/IwBB0ABrIgIkACACQcgAaiABEBMgAigCTCEBAkAgAigCSEUNAAJAIAEoAggiA0EBaiIEIANJDQAgBCABKAIESw0AIAEoAgAgA2otAABBIEcNACABIAQ2AggMAQsgAkFAayABEA0gAigCRCEBIAIoAkBFDQAgAUE8aigCACEEIAEoAlQiAyABQdAAaigCAEYEQCABQcwAaiADEFMgASgCVCEDCyABKAJMIANBAnRqIAQ2AgAgASABKAJUQQFqNgJUIAJBOGogARAHIAIoAjwhASACKAI4RQRAIAEoAlQiA0UNASABIANBf2o2AlQMAQsgAUE0ahBCIAJBMGogARAfIAIoAjQhASACKAIwRQ0AIAJBKGogARAcIAIoAiwhASACKAIoRQ0AIAJBIGogARACIAIoAiQhASACKAIgRQ0AIAJBGGogARAIIAIoAhwhASACKAIYRQ0AIAJBEGogARARIAIoAhQhASACKAIQRQ0AIAJBCGogARAOIAIoAgwhASACKAIIIQULIAAgATYCBCAAIAU2AgAgAkHQAGokAAuDAwEDfwJAAkACQAJAIAFBCU8EQEEQQQgQrwEgAUsNAQwCCyAAEAEhAwwCC0EQQQgQrwEhAQtBgIB8QQhBCBCvAUEUQQgQrwFqQRBBCBCvAWprQXdxQX1qIgRBAEEQQQgQrwFBAnRrIgIgAiAESxsgAWsgAE0NACABQRAgAEEEakEQQQgQrwFBe2ogAEsbQQgQrwEiBGpBEEEIEK8BakF8ahABIgJFDQAgAhDlASEAAkAgAUF/aiIDIAJxRQRAIAAhAQwBCyACIANqQQAgAWtxEOUBIQJBEEEIEK8BIQMgABDVASACQQAgASACIABrIANLG2oiASAAayICayEDIAAQwwFFBEAgASADEJ0BIAAgAhCdASAAIAIQLwwBCyAAKAIAIQAgASADNgIEIAEgACACajYCAAsgARDDAQ0BIAEQ1QEiAkEQQQgQrwEgBGpNDQEgASAEEOIBIQAgASAEEJ0BIAAgAiAEayIEEJ0BIAAgBBAvDAELIAMPCyABEOQBIAEQwwEaC9cCAQd/QQEhCQJAAkAgAkUNACABIAJBAXRqIQogAEGA/gNxQQh2IQsgAEH/AXEhDQJAA0AgAUECaiEMIAcgAS0AASICaiEIIAsgAS0AACIBRwRAIAEgC0sNAyAIIQcgDCIBIApHDQEMAwsgCCAHTwRAIAggBEsNAiADIAdqIQECQANAIAJFDQEgAkF/aiECIAEtAAAgAUEBaiEBIA1HDQALQQAhCQwFCyAIIQcgDCIBIApHDQEMAwsLIAcgCBDcAQALIAggBBDbAQALIAZFDQAgBSAGaiEDIABB//8DcSEBA0ACQCAFQQFqIQACfyAAIAUtAAAiAkEYdEEYdSIEQQBODQAaIAAgA0YNASAFLQABIARB/wBxQQh0ciECIAVBAmoLIQUgASACayIBQQBIDQIgCUEBcyEJIAMgBUcNAQwCCwtBlKvAAEErQcyywAAQiwEACyAJQQFxC5ADAgV/An4jAEFAaiIFJABBASEHAkAgAC0ABA0AIAAtAAUhCCAAKAIAIgYoAgAiCUEEcUUEQCAGKAIYQY2swABBj6zAACAIG0ECQQMgCBsgBkEcaigCACgCDBECAA0BIAYoAhggASACIAYoAhwoAgwRAgANASAGKAIYQdmrwABBAiAGKAIcKAIMEQIADQEgAyAGIAQoAgwRAQAhBwwBCyAIRQRAIAYoAhhBiKzAAEEDIAZBHGooAgAoAgwRAgANASAGKAIAIQkLIAVBAToAFyAFQTRqQeyrwAA2AgAgBUEQaiAFQRdqNgIAIAUgCTYCGCAFIAYpAhg3AwggBikCCCEKIAYpAhAhCyAFIAYtACA6ADggBSAGKAIENgIcIAUgCzcDKCAFIAo3AyAgBSAFQQhqNgIwIAVBCGogASACECYNACAFQQhqQdmrwABBAhAmDQAgAyAFQRhqIAQoAgwRAQANACAFKAIwQYuswABBAiAFKAI0KAIMEQIAIQcLIABBAToABSAAIAc6AAQgBUFAayQAC+ECAQV/IABBC3QhBEEgIQJBICEDAkADQAJAAkAgAkEBdiABaiICQQJ0Qai+wABqKAIAQQt0IgUgBE8EQCAEIAVGDQIgAiEDDAELIAJBAWohAQsgAyABayECIAMgAUsNAQwCCwsgAkEBaiEBCwJAAkAgAUEfTQRAIAFBAnQhBEHDBSEDIAFBH0cEQCAEQay+wABqKAIAQRV2IQMLQQAhBSABQX9qIgIgAU0EQCACQSBPDQIgAkECdEGovsAAaigCAEH///8AcSEFCwJAIAMgBEGovsAAaigCAEEVdiIBQX9zakUNACAAIAVrIQQgAUHDBSABQcMFSxshAiADQX9qIQBBACEDA0AgASACRg0EIAMgAUGov8AAai0AAGoiAyAESw0BIAAgAUEBaiIBRw0ACyAAIQELIAFBAXEPCyABQSBB8L3AABB6AAsgAkEgQZC+wAAQegALIAJBwwVBgL7AABB6AAvSAgEDfyMAQRBrIgIkAAJAAn8CQCABQYABTwRAIAJBADYCDCABQYAQTw0BIAIgAUE/cUGAAXI6AA0gAiABQQZ2QcABcjoADEECDAILIAAoAggiAyAAQQRqKAIARgRAIAAgAxBcIAAoAgghAwsgACADQQFqNgIIIAAoAgAgA2ogAToAAAwCCyABQYCABE8EQCACIAFBP3FBgAFyOgAPIAIgAUESdkHwAXI6AAwgAiABQQZ2QT9xQYABcjoADiACIAFBDHZBP3FBgAFyOgANQQQMAQsgAiABQT9xQYABcjoADiACIAFBDHZB4AFyOgAMIAIgAUEGdkE/cUGAAXI6AA1BAwshASAAQQRqKAIAIABBCGoiBCgCACIDayABSQRAIAAgAyABEFsgBCgCACEDCyAAKAIAIANqIAJBDGogARDfARogBCABIANqNgIACyACQRBqJAAL1AIBA38jAEEQayICJAACQAJ/AkACQCABQYABTwRAIAJBADYCDCABQYAQSQ0BIAFBgIAETw0CIAIgAUE/cUGAAXI6AA4gAiABQQx2QeABcjoADCACIAFBBnZBP3FBgAFyOgANQQMMAwsgACgCCCIDIABBBGooAgBGBEAgACADEFwgACgCCCEDCyAAIANBAWo2AgggACgCACADaiABOgAADAMLIAIgAUE/cUGAAXI6AA0gAiABQQZ2QcABcjoADEECDAELIAIgAUE/cUGAAXI6AA8gAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBAshASAAQQRqKAIAIABBCGoiBCgCACIDayABSQRAIAAgAyABEFsgBCgCACEDCyAAKAIAIANqIAJBDGogARDfARogBCABIANqNgIACyACQRBqJAAL5wMAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAC0AAEEBaw4bAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobAAsgAUG9nMAAQQMQrQEPCyABQbicwABBBRCtAQ8LIAFBtpzAAEECEK0BDwsgAUGznMAAQQMQrQEPCyABQbCcwABBAxCtAQ8LIAFBppzAAEEKEK0BDwsgAUGfnMAAQQcQrQEPCyABQZqcwABBBRCtAQ8LIAFBjpzAAEEMEK0BDwsgAUGCnMAAQQwQrQEPCyABQfqbwABBCBCtAQ8LIAFB7JvAAEEOEK0BDwsgAUHim8AAQQoQrQEPCyABQdSbwABBDhCtAQ8LIAFBypvAAEEKEK0BDwsgAUHDm8AAQQcQrQEPCyABQbybwABBBxCtAQ8LIAFBs5vAAEEJEK0BDwsgAUGsm8AAQQcQrQEPCyABQambwABBAxCtAQ8LIAFBpZvAAEEEEK0BDwsgAUGfm8AAQQYQrQEPCyABQZubwABBBBCtAQ8LIAFBj5vAAEEMEK0BDwsgAUGGm8AAQQkQrQEPCyABQYGbwABBBRCtAQ8LIAFB/JrAAEEFEK0BDwsgAUH4msAAQQQQrQELtgIBB38CQCACQQ9NBEAgACEDDAELIABBACAAa0EDcSIEaiEFIAQEQCAAIQMgASEGA0AgAyAGLQAAOgAAIAZBAWohBiADQQFqIgMgBUkNAAsLIAUgAiAEayIIQXxxIgdqIQMCQCABIARqIgRBA3EEQCAHQQFIDQEgBEEDdCICQRhxIQkgBEF8cSIGQQRqIQFBACACa0EYcSECIAYoAgAhBgNAIAUgBiAJdiABKAIAIgYgAnRyNgIAIAFBBGohASAFQQRqIgUgA0kNAAsMAQsgB0EBSA0AIAQhAQNAIAUgASgCADYCACABQQRqIQEgBUEEaiIFIANJDQALCyAIQQNxIQIgBCAHaiEBCyACBEAgAiADaiECA0AgAyABLQAAOgAAIAFBAWohASADQQFqIgMgAkkNAAsLIAALvgIBBX8CQAJAAkACQCACQQNqQXxxIAJrIgRFDQAgAyAEIAQgA0sbIgRFDQAgAUH/AXEhB0EBIQYDQCACIAVqLQAAIAdGDQQgBCAFQQFqIgVHDQALIAQgA0F4aiIGSw0CDAELIANBeGohBkEAIQQLIAFB/wFxQYGChAhsIQUDQCACIARqIgcoAgAgBXMiCEF/cyAIQf/9+3dqcSAHQQRqKAIAIAVzIgdBf3MgB0H//ft3anFyQYCBgoR4cUUEQCAEQQhqIgQgBk0NAQsLIAQgA00NACAEIAMQ2gEACwJAIAMgBEYNACAEIANrIQMgAiAEaiECQQAhBSABQf8BcSEBA0AgASACIAVqLQAARwRAIAMgBUEBaiIFag0BDAILCyAEIAVqIQVBASEGDAELQQAhBgsgACAFNgIEIAAgBjYCAAvCAgEJfyAAQSBqKAIAIgFFBEAgAEEANgIIIABBFGpBADYCAA8LIAAgAUF/aiICNgIgIAAoAggiASAAKAIYIAJBAnRqKAIAIgNPBEACQCABIANHBEAgA0EUbCABQRRsIgFrIQQgAEEMaiEFIAEgACgCAGpBbGohAQNAAkAgAAJ/IAEoAgBFBEAgACgCFCICRQ0CIAJBf2oMAQsgAUEQaigCACEGIAFBDGooAgAhByABQQhqKAIAIQggAUEEaigCACEJIAAoAhQiAiAAQRBqKAIARgRAIAUgAhBUIAAoAhQhAgsgACgCDCACQQR0aiICIAY2AgwgAiAHNgIIIAIgCDYCBCACIAk2AgAgACgCFEEBags2AhQLIAFBbGohASAEQRRqIgQNAAsgACgCCCADSQ0BCyAAIAM2AggLDwsgAyABENoBAAu+AgIFfwF+IwBBMGsiBCQAQSchAgJAIABCkM4AVARAIAAhBwwBCwNAIARBCWogAmoiA0F8aiAAIABCkM4AgCIHQpDOAH59pyIFQf//A3FB5ABuIgZBAXRBnqzAAGovAAA7AAAgA0F+aiAFIAZB5ABsa0H//wNxQQF0QZ6swABqLwAAOwAAIAJBfGohAiAAQv/B1y9WIAchAA0ACwsgB6ciA0HjAEsEQCACQX5qIgIgBEEJamogB6ciAyADQf//A3FB5ABuIgNB5ABsa0H//wNxQQF0QZ6swABqLwAAOwAACwJAIANBCk8EQCACQX5qIgIgBEEJamogA0EBdEGerMAAai8AADsAAAwBCyACQX9qIgIgBEEJamogA0EwajoAAAsgAUHEqsAAQQAgBEEJaiACakEnIAJrEB4gBEEwaiQAC7ECAQN/IwBBgAFrIgQkAAJAAkACQAJAIAEoAgAiAkEQcUUEQCACQSBxDQEgADUCACABEEMhAAwECyAAKAIAIQBBACECA0AgAiAEakH/AGpBMEHXACAAQQ9xIgNBCkkbIANqOgAAIAJBf2ohAiAAQQ9LIABBBHYhAA0ACyACQYABaiIAQYEBTw0BIAFBnKzAAEECIAIgBGpBgAFqQQAgAmsQHiEADAMLIAAoAgAhAEEAIQIDQCACIARqQf8AakEwQTcgAEEPcSIDQQpJGyADajoAACACQX9qIQIgAEEPSyAAQQR2IQANAAsgAkGAAWoiAEGBAU8NASABQZyswABBAiACIARqQYABakEAIAJrEB4hAAwCCyAAQYABENoBAAsgAEGAARDaAQALIARBgAFqJAAgAAvYAgIEfwJ+IwBBQGoiAyQAIAACfyAALQAIBEAgACgCBCEFQQEMAQsgACgCBCEFIAAoAgAiBCgCACIGQQRxRQRAQQEgBCgCGEGNrMAAQZeswAAgBRtBAkEBIAUbIARBHGooAgAoAgwRAgANARogASAEIAIoAgwRAQAMAQsgBUUEQCAEKAIYQZWswABBAiAEQRxqKAIAKAIMEQIABEBBACEFQQEMAgsgBCgCACEGCyADQQE6ABcgA0E0akHsq8AANgIAIANBEGogA0EXajYCACADIAY2AhggAyAEKQIYNwMIIAQpAgghByAEKQIQIQggAyAELQAgOgA4IAMgBCgCBDYCHCADIAg3AyggAyAHNwMgIAMgA0EIajYCMEEBIAEgA0EYaiACKAIMEQEADQAaIAMoAjBBi6zAAEECIAMoAjQoAgwRAgALOgAIIAAgBUEBajYCBCADQUBrJAALpwIBBX8gAEIANwIQIAACf0EAIAFBgAJJDQAaQR8gAUH///8HSw0AGiABQQYgAUEIdmciAmt2QQFxIAJBAXRrQT5qCyICNgIcIAJBAnRBtMfAAGohAyAAIQQCQAJAAkACQEGoxcAAKAIAIgVBASACdCIGcQRAIAMoAgAhAyACEKsBIQIgAxDVASABRw0BIAMhAgwCC0GoxcAAIAUgBnI2AgAgAyAANgIADAMLIAEgAnQhBQNAIAMgBUEddkEEcWpBEGoiBigCACICRQ0CIAVBAXQhBSACIgMQ1QEgAUcNAAsLIAIoAggiASAENgIMIAIgBDYCCCAEIAI2AgwgBCABNgIIIABBADYCGA8LIAYgADYCAAsgACADNgIYIAQgBDYCCCAEIAQ2AgwL2wICBH8CfiMAQUBqIgIkAEEBIQQCQCAALQAEDQAgAC0ABSEEAkACQAJAIAAoAgAiAygCACIFQQRxRQRAIAQNAQwDCyAEDQFBASEEIAMoAhhBmazAAEEBIANBHGooAgAoAgwRAgANAyADKAIAIQUMAQtBASEEIAMoAhhBjazAAEECIANBHGooAgAoAgwRAgBFDQEMAgtBASEEIAJBAToAFyACQTRqQeyrwAA2AgAgAkEQaiACQRdqNgIAIAIgBTYCGCACIAMpAhg3AwggAykCCCEGIAMpAhAhByACIAMtACA6ADggAiADKAIENgIcIAIgBzcDKCACIAY3AyAgAiACQQhqNgIwIAEgAkEYakGolMAAKAIAEQEADQEgAigCMEGLrMAAQQIgAigCNCgCDBECACEEDAELIAEgA0GolMAAKAIAEQEAIQQLIABBAToABSAAIAQ6AAQgAkFAayQAC7YCAQV/IAAoAhghBAJAAkAgACAAKAIMRgRAIABBFEEQIABBFGoiASgCACIDG2ooAgAiAg0BQQAhAQwCCyAAKAIIIgIgACgCDCIBNgIMIAEgAjYCCAwBCyABIABBEGogAxshAwNAIAMhBSACIgFBFGoiAygCACICRQRAIAFBEGohAyABKAIQIQILIAINAAsgBUEANgIACwJAIARFDQACQCAAIAAoAhxBAnRBtMfAAGoiAigCAEcEQCAEQRBBFCAEKAIQIABGG2ogATYCACABDQEMAgsgAiABNgIAIAENAEGoxcAAQajFwAAoAgBBfiAAKAIcd3E2AgAPCyABIAQ2AhggACgCECICBEAgASACNgIQIAIgATYCGAsgAEEUaigCACIARQ0AIAFBFGogADYCACAAIAE2AhgLC28BDH9B1MjAACgCACICRQRAQeTIwABB/x82AgBBAA8LQczIwAAhBgNAIAIiASgCCCECIAEoAgQhAyABKAIAIQQgAUEMaigCABogASEGIAVBAWohBSACDQALQeTIwAAgBUH/HyAFQf8fSxs2AgAgCAuKAgEGfyABQQRqKAIAIQIgASgCACEDAkACQCABKAIIIgRFDQAgAiAETQRAIAIgBEYNAQwCCyADIARqLAAAQb9/TA0BC0EBIQcCQCACIARGDQAgAyAEaiICLAAAIgNBf0oNACACLQABQT9xIQUgA0EfcSEGAkAgA0FgSQRAIAZBBnQgBXIhAgwBCyACLQACQT9xIAVBBnRyIQUgA0FwSQRAIAUgBkEMdHIhAgwBCyAGQRJ0QYCA8ABxIAItAANBP3EgBUEGdHJyIgJBgIDEAEYNAQsgAkGA5H5qQaWjAUsNACABIARBA2o2AghBACEHCyAAIAE2AgQgACAHNgIADwsgAyACIAQgAhCaAQALiwICBH8BfiMAQTBrIgIkACABQQRqIQQgASgCBEUEQCABKAIAIQMgAkEQaiIFQQA2AgAgAkIBNwMIIAIgAkEIajYCFCACQShqIANBEGopAgA3AwAgAkEgaiADQQhqKQIANwMAIAIgAykCADcDGCACQRRqQZCmwAAgAkEYahAsGiAEQQhqIAUoAgA2AgAgBCACKQMINwIACyACQSBqIgMgBEEIaigCADYCACABQQxqQQA2AgAgBCkCACEGIAFCATcCBCACIAY3AxhBDEEEELsBIgFFBEBBDEEEENkBAAsgASACKQMYNwIAIAFBCGogAygCADYCACAAQeynwAA2AgQgACABNgIAIAJBMGokAAvmAQEBfyMAQRBrIgIkACAA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AkEQaiQAC3ABAX8jAEEwayICJAAgAiABNgIEIAIgADYCACACQRxqQQI2AgAgAkEsakEDNgIAIAJCAzcCDCACQayqwAA2AgggAkEDNgIkIAIgAkEgajYCGCACIAJBBGo2AiggAiACNgIgIAJBCGpByJjAABCSAQALcAEBfyMAQTBrIgIkACACIAE2AgQgAiAANgIAIAJBHGpBAjYCACACQSxqQQM2AgAgAkICNwIMIAJBhK/AADYCCCACQQM2AiQgAiACQSBqNgIYIAIgAkEEajYCKCACIAI2AiAgAkEIakGUr8AAEJIBAAtwAQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEcakECNgIAIAJBLGpBAzYCACACQgI3AgwgAkG0rsAANgIIIAJBAzYCJCACIAJBIGo2AhggAiACQQRqNgIoIAIgAjYCICACQQhqQeSuwAAQkgEAC3ABAX8jAEEwayICJAAgAiABNgIEIAIgADYCACACQRxqQQI2AgAgAkEsakEDNgIAIAJCAjcCDCACQcivwAA2AgggAkEDNgIkIAIgAkEgajYCGCACIAJBBGo2AiggAiACNgIgIAJBCGpB2K/AABCSAQALbQEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQM2AgAgA0ICNwIMIANBhKvAADYCCCADQQM2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEJIBAAtWAQJ/IwBBIGsiAiQAIABBHGooAgAhAyAAKAIYIAJBGGogAUEQaikCADcDACACQRBqIAFBCGopAgA3AwAgAiABKQIANwMIIAMgAkEIahAsIAJBIGokAAtZAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQbilwAAgAkEIahAsIAJBIGokAAtZAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQZCmwAAgAkEIahAsIAJBIGokAAtoACMAQTBrIgEkAEHsxMAALQAABEAgAUEcakEBNgIAIAFCAjcCDCABQfimwAA2AgggAUEDNgIkIAEgADYCLCABIAFBIGo2AhggASABQSxqNgIgIAFBCGpBoKfAABCSAQALIAFBMGokAAtZAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQbSowAAgAkEIahAsIAJBIGokAAtoAQJ/IAEoAgAhAwJAAkACQCABQQhqKAIAIgFFBEBBASECDAELIAFBf0wNASABQQEQuwEiAkUNAgsgAiADIAEQ3wEhAiAAIAE2AgggACABNgIEIAAgAjYCAA8LEJEBAAsgAUEBENkBAAtZAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQeitwAAgAkEIahAsIAJBIGokAAtWAQF/IwBBIGsiAiQAIAIgADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQeitwAAgAkEIahAsIAJBIGokAAtaAQF/IwBBEGsiAiQAAn8gACgCACIAKAIARQRAIAFBiJfAAEEEEK0BDAELIAIgAUH0lsAAQQQQlgEgAiAANgIMIAIgAkEMakH4lsAAEEUgAhBrCyACQRBqJAALUQECfyAAQQhqKAIAIQIgAEEgaigCACIBIABBHGooAgBGBEAgAEEYaiABEFMgACgCICEBCyAAKAIYIAFBAnRqIAI2AgAgACAAKAIgQQFqNgIgC1YBAn8gASgCACECIAFBADYCAAJAIAIEQCABKAIEIQNBCEEEELsBIgFFDQEgASADNgIEIAEgAjYCACAAQYyXwAA2AgQgACABNgIADwsAC0EIQQQQ2QEAC08BAn8gACgCACIDQQRqKAIAIANBCGoiBCgCACIAayACSQRAIAMgACACEFsgBCgCACEACyADKAIAIABqIAEgAhDfARogBCAAIAJqNgIAQQALTAACQCADRQ0AAkAgAiADTQRAIAIgA0cNAQwCCyABIANqLAAAQb9/Sg0BCyAAQQA2AgAPCyAAIAI2AgQgACABNgIAIABBCGogAzYCAAtDAQN/AkAgAkUNAANAIAAtAAAiBCABLQAAIgVGBEAgAEEBaiEAIAFBAWohASACQX9qIgINAQwCCwsgBCAFayEDCyADC0sAAkACfyABQYCAxABHBEBBASAAKAIYIAEgAEEcaigCACgCEBEBAA0BGgsgAg0BQQALDwsgACgCGCACIAMgAEEcaigCACgCDBECAAtIAQF/IwBBEGsiAiQAIAJBCGogARCOASACIAIoAgggAigCDCgCGBEAACACKAIEIQEgACACKAIANgIAIAAgATYCBCACQRBqJAALSAEBfyMAQSBrIgMkACADQRRqQQA2AgAgA0HEqsAANgIQIANCATcCBCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQkgEAC0kBAX8jAEEgayICJAAgAkEUakEBNgIAIAJCATcCBCACQdCrwAA2AgAgAkHCADYCHCACIAA2AhggAiACQRhqNgIQIAIgARCSAQALRgECfyABKAIEIQIgASgCACEDQQhBBBC7ASIBRQRAQQhBBBDZAQALIAEgAjYCBCABIAM2AgAgAEH8p8AANgIEIAAgATYCAAs+AQF/IwBBEGsiAiQAIAJBCGogASABKAIAKAIEEQAAIAIoAgwhASAAIAIoAgg2AgAgACABNgIEIAJBEGokAAs5AQF/IAFBEHZAACECIABBADYCCCAAQQAgAUGAgHxxIAJBf0YiARs2AgQgAEEAIAJBEHQgARs2AgALagEDfyMAQRBrIgEkACAAKAIMIgJFBEBBqKbAAEErQcynwAAQiwEACyAAKAIIIgNFBEBBqKbAAEErQdynwAAQiwEACyABIAI2AgggASAANgIEIAEgAzYCACABKAIAIAEoAgQgASgCCBBsAAtAAQF/IwBBIGsiACQAIABBHGpBADYCACAAQcyowAA2AhggAEIBNwIMIABBjKnAADYCCCAAQQhqQZSpwAAQkgEACz8BAX8jAEEgayICJAAgAkEBOgAYIAIgATYCFCACIAA2AhAgAkHAq8AANgIMIAJBxKrAADYCCCACQQhqEJABAAsrAAJAIABBfEsNACAARQRAQQQPCyAAIABBfUlBAnQQuwEiAEUNACAADwsACzABAX8jAEEQayICJAAgAkEIaiAAEI4BIAIoAgggASACKAIMKAIQEQEAIAJBEGokAAs8ACAAKAIAIQAgAS0AAEEQcUEEdkUEQCABLQAAQSBxQQV2RQRAIAAgARDIAQ8LIAAgARBoDwsgACABEGcLNAAgACABKAIYIAIgAyABQRxqKAIAKAIMEQIAOgAIIAAgATYCACAAIANFOgAJIABBADYCBAs1AQF/QeQAQQQQuwEiAUUEQEHkAEEEENkBAAsgAUG8ksAANgIAIAFBBGogAEHgABDfARogAQswAQF/IAAgAUEMaigCAEENIAEoAgAiAhs2AgQgACABQQRqKAIAQYaRwAAgAhs2AgALLgEBfyMAQRBrIgMkACADIAE2AgwgAyAANgIIIANBCGpBiJTAAEEAIAJBARBdAAtAAQF/IwBBEGsiBCQAIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCACAEKAIAIAQoAgQgBCgCCCAEKAIMEBIACzAAIAEoAhggAiADIAFBHGooAgAoAgwRAgAhAiAAQQA6AAUgACACOgAEIAAgATYCAAs1AQF/IAEoAhhBmqzAAEEBIAFBHGooAgAoAgwRAgAhAiAAQQA6AAUgACACOgAEIAAgATYCAAsnACAAIAAoAgRBAXEgAXJBAnI2AgQgACABaiIAIAAoAgRBAXI2AgQLLwEBf0EBIQEgAC0ABAR/IAEFIAAoAgAiACgCGEGbrMAAQQEgACgCHCgCDBECAAsLNQEBfyMAQRBrIgMkACADIAI2AgggAyABNgIEIAMgADYCACADKAIAIAMoAgQgAygCCBCZAQALIAEBfwJAIAAoAgQiAUUNACAAQQhqKAIARQ0AIAEQGgsLJgEBfyMAQRBrIgMkACADIAE2AgwgAyAANgIIIANBCGogAhCMAQALHwACQCABQXxNBEAgACABQQQgAhC0ASIADQELAAsgAAsjACACIAIoAgRBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAseACAAIAFBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQLFAAgAEEEaigCAARAIAAoAgAQGgsLHQAgASgCAEUEQAALIABBjJfAADYCBCAAIAE2AgALHgAgACAENgIMIAAgAzYCCCAAIAI2AgQgACABNgIACxkBAX8gACgCECIBBH8gAQUgAEEUaigCAAsLGAAgACgCACIAKAIAIABBCGooAgAgARAgCxkAIAAoAgAiACgCACAAQQhqKAIAIAEQ3QELEgBBAEEZIABBAXZrIABBH0YbCxYAIAAgAUEBcjYCBCAAIAFqIAE2AgALGQAgACgCGCABIAIgAEEcaigCACgCDBECAAscACABKAIYQaC+wABBBSABQRxqKAIAKAIMEQIACxAAIAAgAWpBf2pBACABa3ELFAAgACgCACAAQQhqKAIAIAEQ3QELFgAgAEHklMAANgIEIAAgAUEEajYCAAsNACAAQQRqEFogABAaCxgAIABBBGpBACABQvbYw8Knpo2P2ABRGwsMACAAIAEgAiADECILCwAgAQRAIAAQGgsLDwAgAEEBdCIAQQAgAGtyCxQAIAAoAgAgASAAKAIEKAIQEQEACxQAIAAoAgAgASAAKAIEKAIMEQEACxMAIABBKDYCBCAAQayUwAA2AgALEwAgAEGglcAANgIEIAAgATYCAAsIACAAIAEQOQsNACAAKAIAIAEQPUEACxMAIABB/KfAADYCBCAAIAE2AgALDQAgAC0ABEECcUEBdgsQACABIAAoAgAgACgCBBAdCxEAIABBxQA2AgQgACABNgIACw0AIAAoAgAgASACECsLCgBBACAAayAAcQsLACAALQAEQQNxRQsMACAAIAFBA3I2AgQLDQAgACgCACAAKAIEagsNACAAKAIAIAEQPkEACw4AIAAoAgAaA0AMAAsACwsAIAA1AgAgARBDCwwAIAAgASACEKEBAAsNACAAKAIAIAEgAhAmCwsAIAAjAGokACMACwsAIAAoAgAgARBtCwsAIAAoAgAgARBwCwkAIABBBGoQWgsGACAAEBoLCwAgACgCACABED8LDQBB6KPAAEEbENMBAAsOAEGDpMAAQc8AENMBAAsJACAAIAEQAAALCwAgACgCACABEDELCgAgACgCBEF4cQsKACAAKAIEQQFxCwoAIAAoAgxBAXELCgAgACgCDEEBdgsZACAAIAFBkMXAACgCACIAQTAgABsRAAAACwkAIAAgARB4AAsJACAAIAEQdwALCQAgACABEHkACwoAIAIgACABEB0LCwAgACABIAIQiAELCgAgACABIAIQQAsJACAAQQA2AgALCAAgACABEDELBwAgACABagsHACAAIAFrCwcAIABBCGoLBwAgAEF4agsUACAAKAIAIgAgACgCACgCABEFAAsNAEL22MPCp6aNj9gACwQAQQALDQBCy+LAreLn4Lr1AAsNAEKL5OeV8riP17h/CwwAQtDP+OGG3NjFbQsNAELQ5fiHi+Oq9e8ACwMAAQsL8kQCAEGAgMAAC/EldW5rbm93biBwYXJzaW5nIGVycm9yZXhwZWN0ZWQgAAAVABAACQAAAHVuZXhwZWN0ZWQgACgAEAALAAAAOyBleHBlY3RlZCAAKAAQAAsAAAA8ABAACwAAAC0tPiA6CiB8CiB8ICA9IAAAABAAAAAAAFgAEAAEAAAAAAAQAAAAAABcABAAAQAAAF0AEAABAAAAXgAQAAMAAABhABAAAwAAAF0AEAABAAAAYQAQAAMAAABdABAAAQAAAF4AEAADAAAAZAAQAAMAAAAAAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAEAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAgAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAADAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAAAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAgAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAEAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAAAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAABQAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAAAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAAAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAABgAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAgfCAuLi4KAAAAEAAAAAAAWAAQAAQAAAAAABAAAAAAAFwAEAABAAAAXQAQAAEAAABeABAAAwAAAGEAEAADAAAAXQAQAAEAAABIAhAABwAAAGEAEAADAAAAXQAQAAEAAABhABAAAwAAAF0AEAABAAAAXgAQAAMAAABkABAAAwAAAAAAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAQAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAACAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAQAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAAAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAACAAAAIAAAAAAAAAACAAAAAAAAAAEAAAAJAAAAAwAAAAUAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAAAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAADAAAAIAAAAAAAAAACAAAAAAAAAAEAAAAJAAAAAwAAAAYAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAAAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAHAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAAAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAAAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAIAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAAAEAAAAAAAWAAQAAQAAAAAABAAAAAAAFwAEAABAAAAXQAQAAEAAABeABAAAwAAAGEAEAADAAAAXQAQAAEAAABhABAAAwAAAF0AEAABAAAAYQAQAAMAAABdABAAAQAAAF4AEAADAAAAZAAQAAMAAAAAAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAEAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAgAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAEAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAAAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAgAAACAAAAAAAAAAAgAAAAAAAAABAAAACQAAAAMAAAAFAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAMAAAAgAAAAAAAAAAIAAAAAAAAAAQAAAAkAAAADAAAABgAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAAAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAcAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAAAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAAAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAgAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAAAQAAAAAABcABAAAQAAAAAAEAAAAAAALCAsIG9yIAAAABAAAAAAAPIGEAAFAAAAIG9yIAAAEAAAAAAACAcQAAQAAABwb3NpdGlvbiBvdXQgb2YgYm91bmRzL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3Blc3QtMi4xLjMvc3JjL3Bvc2l0aW9uLnJzAAAAMgcQAFcAAADHAAAADQAAADIHEABXAAAAygAAAAoAAAAyBxAAVwAAAIkAAAANAAAAMgcQAFcAAACOAAAAFgAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGUyBxAAVwAAAK0AAAAZAAAARXJyb3J2YXJpYW50BQAAAAQAAAAEAAAABgAAAGxvY2F0aW9uBQAAAAQAAAAEAAAABwAAAGxpbmVfY29sBQAAAAQAAAAEAAAACAAAAHBhdGgFAAAABAAAAAQAAAAJAAAAbGluZQUAAAAEAAAABAAAAAoAAABjb250aW51ZWRfbGluZXBhcnNpbmcgZXJyb3JDdXN0b21FcnJvcm1lc3NhZ2VQYXJzaW5nRXJyb3Jwb3NpdGl2ZXMAAAUAAAAEAAAABAAAAAsAAABuZWdhdGl2ZXMvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGVzdC0yLjEuMy9zcmMvc3RhY2sucnMAAADVCBAAVAAAAFkAAAAeAAAADAAAAA0AAAAOAAAADwAAABAAAAAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGVzdC0yLjEuMy9zcmMvaXRlcmF0b3JzL3BhaXIucnMAAABQCRAAXQAAAPoAAAAPAAAAUAkQAF0AAADxAAAADwAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGVQCRAAXQAAAPUAAAASAAAAEQAAAAgAAAAEAAAAEgAAABMAAAARAAAABAAAAAQAAAACAAAAZGVzY3JpcHRpb24oKSBpcyBkZXByZWNhdGVkOyB1c2UgRGlzcGxheRQAAABgAAAABAAAABUAAAAUAAAAYAAAAAQAAAAWAAAAFQAAAFQKEAAXAAAAGAAAABkAAAAaAAAAGwAAABwAAABkAAAABAAAAB0AAAAcAAAAZAAAAAQAAAAeAAAAHQAAAJAKEAAfAAAAIAAAACEAAAAiAAAAHwAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wZXN0LTIuMS4zL3NyYy9pdGVyYXRvcnMvcGFpcnMucnMAAMwKEABeAAAAwwAAAA8AAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlzAoQAF4AAADHAAAAEgAAAFNvbWUjAAAABAAAAAQAAAAKAAAATm9uZSMAAAAIAAAABAAAACQAAAAvcnVzdGMvNGI5MWE2ZWE3MjU4YTk0N2U1OWM2NTIyY2Q1ODk4ZTdjMGE2YTg4Zi9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAnAsQAEoAAABpBAAAFQAAAJwLEABKAAAAdwQAAB4AAACcCxAASgAAAIAEAAAYAAAAnAsQAEoAAACBBAAAGQAAAJwLEABKAAAAhAQAABoAAACcCxAASgAAAIoEAAANAAAAnAsQAEoAAACLBAAAEgAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGVzdC0yLjEuMy9zcmMvaXRlcmF0b3JzL3BhaXIucnODDBAAXQAAAHQAAAAKAAAAgwwQAF0AAABTAAAADwAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGWDDBAAXQAAAFUAAAASAAAAc3JjL3BhcnNlci5ycwAAADgNEAANAAAAJgAAAC8AAAA4DRAADQAAADwAAAAuAAAAOA0QAA0AAABBAAAAHwAAAExpbmVCbG9ja090aGVyT3RoZXJDaGFyU3BlY2lhbEJsb2NrVGltZW1pblNlY2hvdXJVUkx1cmxCb2R5dXJsU2NoZW1hRG9jTGlua2RvY0NoYXJJbmxpbmVNYXRoaW5saW5lTWF0aENoYXJJbmxpbmVDb2RlaW5saW5lQ29kZUNoYXJJbmxpbmVFbWlubGluZUVtQ2hhcmVtcGhhc2lzTWFya1B1bmN0RldQdW5jdE11bHRpU3BhY2VOdW1FbmdDblNwYWNlRU9JYXNzZXJ0aW9uIGZhaWxlZDogbWlkIDw9IHNlbGYubGVuKClhdHRlbXB0IHRvIGpvaW4gaW50byBjb2xsZWN0aW9uIHdpdGggbGVuID4gdXNpemU6Ok1BWC9ydXN0Yy80YjkxYTZlYTcyNThhOTQ3ZTU5YzY1MjJjZDU4OThlN2MwYTZhODhmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0ci5yc5gOEABIAAAAqwAAAAoAAACYDhAASAAAAMIAAAAWAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZXBlZWsgd2FzIGNhbGxlZCBvbiBlbXB0eSBzdGFjay9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wZXN0LTIuMS4zL3NyYy9wYXJzZXJfc3RhdGUucnNJDxAAWwAAAHQDAAAOAAAASQ8QAFsAAADsAAAAGwAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGVJDxAAWwAAAPEAAAAeAAAAcG9wIHdhcyBjYWxsZWQgb24gZW1wdHkgc3RhY2sAAABJDxAAWwAAAJEDAAAOAAAASQ8QAFsAAABhAAAAQwAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wZXN0LTIuMS4zL3NyYy9zcGFuLnJzADwQEABTAAAAtQAAAAoAAAAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGVzdC0yLjEuMy9zcmMvcG9zaXRpb24ucnMAoBAQAFcAAAB7AQAAHAAAAKAQEABXAAAAZwEAABoAAACgEBAAVwAAAAQBAAAfAAAAc3BhbiBjcmVhdGVkIGZyb20gcG9zaXRpb25zIGZyb20gZGlmZmVyZW50IGlucHV0cwAAAKAQEABXAAAAcgAAAA0AAADjgILvvIzvvJvjgIHvvIHvvJ/vvJpmdHA6Ly9jYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJg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AgYCAgEEIwEeG1sLOgkJARgEAQkBAwEFKwM8CCoYASA3AQEBBAgEAQMHCgIdAToBAQECBAgBCQEKAhoBAgI5AQQCBAICAwMBHgIDAQsCOQEEBQECBAEUAhYGAQE6AQECAQQIAQcDCgIeATsBAQEMAQkBKAEDATcBAQMFAwEEBwILAh0BOgECAQIBAwEFAgcCCwIcAjkCAQECBAgBCQEKAh0BSAEEAQIDAQEIAVEBAgcMCGIBAgkLBkoCGwEBAQEBNw4BBQECBQsBJAkBZgQBBgECAgIZAgQDEAQNAQICBgEPAQADAAMdAh4CHgJAAgEHCAECCwkBLQMBAXUCIgF2AwQCCQEGA9sCAgE6AQEHAQEBAQIIBgoCATAfMQQwBwEBBQEoCQwCIAQCAgEDOAEBAgMBAQM6CAICmAMBDQEHBAEGAQMCxkAAAcMhAAONAWAgAAZpAgAEAQogAlACAAEDAQQBGQIFAZcCGhINASYIGQsuAzABAgQCAicBQwYCAgICDAEIAS8BMwEBAwICBQIBASoCCAHuAQIBBAEAAQAQEBAAAgAB4gGVBQADAQIFBCgDBAGlAgAEAAKZCzEEewE2DykBAgIKAzEEAgIHAT0DJAUBCD4BDAI0CQoEAgFfAwIBAQIGAaABAwgVAjkCAQEBARYBDgcDBcMIAgMBARcBUQECBgEBAgEBAgEC6wECBAYCAQIbAlUIAgEBAmoBAQECBgEBZQMCBAEFAAkBAvUBCgIBAQQBkAQCAgQBIAooBgIECAEJBgIDLg0BAgAHAQYBAVIWAgcBAgECegYDAQECAQcBAUgCAwEBAQACAAU7BwABPwRRAQACAC4CFwABAQMEBQgIAgceBJQDADcEMggBDgEWBQEPAAcBEQIHAQIBBQAHAAE9BAAHbQcAYIDwAHsJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0Yx0xLjYzLjAgKDRiOTFhNmVhNyAyMDIyLTA4LTA4KQZ3YWxydXMGMC4xOS4wDHdhc20tYmluZGdlbhIwLjIuODAgKDRjYWE5ODE2NSk=");

// liberty-web/charliberty.js
var wasm;
var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
var cachegetUint8Memory0 = null;
function getUint8Memory0() {
  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachegetUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = new TextEncoder("utf-8");
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachegetInt32Memory0 = null;
function getInt32Memory0() {
  if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
    cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachegetInt32Memory0;
}
function formatLine(line) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(line, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.formatLine(retptr, ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    return getStringFromWasm0(r0, r1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(r0, r1);
  }
}
var cachegetUint32Memory0 = null;
function getUint32Memory0() {
  if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);
  }
  return cachegetUint32Memory0;
}
function getArrayU32FromWasm0(ptr, len) {
  return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);
}
function getBlockRanges(line, cursor_pos) {
  const ptr0 = passStringToWasm0(line, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.getBlockRanges(ptr0, len0, cursor_pos);
  return Blocks.__wrap(ret);
}
var Blocks = class {
  static __wrap(ptr) {
    const obj = Object.create(Blocks.prototype);
    obj.ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_blocks_free(ptr);
  }
  get special() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.blocks_special(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var v0 = getArrayU32FromWasm0(r0, r1).slice();
      wasm.__wbindgen_free(r0, r1 * 4);
      return v0;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  get emphasis() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.blocks_emphasis(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var v0 = getArrayU32FromWasm0(r0, r1).slice();
      wasm.__wbindgen_free(r0, r1 * 4);
      return v0;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
function load(module2, imports) {
  return __async(this, null, function* () {
    if (typeof Response === "function" && module2 instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming === "function") {
        try {
          return yield WebAssembly.instantiateStreaming(module2, imports);
        } catch (e) {
          if (module2.headers.get("Content-Type") != "application/wasm") {
            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
          } else {
            throw e;
          }
        }
      }
      const bytes = yield module2.arrayBuffer();
      return yield WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = yield WebAssembly.instantiate(module2, imports);
      if (instance instanceof WebAssembly.Instance) {
        return { instance, module: module2 };
      } else {
        return instance;
      }
    }
  });
}
function init(input) {
  return __async(this, null, function* () {
    if (typeof input === "undefined") {
      input = new URL("charliberty_bg.wasm", "");
    }
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
      input = fetch(input);
    }
    const { instance, module: module2 } = yield load(yield input, imports);
    wasm = instance.exports;
    init.__wbindgen_wasm_module = module2;
    return wasm;
  });
}
var charliberty_default = init;

// src/const.ts
var FW;
((FW2) => {
  FW2.DOT = "\xB7";
  FW2.MONEY = "\uFFE5";
  FW2.FULLSTOP = "\u3002";
  FW2.LT = "\u300A";
  FW2.GT = "\u300B";
  FW2.SLASH = "\u3001";
  FW2.LEFTQUO = "\u201C";
  FW2.RIGHTQUO = "\u201D";
  FW2.LEFTPAREN = "\uFF08";
  FW2.RIGHTPAREN = "\uFF09";
})(FW || (FW = {}));
var SW;
((SW2) => {
  SW2.DOT = "`";
  SW2.MONEY = "$";
  SW2.FULLSTOP = ".";
  SW2.LT = "<";
  SW2.GT = ">";
  SW2.SLASH = "/";
  SW2.LEFTQUO = '"';
  SW2.RIGHTQUO = '"';
  SW2.LEFTPAREN = "(";
  SW2.RIGHTPAREN = ")";
})(SW || (SW = {}));
var PUNCTS = new Set(" \uFF0C\u3002\uFF1A\uFF1F,.:?");
var DEFAULT_RULES = String.raw`
# Line head conversion
# Note: this rule can't apply to the very first line of the document
'\n|' -> '\n>|'
'\n|' -> '\n/|'

# CN symbols to EN
'|' -> '.|'
'|' -> '>|'
'|' -> '/|'
'|' -> ';|'
'|' -> ',|'

# Auto-pair, Input Conversion, and Deletion
'|' -> '<|' # this one take higer priority than the next line
'|'    -> '|'
'|'   -x '|'
'|' -> '(|)'
'|'     -> '|'
'|'   -x '|'

# Auto code block
'|'  -> '\`|\`' # inline block
'\`|\`' -> '\`\`\`|\n\`\`\`'

# have fun converting!
'dpx|' -> 'don\'t panic|'


# Selection Insert Rules
''  -> '\`' + '\`'
''  -> '$' + '$'
''  -> '' + ''
'<'  -> '<' + '>'
`.replaceAll("\\`", "`");

// src/utils.ts
var config;
function initLog(cfg) {
  config = cfg;
}
function log(format, ...parts) {
  if (config != void 0 && config.debug) {
    parts.forEach((v, idx) => {
      if (typeof v === "string" || v instanceof String) {
        parts[idx] = JSON.stringify(v);
      }
    });
    console.log(format, ...parts);
  }
}

// src/ext_convert.ts
var EOF = "EOF";
var ANCHOR = "\xA6";
var DEL_TRIG = "\u274C";
var ParseResult = class {
  constructor(value, error) {
    this.value = value;
    this.error = error;
  }
  get isOk() {
    return this.error == "";
  }
};
function Ok(val) {
  return new ParseResult(val, "");
}
function Err(err) {
  return new ParseResult(null, err);
}
function findOnlyAnchor(s) {
  let res = -1, idx = 0;
  for (const ch of s) {
    if (ch === ANCHOR) {
      if (res == -1) {
        res = idx;
      } else {
        return -2;
      }
    }
    idx++;
  }
  return res;
}
function prefixOf(s1, s2) {
  if (s1.length > s2.length)
    return false;
  for (let i = 0; i < s1.length; i++) {
    if (s1[i] != s2[i])
      return false;
  }
  return true;
}
function suffixOf(s1, s2) {
  if (s1.length > s2.length)
    return false;
  for (let i = s1.length - 1, j = s2.length - 1; i > -1; i--, j--) {
    if (s1[i] != s2[j])
      return false;
  }
  return true;
}
var Rule = class {
};
var SideRule = class {
  constructor(trig, left, right) {
    this.trig = trig;
    this.left = left;
    this.right = right;
  }
  get isValid() {
    return this.trig.length === 1;
  }
};
var ConvRule = class {
  constructor(left, right, isForDelete = false) {
    this.isForDelete = isForDelete;
    this.left = Array.from(left);
    this.right = Array.from(right);
    this.lanchor = findOnlyAnchor(this.left);
    this.ranchor = findOnlyAnchor(this.right);
    if (this.lanchor > 0 && isForDelete) {
      this.left.splice(this.lanchor, 0, DEL_TRIG);
      this.lanchor += 1;
    }
    this.innerTrig = this.left[this.lanchor - 1];
    this.replace = this.right.slice(0, this.ranchor).join("") + this.right.slice(this.ranchor + 1).join("");
  }
  get isValid() {
    return this.lanchor > 0 && this.ranchor >= 0;
  }
  invalidReasons() {
    const reasons = [];
    if (this.lanchor < 0) {
      reasons.push(`Expected one | on left side, but found ${this.lanchor == -1 ? "none" : "multiple"}`);
    } else if (this.lanchor === 0) {
      reasons.push("Invalid Placement of | on the left side. Note: left side cannot start with |");
    }
    if (this.ranchor < 0) {
      reasons.push(`Expected one | on right side, but found ${this.ranchor == -1 ? "none" : "multiple"}`);
    }
    return reasons.join("\n");
  }
  get trigChar() {
    if (this.isForDelete) {
      return this.left[this.lanchor - 2];
    } else {
      return this.left[this.lanchor - 1];
    }
  }
  canConvert(inputS, insChr, insPosBaseHead) {
    const input = Array.from(inputS);
    if (!this.isValid || insChr != this.innerTrig)
      return false;
    const { left, lanchor } = this;
    if (!suffixOf(left.slice(0, lanchor - 1), input.slice(0, insPosBaseHead)))
      return false;
    return prefixOf(left.slice(lanchor + 1), input.slice(insPosBaseHead));
  }
  leftMatchPart() {
    return this.left.slice(0, this.lanchor);
  }
  mapToChanges(pos) {
    const { left, lanchor, ranchor } = this;
    const from = pos + 1 - lanchor;
    const to = from + left.length - 2;
    const newPos = pos + (ranchor - lanchor + 1);
    return {
      changes: { from, to, insert: this.replace },
      selection: { anchor: newPos, head: newPos }
    };
  }
};
var readable = JSON.stringify;
var RuleParser = class {
  constructor(input) {
    this.idx = 0;
    this.input = Array.from(input);
    this.convRules = [];
    this.sideRules = /* @__PURE__ */ new Map();
    this.errors = [];
  }
  peek() {
    const { idx, input } = this;
    if (idx == input.length) {
      return EOF;
    }
    return input[idx];
  }
  eat() {
    const { idx, input } = this;
    if (idx == input.length) {
      return EOF;
    }
    return input[this.idx++];
  }
  rewind() {
    this.idx--;
  }
  ignoreSpace() {
    while (this.peek() === " ") {
      this.eat();
    }
  }
  parseString() {
    this.ignoreSpace();
    if (this.peek() != "'") {
      return Err("Expected a rule starting with ', but found " + readable(this.peek()));
    }
    this.eat();
    const result = [];
    let ch;
    while (true) {
      ch = this.eat();
      switch (ch) {
        case "\\":
          switch (this.peek()) {
            case "'":
              result.push(this.eat());
              break;
            case "n":
              this.eat();
              result.push("\n");
              break;
            default:
              result.push(ch);
              break;
          }
          break;
        case "'":
          return Ok(result.join(""));
        case "\n":
          return Err("Expected a rule ending with ', but found newline. Note: escape intentional newline with '\\n'");
        case EOF:
          return Err("Expected a rule ending with ', but found nothing");
        default:
          result.push(ch);
          break;
      }
    }
  }
  parseMapArrow() {
    this.ignoreSpace();
    const first = this.eat(), second = this.eat();
    if (first === "-" && second === ">") {
      return Ok(0 /* Insert */);
    } else if (first === "-" && second === "x") {
      return Ok(1 /* Delete */);
    }
    return Err(`Expected -> or -x, but found ${readable(first)}${readable(second)}`);
  }
  parseComment() {
    this.ignoreSpace();
    let ch = this.peek();
    if (ch === "#") {
      while (ch != "\n" && ch != EOF) {
        ch = this.eat();
      }
      if (ch === "\n") {
        this.rewind();
      }
    }
    if (ch != "\n" && ch != EOF) {
      return Err("Expected only one rule in each line, but found " + readable(ch));
    }
    return Ok("#no content#");
  }
  isSideRule() {
    this.ignoreSpace();
    const ch = this.peek();
    if (ch != "+") {
      return false;
    } else {
      this.eat();
      return true;
    }
  }
  parseOne() {
    const r1 = this.parseString();
    if (!r1.isOk) {
      return Err(r1.error);
    }
    const r2 = this.parseMapArrow();
    if (!r2.isOk) {
      return Err(r2.error);
    }
    const r3 = this.parseString();
    if (!r3.isOk) {
      return Err(r3.error);
    }
    const rule = new Rule();
    if (this.isSideRule()) {
      if (r2.value === 1 /* Delete */) {
        return Err("Expected ->, but found -x. Note: selection rules cannot be deletion rules");
      }
      const rightInsert = this.parseString();
      if (!rightInsert.isOk) {
        return Err(rightInsert.error);
      }
      const sideRule = new SideRule(r1.value, r3.value, rightInsert.value);
      if (!sideRule.isValid) {
        return Err("Expected one char, but found multiple. Note: the selection rule trigger char can only be a single character");
      }
      rule.type = 1 /* SideRule */;
      rule.side = sideRule;
    } else {
      const convRule = new ConvRule(r1.value, r3.value, r2.value === 1 /* Delete */);
      if (!convRule.isValid) {
        return Err(convRule.invalidReasons());
      }
      rule.type = 0 /* ConvRule */;
      rule.conv = convRule;
    }
    const r4 = this.parseComment();
    if (!r4.isOk) {
      return Err(r4.error);
    }
    return Ok(rule);
  }
  parse() {
    let line = 1;
    while (true) {
      const r = this.parseComment();
      if (!r.isOk) {
        const rRes = this.parseOne();
        if (!rRes.isOk) {
          for (const msg of rRes.error.split("\n")) {
            this.errors.push(`line ${line}: ` + msg);
          }
        } else if (rRes.value.type === 0 /* ConvRule */) {
          this.convRules.push(rRes.value.conv);
        } else {
          const s = rRes.value.side;
          this.sideRules.set(s.trig, { l: s.left, r: s.right });
        }
      }
      const ch = this.eat();
      if (ch === "\n") {
        line++;
      } else {
        break;
      }
    }
  }
};
var Rules = class {
  constructor(ruletxt, justCheck = false) {
    const unescapedTxt = ruletxt.replaceAll("\\|", "{0v0}").replaceAll("|", ANCHOR).replaceAll("{0v0}", "|");
    const parser2 = new RuleParser(unescapedTxt);
    parser2.parse();
    this.rules = [];
    this.insertTrigSet = /* @__PURE__ */ new Set();
    this.deleteTrigSet = /* @__PURE__ */ new Set();
    this.lmax = this.rmax = 0;
    this.errors = parser2.errors;
    if (this.errors.length > 0)
      return;
    if (justCheck)
      return;
    this.rules = parser2.convRules;
    this.index = newConvRulesIndex(this.rules);
    this.sideInsertMap = parser2.sideRules;
    let lmax = 0, rmax = 0;
    for (const r of this.rules) {
      if (r.isForDelete) {
        this.deleteTrigSet.add(r.trigChar);
      } else {
        this.insertTrigSet.add(r.trigChar);
      }
      const lmax_ = r.lanchor - 1, rmax_ = r.left.length - 1 - r.lanchor;
      if (lmax_ > lmax)
        lmax = lmax_;
      if (rmax_ > rmax)
        rmax = rmax_;
    }
    this.lmax = lmax;
    this.rmax = rmax;
  }
  match(input, insChar, insPosBaseLineHead) {
    const leftMatch = input.slice(0, insPosBaseLineHead);
    const candidates = this.index.collectIdxsAlong(leftMatch + insChar);
    for (const idx of candidates.sort((a, b) => a - b)) {
      if (this.rules[idx].canConvert(input, insChar, insPosBaseLineHead)) {
        return this.rules[idx];
      }
    }
    return null;
  }
};
function newConvRulesIndex(rules) {
  const root = new TrieNode();
  for (let i = 0; i < rules.length; i++) {
    root.insert(rules[i], i);
  }
  return root;
}
var TrieNode = class {
  constructor() {
    this.next = /* @__PURE__ */ new Map();
    this.value = [];
  }
  isKeyStop() {
    return this.value.length > 0;
  }
  insert(rule, idx) {
    const key = rule.leftMatchPart();
    let node = this;
    for (let i = key.length - 1; i > -1; i--) {
      const ch = key[i];
      if (node.next.has(ch)) {
        node = node.next.get(ch);
      } else {
        const newNode = new TrieNode();
        node.next.set(ch, newNode);
        node = newNode;
      }
    }
    node.value.push(idx);
  }
  collectIdxsAlong(key) {
    const idxs = [];
    let node = this;
    for (let i = key.length - 1; i > -1; i--) {
      if (node.isKeyStop()) {
        idxs.push(...node.value);
      }
      node = node.next.get(key[i]);
      if (node === void 0) {
        break;
      }
    }
    if (node != void 0 && node.isKeyStop()) {
      idxs.push(...node.value);
    }
    return idxs;
  }
};

// src/ext_libertyzone.ts
var import_view = require("@codemirror/view");
function libertyZone(zonespotter) {
  return import_view.ViewPlugin.fromClass(class {
    constructor(_) {
      this.decorations = import_view.Decoration.none;
      this.cleanTimer = -1;
    }
    get isTimerActive() {
      return this.cleanTimer >= 0;
    }
    tryRemoveTimer() {
      if (this.isTimerActive) {
        window.clearTimeout(this.cleanTimer);
        this.cleanTimer = -1;
      }
    }
    update(update) {
      const range = zonespotter(update);
      if (range === void 0 || update.state.doc.lineAt(range.from).from == range.from) {
        this.tryRemoveTimer();
        this.cleanTimer = window.setTimeout(() => {
          if (this.decorations.size) {
            this.decorations = import_view.Decoration.none;
          }
        }, 1e3);
        return;
      }
      this.decorations = import_view.Decoration.set(import_view.Decoration.widget({
        widget: new MarkWidget(15),
        side: 1
      }).range(range.from));
      this.tryRemoveTimer();
    }
  }, {
    decorations: (v) => v.decorations
  });
}
var MarkWidget = class extends import_view.WidgetType {
  constructor(lineHeight) {
    super();
    this.lineHeight = lineHeight;
  }
  toDOM() {
    const mark = document.createElement("span");
    mark.style.position = "relative";
    mark.style.top = `-${this.lineHeight}px`;
    mark.innerText = "\u2B50\uFE0F";
    const wrapper = document.createElement("div");
    wrapper.style.display = "inline-block";
    wrapper.style.position = "absolute";
    wrapper.append(mark);
    return wrapper;
  }
  ignoreEvent() {
    return false;
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var import_state = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var import_language2 = require("@codemirror/language");

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var Range = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
};
var NodeProp = class {
  constructor(config3 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config3.perNode;
    this.deserialize = config3.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class {
  constructor(name2, props, id2, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id2;
    this.flags = flags;
  }
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  prop(prop) {
    return this.props[prop.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
var NodeSet = class {
  constructor(types) {
    this.types = types;
    for (let i = 0; i < types.length; i++)
      if (types[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add = source(type);
        if (add) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          newProps[add[0].id] = add[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new NodeSet(newTypes);
  }
};
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class {
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  toString() {
    let mounted = this.prop(NodeProp.mounted);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    cursor.moveTo(pos, side);
    CachedNode.set(this, cursor._tree);
    return cursor;
  }
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {
        if (c.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && !c.type.isAnonymous)
          leave(c);
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        entered = true;
      }
    }
  }
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  get propValues() {
    let result = [];
    if (this.props)
      for (let id2 in this.props)
        result.push([+id2, this.props[id2]]);
    return result;
  }
  balance(config3 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config3.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
  }
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class {
  constructor(buffer, index) {
    this.buffer = buffer;
    this.index = index;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class {
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  get type() {
    return NodeType.none;
  }
  toString() {
    let result = [];
    for (let index = 0; index < this.buffer.length; ) {
      result.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result.join(",");
  }
  childString(index) {
    let id2 = this.buffer[index], endIndex = this.buffer[index + 3];
    let type = this.set.types[id2], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index += 4;
    if (endIndex == index)
      return result;
    let children = [];
    while (index < endIndex) {
      children.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  slice(startI, endI, from, to) {
    let b = this.buffer;
    let copy = new Uint16Array(endI - startI);
    for (let i = startI, j = 0; i < endI; ) {
      copy[j++] = b[i++];
      copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - startI;
    }
    return new TreeBuffer(copy, to - from, this.set);
  }
};
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function enterUnfinishedNodesBefore(node, pos) {
  let scan = node.childBefore(pos);
  while (scan) {
    let last = scan.lastChild;
    if (!last || last.to != scan.to)
      break;
    if (last.type.isError && last.from == last.to) {
      node = scan;
      scan = last.prevSibling;
    } else {
      scan = last;
    }
  }
  return node;
}
function resolveNode(node, pos, side, overlays) {
  var _a;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, mode);
    if (!inner)
      return node;
    node = inner;
  }
}
var TreeNode = class {
  constructor(_tree, from, index, _parent) {
    this._tree = _tree;
    this.from = from;
    this.index = index;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i], start = positions[i] + parent.from;
        if (!checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index > -1)
            return new BufferNode(new BufferContext(parent, next, i, start), null, index);
        } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
            return new TreeNode(mounted.tree, start, i, parent);
          let inner = new TreeNode(next, start, i, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i = parent.index + dir;
      else
        i = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(pos) {
    return this.nextChild(0, 1, pos, 2);
  }
  childBefore(pos) {
    return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  enterUnfinishedNodesBefore(pos) {
    return enterUnfinishedNodesBefore(this, pos);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  toString() {
    return this._tree.toString();
  }
  get node() {
    return this;
  }
  matchContext(context) {
    return matchNodeContext(this, context);
  }
};
function getChildren(node, type, before, after) {
  let cur = node.cursor(), result = [];
  if (!cur.firstChild())
    return result;
  if (before != null) {
    while (!cur.type.is(before))
      if (!cur.nextSibling())
        return result;
  }
  for (; ; ) {
    if (after != null && cur.type.is(after))
      return result;
    if (cur.type.is(type))
      result.push(cur.node);
    if (!cur.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node, context, i = context.length - 1) {
  for (let p = node.parent; i >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context[i] && context[i] != p.name)
        return false;
      i--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent, buffer, index, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start;
  }
};
var BufferNode = class {
  constructor(context, _parent, index) {
    this.context = context;
    this._parent = _parent;
    this.index = index;
    this.type = context.buffer.set.types[context.buffer.buffer[index]];
  }
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(pos) {
    return this.child(1, pos, 2);
  }
  childBefore(pos) {
    return this.child(-1, pos, -2);
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
  }
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
      children.push(buffer.slice(startI, endI, from, to));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  enterUnfinishedNodesBefore(pos) {
    return enterUnfinishedNodesBefore(this, pos);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  get node() {
    return this;
  }
  matchContext(context) {
    return matchNodeContext(this, context);
  }
};
var TreeCursor = class {
  constructor(node, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  get name() {
    return this.type.name;
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index, type) {
    this.index = index;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index]];
    this.from = start + buffer.buffer[index + 1];
    this.to = start + buffer.buffer[index + 2];
    return true;
  }
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index);
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(pos) {
    return this.enterChild(1, pos, 2);
  }
  childBefore(pos) {
    return this.enterChild(-1, pos, -2);
  }
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({ index, parent } = buffer);
    } else {
      ({ index, _parent: parent } = this._tree);
    }
    for (; parent; { index, _parent: parent } = parent) {
      if (index > -1)
        for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
          let child = parent._tree.children[i];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(dir, 0, 4))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  next(enter = true) {
    return this.move(1, enter);
  }
  prev(enter = true) {
    return this.move(-1, enter);
  }
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache = this.bufferNode, result = null, depth = 0;
    if (cache && cache.context == this.buffer) {
      scan:
        for (let index = this.index, d = this.stack.length; d >= 0; ) {
          for (let c = cache; c; c = c._parent)
            if (c.index == index) {
              if (index == this.index)
                return c;
              result = c;
              depth = d + 1;
              break scan;
            }
          index = this.stack[--d];
        }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (this.nextSibling())
          break;
        if (!depth)
          return;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node, context);
    let { buffer } = this.buffer, { types } = buffer.set;
    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
      if (d < 0)
        return matchNodeContext(this.node, context, i);
      let type = types[buffer.buffer[this.stack[d]]];
      if (!type.isAnonymous) {
        if (context[i] && context[i] != type.name)
          return false;
        i--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
  var _a;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
    let { id: id2, start, end, size } = cursor;
    let lookAheadAtStart = lookAhead;
    while (size < 0) {
      cursor.next();
      if (size == -1) {
        let node2 = reused[id2];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id2;
        return;
      } else if (size == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types[id2], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor.pos - buffer2.size, index = data2.length;
      while (cursor.pos > endPos)
        index = copyToBuffer(buffer2.start, data2, index);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor.pos > endPos) {
        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
          if (cursor.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor.end;
          }
          cursor.next();
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function makeBalanced(type) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length2)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base, i, from, to, type, lookAhead2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base - from);
    }
    children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to));
    positions2.push(from - base);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2 = 0, props) {
    if (contextHash) {
      let pair2 = [NodeProp.contextHash, contextHash];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan:
      for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        let nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        let startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3)
              localSkipped += 4;
            else
              break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start = nodeStart;
        size += nodeSize2;
        skip += localSkipped;
      }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index) {
    let { id: id2, start, end, size } = cursor;
    cursor.next();
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index;
      if (size > 4) {
        let endPos = cursor.pos - (size - 4);
        while (cursor.pos > endPos)
          index = copyToBuffer(bufferStart, buffer2, index);
      }
      buffer2[--index] = startIndex;
      buffer2[--index] = end - bufferStart;
      buffer2[--index] = start - bufferStart;
      buffer2[--index] = id2;
    } else if (size == -3) {
      contextHash = id2;
    } else if (size == -4) {
      lookAhead = id2;
    }
    return index;
  }
  let children = [], positions = [];
  while (cursor.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i = from; i < to; i++)
    total += nodeSize(balanceType, children[i]);
  let maxChild = Math.ceil(total * 1.5 / 8);
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from2, to2, offset) {
    for (let i = from2; i < to2; ) {
      let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
      i++;
      for (; i < to2; i++) {
        let nextSize = nodeSize(balanceType, children2[i]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
var Parser = class {
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map((r) => new Range(r.from, r.to)) : [new Range(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse.advance();
      if (done)
        return done;
    }
  }
};
var StringInput = class {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to) {
    return this.string.slice(from, to);
  }
};
var stoppedInner = new NodeProp({ perNode: true });

// node_modules/@lezer/lr/dist/index.js
var Stack = class {
  constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  toString() {
    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(p, state, pos = 0) {
    let cx = p.parser.context;
    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  reduce(action) {
    let depth = action >> 19, type = action & 65535;
    let { parser: parser2 } = this.p;
    let dPrec = parser2.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth == 0) {
      this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
      if (type < parser2.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = this.stack[base - 2];
    let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base];
    } else {
      let baseStateID = this.stack[base - 3];
      this.state = parser2.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base)
      this.stack.pop();
    this.reduceContext(type, start);
  }
  storeNode(term, start, end, size = 4, isReduce = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur = this, top = this.buffer.length;
      if (top == 0 && cur.parent) {
        top = cur.bufferBase - cur.parent.bufferBase;
        cur = cur.parent;
      }
      if (top > 0 && cur.buffer[top - 4] == 0 && cur.buffer[top - 1] > -1) {
        if (start == end)
          return;
        if (cur.buffer[top - 2] >= start) {
          cur.buffer[top - 2] = end;
          return;
        }
      }
    }
    if (!isReduce || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index = this.buffer.length;
      if (index > 0 && this.buffer[index - 4] != 0)
        while (index > 0 && this.buffer[index - 2] > end) {
          this.buffer[index] = this.buffer[index - 4];
          this.buffer[index + 1] = this.buffer[index - 3];
          this.buffer[index + 2] = this.buffer[index - 2];
          this.buffer[index + 3] = this.buffer[index - 1];
          index -= 4;
          if (size > 4)
            size -= 4;
        }
      this.buffer[index] = term;
      this.buffer[index + 1] = start;
      this.buffer[index + 2] = end;
      this.buffer[index + 3] = size;
    }
  }
  shift(action, next, nextEnd) {
    let start = this.pos;
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, { parser: parser2 } = this.p;
      if (nextEnd > this.pos || next <= parser2.maxNode) {
        this.pos = nextEnd;
        if (!parser2.stateFlag(nextState, 1))
          this.reducePos = nextEnd;
      }
      this.pushState(nextState, start);
      this.shiftContext(next, start);
      if (next <= parser2.maxNode)
        this.buffer.push(next, start, nextEnd, 4);
    } else {
      this.pos = nextEnd;
      this.shiftContext(next, start);
      if (next <= this.p.parser.maxNode)
        this.buffer.push(next, start, nextEnd, 4);
    }
  }
  apply(action, next, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next, nextEnd);
  }
  useNode(value, next) {
    let index = this.p.reused.length - 1;
    if (index < 0 || this.p.reused[index] != value) {
      this.p.reused.push(value);
      index++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(index, start, this.reducePos, -1);
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
    while (parent && base == parent.bufferBase)
      parent = parent.parent;
    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
  }
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
      if ((action & 65536) == 0)
        return true;
      if (action == 0)
        return false;
      sim.reduce(action);
    }
  }
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i = 0, s; i < nextStates.length; i += 2) {
        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
          best.push(nextStates[i], s);
      }
      if (this.stack.length < 120)
        for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
          let s = nextStates[i + 1];
          if (!best.some((v, i2) => i2 & 1 && v == s))
            best.push(nextStates[i], s);
        }
      nextStates = best;
    }
    let result = [];
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s = nextStates[i + 1];
      if (s == this.state)
        continue;
      let stack = this.split();
      stack.pushState(s, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i], this.pos);
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  forceReduce() {
    let reduce = this.p.parser.stateSlot(this.state, 5);
    if ((reduce & 65536) == 0)
      return false;
    let { parser: parser2 } = this.p;
    if (!parser2.validAction(this.state, reduce)) {
      let depth = reduce >> 19, term = reduce & 65535;
      let target = this.stack.length - depth * 3;
      if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0)
        return false;
      this.storeNode(0, this.reducePos, this.reducePos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce);
    return true;
  }
  forceAll() {
    while (!this.p.parser.stateFlag(this.state, 2)) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser2 } = this.p;
    return parser2.data[parser2.stateSlot(this.state, 1)] == 65535 && !parser2.stateSlot(this.state, 4);
  }
  restart() {
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i = 0; i < this.stack.length; i += 3)
      if (this.stack[i] != other.stack[i])
        return false;
    return true;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3)
      this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
  }
  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4)
      this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead();
      this.lookAhead = lookAhead;
    }
  }
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
};
var StackContext = class {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
};
var Recover;
(function(Recover2) {
  Recover2[Recover2["Insert"] = 200] = "Insert";
  Recover2[Recover2["Delete"] = 190] = "Delete";
  Recover2[Recover2["Reduce"] = 100] = "Reduce";
  Recover2[Recover2["MaxNext"] = 4] = "MaxNext";
  Recover2[Recover2["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
  Recover2[Recover2["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
var SimulatedStack = class {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth = action >> 19;
    if (depth == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
};
var StackBufferCursor = class {
  constructor(stack, pos, index) {
    this.stack = stack;
    this.pos = pos;
    this.index = index;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index);
  }
};
var CachedToken = class {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
};
var nullToken = new CachedToken();
var InputStream = class {
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  resolveOffset(offset, assoc) {
    let range = this.range, index = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range.from) {
      if (!index)
        return null;
      let next = this.ranges[--index];
      pos -= range.from - next.to;
      range = next;
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index == this.ranges.length - 1)
        return null;
      let next = this.ranges[++index];
      pos += next.from - range.to;
      range = next;
    }
    return pos;
  }
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to)
      return pos;
    for (let range of this.ranges)
      if (range.to > pos)
        return Math.max(pos, range.from);
    return this.end;
  }
  peek(offset) {
    let idx = this.chunkOff + offset, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i = this.rangeIndex, range = this.range;
        while (range.to <= pos)
          range = this.ranges[++i];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to)
          this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  advance(n = 1) {
    this.chunkOff += n;
    while (this.pos + n >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = pos;
      token.lookAhead = pos + 1;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
    if (from >= this.range.from && to <= this.range.to)
      return this.input.read(from, to);
    let result = "";
    for (let r of this.ranges) {
      if (r.from >= to)
        break;
      if (r.to > from)
        result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
    }
    return result;
  }
};
var TokenGroup = class {
  constructor(data, id2) {
    this.data = data;
    this.id = id2;
  }
  token(input, stack) {
    readToken(this.data, input, stack, this.id);
  }
};
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var ExternalTokenizer = class {
  constructor(token, options = {}) {
    this.token = token;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }
};
function readToken(data, input, stack, group) {
  let state = 0, groupMask = 1 << group, { parser: parser2 } = stack.p, { dialect } = parser2;
  scan:
    for (; ; ) {
      if ((groupMask & data[state]) == 0)
        break;
      let accEnd = data[state + 1];
      for (let i = state + 3; i < accEnd; i += 2)
        if ((data[i + 1] & groupMask) > 0) {
          let term = data[i];
          if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || parser2.overrides(term, input.token.value))) {
            input.acceptToken(term);
            break;
          }
        }
      let next = input.next, low = 0, high = data[state + 2];
      if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
        state = data[accEnd + high * 3 - 1];
        continue scan;
      }
      for (; low < high; ) {
        let mid = low + high >> 1;
        let index = accEnd + mid + (mid << 1);
        let from = data[index], to = data[index + 1];
        if (next < from)
          high = mid;
        else if (next >= to)
          low = mid + 1;
        else {
          state = data[index + 2];
          input.advance();
          continue scan;
        }
      }
      break;
    }
}
function decodeArray(input, Type = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type(value);
  }
  return array;
}
var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
var stackIDs = null;
var Safety;
(function(Safety2) {
  Safety2[Safety2["Margin"] = 25] = "Margin";
})(Safety || (Safety = {}));
function cutAt(tree, pos, side) {
  let cursor = tree.cursor(IterMode.IncludeAnonymous);
  cursor.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
          return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25));
        if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
          break;
        if (!cursor.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
var FragmentCursor = class {
  constructor(fragments, nodeSet) {
    this.fragments = fragments;
    this.nodeSet = nodeSet;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top = this.trees[last], index = this.index[last];
      if (index == top.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top.children[index];
      let start = this.start[last] + top.positions[index];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom)
            return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to)
              return next;
          }
        }
        this.index[last]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start + next.length;
      }
    }
  }
};
var TokenCache = class {
  constructor(parser2, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser2 } = stack.p, { tokenizers } = parser2;
    let mask = parser2.stateSlot(stack.state, 3);
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0)
        continue;
      let tokenizer = tokenizers[i], token = this.tokens[i];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }
      if (token.lookAhead > token.end + 25)
        lookAhead = Math.max(token.lookAhead, lookAhead);
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken)
      return this.mainToken;
    let main = new CachedToken(), { pos, p } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p.stream.end);
    main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos);
    tokenizer.token(this.stream.reset(start, token), stack);
    if (token.value > -1) {
      let { parser: parser2 } = stack.p;
      for (let i = 0; i < parser2.specialized.length; i++)
        if (parser2.specialized[i] == token.value) {
          let result = parser2.specializers[i](this.stream.read(token.start, token.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token.value = result >> 1;
            else
              token.extended = result >> 1;
            break;
          }
        }
    } else {
      token.value = 0;
      token.end = this.stream.clipPos(start + 1);
    }
  }
  putAction(action, token, end, index) {
    for (let i = 0; i < index; i += 3)
      if (this.actions[i] == action)
        return index;
    this.actions[index++] = action;
    this.actions[index++] = token;
    this.actions[index++] = end;
    return index;
  }
  addActions(stack, token, end, index) {
    let { state } = stack, { parser: parser2 } = stack.p, { data } = parser2;
    for (let set = 0; set < 2; set++) {
      for (let i = parser2.stateSlot(state, set ? 2 : 1); ; i += 3) {
        if (data[i] == 65535) {
          if (data[i + 1] == 1) {
            i = pair(data, i + 2);
          } else {
            if (index == 0 && data[i + 1] == 2)
              index = this.putAction(pair(data, i + 2), token, end, index);
            break;
          }
        }
        if (data[i] == token)
          index = this.putAction(pair(data, i + 1), token, end, index);
      }
    }
    return index;
  }
};
var Rec;
(function(Rec2) {
  Rec2[Rec2["Distance"] = 5] = "Distance";
  Rec2[Rec2["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
  Rec2[Rec2["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
  Rec2[Rec2["ForceReduceLimit"] = 10] = "ForceReduceLimit";
  Rec2[Rec2["CutDepth"] = 15e3] = "CutDepth";
  Rec2[Rec2["CutTo"] = 9e3] = "CutTo";
})(Rec || (Rec = {}));
var Parse = class {
  constructor(parser2, input, fragments, ranges) {
    this.parser = parser2;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser2, this.stream);
    this.topTerm = parser2.top[1];
    let { from } = ranges[0];
    this.stacks = [Stack.start(this, parser2.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished)
        return this.stackToTree(finished);
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished)
        return this.stackToTree(finished.forceAll());
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s) => s.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer:
        for (let i = 0; i < newStacks.length - 1; i++) {
          let stack = newStacks[i];
          for (let j = i + 1; j < newStacks.length; j++) {
            let other = newStacks[j];
            if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
              if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                newStacks.splice(j--, 1);
              } else {
                newStacks.splice(i--, 1);
                continue outer;
              }
            }
          }
        }
    }
    this.minStackPos = newStacks[0].pos;
    for (let i = 1; i < newStacks.length; i++)
      if (newStacks[i].pos < this.minStackPos)
        this.minStackPos = newStacks[i].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  advanceStack(stack, stacks, split) {
    let start = stack.pos, { parser: parser2 } = this;
    let base = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt)
      return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose)
            console.log(base + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser2.stateSlot(stack.state, 4);
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base + this.stackID(stack) + ` (via always-reduce ${parser2.getName(defaultReduce & 65535)})`);
      return true;
    }
    if (stack.stack.length >= 15e3) {
      while (stack.stack.length > 9e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i = 0; i < actions.length; ) {
      let action = actions[i++], term = actions[i++], end = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack : stack.split();
      localStack.apply(action, term, end);
      if (verbose)
        console.log(base + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(action & 65535)}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
      let base = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done)
          continue;
      }
      let force = stack.split(), forceBase = base;
      for (let j = 0; force.forceReduce() && j < 10; j++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert of stack.recoverByInsert(token)) {
        if (verbose)
          console.log(base + this.stackID(insert) + " (via recover-insert)");
        this.advanceFully(insert, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose)
          console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    return finished;
  }
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id2)
      stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack;
  }
};
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score)
        newStacks[i] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
var Dialect = class {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
};
var id = (x) => x;
var ContextTracker = class {
  constructor(spec) {
    this.start = spec.start;
    this.shift = spec.shift || id;
    this.reduce = spec.reduce || id;
    this.reuse = spec.reuse || id;
    this.hash = spec.hash || (() => 0);
    this.strict = spec.strict !== false;
  }
};
var LRParser = class extends Parser {
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i = 0; i < spec.repeatNodeCount; i++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
    let nodeProps = [];
    for (let i = 0; i < nodeNames.length; i++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        if (typeof prop == "string")
          prop = NodeProp[prop];
        for (let i = 1; i < propSpec.length; ) {
          let next = propSpec[i++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i++]);
          } else {
            let value = propSpec[i + -next];
            for (let j = -next; j > 0; j--)
              setProp(propSpec[i++], prop, value);
            i++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
      name: i >= this.minRepeatTerm ? void 0 : name2,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    if (spec.propSources)
      this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specializerSpecs = spec.specialized || [];
    this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let i = 0; i < this.specializerSpecs.length; i++)
      this.specialized[i] = this.specializerSpecs[i].term;
    this.specializers = this.specializerSpecs.map(getSpecializer);
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse = new Parse(this, input, fragments, ranges);
    for (let w of this.wrappers)
      parse = w(parse, input, fragments, ranges);
    return parse;
  }
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last = groupTag & 1;
      let target = table[pos++];
      if (last && loose)
        return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table[pos] == state)
          return target;
      if (last)
        return -1;
    }
  }
  hasAction(state, terminal) {
    let data = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i = this.stateSlot(state, set ? 2 : 1), next; ; i += 3) {
        if ((next = data[i]) == 65535) {
          if (data[i + 1] == 1)
            next = data[i = pair(data, i + 2)];
          else if (data[i + 1] == 2)
            return pair(data, i + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data, i + 1);
      }
    }
    return 0;
  }
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  stateFlag(state, flag) {
    return (this.stateSlot(state, 0) & flag) > 0;
  }
  validAction(state, action) {
    if (action == this.stateSlot(state, 4))
      return true;
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          return false;
      }
      if (action == pair(this.data, i + 1))
        return true;
    }
  }
  nextStates(state) {
    let result = [];
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      if ((this.data[i + 2] & 65536 >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i2) => i2 & 1 && v == value))
          result.push(this.data[i], value);
      }
    }
    return result;
  }
  overrides(token, prev) {
    let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
  }
  configure(config3) {
    let copy = Object.assign(Object.create(LRParser.prototype), this);
    if (config3.props)
      copy.nodeSet = this.nodeSet.extend(...config3.props);
    if (config3.top) {
      let info = this.topRules[config3.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config3.top}`);
      copy.top = info;
    }
    if (config3.tokenizers)
      copy.tokenizers = this.tokenizers.map((t2) => {
        let found = config3.tokenizers.find((r) => r.from == t2);
        return found ? found.to : t2;
      });
    if (config3.specializers) {
      copy.specializers = this.specializers.slice();
      copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
        let found = config3.specializers.find((r) => r.from == s.external);
        if (!found)
          return s;
        let spec = Object.assign(Object.assign({}, s), { external: found.to });
        copy.specializers[i] = getSpecializer(spec);
        return spec;
      });
    }
    if (config3.contextTracker)
      copy.context = config3.contextTracker;
    if (config3.dialect)
      copy.dialect = this.parseDialect(config3.dialect);
    if (config3.strict != null)
      copy.strict = config3.strict;
    if (config3.wrap)
      copy.wrappers = copy.wrappers.concat(config3.wrap);
    if (config3.bufferLength != null)
      copy.bufferLength = config3.bufferLength;
    return copy;
  }
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(term) {
    let prec = this.dynamicPrecedences;
    return prec == null ? 0 : prec[term] || 0;
  }
  parseDialect(dialect) {
    let values = Object.keys(this.dialects), flags = values.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id2 = values.indexOf(part);
        if (id2 >= 0)
          flags[id2] = true;
      }
    let disabled = null;
    for (let i = 0; i < values.length; i++)
      if (!flags[i]) {
        for (let j = this.dialects[values[i]], id2; (id2 = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
      }
    return new Dialect(dialect, flags, disabled);
  }
  static deserialize(spec) {
    return new LRParser(spec);
  }
};
function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}
function findOffset(data, start, term) {
  for (let i = start, next; (next = data[i]) != 65535; i++)
    if (next == term)
      return i - start;
  return -1;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}

// node_modules/@lezer/highlight/dist/index.js
var nextTagID = 0;
var Tag = class {
  constructor(set, base, modified) {
    this.set = set;
    this.base = base;
    this.modified = modified;
    this.id = nextTagID++;
  }
  static define(parent) {
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new Tag([], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  static defineModifier() {
    let mod = new Modifier();
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class {
  constructor() {
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base, mods) {
    if (!mods.length)
      return base;
    let exists = mods[0].instances.find((t2) => t2.base == base && sameArray(mods, t2.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(set, base, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = permute(mods);
    for (let parent of base.set)
      for (let config3 of configs)
        set.push(Modifier.get(parent, config3));
    return tag;
  }
};
function sameArray(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function permute(array) {
  let result = [array];
  for (let i = 0; i < array.length; i++) {
    for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))
      result.push(a);
  }
  return result;
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule2(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = new NodeProp();
var Rule2 = class {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
function tagHighlighter(tags2, options) {
  let map = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag))
      map[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map[tag.id] = style.class;
  }
  let { scope, all = null } = options || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
var t = Tag.define;
var comment = t();
var name = t();
var typeName = t(name);
var propertyName = t(name);
var literal = t();
var string = t(literal);
var number = t(literal);
var content = t();
var heading = t(content);
var keyword = t();
var operator = t();
var punctuation = t();
var bracket = t(punctuation);
var meta = t();
var tags = {
  comment,
  lineComment: t(comment),
  blockComment: t(comment),
  docComment: t(comment),
  name,
  variableName: t(name),
  typeName,
  tagName: t(typeName),
  propertyName,
  attributeName: t(propertyName),
  className: t(name),
  labelName: t(name),
  namespace: t(name),
  macroName: t(name),
  literal,
  string,
  docString: t(string),
  character: t(string),
  attributeValue: t(string),
  number,
  integer: t(number),
  float: t(number),
  bool: t(literal),
  regexp: t(literal),
  escape: t(literal),
  color: t(literal),
  url: t(literal),
  keyword,
  self: t(keyword),
  null: t(keyword),
  atom: t(keyword),
  unit: t(keyword),
  modifier: t(keyword),
  operatorKeyword: t(keyword),
  controlKeyword: t(keyword),
  definitionKeyword: t(keyword),
  moduleKeyword: t(keyword),
  operator,
  derefOperator: t(operator),
  arithmeticOperator: t(operator),
  logicOperator: t(operator),
  bitwiseOperator: t(operator),
  compareOperator: t(operator),
  updateOperator: t(operator),
  definitionOperator: t(operator),
  typeOperator: t(operator),
  controlOperator: t(operator),
  punctuation,
  separator: t(punctuation),
  bracket,
  angleBracket: t(bracket),
  squareBracket: t(bracket),
  paren: t(bracket),
  brace: t(bracket),
  content,
  heading,
  heading1: t(heading),
  heading2: t(heading),
  heading3: t(heading),
  heading4: t(heading),
  heading5: t(heading),
  heading6: t(heading),
  contentSeparator: t(content),
  list: t(content),
  quote: t(content),
  emphasis: t(content),
  strong: t(content),
  link: t(content),
  monospace: t(content),
  strikethrough: t(content),
  inserted: t(),
  deleted: t(),
  changed: t(),
  invalid: t(),
  meta,
  documentMeta: t(meta),
  annotation: t(meta),
  processingInstruction: t(meta),
  definition: Tag.defineModifier(),
  constant: Tag.defineModifier(),
  function: Tag.defineModifier(),
  standard: Tag.defineModifier(),
  local: Tag.defineModifier(),
  special: Tag.defineModifier()
};
var classHighlighter = tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);

// node_modules/@lezer/python/dist/index.es.js
var printKeyword = 1;
var indent = 189;
var dedent = 190;
var newline$1 = 191;
var newlineBracketed = 192;
var newlineEmpty = 193;
var eof = 194;
var ParenL = 22;
var ParenthesizedExpression = 23;
var TupleExpression = 47;
var ComprehensionExpression = 48;
var BracketL = 53;
var ArrayExpression = 54;
var ArrayComprehensionExpression = 55;
var BraceL = 57;
var DictionaryExpression = 58;
var DictionaryComprehensionExpression = 59;
var SetExpression = 60;
var SetComprehensionExpression = 61;
var ArgList = 63;
var subscript = 230;
var FormatReplacement = 71;
var importList = 255;
var ParamList = 121;
var SequencePattern = 142;
var MappingPattern = 143;
var PatternArgList = 146;
var newline = 10;
var carriageReturn = 13;
var space = 32;
var tab = 9;
var hash = 35;
var parenOpen = 40;
var dot = 46;
var bracketed = /* @__PURE__ */ new Set([
  ParenthesizedExpression,
  TupleExpression,
  ComprehensionExpression,
  importList,
  ArgList,
  ParamList,
  ArrayExpression,
  ArrayComprehensionExpression,
  subscript,
  SetExpression,
  SetComprehensionExpression,
  DictionaryExpression,
  DictionaryComprehensionExpression,
  FormatReplacement,
  SequencePattern,
  MappingPattern,
  PatternArgList
]);
var newlines = new ExternalTokenizer((input, stack) => {
  if (input.next < 0) {
    input.acceptToken(eof);
  } else if (input.next != newline && input.next != carriageReturn)
    ;
  else if (stack.context.depth < 0) {
    input.acceptToken(newlineBracketed, 1);
  } else {
    input.advance();
    let spaces = 0;
    while (input.next == space || input.next == tab) {
      input.advance();
      spaces++;
    }
    let empty = input.next == newline || input.next == carriageReturn || input.next == hash;
    input.acceptToken(empty ? newlineEmpty : newline$1, -spaces);
  }
}, { contextual: true, fallback: true });
var indentation = new ExternalTokenizer((input, stack) => {
  let cDepth = stack.context.depth;
  if (cDepth < 0)
    return;
  let prev = input.peek(-1);
  if ((prev == newline || prev == carriageReturn) && stack.context.depth >= 0) {
    let depth = 0, chars = 0;
    for (; ; ) {
      if (input.next == space)
        depth++;
      else if (input.next == tab)
        depth += 8 - depth % 8;
      else
        break;
      input.advance();
      chars++;
    }
    if (depth != cDepth && input.next != newline && input.next != carriageReturn && input.next != hash) {
      if (depth < cDepth)
        input.acceptToken(dedent, -chars);
      else
        input.acceptToken(indent);
    }
  }
});
function IndentLevel(parent, depth) {
  this.parent = parent;
  this.depth = depth;
  this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + depth + (depth << 4);
}
var topIndent = new IndentLevel(null, 0);
function countIndent(space2) {
  let depth = 0;
  for (let i = 0; i < space2.length; i++)
    depth += space2.charCodeAt(i) == tab ? 8 - depth % 8 : 1;
  return depth;
}
var trackIndent = new ContextTracker({
  start: topIndent,
  reduce(context, term) {
    return context.depth < 0 && bracketed.has(term) ? context.parent : context;
  },
  shift(context, term, stack, input) {
    if (term == indent)
      return new IndentLevel(context, countIndent(input.read(input.pos, stack.pos)));
    if (term == dedent)
      return context.parent;
    if (term == ParenL || term == BracketL || term == BraceL)
      return new IndentLevel(context, -1);
    return context;
  },
  hash(context) {
    return context.hash;
  }
});
var legacyPrint = new ExternalTokenizer((input) => {
  for (let i = 0; i < 5; i++) {
    if (input.next != "print".charCodeAt(i))
      return;
    input.advance();
  }
  if (/\w/.test(String.fromCharCode(input.next)))
    return;
  for (let off = 0; ; off++) {
    let next = input.peek(off);
    if (next == space || next == tab)
      continue;
    if (next != parenOpen && next != dot && next != newline && next != carriageReturn && next != hash)
      input.acceptToken(printKeyword);
    return;
  }
});
var pythonHighlighting = styleTags({
  'async "*" "**" FormatConversion FormatSpec': tags.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield": tags.controlKeyword,
  "in not and or is del": tags.operatorKeyword,
  "from def class global nonlocal lambda": tags.definitionKeyword,
  import: tags.moduleKeyword,
  "with as print": tags.keyword,
  Boolean: tags.bool,
  None: tags.null,
  VariableName: tags.variableName,
  "CallExpression/VariableName": tags.function(tags.variableName),
  "FunctionDefinition/VariableName": tags.function(tags.definition(tags.variableName)),
  "ClassDefinition/VariableName": tags.definition(tags.className),
  PropertyName: tags.propertyName,
  "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
  Comment: tags.lineComment,
  Number: tags.number,
  String: tags.string,
  FormatString: tags.special(tags.string),
  UpdateOp: tags.updateOperator,
  ArithOp: tags.arithmeticOperator,
  BitOp: tags.bitwiseOperator,
  CompareOp: tags.compareOperator,
  AssignOp: tags.definitionOperator,
  Ellipsis: tags.punctuation,
  At: tags.meta,
  "( )": tags.paren,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace,
  ".": tags.derefOperator,
  ", ;": tags.separator
});
var spec_identifier = { __proto__: null, await: 40, or: 50, and: 52, in: 56, not: 58, is: 60, if: 66, else: 68, lambda: 72, yield: 90, from: 92, async: 98, for: 100, None: 152, True: 154, False: 154, del: 168, pass: 172, break: 176, continue: 180, return: 184, raise: 192, import: 196, as: 198, global: 202, nonlocal: 204, assert: 208, elif: 218, while: 222, try: 228, except: 230, finally: 232, with: 236, def: 240, class: 250, match: 261, case: 267 };
var parser = LRParser.deserialize({
  version: 14,
  states: "!L`O`Q$IXOOO%fQ$I[O'#G|OOQ$IS'#Cm'#CmOOQ$IS'#Cn'#CnO'UQ$IWO'#ClO(wQ$I[O'#G{OOQ$IS'#G|'#G|OOQ$IS'#DS'#DSOOQ$IS'#G{'#G{O)eQ$IWO'#CsO)uQ$IWO'#DdO*VQ$IWO'#DhOOQ$IS'#Ds'#DsO*jO`O'#DsO*rOpO'#DsO*zO!bO'#DtO+VO#tO'#DtO+bO&jO'#DtO+mO,UO'#DtO-oQ$I[O'#GmOOQ$IS'#Gm'#GmO'UQ$IWO'#GlO/RQ$I[O'#GlOOQ$IS'#E]'#E]O/jQ$IWO'#E^OOQ$IS'#Gk'#GkO/tQ$IWO'#GjOOQ$IV'#Gj'#GjO0PQ$IWO'#FPOOQ$IS'#GX'#GXO0UQ$IWO'#FOOOQ$IV'#Hx'#HxOOQ$IV'#Gi'#GiOOQ$IT'#Fh'#FhQ`Q$IXOOO'UQ$IWO'#CoO0dQ$IWO'#C{O0kQ$IWO'#DPO0yQ$IWO'#HQO1ZQ$I[O'#EQO'UQ$IWO'#EROOQ$IS'#ET'#ETOOQ$IS'#EV'#EVOOQ$IS'#EX'#EXO1oQ$IWO'#EZO2VQ$IWO'#E_O0PQ$IWO'#EaO2jQ$I[O'#EaO0PQ$IWO'#EdO/jQ$IWO'#EgO/jQ$IWO'#EkO/jQ$IWO'#EnO2uQ$IWO'#EpO2|Q$IWO'#EuO3XQ$IWO'#EqO/jQ$IWO'#EuO0PQ$IWO'#EwO0PQ$IWO'#E|O3^Q$IWO'#FROOQ$IS'#Cc'#CcOOQ$IS'#Cd'#CdOOQ$IS'#Ce'#CeOOQ$IS'#Cf'#CfOOQ$IS'#Cg'#CgOOQ$IS'#Ch'#ChOOQ$IS'#Cj'#CjO'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O3eQ$IWO'#DmOOQ$IS,5:W,5:WO3xQ$IWO'#H[OOQ$IS,5:Z,5:ZO4VQ%1`O,5:ZO4[Q$I[O,59WO0dQ$IWO,59`O0dQ$IWO,59`O0dQ$IWO,59`O6zQ$IWO,59`O7PQ$IWO,59`O7WQ$IWO,59hO7_Q$IWO'#G{O8eQ$IWO'#GzOOQ$IS'#Gz'#GzOOQ$IS'#DY'#DYO8|Q$IWO,59_O'UQ$IWO,59_O9[Q$IWO,59_O9aQ$IWO,5:PO'UQ$IWO,5:POOQ$IS,5:O,5:OO9oQ$IWO,5:OO9tQ$IWO,5:VO'UQ$IWO,5:VO'UQ$IWO,5:TOOQ$IS,5:S,5:SO:VQ$IWO,5:SO:[Q$IWO,5:UOOOO'#Fp'#FpO:aO`O,5:_OOQ$IS,5:_,5:_OOOO'#Fq'#FqO:iOpO,5:_O:qQ$IWO'#DuOOOO'#Fr'#FrO;RO!bO,5:`OOQ$IS,5:`,5:`OOOO'#Fu'#FuO;^O#tO,5:`OOOO'#Fv'#FvO;iO&jO,5:`OOOO'#Fw'#FwO;tO,UO,5:`OOQ$IS'#Fx'#FxO<PQ$I[O,5:dO>qQ$I[O,5=WO?[Q%GlO,5=WO?{Q$I[O,5=WOOQ$IS,5:x,5:xO@dQ$IXO'#GQOAsQ$IWO,5;TOOQ$IV,5=U,5=UOBOQ$I[O'#HtOBgQ$IWO,5;kOOQ$IS-E:V-E:VOOQ$IV,5;j,5;jO3SQ$IWO'#EwOOQ$IT-E9f-E9fOBoQ$I[O,59ZODvQ$I[O,59gOEaQ$IWO'#G}OElQ$IWO'#G}O0PQ$IWO'#G}OEwQ$IWO'#DROFPQ$IWO,59kOFUQ$IWO'#HRO'UQ$IWO'#HRO/jQ$IWO,5=lOOQ$IS,5=l,5=lO/jQ$IWO'#D|OOQ$IS'#D}'#D}OFsQ$IWO'#FzOGTQ$IWO,58zOGTQ$IWO,58zO)hQ$IWO,5:jOGcQ$I[O'#HTOOQ$IS,5:m,5:mOOQ$IS,5:u,5:uOGvQ$IWO,5:yOHXQ$IWO,5:{OOQ$IS'#F}'#F}OHgQ$I[O,5:{OHuQ$IWO,5:{OHzQ$IWO'#HwOOQ$IS,5;O,5;OOIYQ$IWO'#HsOOQ$IS,5;R,5;RO3XQ$IWO,5;VO3XQ$IWO,5;YOIkQ$I[O'#HyO'UQ$IWO'#HyOIuQ$IWO,5;[O2uQ$IWO,5;[O/jQ$IWO,5;aO0PQ$IWO,5;cOIzQ$IXO'#ElOKTQ$IZO,5;]ONiQ$IWO'#HzO3XQ$IWO,5;aONtQ$IWO,5;cONyQ$IWO,5;hO! RQ$I[O,5;mO'UQ$IWO,5;mO!#uQ$I[O1G.hO!#|Q$I[O1G.hO!&mQ$I[O1G.hO!&wQ$I[O1G.hO!)bQ$I[O1G.hO!)uQ$I[O1G.hO!*YQ$IWO'#HZO!*hQ$I[O'#GmO/jQ$IWO'#HZO!*rQ$IWO'#HYOOQ$IS,5:X,5:XO!*zQ$IWO,5:XO!+PQ$IWO'#H]O!+[Q$IWO'#H]O!+oQ$IWO,5=vOOQ$IS'#Dq'#DqOOQ$IS1G/u1G/uOOQ$IS1G.z1G.zO!,oQ$I[O1G.zO!,vQ$I[O1G.zO0dQ$IWO1G.zO!-cQ$IWO1G/SOOQ$IS'#DX'#DXO/jQ$IWO,59rOOQ$IS1G.y1G.yO!-jQ$IWO1G/cO!-zQ$IWO1G/cO!.SQ$IWO1G/dO'UQ$IWO'#HSO!.XQ$IWO'#HSO!.^Q$I[O1G.yO!.nQ$IWO,59gO!/tQ$IWO,5=rO!0UQ$IWO,5=rO!0^Q$IWO1G/kO!0cQ$I[O1G/kOOQ$IS1G/j1G/jO!0sQ$IWO,5=mO!1jQ$IWO,5=mO/jQ$IWO1G/oO!2XQ$IWO1G/qO!2^Q$I[O1G/qO!2nQ$I[O1G/oOOQ$IS1G/n1G/nOOQ$IS1G/p1G/pOOOO-E9n-E9nOOQ$IS1G/y1G/yOOOO-E9o-E9oO!3OQ$IWO'#HhO/jQ$IWO'#HhO!3^Q$IWO,5:aOOOO-E9p-E9pOOQ$IS1G/z1G/zOOOO-E9s-E9sOOOO-E9t-E9tOOOO-E9u-E9uOOQ$IS-E9v-E9vO!3iQ%GlO1G2rO!4YQ$I[O1G2rO'UQ$IWO,5<eOOQ$IS,5<e,5<eOOQ$IS-E9w-E9wOOQ$IS,5<l,5<lOOQ$IS-E:O-E:OOOQ$IV1G0o1G0oO0PQ$IWO'#F|O!4qQ$I[O,5>`OOQ$IS1G1V1G1VO!5YQ$IWO1G1VOOQ$IS'#DT'#DTO/jQ$IWO,5=iOOQ$IS,5=i,5=iO!5_Q$IWO'#FiO!5jQ$IWO,59mO!5rQ$IWO1G/VO!5|Q$I[O,5=mOOQ$IS1G3W1G3WOOQ$IS,5:h,5:hO!6mQ$IWO'#GlOOQ$IS,5<f,5<fOOQ$IS-E9x-E9xO!7OQ$IWO1G.fOOQ$IS1G0U1G0UO!7^Q$IWO,5=oO!7nQ$IWO,5=oO/jQ$IWO1G0eO/jQ$IWO1G0eO0PQ$IWO1G0gOOQ$IS-E9{-E9{O!8PQ$IWO1G0gO!8[Q$IWO1G0gO!8aQ$IWO,5>cO!8oQ$IWO,5>cO!8}Q$IWO,5>_O!9eQ$IWO,5>_O!9vQ$IZO1G0qO!=XQ$IZO1G0tO!@gQ$IWO,5>eO!@qQ$IWO,5>eO!@yQ$I[O,5>eO/jQ$IWO1G0vO!ATQ$IWO1G0vO3XQ$IWO1G0{ONtQ$IWO1G0}OOQ$IV,5;W,5;WO!AYQ$IYO,5;WO!A_Q$IZO1G0wO!DsQ$IWO'#GUO3XQ$IWO1G0wO3XQ$IWO1G0wO!EQQ$IWO,5>fO!E_Q$IWO,5>fO0PQ$IWO,5>fOOQ$IV1G0{1G0{O!EgQ$IWO'#EyO!ExQ%1`O1G0}OOQ$IV1G1S1G1SO3XQ$IWO1G1SO!FQQ$IWO'#FTOOQ$IV1G1X1G1XO! RQ$I[O1G1XOOQ$IS,5=u,5=uOOQ$IS'#Dn'#DnO/jQ$IWO,5=uO!FVQ$IWO,5=tO!FjQ$IWO,5=tOOQ$IS1G/s1G/sO!FrQ$IWO,5=wO!GSQ$IWO,5=wO!G[Q$IWO,5=wO!GoQ$IWO,5=wO!HPQ$IWO,5=wOOQ$IS1G3b1G3bOOQ$IS7+$f7+$fO!5rQ$IWO7+$nO!IrQ$IWO1G.zO!IyQ$IWO1G.zOOQ$IS1G/^1G/^OOQ$IS,5<V,5<VO'UQ$IWO,5<VOOQ$IS7+$}7+$}O!JQQ$IWO7+$}OOQ$IS-E9i-E9iOOQ$IS7+%O7+%OO!JbQ$IWO,5=nO'UQ$IWO,5=nOOQ$IS7+$e7+$eO!JgQ$IWO7+$}O!JoQ$IWO7+%OO!JtQ$IWO1G3^OOQ$IS7+%V7+%VO!KUQ$IWO1G3^O!K^Q$IWO7+%VOOQ$IS,5<U,5<UO'UQ$IWO,5<UO!KcQ$IWO1G3XOOQ$IS-E9h-E9hO!LYQ$IWO7+%ZOOQ$IS7+%]7+%]O!LhQ$IWO1G3XO!MVQ$IWO7+%]O!M[Q$IWO1G3_O!MlQ$IWO1G3_O!MtQ$IWO7+%ZO!MyQ$IWO,5>SO!NaQ$IWO,5>SO!NaQ$IWO,5>SO!NoO!LQO'#DwO!NzOSO'#HiOOOO1G/{1G/{O# PQ$IWO1G/{O# XQ%GlO7+(^O# xQ$I[O1G2PP#!cQ$IWO'#FyOOQ$IS,5<h,5<hOOQ$IS-E9z-E9zOOQ$IS7+&q7+&qOOQ$IS1G3T1G3TOOQ$IS,5<T,5<TOOQ$IS-E9g-E9gOOQ$IS7+$q7+$qO#!pQ$IWO,5=WO##ZQ$IWO,5=WO##lQ$I[O,5<WO#$PQ$IWO1G3ZOOQ$IS-E9j-E9jOOQ$IS7+&P7+&PO#$aQ$IWO7+&POOQ$IS7+&R7+&RO#$oQ$IWO'#HvO0PQ$IWO'#HuO#%TQ$IWO7+&ROOQ$IS,5<k,5<kO#%`Q$IWO1G3}OOQ$IS-E9}-E9}OOQ$IS,5<g,5<gO#%nQ$IWO1G3yOOQ$IS-E9y-E9yO#&UQ$IZO7+&]O!DsQ$IWO'#GSO3XQ$IWO7+&]O3XQ$IWO7+&`O#)gQ$I[O,5<oO'UQ$IWO,5<oO#)qQ$IWO1G4POOQ$IS-E:R-E:RO#){Q$IWO1G4PO3XQ$IWO7+&bO/jQ$IWO7+&bOOQ$IV7+&g7+&gO!ExQ%1`O7+&iO#*TQ$IXO1G0rOOQ$IV-E:S-E:SO3XQ$IWO7+&cO3XQ$IWO7+&cOOQ$IV,5<p,5<pO#+yQ$IWO,5<pOOQ$IV7+&c7+&cO#,UQ$IZO7+&cO#/dQ$IWO,5<qO#/oQ$IWO1G4QOOQ$IS-E:T-E:TO#/|Q$IWO1G4QO#0UQ$IWO'#H|O#0dQ$IWO'#H|O0PQ$IWO'#H|OOQ$IS'#H|'#H|O#0oQ$IWO'#H{OOQ$IS,5;e,5;eO#0wQ$IWO,5;eO/jQ$IWO'#E{OOQ$IV7+&i7+&iO3XQ$IWO7+&iOOQ$IV7+&n7+&nO#0|Q$IYO,5;oOOQ$IV7+&s7+&sOOQ$IS1G3a1G3aOOQ$IS,5<Y,5<YO#1RQ$IWO1G3`OOQ$IS-E9l-E9lO#1fQ$IWO,5<ZO#1qQ$IWO,5<ZO#2UQ$IWO1G3cOOQ$IS-E9m-E9mO#2fQ$IWO1G3cO#2nQ$IWO1G3cO#3OQ$IWO1G3cO#2fQ$IWO1G3cOOQ$IS<<HY<<HYO#3ZQ$I[O1G1qOOQ$IS<<Hi<<HiP#3hQ$IWO'#FkO7WQ$IWO1G3YO#3uQ$IWO1G3YO#3zQ$IWO<<HiOOQ$IS<<Hj<<HjO#4[Q$IWO7+(xOOQ$IS<<Hq<<HqO#4lQ$I[O1G1pP#5]Q$IWO'#FjO#5jQ$IWO7+(yO#5zQ$IWO7+(yO#6SQ$IWO<<HuO#6XQ$IWO7+(sOOQ$IS<<Hw<<HwO#7OQ$IWO,5<XO'UQ$IWO,5<XOOQ$IS-E9k-E9kOOQ$IS<<Hu<<HuOOQ$IS,5<_,5<_O/jQ$IWO,5<_O#7TQ$IWO1G3nOOQ$IS-E9q-E9qO#7kQ$IWO1G3nOOOO'#Ft'#FtO#7yO!LQO,5:cOOOO,5>T,5>TOOOO7+%g7+%gO#8UQ$IWO1G2rO#8oQ$IWO1G2rP'UQ$IWO'#FlO/jQ$IWO<<IkO#9QQ$IWO,5>bO#9cQ$IWO,5>bO0PQ$IWO,5>bO#9tQ$IWO,5>aOOQ$IS<<Im<<ImP0PQ$IWO'#GPP/jQ$IWO'#F{OOQ$IV-E:Q-E:QO3XQ$IWO<<IwOOQ$IV,5<n,5<nO3XQ$IWO,5<nOOQ$IV<<Iw<<IwOOQ$IV<<Iz<<IzO#9yQ$I[O1G2ZP#:TQ$IWO'#GTO#:[Q$IWO7+)kO#:fQ$IZO<<I|O3XQ$IWO<<I|OOQ$IV<<JT<<JTO3XQ$IWO<<JTOOQ$IV'#GR'#GRO#=tQ$IZO7+&^OOQ$IV<<I}<<I}O#?pQ$IZO<<I}OOQ$IV1G2[1G2[O0PQ$IWO1G2[O3XQ$IWO<<I}O0PQ$IWO1G2]P/jQ$IWO'#GVO#COQ$IWO7+)lO#C]Q$IWO7+)lOOQ$IS'#Ez'#EzO/jQ$IWO,5>hO#CeQ$IWO,5>hOOQ$IS,5>h,5>hO#CpQ$IWO,5>gO#DRQ$IWO,5>gOOQ$IS1G1P1G1POOQ$IS,5;g,5;gO#DZQ$IWO1G1ZP#D`Q$IWO'#FnO#DpQ$IWO1G1uO#ETQ$IWO1G1uO#EeQ$IWO1G1uP#EpQ$IWO'#FoO#E}Q$IWO7+(}O#F_Q$IWO7+(}O#F_Q$IWO7+(}O#FgQ$IWO7+(}O#FwQ$IWO7+(tO7WQ$IWO7+(tOOQ$ISAN>TAN>TO#GbQ$IWO<<LeOOQ$ISAN>aAN>aO/jQ$IWO1G1sO#GrQ$I[O1G1sP#G|Q$IWO'#FmOOQ$IS1G1y1G1yP#HZQ$IWO'#FsO#HhQ$IWO7+)YOOOO-E9r-E9rO#IOQ$IWO7+(^OOQ$ISAN?VAN?VO#IiQ$IWO,5<jO#I}Q$IWO1G3|OOQ$IS-E9|-E9|O#J`Q$IWO1G3|OOQ$IS1G3{1G3{OOQ$IVAN?cAN?cOOQ$IV1G2Y1G2YO3XQ$IWOAN?hO#JqQ$IZOAN?hOOQ$IVAN?oAN?oOOQ$IV-E:P-E:POOQ$IV<<Ix<<IxO3XQ$IWOAN?iO3XQ$IWO7+'vOOQ$IVAN?iAN?iOOQ$IS7+'w7+'wO#NPQ$IWO<<MWOOQ$IS1G4S1G4SO/jQ$IWO1G4SOOQ$IS,5<r,5<rO#N^Q$IWO1G4ROOQ$IS-E:U-E:UOOQ$IU'#GY'#GYO#NoQ$IYO7+&uO#NzQ$IWO'#FUO$ rQ$IWO7+'aO$!SQ$IWO7+'aOOQ$IS7+'a7+'aO$!_Q$IWO<<LiO$!oQ$IWO<<LiO$!oQ$IWO<<LiO$!wQ$IWO'#HUOOQ$IS<<L`<<L`O$#RQ$IWO<<L`OOQ$IS7+'_7+'_O0PQ$IWO1G2UP0PQ$IWO'#GOO$#lQ$IWO7+)hO$#}Q$IWO7+)hOOQ$IVG25SG25SO3XQ$IWOG25SOOQ$IVG25TG25TOOQ$IV<<Kb<<KbOOQ$IS7+)n7+)nP$$`Q$IWO'#GWOOQ$IU-E:W-E:WOOQ$IV<<Ja<<JaO$%SQ$I[O'#FWOOQ$IS'#FY'#FYO$%dQ$IWO'#FXO$&UQ$IWO'#FXOOQ$IS'#FX'#FXO$&ZQ$IWO'#IOO#NzQ$IWO'#F`O#NzQ$IWO'#F`O$&rQ$IWO'#FaO#NzQ$IWO'#FbO$&yQ$IWO'#IPOOQ$IS'#IP'#IPO$'hQ$IWO,5;pOOQ$IS<<J{<<J{O$'pQ$IWO<<J{O$(QQ$IWOANBTO$(bQ$IWOANBTO$(jQ$IWO'#HVOOQ$IS'#HV'#HVO0kQ$IWO'#DaO$)TQ$IWO,5=pOOQ$ISANAzANAzOOQ$IS7+'p7+'pO$)lQ$IWO<<MSOOQ$IVLD*nLD*nO4VQ%1`O'#G[O$)}Q$I[O,5;yO#NzQ$IWO'#FdOOQ$IS,5;},5;}OOQ$IS'#FZ'#FZO$*oQ$IWO,5;sO$*tQ$IWO,5;sOOQ$IS'#F^'#F^O#NzQ$IWO'#GZO$+fQ$IWO,5;wO$,QQ$IWO,5>jO$,bQ$IWO,5>jO0PQ$IWO,5;vO$,sQ$IWO,5;zO$,xQ$IWO,5;zO#NzQ$IWO'#IQO$,}Q$IWO'#IQO$-SQ$IWO,5;{OOQ$IS,5;|,5;|O'UQ$IWO'#FgOOQ$IU1G1[1G1[O3XQ$IWO1G1[OOQ$ISAN@gAN@gO$-XQ$IWOG27oO$-iQ$IWO,59{OOQ$IS1G3[1G3[OOQ$IS,5<v,5<vOOQ$IS-E:Y-E:YO$-nQ$I[O'#FWO$-uQ$IWO'#IRO$.TQ$IWO'#IRO$.]Q$IWO,5<OOOQ$IS1G1_1G1_O$.bQ$IWO1G1_O$.gQ$IWO,5<uOOQ$IS-E:X-E:XO$/RQ$IWO,5<yO$/jQ$IWO1G4UOOQ$IS-E:]-E:]OOQ$IS1G1b1G1bOOQ$IS1G1f1G1fO$/zQ$IWO,5>lO#NzQ$IWO,5>lOOQ$IS1G1g1G1gO$0YQ$I[O,5<ROOQ$IU7+&v7+&vO$!wQ$IWO1G/gO#NzQ$IWO,5<PO$0aQ$IWO,5>mO$0hQ$IWO,5>mOOQ$IS1G1j1G1jOOQ$IS7+&y7+&yP#NzQ$IWO'#G_O$0pQ$IWO1G4WO$0zQ$IWO1G4WO$1SQ$IWO1G4WOOQ$IS7+%R7+%RO$1bQ$IWO1G1kO$1pQ$I[O'#FWO$1wQ$IWO,5<xOOQ$IS,5<x,5<xO$2VQ$IWO1G4XOOQ$IS-E:[-E:[O#NzQ$IWO,5<wO$2^Q$IWO,5<wO$2cQ$IWO7+)rOOQ$IS-E:Z-E:ZO$2mQ$IWO7+)rO#NzQ$IWO,5<QP#NzQ$IWO'#G^O$2uQ$IWO1G2cO#NzQ$IWO1G2cP$3TQ$IWO'#G]O$3[Q$IWO<<M^O$3fQ$IWO1G1lO$3tQ$IWO7+'}O7WQ$IWO'#C{O7WQ$IWO,59`O7WQ$IWO,59`O7WQ$IWO,59`O$4SQ$I[O,5=WO7WQ$IWO1G.zO/jQ$IWO1G/VO/jQ$IWO7+$nP$4gQ$IWO'#FyO'UQ$IWO'#GlO$4tQ$IWO,59`O$4yQ$IWO,59`O$5QQ$IWO,59kO$5VQ$IWO1G/SO0kQ$IWO'#DPO7WQ$IWO,59h",
  stateData: "$5m~O%[OS%XOS%WOSQOS~OPhOTeOdsOfXOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!VYO!ZZO!fdO!mdO!ndO!odO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO#v![O%VqO%gQO%hQO%lRO%mVO&R[O&S]O&V^O&Y_O&``O&caO&ebO~OT!bO]!bO_!cOf!jO!V!lO!d!nO%b!]O%c!^O%d!_O%e!`O%f!`O%g!aO%h!aO%i!bO%j!bO%k!bO~Oi%pXj%pXk%pXl%pXm%pXn%pXq%pXx%pXy%pX!s%pX#^%pX%V%pX%Y%pX%r%pXe%pX!R%pX!S%pX%s%pX!U%pX!Y%pX!O%pX#V%pXr%pX!j%pX~P$bOdsOfXO!VYO!ZZO!fdO!mdO!ndO!odO%gQO%hQO%lRO%mVO&R[O&S]O&V^O&Y_O&``O&caO&ebO~Ox%oXy%oX#^%oX%V%oX%Y%oX%r%oX~Oi!qOj!rOk!pOl!pOm!sOn!tOq!uO!s%oX~P(cOT!{Om/iOt/wO}vO~P'UOT#OOm/iOt/wO!U#PO~P'UOT#SO_#TOm/iOt/wO!Y#UO~P'UO&T#XO&U#ZO~O&W#[O&X#ZO~O!Z#^O&Z#_O&_#aO~O!Z#^O&a#bO&b#aO~O!Z#^O&U#aO&d#dO~O!Z#^O&X#aO&f#fO~OT%aX]%aX_%aXf%aXi%aXj%aXk%aXl%aXm%aXn%aXq%aXx%aX!V%aX!d%aX%b%aX%c%aX%d%aX%e%aX%f%aX%g%aX%h%aX%i%aX%j%aX%k%aXe%aX!R%aX!S%aX~O&R[O&S]O&V^O&Y_O&``O&caO&ebOy%aX!s%aX#^%aX%V%aX%Y%aX%r%aX%s%aX!U%aX!Y%aX!O%aX#V%aXr%aX!j%aX~P+xOx#kOy%`X!s%`X#^%`X%V%`X%Y%`X%r%`X~Om/iOt/wO~P'UO#^#nO%V#pO%Y#pO~O%mVO~O!R#uO#l!YO#q!ZO#tlO~OmtO~P'UOT#zO_#{O%mVOyuP~OT$POm/iOt/wO!O$QO~P'UOy$SO!s$XO%r$TO#^!tX%V!tX%Y!tX~OT$POm/iOt/wO#^!}X%V!}X%Y!}X~P'UOm/iOt/wO#^#RX%V#RX%Y#RX~P'UO!d$_O!m$_O%mVO~OT$iO~P'UO!S$kO#j$lO#l$mO~Oy$nO~OT$uO~P'UOT%OO_%OOe%QOm/iOt/wO~P'UOm/iOt/wOy%TO~P'UO&Q%VO~O_!cOf!jO!V!lO!d!nOT`a]`ai`aj`ak`al`am`an`aq`ax`ay`a!s`a#^`a%V`a%Y`a%b`a%c`a%d`a%e`a%f`a%g`a%h`a%i`a%j`a%k`a%r`ae`a!R`a!S`a%s`a!U`a!Y`a!O`a#V`ar`a!j`a~Ol%[O~Om%[O~P'UOm/iO~P'UOi/kOj/lOk/jOl/jOm/sOn/tOq/xOe%oX!R%oX!S%oX%s%oX!U%oX!Y%oX!O%oX#V%oX!j%oX~P(cO%s%^Oe%nXx%nX!R%nX!S%nX!U%nXy%nX~Oe%`Ox%aO!R%eO!S%dO~Oe%`O~Ox%hO!R%eO!S%dO!U%zX~O!U%lO~Ox%mOy%oO!R%eO!S%dO!Y%uX~O!Y%sO~O!Y%tO~O&T#XO&U%vO~O&W#[O&X%vO~OT%yOm/iOt/wO}vO~P'UO!Z#^O&Z#_O&_%|O~O!Z#^O&a#bO&b%|O~O!Z#^O&U%|O&d#dO~O!Z#^O&X%|O&f#fO~OT!la]!la_!laf!lai!laj!lak!lal!lam!lan!laq!lax!lay!la!V!la!d!la!s!la#^!la%V!la%Y!la%b!la%c!la%d!la%e!la%f!la%g!la%h!la%i!la%j!la%k!la%r!lae!la!R!la!S!la%s!la!U!la!Y!la!O!la#V!lar!la!j!la~P#yOx&ROy%`a!s%`a#^%`a%V%`a%Y%`a%r%`a~P$bOT&TOmtOtuOy%`a!s%`a#^%`a%V%`a%Y%`a%r%`a~P'UOx&ROy%`a!s%`a#^%`a%V%`a%Y%`a%r%`a~OPhOTeOmtOtuO}vO!O!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#^$tX%V$tX%Y$tX~P'UO#^#nO%V&YO%Y&YO~O!d&ZOf&hX%V&hX#V&hX#^&hX%Y&hX#U&hX~Of!jO%V&]O~Oicajcakcalcamcancaqcaxcayca!sca#^ca%Vca%Yca%rcaeca!Rca!Sca%sca!Uca!Yca!Oca#Vcarca!jca~P$bOqoaxoayoa#^oa%Voa%Yoa%roa~Oi!qOj!rOk!pOl!pOm!sOn!tO!soa~PD_O%r&_Ox%qXy%qX~O%mVOx%qXy%qX~Ox&bOyuX~Oy&dO~Ox%mO#^%uX%V%uX%Y%uXe%uXy%uX!Y%uX!j%uX%r%uX~OT/rOm/iOt/wO}vO~P'UO%r$TO#^Sa%VSa%YSa~Ox&mO#^%wX%V%wX%Y%wXl%wX~P$bOx&pO!O&oO#^#Ra%V#Ra%Y#Ra~O#V&qO#^#Ta%V#Ta%Y#Ta~O!d$_O!m$_O#U&sO%mVO~O#U&sO~Ox&uO#^&kX%V&kX%Y&kX~Ox&wO#^&gX%V&gX%Y&gXy&gX~Ox&{Ol&mX~P$bOl'OO~OPhOTeOmtOtuO}vO!O!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO%V'TO~P'UOr'XO#g'VO#h'WOP#eaT#ead#eaf#eam#eaq#eat#ea}#ea!O#ea!R#ea!S#ea!V#ea!Z#ea!f#ea!m#ea!n#ea!o#ea!v#ea!x#ea!z#ea!|#ea#O#ea#S#ea#U#ea#X#ea#Y#ea#[#ea#c#ea#f#ea#j#ea#l#ea#q#ea#t#ea#v#ea%S#ea%V#ea%g#ea%h#ea%l#ea%m#ea&R#ea&S#ea&V#ea&Y#ea&`#ea&c#ea&e#ea%U#ea%Y#ea~Ox'YO#V'[Oy&nX~Of'^O~Of!jOy$nO~Oy'bO~P$bOT!bO]!bO_!cOf!jO!V!lO!d!nO%d!_O%e!`O%f!`O%g!aO%h!aO%i!bO%j!bO%k!bOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui%VUi%YUi%bUi%rUieUi!RUi!SUi%sUi!UUi!YUi!OUi#VUirUi!jUi~O%c!^O~P! YO%cUi~P! YOT!bO]!bO_!cOf!jO!V!lO!d!nO%g!aO%h!aO%i!bO%j!bO%k!bOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui%VUi%YUi%bUi%cUi%dUi%rUieUi!RUi!SUi%sUi!UUi!YUi!OUi#VUirUi!jUi~O%e!`O%f!`O~P!$TO%eUi%fUi~P!$TO_!cOf!jO!V!lO!d!nOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui%VUi%YUi%bUi%cUi%dUi%eUi%fUi%gUi%hUi%rUieUi!RUi!SUi%sUi!UUi!YUi!OUi#VUirUi!jUi~OT!bO]!bO%i!bO%j!bO%k!bO~P!'ROTUi]Ui%iUi%jUi%kUi~P!'RO!R%eO!S%dOe%}Xx%}X~O%r'fO%s'fO~P+xOx'hOe%|X~Oe'jO~Ox'kOy'mO!U&PX~Om/iOt/wOx'kOy'nO!U&PX~P'UO!U'pO~Ok!pOl!pOm!sOn!tOihiqhixhiyhi!shi#^hi%Vhi%Yhi%rhi~Oj!rO~P!+tOjhi~P!+tOi/kOj/lOk/jOl/jOm/sOn/tO~Or'rO~P!,}OT'wOe'xOm/iOt/wO~P'UOe'xOx'yO~Oe'{O~O!S'}O~Oe(OOx'yO!R%eO!S%dO~P$bOi/kOj/lOk/jOl/jOm/sOn/tOeoa!Roa!Soa%soa!Uoa!Yoa!Ooa#Voaroa!joa~PD_OT'wOm/iOt/wO!U%za~P'UOx(RO!U%za~O!U(SO~Ox(RO!R%eO!S%dO!U%za~P$bOT(WOm/iOt/wO!Y%ua#^%ua%V%ua%Y%uae%uay%ua!j%ua%r%ua~P'UOx(XO!Y%ua#^%ua%V%ua%Y%uae%uay%ua!j%ua%r%ua~O!Y([O~Ox(XO!R%eO!S%dO!Y%ua~P$bOx(_O!R%eO!S%dO!Y%{a~P$bOx(bOy&[X!Y&[X!j&[X~Oy(eO!Y(gO!j(hO~OT&TOmtOtuOy%`i!s%`i#^%`i%V%`i%Y%`i%r%`i~P'UOx(iOy%`i!s%`i#^%`i%V%`i%Y%`i%r%`i~O!d&ZOf&ha%V&ha#V&ha#^&ha%Y&ha#U&ha~O%V(nO~OT#zO_#{O%mVO~Ox&bOyua~OmtOtuO~P'UOx(XO#^%ua%V%ua%Y%uae%uay%ua!Y%ua!j%ua%r%ua~P$bOx(sO#^%`X%V%`X%Y%`X%r%`X~O%r$TO#^Si%VSi%YSi~O#^%wa%V%wa%Y%wal%wa~P'UOx(vO#^%wa%V%wa%Y%wal%wa~OT(zOf(|O%mVO~O#U(}O~O%mVO#^&ka%V&ka%Y&ka~Ox)PO#^&ka%V&ka%Y&ka~Om/iOt/wO#^&ga%V&ga%Y&gay&ga~P'UOx)SO#^&ga%V&ga%Y&gay&ga~Or)WO#a)VOP#_iT#_id#_if#_im#_iq#_it#_i}#_i!O#_i!R#_i!S#_i!V#_i!Z#_i!f#_i!m#_i!n#_i!o#_i!v#_i!x#_i!z#_i!|#_i#O#_i#S#_i#U#_i#X#_i#Y#_i#[#_i#c#_i#f#_i#j#_i#l#_i#q#_i#t#_i#v#_i%S#_i%V#_i%g#_i%h#_i%l#_i%m#_i&R#_i&S#_i&V#_i&Y#_i&`#_i&c#_i&e#_i%U#_i%Y#_i~Or)XOP#biT#bid#bif#bim#biq#bit#bi}#bi!O#bi!R#bi!S#bi!V#bi!Z#bi!f#bi!m#bi!n#bi!o#bi!v#bi!x#bi!z#bi!|#bi#O#bi#S#bi#U#bi#X#bi#Y#bi#[#bi#c#bi#f#bi#j#bi#l#bi#q#bi#t#bi#v#bi%S#bi%V#bi%g#bi%h#bi%l#bi%m#bi&R#bi&S#bi&V#bi&Y#bi&`#bi&c#bi&e#bi%U#bi%Y#bi~OT)ZOl&ma~P'UOx)[Ol&ma~Ox)[Ol&ma~P$bOl)`O~O%T)cO~Or)fO#g'VO#h)eOP#eiT#eid#eif#eim#eiq#eit#ei}#ei!O#ei!R#ei!S#ei!V#ei!Z#ei!f#ei!m#ei!n#ei!o#ei!v#ei!x#ei!z#ei!|#ei#O#ei#S#ei#U#ei#X#ei#Y#ei#[#ei#c#ei#f#ei#j#ei#l#ei#q#ei#t#ei#v#ei%S#ei%V#ei%g#ei%h#ei%l#ei%m#ei&R#ei&S#ei&V#ei&Y#ei&`#ei&c#ei&e#ei%U#ei%Y#ei~Om/iOt/wOy$nO~P'UOm/iOt/wOy&na~P'UOx)lOy&na~OT)pO_)qOe)tO%i)rO%mVO~Oy$nO&q)vO~O%V)zO~OT%OO_%OOm/iOt/wOe%|a~P'UOx*OOe%|a~Om/iOt/wOy*RO!U&Pa~P'UOx*SO!U&Pa~Om/iOt/wOx*SOy*VO!U&Pa~P'UOm/iOt/wOx*SO!U&Pa~P'UOx*SOy*VO!U&Pa~Ok/jOl/jOm/sOn/tOehiihiqhixhi!Rhi!Shi%shi!Uhiyhi!Yhi#^hi%Vhi%Yhi!Ohi#Vhirhi!jhi%rhi~Oj/lO~P!H[Ojhi~P!H[OT'wOe*[Om/iOt/wO~P'UOl*^O~Oe*[Ox*`O~Oe*aO~OT'wOm/iOt/wO!U%zi~P'UOx*bO!U%zi~O!U*cO~OT(WOm/iOt/wO!Y%ui#^%ui%V%ui%Y%uie%uiy%ui!j%ui%r%ui~P'UOx*fO!R%eO!S%dO!Y%{i~Ox*iO!Y%ui#^%ui%V%ui%Y%uie%uiy%ui!j%ui%r%ui~O!Y*jO~O_*lOm/iOt/wO!Y%{i~P'UOx*fO!Y%{i~O!Y*nO~OT*pOm/iOt/wOy&[a!Y&[a!j&[a~P'UOx*qOy&[a!Y&[a!j&[a~O!Z#^O&^*tO!Y!kX~O!Y*vO~Oy(eO!Y*wO~OT&TOmtOtuOy%`q!s%`q#^%`q%V%`q%Y%`q%r%`q~P'UOx$miy$mi!s$mi#^$mi%V$mi%Y$mi%r$mi~P$bOT&TOmtOtuO~P'UOT&TOm/iOt/wO#^%`a%V%`a%Y%`a%r%`a~P'UOx*xO#^%`a%V%`a%Y%`a%r%`a~Ox$`a#^$`a%V$`a%Y$`al$`a~P$bO#^%wi%V%wi%Y%wil%wi~P'UOx*{O#^#Rq%V#Rq%Y#Rq~Ox*|O#V+OO#^&jX%V&jX%Y&jXe&jX~OT+QOf(|O%mVO~O%mVO#^&ki%V&ki%Y&ki~Om/iOt/wO#^&gi%V&gi%Y&giy&gi~P'UOr+UO#a)VOP#_qT#_qd#_qf#_qm#_qq#_qt#_q}#_q!O#_q!R#_q!S#_q!V#_q!Z#_q!f#_q!m#_q!n#_q!o#_q!v#_q!x#_q!z#_q!|#_q#O#_q#S#_q#U#_q#X#_q#Y#_q#[#_q#c#_q#f#_q#j#_q#l#_q#q#_q#t#_q#v#_q%S#_q%V#_q%g#_q%h#_q%l#_q%m#_q&R#_q&S#_q&V#_q&Y#_q&`#_q&c#_q&e#_q%U#_q%Y#_q~Ol$wax$wa~P$bOT)ZOl&mi~P'UOx+]Ol&mi~OPhOTeOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO#v![O~P'UOx+gOy$nO#V+gO~O#h+hOP#eqT#eqd#eqf#eqm#eqq#eqt#eq}#eq!O#eq!R#eq!S#eq!V#eq!Z#eq!f#eq!m#eq!n#eq!o#eq!v#eq!x#eq!z#eq!|#eq#O#eq#S#eq#U#eq#X#eq#Y#eq#[#eq#c#eq#f#eq#j#eq#l#eq#q#eq#t#eq#v#eq%S#eq%V#eq%g#eq%h#eq%l#eq%m#eq&R#eq&S#eq&V#eq&Y#eq&`#eq&c#eq&e#eq%U#eq%Y#eq~O#V+iOx$yay$ya~Om/iOt/wOy&ni~P'UOx+kOy&ni~Oy$SO%r+mOe&pXx&pX~O%mVOe&pXx&pX~Ox+qOe&oX~Oe+sO~O%T+uO~OT%OO_%OOm/iOt/wOe%|i~P'UOy+wOx$ca!U$ca~Om/iOt/wOy+xOx$ca!U$ca~P'UOm/iOt/wOy*RO!U&Pi~P'UOx+{O!U&Pi~Om/iOt/wOx+{O!U&Pi~P'UOx+{Oy,OO!U&Pi~Oe$_ix$_i!U$_i~P$bOT'wOm/iOt/wO~P'UOl,QO~OT'wOe,ROm/iOt/wO~P'UOT'wOm/iOt/wO!U%zq~P'UOx$^i!Y$^i#^$^i%V$^i%Y$^ie$^iy$^i!j$^i%r$^i~P$bOT(WOm/iOt/wO~P'UO_*lOm/iOt/wO!Y%{q~P'UOx,SO!Y%{q~O!Y,TO~OT(WOm/iOt/wO!Y%uq#^%uq%V%uq%Y%uqe%uqy%uq!j%uq%r%uq~P'UOy,UO~OT*pOm/iOt/wOy&[i!Y&[i!j&[i~P'UOx,ZOy&[i!Y&[i!j&[i~O!Z#^O&^*tO!Y!ka~OT&TOm/iOt/wO#^%`i%V%`i%Y%`i%r%`i~P'UOx,]O#^%`i%V%`i%Y%`i%r%`i~O%mVO#^&ja%V&ja%Y&jae&ja~Ox,`O#^&ja%V&ja%Y&jae&ja~Oe,cO~Ol$wix$wi~P$bOT)ZO~P'UOT)ZOl&mq~P'UOr,fOP#dyT#dyd#dyf#dym#dyq#dyt#dy}#dy!O#dy!R#dy!S#dy!V#dy!Z#dy!f#dy!m#dy!n#dy!o#dy!v#dy!x#dy!z#dy!|#dy#O#dy#S#dy#U#dy#X#dy#Y#dy#[#dy#c#dy#f#dy#j#dy#l#dy#q#dy#t#dy#v#dy%S#dy%V#dy%g#dy%h#dy%l#dy%m#dy&R#dy&S#dy&V#dy&Y#dy&`#dy&c#dy&e#dy%U#dy%Y#dy~OPhOTeOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO#v![O%U,jO%Y,jO~P'UO#h,kOP#eyT#eyd#eyf#eym#eyq#eyt#ey}#ey!O#ey!R#ey!S#ey!V#ey!Z#ey!f#ey!m#ey!n#ey!o#ey!v#ey!x#ey!z#ey!|#ey#O#ey#S#ey#U#ey#X#ey#Y#ey#[#ey#c#ey#f#ey#j#ey#l#ey#q#ey#t#ey#v#ey%S#ey%V#ey%g#ey%h#ey%l#ey%m#ey&R#ey&S#ey&V#ey&Y#ey&`#ey&c#ey&e#ey%U#ey%Y#ey~Om/iOt/wOy&nq~P'UOx,oOy&nq~O%r+mOe&pax&pa~OT)pO_)qO%i)rO%mVOe&oa~Ox,sOe&oa~O#y,wO~OT%OO_%OOm/iOt/wO~P'UOm/iOt/wOy,xOx$ci!U$ci~P'UOm/iOt/wOx$ci!U$ci~P'UOy,xOx$ci!U$ci~Om/iOt/wOy*RO~P'UOm/iOt/wOy*RO!U&Pq~P'UOx,{O!U&Pq~Om/iOt/wOx,{O!U&Pq~P'UOq-OO!R%eO!S%dOe%vq!U%vq!Y%vqx%vq~P!,}O_*lOm/iOt/wO!Y%{y~P'UOx$ai!Y$ai~P$bO_*lOm/iOt/wO~P'UOT*pOm/iOt/wO~P'UOT*pOm/iOt/wOy&[q!Y&[q!j&[q~P'UOT&TOm/iOt/wO#^%`q%V%`q%Y%`q%r%`q~P'UO#V-SOx$ra#^$ra%V$ra%Y$rae$ra~O%mVO#^&ji%V&ji%Y&jie&ji~Ox-UO#^&ji%V&ji%Y&jie&ji~Or-XOP#d!RT#d!Rd#d!Rf#d!Rm#d!Rq#d!Rt#d!R}#d!R!O#d!R!R#d!R!S#d!R!V#d!R!Z#d!R!f#d!R!m#d!R!n#d!R!o#d!R!v#d!R!x#d!R!z#d!R!|#d!R#O#d!R#S#d!R#U#d!R#X#d!R#Y#d!R#[#d!R#c#d!R#f#d!R#j#d!R#l#d!R#q#d!R#t#d!R#v#d!R%S#d!R%V#d!R%g#d!R%h#d!R%l#d!R%m#d!R&R#d!R&S#d!R&V#d!R&Y#d!R&`#d!R&c#d!R&e#d!R%U#d!R%Y#d!R~Om/iOt/wOy&ny~P'UOT)pO_)qO%i)rO%mVOe&oi~O#y,wO%U-_O%Y-_O~OT-iOf-gO!V-fO!Z-hO!f-bO!n-dO!o-dO%h-aO%mVO&R[O&S]O&V^O~Om/iOt/wOx$cq!U$cq~P'UOy-nOx$cq!U$cq~Om/iOt/wOy*RO!U&Py~P'UOx-oO!U&Py~Om/iOt-sO~P'UOq-OO!R%eO!S%dOe%vy!U%vy!Y%vyx%vy~P!,}O%mVO#^&jq%V&jq%Y&jqe&jq~Ox-wO#^&jq%V&jq%Y&jqe&jq~OT)pO_)qO%i)rO%mVO~Of-{O!d-yOx#zX#V#zX%b#zXe#zX~Oq#zXy#zX!U#zX!Y#zX~P$$nO%g-}O%h-}Oq#{Xx#{Xy#{X#V#{X%b#{X!U#{Xe#{X!Y#{X~O!f.PO~Ox.TO#V.VO%b.QOq&rXy&rX!U&rXe&rX~O_.YO~P$ WOf-{Oq&sXx&sXy&sX#V&sX%b&sX!U&sXe&sX!Y&sX~Oq.^Oy$nO~Om/iOt/wOx$cy!U$cy~P'UOm/iOt/wOy*RO!U&P!R~P'UOx.bO!U&P!R~Oe%yXq%yX!R%yX!S%yX!U%yX!Y%yXx%yX~P!,}Oq-OO!R%eO!S%dOe%xa!U%xa!Y%xax%xa~O%mVO#^&jy%V&jy%Y&jye&jy~O!d-yOf$Raq$Rax$Ray$Ra#V$Ra%b$Ra!U$Rae$Ra!Y$Ra~O!f.kO~O%g-}O%h-}Oq#{ax#{ay#{a#V#{a%b#{a!U#{ae#{a!Y#{a~O%b.QOq$Pax$Pay$Pa#V$Pa!U$Pae$Pa!Y$Pa~Oq&ray&ra!U&rae&ra~P#NzOx.pOq&ray&ra!U&rae&ra~O!U.sO~Oe.sO~Oy.uO~O!Y.vO~Om/iOt/wOy*RO!U&P!Z~P'UOy.yO~O%r.zO~P$$nOx.{O#V.VO%b.QOe&uX~Ox.{Oe&uX~Oe.}O~O!f/OO~O#V.VOq$}ax$}ay$}a%b$}a!U$}ae$}a!Y$}a~O#V.VO%b.QOq%Rax%Ray%Ra!U%Rae%Ra~Oq&riy&ri!U&rie&ri~P#NzOx/QO#V.VO%b.QO!Y&ta~Oy$Za~P$bOe&ua~P#NzOx/YOe&ua~O_/[O!Y&ti~P$ WOx/^O!Y&ti~Ox/^O#V.VO%b.QO!Y&ti~O#V.VO%b.QOe$Xix$Xi~O%r/aO~P$$nO#V.VO%b.QOe%Qax%Qa~Oe&ui~P#NzOy/dO~O_/[O!Y&tq~P$ WOx/fO!Y&tq~O#V.VO%b.QOx%Pi!Y%Pi~O_/[O~P$ WO_/[O!Y&ty~P$ WO#V.VO%b.QOe$Yix$Yi~O#V.VO%b.QOx%Pq!Y%Pq~Ox*xO#^%`a%V%`a%Y%`a%r%`a~P$bOT&TOm/iOt/wO~P'UOl/nO~Om/nO~P'UOy/oO~Or/pO~P!,}O&S&V&c&e&R!Z&Z&a&d&f&Y&`&Y%m~",
  goto: "!9p&vPPPP&wP'P*e*}+h,S,o-]P-zP'P.k.k'PPPP'P2PPPPPPP2P4oPP4oP6{7U=QPP=T=c=fPP'P'PPP=rPP'P'PPP'P'P'P'P'P=v>m'PP>pP>vByFcPFw'PPPPF{GR&wP&w&wP&wP&wP&wP&wP&w&w&wP&wPP&wPP&wPGXPG`GfPG`PG`G`PPPG`PIePInItIzIePG`JQPG`PJXJ_PJcJwKfLPJcJcLVLdJcJcJcJcLxMOMRMWMZMaMgMsNVN]NgNm! Z! a! g! m! w! }!!T!!Z!!a!!g!!y!#T!#Z!#a!#g!#q!#w!#}!$T!$Z!$e!$k!$u!${!%U!%[!%k!%s!%}!&UPPPPPPPPP!&[!&d!&m!&w!'SPPPPPPPPPPPP!+r!,[!0j!3vPP!4O!4^!4g!5]!5S!5f!5l!5o!5r!5u!5}!6nPPPPPPPPPP!6q!6tPPPPPPPPP!6z!7W!7d!7j!7s!7v!7|!8S!8Y!8]P!8e!8n!9j!9m]iOr#n$n)c+c'udOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/x}!dP#j#w$Y$h$t%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!P!eP#j#w$Y$h$t$v%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!R!fP#j#w$Y$h$t$v$w%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!T!gP#j#w$Y$h$t$v$w$x%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!V!hP#j#w$Y$h$t$v$w$x$y%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!X!iP#j#w$Y$h$t$v$w$x$y$z%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!]!iP!o#j#w$Y$h$t$v$w$x$y$z${%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m'uSOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/x&ZUOXYZhrtv|}!R!S!T!X!j!l!p!q!r!t!u#^#k#n$Q$S$U$X$l$n%O%T%[%_%a%h%m%o%y&R&`&d&o&p&w'O'V'Y'g'h'k'm'n'r'y(R(X(_(b(i(k(s)S)V)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*p*q*x*{+S+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.b.y/i/j/k/l/n/o/p/q/t/x%eWOXYZhrv|}!R!S!T!X!j!l#^#k#n$Q$S$U$X$l$n%O%T%_%a%h%m%o%y&R&`&d&o&p&w'O'V'Y'g'h'k'm'n'r'y(R(X(_(b(i(k(s)S)V)`)c)l)v*O*R*S*V*]*`*b*e*f*i*p*q*x*{+S+c+j+k+n+v+w+x+z+{,O,S,U,W,Y,Z,],o,q,x,{-n-o.b/o/p/qQ#}uQ.c-sR/u/w'ldOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/xW#ql!O!P$`W#yu&b-s/wQ$b!QQ$r!YQ$s!ZW$}!j'h*O+vS&a#z#{Q'R$mQ(l&ZQ(z&qU({&s(|(}U)O&u)P+RQ)n'[W)o'^+q,s-]S+p)p)qY,_*|,`-T-U-wQ,b+OQ,l+gQ,n+il-`,w-f-g-i.R.T.Y.p.u.z/P/[/a/dQ-v-SQ.Z-hQ.g-{Q.r.VU/V.{/Y/bX/]/Q/^/e/fR&`#yi!xXY!S!T%a%h'y(R)V*]*`*bR%_!wQ!|XQ%z#^Q&i$UR&l$XT-r-O.y![!kP!o#j#w$Y$h$t$v$w$x$y$z${%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/mQ&^#rR'a$sR'g$}Q%W!nR.e-y'tcOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/xS#hc#i!P-d,w-f-g-h-i-{.R.T.Y.p.u.z.{/P/Q/Y/[/^/a/b/d/e/f'tcOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/xT#hc#iS#__#`S#b`#cS#da#eS#fb#gT*t(e*uT(f%z(hQ$WwR+o)oX$Uw$V$W&kZkOr$n)c+cXoOr)c+cQ$o!WQ&y$fQ&z$gQ']$qQ'`$sQ)a'QQ)g'VQ)i'WQ)j'XQ)w'_Q)y'aQ+V)VQ+X)WQ+Y)XQ+^)_S+`)b)xQ+d)eQ+e)fQ+f)hQ,d+UQ,e+WQ,g+_Q,h+aQ,m+hQ-W,fQ-Y,kQ-Z,lQ-x-XQ._-lR.x.`WoOr)c+cR#tnQ'_$rR)b'RQ+n)oR,q+oQ)x'_R+a)bZmOnr)c+cQ'c$tR){'dT,u+u,vu-k,w-f-g-i-{.R.T.Y.p.u.z.{/P/Y/[/a/b/dt-k,w-f-g-i-{.R.T.Y.p.u.z.{/P/Y/[/a/b/dQ.Z-hX/]/Q/^/e/f!P-c,w-f-g-h-i-{.R.T.Y.p.u.z.{/P/Q/Y/[/^/a/b/d/e/fQ.O-bR.l.Pg.R-e.S.h.o.t/S/U/W/c/g/hu-j,w-f-g-i-{.R.T.Y.p.u.z.{/P/Y/[/a/b/dX-|-`-j.g/VR.i-{V/X.{/Y/bR.`-lQrOR#vrQ&c#|R(q&cS%n#R$OS(Y%n(]T(]%q&eQ%b!zQ%i!}W'z%b%i(P(TQ(P%fR(T%kQ&n$YR(w&nQ(`%rQ*g(ZT*m(`*gQ'i%PR*P'iS'l%S%TY*T'l*U+|,|-pU*U'm'n'oU+|*V*W*XS,|+},OR-p,}Q#Y]R%u#YQ#]^R%w#]Q#`_R%{#`Q(c%xS*r(c*sR*s(dQ*u(eR,[*uQ#c`R%}#cQ#eaR&O#eQ#gbR&P#gQ#icR&Q#iQ#lfQ&S#jW&V#l&S(t*yQ(t&hR*y/mQ$VwS&j$V&kR&k$WQ&x$dR)T&xQ&[#qR(m&[Q$`!PR&r$`Q*}({S,a*}-VR-V,bQ&v$bR)Q&vQ#ojR&X#oQ+c)cR,i+cQ)U&yR+T)UQ&|$hS)]&|)^R)^&}Q'U$oR)d'UQ'Z$pS)m'Z+lR+l)nQ+r)sR,t+rWnOr)c+cR#snQ,v+uR-^,vd.S-e.h.o.t/S/U/W/c/g/hR.n.SU-z-`.g/VR.f-zQ/R.tS/_/R/`R/`/SS.|.h.iR/Z.|Q.U-eR.q.USqOrT+b)c+cWpOr)c+cR'S$nYjOr$n)c+cR&W#n[wOr#n$n)c+cR&i$U&YPOXYZhrtv|}!R!S!T!X!j!l!p!q!r!t!u#^#k#n$Q$S$U$X$l$n%O%T%[%_%a%h%m%o%y&R&`&d&o&p&w'O'V'Y'g'h'k'm'n'r'y(R(X(_(b(i(k(s)S)V)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*p*q*x*{+S+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.b.y/i/j/k/l/n/o/p/q/t/xQ!oSQ#jeQ#wsU$Yx%d'}S$h!U$kQ$t![Q$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ${!iQ%f!{Q%k#OQ%q#SQ%r#TQ&e$PQ&}$iQ'd$uQ(j&TU(u&m(v*zW)Y&{)[+[+]Q*Z'wQ*d(WQ+Z)ZQ,V*lQ.w.^R/m/rQ!zXQ!}YQ$f!SQ$g!T^'v%a%h'y(R*]*`*bR+W)V[fOr#n$n)c+ch!wXY!S!T%a%h'y(R)V*]*`*bQ#RZQ#mhS$Ov|Q$]}W$d!R$X'O)`S$p!X$lW$|!j'h*O+vQ%S!lQ%x#^`&U#k&R(i(k(s*x,]/qQ&f$QQ&g$SQ&h$UQ'e%OQ'o%TQ'u%_W(V%m(X*e*iQ(Z%oQ(d%yQ(o&`S(r&d/oQ(x&oQ(y&pU)R&w)S+SQ)h'VY)k'Y)l+j+k,oQ)|'g^*Q'k*S+z+{,{-o.bQ*W'mQ*X'nS*Y'r/pW*k(_*f,S,WW*o(b*q,Y,ZQ+t)vQ+y*RQ+}*VQ,X*pQ,^*{Q,p+nQ,y+wQ,z+xQ,},OQ-R,UQ-[,qQ-m,xR.a-nhTOr#k#n$n&R&d'r(i(k)c+c$z!vXYZhv|}!R!S!T!X!j!l#^$Q$S$U$X$l%O%T%_%a%h%m%o%y&`&o&p&w'O'V'Y'g'h'k'm'n'y(R(X(_(b(s)S)V)`)l)v*O*R*S*V*]*`*b*e*f*i*p*q*x*{+S+j+k+n+v+w+x+z+{,O,S,U,W,Y,Z,],o,q,x,{-n-o.b/o/p/qQ#xtW%X!p!t/j/tQ%Y!qQ%Z!rQ%]!uQ%g/iS'q%[/nQ's/kQ't/lQ,P*^Q-Q,QS-q-O.yR/v/xU#|u-s/wR(p&b[gOr#n$n)c+cX!yX#^$U$XQ#WZQ$RvR$[|Q%c!zQ%j!}Q%p#RQ'e$|Q(Q%fQ(U%kQ(^%qQ(a%rQ*h(ZQ-P,PQ-u-QR.d-tQ$ZxQ'|%dR*_'}Q-t-OR/T.yR#QYR#VZR%R!jQ%P!jV)}'h*O+v!]!mP!o#j#w$Y$h$t$v$w$x$y$z${%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/mR%U!lR%z#^Q(g%zR*w(hQ$e!RQ&l$XQ)_'OR+_)`Q#rlQ$^!OQ$a!PR&t$`Q(z&sR+Q(}Q(z&sQ+P(|R+Q(}R$c!QXpOr)c+cQ$j!UR'P$kQ$q!XR'Q$lR)u'^Q)s'^V,r+q,s-]Q-l,wQ.W-fR.X-gU-e,w-f-gQ.]-iQ.h-{Q.m.RU.o.T.p/PQ.t.YQ/S.uQ/U.zU/W.{/Y/bQ/c/[Q/g/aR/h/dR.[-hR.j-{",
  nodeNames: "\u26A0 print Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 267,
  context: trackIndent,
  nodeProps: [
    ["group", -14, 4, 80, 82, 83, 85, 87, 89, 91, 93, 94, 95, 97, 100, 103, "Statement Statement", -22, 6, 16, 19, 23, 38, 47, 48, 54, 55, 58, 59, 60, 61, 62, 65, 68, 69, 70, 74, 75, 76, 77, "Expression", -10, 105, 107, 110, 112, 113, 117, 119, 124, 126, 129, "Statement", -9, 134, 135, 138, 139, 141, 142, 143, 144, 145, "Pattern"],
    ["openedBy", 21, "(", 52, "[", 56, "{"],
    ["closedBy", 22, ")", 53, "]", 57, "}"]
  ],
  propSources: [pythonHighlighting],
  skippedNodes: [0, 2],
  repeatNodeCount: 38,
  tokenData: "&JdMgR!^OX$}XY!&]Y[$}[]!&]]p$}pq!&]qr!(grs!,^st!IYtu$}uv$5[vw$7nwx$8zxy%'vyz%(|z{%*S{|%,r|}%.O}!O%/U!O!P%1k!P!Q%<q!Q!R%?a!R![%Cc![!]%N_!]!^&!q!^!_&#w!_!`&&g!`!a&'s!a!b$}!b!c&*`!c!d&+n!d!e&-`!e!h&+n!h!i&7[!i!t&+n!t!u&@j!u!w&+n!w!x&5j!x!}&+n!}#O&Bt#O#P!'u#P#Q&Cz#Q#R&EQ#R#S&+n#S#T$}#T#U&+n#U#V&-`#V#Y&+n#Y#Z&7[#Z#f&+n#f#g&@j#g#i&+n#i#j&5j#j#o&+n#o#p&F^#p#q&GS#q#r&H`#r#s&I^#s$g$}$g~&+n<r%`Z&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<Q&^Z&^7[&TS&Z`&d!bOr'PrsFisw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'P<Q'`Z&^7[&TS&WW&Z`&d!b&f#tOr'Prs&Rsw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'P;p([Z&^7[&WW&f#tOr(}rs)}sw(}wx={x#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(};p)[Z&^7[&TS&WW&d!b&f#tOr(}rs)}sw(}wx(Rx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(};p*WZ&^7[&TS&d!bOr(}rs*ysw(}wx(Rx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(};p+SZ&^7[&TS&d!bOr(}rs+usw(}wx(Rx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(}8r,OX&^7[&TS&d!bOw+uwx,kx#O+u#O#P.]#P#o+u#o#p0d#p#q+u#q#r.q#r~+u8r,pX&^7[Ow+uwx-]x#O+u#O#P.]#P#o+u#o#p0d#p#q+u#q#r.q#r~+u8r-bX&^7[Ow+uwx-}x#O+u#O#P.]#P#o+u#o#p0d#p#q+u#q#r.q#r~+u7[.SR&^7[O#o-}#p#q-}#r~-}8r.bT&^7[O#o+u#o#p.q#p#q+u#q#r.q#r~+u!f.xV&TS&d!bOw.qwx/_x#O.q#O#P0^#P#o.q#o#p0d#p~.q!f/bVOw.qwx/wx#O.q#O#P0^#P#o.q#o#p0d#p~.q!f/zUOw.qx#O.q#O#P0^#P#o.q#o#p0d#p~.q!f0aPO~.q!f0iV&TSOw1Owx1dx#O1O#O#P2V#P#o1O#o#p.q#p~1OS1TT&TSOw1Owx1dx#O1O#O#P2V#P~1OS1gTOw1Owx1vx#O1O#O#P2V#P~1OS1ySOw1Ox#O1O#O#P2V#P~1OS2YPO~1O;p2bT&^7[O#o(}#o#p2q#p#q(}#q#r2q#r~(}%d2|X&TS&WW&d!b&f#tOr2qrs3isw2qwx5Px#O2q#O#P:R#P#o2q#o#p:X#p~2q%d3pX&TS&d!bOr2qrs4]sw2qwx5Px#O2q#O#P:R#P#o2q#o#p:X#p~2q%d4dX&TS&d!bOr2qrs.qsw2qwx5Px#O2q#O#P:R#P#o2q#o#p:X#p~2q%d5WX&WW&f#tOr2qrs3isw2qwx5sx#O2q#O#P:R#P#o2q#o#p:X#p~2q%d5zX&WW&f#tOr2qrs3isw2qwx6gx#O2q#O#P:R#P#o2q#o#p:X#p~2q#|6nV&WW&f#tOr6grs7Ts#O6g#O#P8S#P#o6g#o#p8Y#p~6g#|7WVOr6grs7ms#O6g#O#P8S#P#o6g#o#p8Y#p~6g#|7pUOr6gs#O6g#O#P8S#P#o6g#o#p8Y#p~6g#|8VPO~6g#|8_V&WWOr8trs9Ys#O8t#O#P9{#P#o8t#o#p6g#p~8tW8yT&WWOr8trs9Ys#O8t#O#P9{#P~8tW9]TOr8trs9ls#O8t#O#P9{#P~8tW9oSOr8ts#O8t#O#P9{#P~8tW:OPO~8t%d:UPO~2q%d:`X&TS&WWOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#p2q#p~:{[;SV&TS&WWOr:{rs;isw:{wx<ox#O:{#O#P=u#P~:{[;nV&TSOr:{rs<Tsw:{wx<ox#O:{#O#P=u#P~:{[<YV&TSOr:{rs1Osw:{wx<ox#O:{#O#P=u#P~:{[<tV&WWOr:{rs;isw:{wx=Zx#O:{#O#P=u#P~:{[=`V&WWOr:{rs;isw:{wx8tx#O:{#O#P=u#P~:{[=xPO~:{;p>UZ&^7[&WW&f#tOr(}rs)}sw(}wx>wx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(}:Y?QX&^7[&WW&f#tOr>wrs?ms#O>w#O#PAP#P#o>w#o#p8Y#p#q>w#q#r6g#r~>w:Y?rX&^7[Or>wrs@_s#O>w#O#PAP#P#o>w#o#p8Y#p#q>w#q#r6g#r~>w:Y@dX&^7[Or>wrs-}s#O>w#O#PAP#P#o>w#o#p8Y#p#q>w#q#r6g#r~>w:YAUT&^7[O#o>w#o#p6g#p#q>w#q#r6g#r~>w<QAjT&^7[O#o'P#o#pAy#p#q'P#q#rAy#r~'P%tBWX&TS&WW&Z`&d!b&f#tOrAyrsBsswAywx5Px#OAy#O#PEo#P#oAy#o#pEu#p~Ay%tB|X&TS&Z`&d!bOrAyrsCiswAywx5Px#OAy#O#PEo#P#oAy#o#pEu#p~Ay%tCrX&TS&Z`&d!bOrAyrsD_swAywx5Px#OAy#O#PEo#P#oAy#o#pEu#p~Ay!vDhV&TS&Z`&d!bOwD_wx/_x#OD_#O#PD}#P#oD_#o#pET#p~D_!vEQPO~D_!vEYV&TSOw1Owx1dx#O1O#O#P2V#P#o1O#o#pD_#p~1O%tErPO~Ay%tE|X&TS&WWOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#pAy#p~:{<QFtZ&^7[&TS&Z`&d!bOr'PrsGgsw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'P9SGrX&^7[&TS&Z`&d!bOwGgwx,kx#OGg#O#PH_#P#oGg#o#pET#p#qGg#q#rD_#r~Gg9SHdT&^7[O#oGg#o#pD_#p#qGg#q#rD_#r~Gg<bIOZ&^7[&WW&ap&f#tOrIqrs)}swIqwx! wx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~Iq<bJQZ&^7[&TS&WW&ap&d!b&f#tOrIqrs)}swIqwxHsx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~Iq<bJxT&^7[O#oIq#o#pKX#p#qIq#q#rKX#r~Iq&UKfX&TS&WW&ap&d!b&f#tOrKXrs3iswKXwxLRx#OKX#O#PN}#P#oKX#o#p! T#p~KX&UL[X&WW&ap&f#tOrKXrs3iswKXwxLwx#OKX#O#PN}#P#oKX#o#p! T#p~KX&UMQX&WW&ap&f#tOrKXrs3iswKXwxMmx#OKX#O#PN}#P#oKX#o#p! T#p~KX$nMvV&WW&ap&f#tOrMmrs7Ts#OMm#O#PN]#P#oMm#o#pNc#p~Mm$nN`PO~Mm$nNhV&WWOr8trs9Ys#O8t#O#P9{#P#o8t#o#pMm#p~8t&U! QPO~KX&U! [X&TS&WWOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#pKX#p~:{<b!!SZ&^7[&WW&ap&f#tOrIqrs)}swIqwx!!ux#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~Iq:z!#QX&^7[&WW&ap&f#tOr!!urs?ms#O!!u#O#P!#m#P#o!!u#o#pNc#p#q!!u#q#rMm#r~!!u:z!#rT&^7[O#o!!u#o#pMm#p#q!!u#q#rMm#r~!!u<r!$WT&^7[O#o$}#o#p!$g#p#q$}#q#r!$g#r~$}&f!$vX&TS&WW&Z`&ap&d!b&f#tOr!$grsBssw!$gwxLRx#O!$g#O#P!%c#P#o!$g#o#p!%i#p~!$g&f!%fPO~!$g&f!%pX&TS&WWOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#p!$g#p~:{Mg!&pa&^7[&TS&WW%[1s&Z`&ap&d!b&f#tOX$}XY!&]Y[$}[]!&]]p$}pq!&]qr$}rs&Rsw$}wxHsx#O$}#O#P!'u#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Mg!'zX&^7[OY$}YZ!&]Z]$}]^!&]^#o$}#o#p!$g#p#q$}#q#r!$g#r~$}<u!(xb&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`!*Q!`#O$}#O#P!$R#P#T$}#T#U!+W#U#f$}#f#g!+W#g#h!+W#h#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u!*eZkR&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u!+kZ!jR&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{!,m_&bp&^7[&TS&R,X&Z`&d!bOY!-lYZ'PZ]!-l]^'P^r!-lrs!G^sw!-lwx!/|x#O!-l#O#P!Cp#P#o!-l#o#p!F[#p#q!-l#q#r!DU#r~!-lGZ!-}_&^7[&TS&WW&R,X&Z`&d!b&f#tOY!-lYZ'PZ]!-l]^'P^r!-lrs!.|sw!-lwx!/|x#O!-l#O#P!Cp#P#o!-l#o#p!F[#p#q!-l#q#r!DU#r~!-lGZ!/ZZ&^7[&TS&R,X&Z`&d!bOr'PrsFisw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PFy!0X_&^7[&WW&R,X&f#tOY!1WYZ(}Z]!1W]^(}^r!1Wrs!2fsw!1Wwx!@Yx#O!1W#O#P!3d#P#o!1W#o#p!;t#p#q!1W#q#r!3x#r~!1WFy!1g_&^7[&TS&WW&R,X&d!b&f#tOY!1WYZ(}Z]!1W]^(}^r!1Wrs!2fsw!1Wwx!/|x#O!1W#O#P!3d#P#o!1W#o#p!;t#p#q!1W#q#r!3x#r~!1WFy!2qZ&^7[&TS&R,X&d!bOr(}rs*ysw(}wx(Rx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(}Fy!3iT&^7[O#o!1W#o#p!3x#p#q!1W#q#r!3x#r~!1W0m!4V]&TS&WW&R,X&d!b&f#tOY!3xYZ2qZ]!3x]^2q^r!3xrs!5Osw!3xwx!5tx#O!3x#O#P!;n#P#o!3x#o#p!;t#p~!3x0m!5XX&TS&R,X&d!bOr2qrs4]sw2qwx5Px#O2q#O#P:R#P#o2q#o#p:X#p~2q0m!5}]&WW&R,X&f#tOY!3xYZ2qZ]!3x]^2q^r!3xrs!5Osw!3xwx!6vx#O!3x#O#P!;n#P#o!3x#o#p!;t#p~!3x0m!7P]&WW&R,X&f#tOY!3xYZ2qZ]!3x]^2q^r!3xrs!5Osw!3xwx!7xx#O!3x#O#P!;n#P#o!3x#o#p!;t#p~!3x/V!8RZ&WW&R,X&f#tOY!7xYZ6gZ]!7x]^6g^r!7xrs!8ts#O!7x#O#P!9`#P#o!7x#o#p!9f#p~!7x/V!8yV&R,XOr6grs7ms#O6g#O#P8S#P#o6g#o#p8Y#p~6g/V!9cPO~!7x/V!9mZ&WW&R,XOY!:`YZ8tZ]!:`]^8t^r!:`rs!;Ss#O!:`#O#P!;h#P#o!:`#o#p!7x#p~!:`,a!:gX&WW&R,XOY!:`YZ8tZ]!:`]^8t^r!:`rs!;Ss#O!:`#O#P!;h#P~!:`,a!;XT&R,XOr8trs9ls#O8t#O#P9{#P~8t,a!;kPO~!:`0m!;qPO~!3x0m!;}]&TS&WW&R,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!>`x#O!<v#O#P!@S#P#o!<v#o#p!3x#p~!<v,e!=PZ&TS&WW&R,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!>`x#O!<v#O#P!@S#P~!<v,e!=yV&TS&R,XOr:{rs<Tsw:{wx<ox#O:{#O#P=u#P~:{,e!>gZ&WW&R,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!?Yx#O!<v#O#P!@S#P~!<v,e!?aZ&WW&R,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!:`x#O!<v#O#P!@S#P~!<v,e!@VPO~!<vFy!@e_&^7[&WW&R,X&f#tOY!1WYZ(}Z]!1W]^(}^r!1Wrs!2fsw!1Wwx!Adx#O!1W#O#P!3d#P#o!1W#o#p!;t#p#q!1W#q#r!3x#r~!1WEc!Ao]&^7[&WW&R,X&f#tOY!AdYZ>wZ]!Ad]^>w^r!Adrs!Bhs#O!Ad#O#P!C[#P#o!Ad#o#p!9f#p#q!Ad#q#r!7x#r~!AdEc!BoX&^7[&R,XOr>wrs@_s#O>w#O#PAP#P#o>w#o#p8Y#p#q>w#q#r6g#r~>wEc!CaT&^7[O#o!Ad#o#p!7x#p#q!Ad#q#r!7x#r~!AdGZ!CuT&^7[O#o!-l#o#p!DU#p#q!-l#q#r!DU#r~!-l0}!De]&TS&WW&R,X&Z`&d!b&f#tOY!DUYZAyZ]!DU]^Ay^r!DUrs!E^sw!DUwx!5tx#O!DU#O#P!FU#P#o!DU#o#p!F[#p~!DU0}!EiX&TS&R,X&Z`&d!bOrAyrsCiswAywx5Px#OAy#O#PEo#P#oAy#o#pEu#p~Ay0}!FXPO~!DU0}!Fe]&TS&WW&R,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!>`x#O!<v#O#P!@S#P#o!<v#o#p!DU#p~!<vGZ!GkZ&^7[&TS&R,X&Z`&d!bOr'Prs!H^sw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PGZ!HmX&X#|&^7[&TS&V,X&Z`&d!bOwGgwx,kx#OGg#O#PH_#P#oGg#o#pET#p#qGg#q#rD_#r~GgMg!Im_Q1s&^7[&TS&WW&Z`&ap&d!b&f#tOY!IYYZ$}Z]!IY]^$}^r!IYrs!Jlsw!IYwx$$[x#O!IY#O#P$1v#P#o!IY#o#p$4Y#p#q!IY#q#r$2j#r~!IYLu!Jy_Q1s&^7[&TS&Z`&d!bOY!KxYZ'PZ]!Kx]^'P^r!Kxrs$ Usw!Kxwx!MYx#O!Kx#O#P#G^#P#o!Kx#o#p#NS#p#q!Kx#q#r#HQ#r~!KxLu!LZ_Q1s&^7[&TS&WW&Z`&d!b&f#tOY!KxYZ'PZ]!Kx]^'P^r!Kxrs!Jlsw!Kxwx!MYx#O!Kx#O#P#G^#P#o!Kx#o#p#NS#p#q!Kx#q#r#HQ#r~!KxLe!Me_Q1s&^7[&WW&f#tOY!NdYZ(}Z]!Nd]^(}^r!Ndrs# rsw!Ndwx#B[x#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdLe!Ns_Q1s&^7[&TS&WW&d!b&f#tOY!NdYZ(}Z]!Nd]^(}^r!Ndrs# rsw!Ndwx!MYx#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdLe# }_Q1s&^7[&TS&d!bOY!NdYZ(}Z]!Nd]^(}^r!Ndrs#!|sw!Ndwx!MYx#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdLe##X_Q1s&^7[&TS&d!bOY!NdYZ(}Z]!Nd]^(}^r!Ndrs#$Wsw!Ndwx!MYx#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdIg#$c]Q1s&^7[&TS&d!bOY#$WYZ+uZ]#$W]^+u^w#$Wwx#%[x#O#$W#O#P#(^#P#o#$W#o#p#,Q#p#q#$W#q#r#)Q#r~#$WIg#%c]Q1s&^7[OY#$WYZ+uZ]#$W]^+u^w#$Wwx#&[x#O#$W#O#P#(^#P#o#$W#o#p#,Q#p#q#$W#q#r#)Q#r~#$WIg#&c]Q1s&^7[OY#$WYZ+uZ]#$W]^+u^w#$Wwx#'[x#O#$W#O#P#(^#P#o#$W#o#p#,Q#p#q#$W#q#r#)Q#r~#$WHP#'cXQ1s&^7[OY#'[YZ-}Z]#'[]^-}^#o#'[#o#p#(O#p#q#'[#q#r#(O#r~#'[1s#(TRQ1sOY#(OZ]#(O^~#(OIg#(eXQ1s&^7[OY#$WYZ+uZ]#$W]^+u^#o#$W#o#p#)Q#p#q#$W#q#r#)Q#r~#$W3Z#)ZZQ1s&TS&d!bOY#)QYZ.qZ]#)Q]^.q^w#)Qwx#)|x#O#)Q#O#P#+l#P#o#)Q#o#p#,Q#p~#)Q3Z#*RZQ1sOY#)QYZ.qZ]#)Q]^.q^w#)Qwx#*tx#O#)Q#O#P#+l#P#o#)Q#o#p#,Q#p~#)Q3Z#*yZQ1sOY#)QYZ.qZ]#)Q]^.q^w#)Qwx#(Ox#O#)Q#O#P#+l#P#o#)Q#o#p#,Q#p~#)Q3Z#+qTQ1sOY#)QYZ.qZ]#)Q]^.q^~#)Q3Z#,XZQ1s&TSOY#,zYZ1OZ]#,z]^1O^w#,zwx#-nx#O#,z#O#P#/Q#P#o#,z#o#p#)Q#p~#,z1w#-RXQ1s&TSOY#,zYZ1OZ]#,z]^1O^w#,zwx#-nx#O#,z#O#P#/Q#P~#,z1w#-sXQ1sOY#,zYZ1OZ]#,z]^1O^w#,zwx#.`x#O#,z#O#P#/Q#P~#,z1w#.eXQ1sOY#,zYZ1OZ]#,z]^1O^w#,zwx#(Ox#O#,z#O#P#/Q#P~#,z1w#/VTQ1sOY#,zYZ1OZ]#,z]^1O^~#,zLe#/mXQ1s&^7[OY!NdYZ(}Z]!Nd]^(}^#o!Nd#o#p#0Y#p#q!Nd#q#r#0Y#r~!Nd6X#0g]Q1s&TS&WW&d!b&f#tOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#1`sw#0Ywx#3dx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y6X#1i]Q1s&TS&d!bOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#2bsw#0Ywx#3dx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y6X#2k]Q1s&TS&d!bOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#)Qsw#0Ywx#3dx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y6X#3m]Q1s&WW&f#tOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#1`sw#0Ywx#4fx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y6X#4o]Q1s&WW&f#tOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#1`sw#0Ywx#5hx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y4q#5qZQ1s&WW&f#tOY#5hYZ6gZ]#5h]^6g^r#5hrs#6ds#O#5h#O#P#8S#P#o#5h#o#p#8h#p~#5h4q#6iZQ1sOY#5hYZ6gZ]#5h]^6g^r#5hrs#7[s#O#5h#O#P#8S#P#o#5h#o#p#8h#p~#5h4q#7aZQ1sOY#5hYZ6gZ]#5h]^6g^r#5hrs#(Os#O#5h#O#P#8S#P#o#5h#o#p#8h#p~#5h4q#8XTQ1sOY#5hYZ6gZ]#5h]^6g^~#5h4q#8oZQ1s&WWOY#9bYZ8tZ]#9b]^8t^r#9brs#:Us#O#9b#O#P#;h#P#o#9b#o#p#5h#p~#9b1{#9iXQ1s&WWOY#9bYZ8tZ]#9b]^8t^r#9brs#:Us#O#9b#O#P#;h#P~#9b1{#:ZXQ1sOY#9bYZ8tZ]#9b]^8t^r#9brs#:vs#O#9b#O#P#;h#P~#9b1{#:{XQ1sOY#9bYZ8tZ]#9b]^8t^r#9brs#(Os#O#9b#O#P#;h#P~#9b1{#;mTQ1sOY#9bYZ8tZ]#9b]^8t^~#9b6X#<RTQ1sOY#0YYZ2qZ]#0Y]^2q^~#0Y6X#<k]Q1s&TS&WWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P#o#=d#o#p#0Y#p~#=d2P#=mZQ1s&TS&WWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P~#=d2P#>gZQ1s&TSOY#=dYZ:{Z]#=d]^:{^r#=drs#?Ysw#=dwx#@Sx#O#=d#O#P#Av#P~#=d2P#?aZQ1s&TSOY#=dYZ:{Z]#=d]^:{^r#=drs#,zsw#=dwx#@Sx#O#=d#O#P#Av#P~#=d2P#@ZZQ1s&WWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@|x#O#=d#O#P#Av#P~#=d2P#ATZQ1s&WWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#9bx#O#=d#O#P#Av#P~#=d2P#A{TQ1sOY#=dYZ:{Z]#=d]^:{^~#=dLe#Bg_Q1s&^7[&WW&f#tOY!NdYZ(}Z]!Nd]^(}^r!Ndrs# rsw!Ndwx#Cfx#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdJ}#Cq]Q1s&^7[&WW&f#tOY#CfYZ>wZ]#Cf]^>w^r#Cfrs#Djs#O#Cf#O#P#Fj#P#o#Cf#o#p#8h#p#q#Cf#q#r#5h#r~#CfJ}#Dq]Q1s&^7[OY#CfYZ>wZ]#Cf]^>w^r#Cfrs#Ejs#O#Cf#O#P#Fj#P#o#Cf#o#p#8h#p#q#Cf#q#r#5h#r~#CfJ}#Eq]Q1s&^7[OY#CfYZ>wZ]#Cf]^>w^r#Cfrs#'[s#O#Cf#O#P#Fj#P#o#Cf#o#p#8h#p#q#Cf#q#r#5h#r~#CfJ}#FqXQ1s&^7[OY#CfYZ>wZ]#Cf]^>w^#o#Cf#o#p#5h#p#q#Cf#q#r#5h#r~#CfLu#GeXQ1s&^7[OY!KxYZ'PZ]!Kx]^'P^#o!Kx#o#p#HQ#p#q!Kx#q#r#HQ#r~!Kx6i#Ha]Q1s&TS&WW&Z`&d!b&f#tOY#HQYZAyZ]#HQ]^Ay^r#HQrs#IYsw#HQwx#3dx#O#HQ#O#P#Mn#P#o#HQ#o#p#NS#p~#HQ6i#Ie]Q1s&TS&Z`&d!bOY#HQYZAyZ]#HQ]^Ay^r#HQrs#J^sw#HQwx#3dx#O#HQ#O#P#Mn#P#o#HQ#o#p#NS#p~#HQ6i#Ji]Q1s&TS&Z`&d!bOY#HQYZAyZ]#HQ]^Ay^r#HQrs#Kbsw#HQwx#3dx#O#HQ#O#P#Mn#P#o#HQ#o#p#NS#p~#HQ3k#KmZQ1s&TS&Z`&d!bOY#KbYZD_Z]#Kb]^D_^w#Kbwx#)|x#O#Kb#O#P#L`#P#o#Kb#o#p#Lt#p~#Kb3k#LeTQ1sOY#KbYZD_Z]#Kb]^D_^~#Kb3k#L{ZQ1s&TSOY#,zYZ1OZ]#,z]^1O^w#,zwx#-nx#O#,z#O#P#/Q#P#o#,z#o#p#Kb#p~#,z6i#MsTQ1sOY#HQYZAyZ]#HQ]^Ay^~#HQ6i#N]]Q1s&TS&WWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P#o#=d#o#p#HQ#p~#=dLu$ c_Q1s&^7[&TS&Z`&d!bOY!KxYZ'PZ]!Kx]^'P^r!Kxrs$!bsw!Kxwx!MYx#O!Kx#O#P#G^#P#o!Kx#o#p#NS#p#q!Kx#q#r#HQ#r~!KxIw$!o]Q1s&^7[&TS&Z`&d!bOY$!bYZGgZ]$!b]^Gg^w$!bwx#%[x#O$!b#O#P$#h#P#o$!b#o#p#Lt#p#q$!b#q#r#Kb#r~$!bIw$#oXQ1s&^7[OY$!bYZGgZ]$!b]^Gg^#o$!b#o#p#Kb#p#q$!b#q#r#Kb#r~$!bMV$$i_Q1s&^7[&WW&ap&f#tOY$%hYZIqZ]$%h]^Iq^r$%hrs# rsw$%hwx$.px#O$%h#O#P$&x#P#o$%h#o#p$-n#p#q$%h#q#r$'l#r~$%hMV$%y_Q1s&^7[&TS&WW&ap&d!b&f#tOY$%hYZIqZ]$%h]^Iq^r$%hrs# rsw$%hwx$$[x#O$%h#O#P$&x#P#o$%h#o#p$-n#p#q$%h#q#r$'l#r~$%hMV$'PXQ1s&^7[OY$%hYZIqZ]$%h]^Iq^#o$%h#o#p$'l#p#q$%h#q#r$'l#r~$%h6y$'{]Q1s&TS&WW&ap&d!b&f#tOY$'lYZKXZ]$'l]^KX^r$'lrs#1`sw$'lwx$(tx#O$'l#O#P$-Y#P#o$'l#o#p$-n#p~$'l6y$)P]Q1s&WW&ap&f#tOY$'lYZKXZ]$'l]^KX^r$'lrs#1`sw$'lwx$)xx#O$'l#O#P$-Y#P#o$'l#o#p$-n#p~$'l6y$*T]Q1s&WW&ap&f#tOY$'lYZKXZ]$'l]^KX^r$'lrs#1`sw$'lwx$*|x#O$'l#O#P$-Y#P#o$'l#o#p$-n#p~$'l5c$+XZQ1s&WW&ap&f#tOY$*|YZMmZ]$*|]^Mm^r$*|rs#6ds#O$*|#O#P$+z#P#o$*|#o#p$,`#p~$*|5c$,PTQ1sOY$*|YZMmZ]$*|]^Mm^~$*|5c$,gZQ1s&WWOY#9bYZ8tZ]#9b]^8t^r#9brs#:Us#O#9b#O#P#;h#P#o#9b#o#p$*|#p~#9b6y$-_TQ1sOY$'lYZKXZ]$'l]^KX^~$'l6y$-w]Q1s&TS&WWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P#o#=d#o#p$'l#p~#=dMV$.}_Q1s&^7[&WW&ap&f#tOY$%hYZIqZ]$%h]^Iq^r$%hrs# rsw$%hwx$/|x#O$%h#O#P$&x#P#o$%h#o#p$-n#p#q$%h#q#r$'l#r~$%hKo$0Z]Q1s&^7[&WW&ap&f#tOY$/|YZ!!uZ]$/|]^!!u^r$/|rs#Djs#O$/|#O#P$1S#P#o$/|#o#p$,`#p#q$/|#q#r$*|#r~$/|Ko$1ZXQ1s&^7[OY$/|YZ!!uZ]$/|]^!!u^#o$/|#o#p$*|#p#q$/|#q#r$*|#r~$/|Mg$1}XQ1s&^7[OY!IYYZ$}Z]!IY]^$}^#o!IY#o#p$2j#p#q!IY#q#r$2j#r~!IY7Z$2{]Q1s&TS&WW&Z`&ap&d!b&f#tOY$2jYZ!$gZ]$2j]^!$g^r$2jrs#IYsw$2jwx$(tx#O$2j#O#P$3t#P#o$2j#o#p$4Y#p~$2j7Z$3yTQ1sOY$2jYZ!$gZ]$2j]^!$g^~$2j7Z$4c]Q1s&TS&WWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P#o#=d#o#p$2j#p~#=dGz$5o]%jQ&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz$6{Z!s,W&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz$8R]%dQ&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{$9Z_&_`&^7[&WW&R,X&ap&f#tOY$:YYZIqZ]$:Y]^Iq^r$:Yrs$;jsw$:Ywx%%zx#O$:Y#O#P%!^#P#o$:Y#o#p%$x#p#q$:Y#q#r%!r#r~$:YGk$:k_&^7[&TS&WW&R,X&ap&d!b&f#tOY$:YYZIqZ]$:Y]^Iq^r$:Yrs$;jsw$:Ywx% ^x#O$:Y#O#P%!^#P#o$:Y#o#p%$x#p#q$:Y#q#r%!r#r~$:YFy$;u_&^7[&TS&R,X&d!bOY$<tYZ(}Z]$<t]^(}^r$<trs$Kvsw$<twx$>Sx#O$<t#O#P$?Q#P#o$<t#o#p$Gb#p#q$<t#q#r$?f#r~$<tFy$=T_&^7[&TS&WW&R,X&d!b&f#tOY$<tYZ(}Z]$<t]^(}^r$<trs$;jsw$<twx$>Sx#O$<t#O#P$?Q#P#o$<t#o#p$Gb#p#q$<t#q#r$?f#r~$<tFy$>_Z&^7[&WW&R,X&f#tOr(}rs)}sw(}wx={x#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(}Fy$?VT&^7[O#o$<t#o#p$?f#p#q$<t#q#r$?f#r~$<t0m$?s]&TS&WW&R,X&d!b&f#tOY$?fYZ2qZ]$?f]^2q^r$?frs$@lsw$?fwx$Ffx#O$?f#O#P$G[#P#o$?f#o#p$Gb#p~$?f0m$@u]&TS&R,X&d!bOY$?fYZ2qZ]$?f]^2q^r$?frs$Answ$?fwx$Ffx#O$?f#O#P$G[#P#o$?f#o#p$Gb#p~$?f0m$Aw]&TS&R,X&d!bOY$?fYZ2qZ]$?f]^2q^r$?frs$Bpsw$?fwx$Ffx#O$?f#O#P$G[#P#o$?f#o#p$Gb#p~$?f-o$ByZ&TS&R,X&d!bOY$BpYZ.qZ]$Bp]^.q^w$Bpwx$Clx#O$Bp#O#P$DW#P#o$Bp#o#p$D^#p~$Bp-o$CqV&R,XOw.qwx/wx#O.q#O#P0^#P#o.q#o#p0d#p~.q-o$DZPO~$Bp-o$DeZ&TS&R,XOY$EWYZ1OZ]$EW]^1O^w$EWwx$Ezx#O$EW#O#P$F`#P#o$EW#o#p$Bp#p~$EW,]$E_X&TS&R,XOY$EWYZ1OZ]$EW]^1O^w$EWwx$Ezx#O$EW#O#P$F`#P~$EW,]$FPT&R,XOw1Owx1vx#O1O#O#P2V#P~1O,]$FcPO~$EW0m$FoX&WW&R,X&f#tOr2qrs3isw2qwx5sx#O2q#O#P:R#P#o2q#o#p:X#p~2q0m$G_PO~$?f0m$Gk]&TS&WW&R,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$I`sw$Hdwx$KSx#O$Hd#O#P$Kp#P#o$Hd#o#p$?f#p~$Hd,e$HmZ&TS&WW&R,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$I`sw$Hdwx$KSx#O$Hd#O#P$Kp#P~$Hd,e$IgZ&TS&R,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$JYsw$Hdwx$KSx#O$Hd#O#P$Kp#P~$Hd,e$JaZ&TS&R,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$EWsw$Hdwx$KSx#O$Hd#O#P$Kp#P~$Hd,e$KZV&WW&R,XOr:{rs;isw:{wx=Zx#O:{#O#P=u#P~:{,e$KsPO~$HdFy$LR_&^7[&TS&R,X&d!bOY$<tYZ(}Z]$<t]^(}^r$<trs$MQsw$<twx$>Sx#O$<t#O#P$?Q#P#o$<t#o#p$Gb#p#q$<t#q#r$?f#r~$<tC{$M]]&^7[&TS&R,X&d!bOY$MQYZ+uZ]$MQ]^+u^w$MQwx$NUx#O$MQ#O#P$Nx#P#o$MQ#o#p$D^#p#q$MQ#q#r$Bp#r~$MQC{$N]X&^7[&R,XOw+uwx-]x#O+u#O#P.]#P#o+u#o#p0d#p#q+u#q#r.q#r~+uC{$N}T&^7[O#o$MQ#o#p$Bp#p#q$MQ#q#r$Bp#r~$MQGk% kZ&^7[&WW&R,X&ap&f#tOrIqrs)}swIqwx! wx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqGk%!cT&^7[O#o$:Y#o#p%!r#p#q$:Y#q#r%!r#r~$:Y1_%#R]&TS&WW&R,X&ap&d!b&f#tOY%!rYZKXZ]%!r]^KX^r%!rrs$@lsw%!rwx%#zx#O%!r#O#P%$r#P#o%!r#o#p%$x#p~%!r1_%$VX&WW&R,X&ap&f#tOrKXrs3iswKXwxLwx#OKX#O#PN}#P#oKX#o#p! T#p~KX1_%$uPO~%!r1_%%R]&TS&WW&R,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$I`sw$Hdwx$KSx#O$Hd#O#P$Kp#P#o$Hd#o#p%!r#p~$HdGk%&XZ&^7[&WW&R,X&ap&f#tOrIqrs)}swIqwx%&zx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqGk%'ZX&U!f&^7[&WW&S,X&ap&f#tOr!!urs?ms#O!!u#O#P!#m#P#o!!u#o#pNc#p#q!!u#q#rMm#r~!!uG{%(ZZf,X&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u%)aZeR&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%*g_T,X&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsxz$}z{%+f{!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%+y]_R&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%-V]%g,X&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u%.cZxR&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Mg%/i^%h,X&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`!a%0e!a#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}B^%0xZ&q&j&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%2O_!dQ&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!O$}!O!P%2}!P!Q$}!Q![%5_![#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%3`]&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!O$}!O!P%4X!P#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%4lZ!m,X&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%5rg!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%5_![!g$}!g!h%7Z!h!l$}!l!m%;k!m#O$}#O#P!$R#P#R$}#R#S%5_#S#X$}#X#Y%7Z#Y#^$}#^#_%;k#_#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%7la&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx{$}{|%8q|}$}}!O%8q!O!Q$}!Q![%9{![#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%9S]&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%9{![#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%:`c!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%9{![!l$}!l!m%;k!m#O$}#O#P!$R#P#R$}#R#S%9{#S#^$}#^#_%;k#_#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%<OZ!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%=U_%iR&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!P$}!P!Q%>T!Q!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz%>h]%kQ&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%?tu!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!O$}!O!P%BX!P!Q$}!Q![%Cc![!d$}!d!e%Ee!e!g$}!g!h%7Z!h!l$}!l!m%;k!m!q$}!q!r%H_!r!z$}!z!{%KR!{#O$}#O#P!$R#P#R$}#R#S%Cc#S#U$}#U#V%Ee#V#X$}#X#Y%7Z#Y#^$}#^#_%;k#_#c$}#c#d%H_#d#l$}#l#m%KR#m#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Bj]&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%5_![#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Cvi!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!O$}!O!P%BX!P!Q$}!Q![%Cc![!g$}!g!h%7Z!h!l$}!l!m%;k!m#O$}#O#P!$R#P#R$}#R#S%Cc#S#X$}#X#Y%7Z#Y#^$}#^#_%;k#_#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Ev`&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!Q$}!Q!R%Fx!R!S%Fx!S#O$}#O#P!$R#P#R$}#R#S%Fx#S#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%G]`!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!Q$}!Q!R%Fx!R!S%Fx!S#O$}#O#P!$R#P#R$}#R#S%Fx#S#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Hp_&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!Q$}!Q!Y%Io!Y#O$}#O#P!$R#P#R$}#R#S%Io#S#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%JS_!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!Q$}!Q!Y%Io!Y#O$}#O#P!$R#P#R$}#R#S%Io#S#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Kdc&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%Lo![!c$}!c!i%Lo!i#O$}#O#P!$R#P#R$}#R#S%Lo#S#T$}#T#Z%Lo#Z#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%MSc!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%Lo![!c$}!c!i%Lo!i#O$}#O#P!$R#P#R$}#R#S%Lo#S#T$}#T#Z%Lo#Z#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Mg%Nr]y1s&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`& k!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u&!OZ%sR&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&#UZ#^,X&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&$[_kR&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!^$}!^!_&%Z!_!`!*Q!`!a!*Q!a#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz&%n]%eQ&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&&z]%r,X&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`!*Q!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&(W^kR&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`!*Q!`!a&)S!a#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz&)g]%fQ&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&*u]]Q#tP&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Mg&,Tc&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr$}rs&Rsw$}wxHsx!Q$}!Q![&+n![!c$}!c!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nMg&-ug&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr$}rs&/^sw$}wx&2dx!Q$}!Q![&+n![!c$}!c!t&+n!t!u&5j!u!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#f&+n#f#g&5j#g#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nGZ&/k_&^7[&TS&R,X&Z`&d!bOY!-lYZ'PZ]!-l]^'P^r!-lrs&0jsw!-lwx!/|x#O!-l#O#P!Cp#P#o!-l#o#p!F[#p#q!-l#q#r!DU#r~!-lGZ&0wZ&^7[&TS&R,X&Z`&d!bOr'Prs&1jsw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PD]&1wX&^7[&TS&V,X&Z`&d!bOwGgwx,kx#OGg#O#PH_#P#oGg#o#pET#p#qGg#q#rD_#r~GgGk&2q_&^7[&WW&R,X&ap&f#tOY$:YYZIqZ]$:Y]^Iq^r$:Yrs$;jsw$:Ywx&3px#O$:Y#O#P%!^#P#o$:Y#o#p%$x#p#q$:Y#q#r%!r#r~$:YGk&3}Z&^7[&WW&R,X&ap&f#tOrIqrs)}swIqwx&4px#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqFT&4}X&^7[&WW&S,X&ap&f#tOr!!urs?ms#O!!u#O#P!#m#P#o!!u#o#pNc#p#q!!u#q#rMm#r~!!uMg&6Pc&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr$}rs&/^sw$}wx&2dx!Q$}!Q![&+n![!c$}!c!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nMg&7qg&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr$}rs&9Ysw$}wx&<Qx!Q$}!Q![&+n![!c$}!c!t&+n!t!u&>x!u!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#f&+n#f#g&>x#g#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nGZ&9gZ&^7[&TS&Z`&d!b&`,XOr'Prs&:Ysw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PGZ&:eZ&^7[&TS&Z`&d!bOr'Prs&;Wsw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PD]&;eX&^7[&TS&e,X&Z`&d!bOwGgwx,kx#OGg#O#PH_#P#oGg#o#pET#p#qGg#q#rD_#r~GgGk&<_Z&^7[&WW&ap&f#t&Y,XOrIqrs)}swIqwx&=Qx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqGk&=]Z&^7[&WW&ap&f#tOrIqrs)}swIqwx&>Ox#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqFT&>]X&^7[&WW&c,X&ap&f#tOr!!urs?ms#O!!u#O#P!#m#P#o!!u#o#pNc#p#q!!u#q#rMm#r~!!uMg&?_c&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr$}rs&9Ysw$}wx&<Qx!Q$}!Q![&+n![!c$}!c!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nMg&APk&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr$}rs&/^sw$}wx&2dx!Q$}!Q![&+n![!c$}!c!h&+n!h!i&>x!i!t&+n!t!u&5j!u!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#U&+n#U#V&5j#V#Y&+n#Y#Z&>x#Z#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nG{&CXZ!V,X&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u&D_Z!UR&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz&Ee]%cQ&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy&FgX&TS&WW!ZGmOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#p!$g#p~:{G{&Gg]%bR&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u&HqX!Y7_&TS&WW&Z`&ap&d!b&f#tOr!$grsBssw!$gwxLRx#O!$g#O#P!%c#P#o!$g#o#p!%i#p~!$gGy&IqZ%l,V&^7[&TS&WW&Z`&ap&d!b&f#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}",
  tokenizers: [legacyPrint, indentation, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, newlines],
  topRules: { "Script": [0, 3] },
  specialized: [{ term: 213, get: (value) => spec_identifier[value] || -1 }],
  tokenPrec: 7282
});

// node_modules/@codemirror/lang-python/dist/index.js
var import_language = require("@codemirror/language");
function indentBody(context, node) {
  let base = context.lineIndent(node.from);
  let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;
  if (!/\S/.test(line.text) && context.node.to < to + 100 && !/\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base)
    return null;
  if (/^\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)
    return null;
  return base + context.unit;
}
var pythonLanguage = /* @__PURE__ */ import_language.LRLanguage.define({
  parser: /* @__PURE__ */ parser.configure({
    props: [
      /* @__PURE__ */ import_language.indentNodeProp.add({
        Body: (context) => {
          var _a;
          return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue();
        },
        IfStatement: (cx) => /^\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        TryStatement: (cx) => /^\s*(except |finally:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: "]" }),
        "String FormatString": () => null,
        Script: (context) => {
          if (context.pos + /\s*/.exec(context.textAfter)[0].length >= context.node.to) {
            let endBody = null;
            for (let cur = context.node, to = cur.to; ; ) {
              cur = cur.lastChild;
              if (!cur || cur.to != to)
                break;
              if (cur.type.name == "Body")
                endBody = cur;
            }
            if (endBody) {
              let bodyIndent = indentBody(context, endBody);
              if (bodyIndent != null)
                return bodyIndent;
            }
          }
          return context.continue();
        }
      }),
      /* @__PURE__ */ import_language.foldNodeProp.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": import_language.foldInside,
        Body: (node, state) => ({ from: node.from + 1, to: node.to - (node.to == state.doc.length ? 0 : 1) })
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "'''", '"""'] },
    commentTokens: { line: "#" },
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/
  }
});
function python() {
  return new import_language.LanguageSupport(pythonLanguage);
}

// src/settings.ts
var config2 = {
  name: "obsidian",
  dark: false,
  background: "var(--background-primary)",
  foreground: "var(--text-normal)",
  selection: "var(--text-selection)",
  cursor: "var(--text-normal)",
  activeLine: "var(--background-primary)",
  string: "var(--text-accent)",
  constant: "var(--text-accent-hover)",
  comment: "var(--text-faint)",
  invalid: "var(--text-error)"
};
var obsidianHighlightStyle = import_language2.HighlightStyle.define([
  { tag: [tags.processingInstruction, tags.string, tags.inserted, tags.special(tags.string)], color: config2.string },
  { tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)], color: config2.constant },
  { tag: tags.comment, color: config2.comment },
  { tag: tags.invalid, color: config2.invalid }
]);
var obsidianTheme = import_view2.EditorView.theme({
  "&": {
    color: config2.foreground,
    backgroundColor: config2.background
  },
  ".cm-content": { caretColor: config2.cursor },
  "&.cm-focused .cm-cursor": { borderLeftColor: config2.cursor },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, & ::selection": { backgroundColor: config2.selection },
  ".cm-activeLine": { backgroundColor: config2.activeLine },
  ".cm-activeLineGutter": { backgroundColor: config2.background },
  ".cm-selectionMatch": { backgroundColor: config2.selection },
  ".cm-gutters": {
    backgroundColor: config2.background,
    color: config2.comment,
    borderRight: "1px solid var(--background-modifier-border)"
  },
  ".cm-lineNumbers, .cm-gutterElement": { color: "inherit" }
});
var BaseProfileName = "global";
var ProfileSwitch = import_state.Annotation.define();
var DEFAULT_SETTINGS = {
  debug: false,
  convertRules: DEFAULT_RULES,
  zoneIndicatorOn: true,
  autoFormatOn: true,
  profiles: [
    { title: BaseProfileName, content: DEFAULT_RULES }
  ],
  activeProfile: BaseProfileName
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
    this.editorState = {
      selectedProfileName: BaseProfileName,
      selectedProfileEl: void 0,
      baseProfileEl: void 0,
      profilesMap: new Map(plugin.settings.profiles.map((p) => {
        return [p.title, p.content];
      })),
      editedProfile: /* @__PURE__ */ new Set()
    };
  }
  hide() {
    return __async(this, null, function* () {
      var _a;
      (_a = this.ruleEditor) == null ? void 0 : _a.destroy();
      const { selectedProfileName: target, profilesMap: map, editedProfile: set } = this.editorState;
      if (set.size > 0) {
        const newProfiles = [];
        for (const [key, value] of map) {
          newProfiles.push({ title: key, content: value });
        }
        this.plugin.settings.profiles = newProfiles;
        log("setting: save profiles");
        yield this.plugin.saveSettings();
      }
      const activeProfile = this.plugin.settings.activeProfile;
      if (target != activeProfile || set.has(BaseProfileName) || set.has(activeProfile)) {
        const newRule = target === BaseProfileName ? map.get(BaseProfileName) : map.get(BaseProfileName) + "\n" + map.get(target);
        yield this.plugin.configureProfile(target, newRule);
      }
    });
  }
  display() {
    const { containerEl, plugin } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Typing Transformer Settings" });
    new import_obsidian.Setting(containerEl).setName("Auto Format").setDesc("Enable the auto insertion of spaces.").addToggle(
      (comp) => comp.setValue(plugin.settings.autoFormatOn).onChange((_val) => __async(this, null, function* () {
        return yield plugin.toggleAutoFormat();
      }))
    );
    new import_obsidian.Setting(containerEl).setName("Zone Indicator").setDesc("Enable indication of a zone's start point with '\u2B50\uFE0F'").addToggle(
      (comp) => comp.setValue(plugin.settings.zoneIndicatorOn).onChange((_val) => __async(this, null, function* () {
        return yield plugin.toggleIndicator();
      }))
    );
    this.ruleEditor = createRuleEditorInContainer(containerEl, plugin, this.editorState);
  }
};
function createRuleEditorInContainer(container, plugin, state) {
  const fragment = document.createDocumentFragment();
  fragment.createEl("span", { text: "Enter conversion, selection, and deletion rules here. NOTES:" });
  const ol = fragment.createEl("ol");
  ol.createEl("li", { text: "Each line is one rule. Rules that come first have higher priority." });
  ol.createEl("li", { text: 'Lines starting with "#" are treated as comments and ignored. Inline comments are also allowed' });
  ol.createEl("li", { text: "Certain characters ' | \\ must be escaped with backslashes \\." });
  ol.createEl("li", { text: "Whatever tab you are on when the plugin settings tab quits will be the profile that is chosen" });
  ol.createEl("li", { text: "The 'global' profile will always be active" });
  const convertRulesSetting = new import_obsidian.Setting(container).setName("Rules").setDesc(fragment).setClass("rules-text-area");
  const profilesContainer = convertRulesSetting.controlEl.createDiv("rules-profiles");
  const customCSSWrapper = convertRulesSetting.controlEl.createDiv("rules-editor-wrapper");
  const rulesFooter = convertRulesSetting.controlEl.createDiv("rules-footer");
  const validity = rulesFooter.createDiv("rules-editor-validity");
  const validityIndicator = new import_obsidian.ExtraButtonComponent(validity);
  validityIndicator.setIcon("checkmark").extraSettingsEl.addClass("rules-editor-validity-indicator");
  const validityText = validity.createDiv("rules-editor-validity-text");
  validityText.classList.add("setting-item-description", "rules-editor-validity-txt");
  function resetValidityIndicator() {
    validityIndicator.setIcon("");
    validityIndicator.extraSettingsEl.removeClasses(["invalid", "valid"]);
    validityText.setText("");
  }
  function tryResetValidityIndicator() {
    return __async(this, null, function* () {
      if (validityIndicator.extraSettingsEl.hasClass("invalid")) {
        return new Promise((resolve, _reject) => {
          new ConfirmationModal(
            app,
            "Are you sure you want to discard changes?",
            (ans) => __async(this, null, function* () {
              if (ans)
                resetValidityIndicator();
              resolve(ans);
            })
          ).open();
        });
      } else {
        resetValidityIndicator();
        return new Promise((resolve, _reject) => resolve(true));
      }
    });
  }
  function updateValidityIndicator(success, errs) {
    validityIndicator.setIcon(success ? "checkmark" : "cross");
    validityIndicator.extraSettingsEl.removeClass(success ? "invalid" : "valid");
    validityIndicator.extraSettingsEl.addClass(success ? "valid" : "invalid");
    const fragment2 = document.createDocumentFragment();
    for (const err of errs) {
      fragment2.createEl("div", { text: err });
    }
    validityText.setText(success ? "Saved" : fragment2);
  }
  const extensions = [
    obsidianTheme,
    (0, import_view2.lineNumbers)(),
    import_view2.EditorView.lineWrapping,
    python(),
    (0, import_language2.syntaxHighlighting)(obsidianHighlightStyle),
    import_view2.EditorView.updateListener.of((v) => __async(this, null, function* () {
      if (v.docChanged) {
        if (v.transactions.reduce((swtich, tr) => swtich || tr.annotation(ProfileSwitch), false)) {
          return;
        }
        const value = v.state.doc.toString();
        yield feedRules(value);
      }
    }))
  ];
  const feedRules = (newRule) => __async(this, null, function* () {
    const errs = plugin.checkRules(newRule);
    if (errs.length != 0) {
      updateValidityIndicator(false, errs);
    } else {
      updateValidityIndicator(true, []);
      const { selectedProfileName: target, profilesMap: map, editedProfile: set } = state;
      map.set(target, newRule);
      set.add(target);
    }
  });
  const setCMEditorContent = (text) => {
    convertRulesEditor.dispatch({
      changes: { from: 0, to: convertRulesEditor.state.doc.length, insert: text },
      annotations: ProfileSwitch.of(true)
    });
  };
  const convertRulesEditor = new import_view2.EditorView({
    state: import_state.EditorState.create({ doc: plugin.settings.convertRules, extensions })
  });
  customCSSWrapper.appendChild(convertRulesEditor.dom);
  const buttonsDiv = rulesFooter.createDiv("rules-editor-buttons");
  const reset = new import_obsidian.ButtonComponent(buttonsDiv);
  reset.setIcon("switch").setTooltip("Reset to default rules").onClick(() => __async(this, null, function* () {
    convertRulesEditor.setState(import_state.EditorState.create({ doc: DEFAULT_RULES, extensions }));
    yield feedRules(DEFAULT_RULES);
  }));
  const onProfileClick = (name2, el) => __async(this, null, function* () {
    var _a;
    if (!(yield tryResetValidityIndicator()))
      return;
    (_a = state.selectedProfileEl) == null ? void 0 : _a.removeClass("selected");
    el == null ? void 0 : el.addClass("selected");
    state.selectedProfileEl = el;
    state.selectedProfileName = name2;
    setCMEditorContent(state.profilesMap.get(name2));
  });
  const onRemoveProfileClick = (name2, el) => {
    if (el === state.selectedProfileEl)
      onProfileClick(BaseProfileName, state.baseProfileEl);
    state.profilesMap.delete(name2);
    state.editedProfile.add(name2);
    profilesContainer.removeChild(el);
  };
  const addProfile = (profile, selected) => {
    const button = new import_obsidian.ExtraButtonComponent(profilesContainer);
    const el = button.extraSettingsEl;
    el.accessKey = profile.title;
    button.onClick(() => onProfileClick(profile.title, el));
    el.addClass("rules-profile-button");
    el.setText(profile.title);
    if (profile.title != BaseProfileName) {
      const closeEl = new import_obsidian.ExtraButtonComponent(el).setIcon("cross").extraSettingsEl;
      closeEl.onClickEvent((ev) => {
        ev.stopPropagation();
        onRemoveProfileClick(profile.title, el);
      });
      closeEl.addClass("rules-profile-close");
    } else {
      state.baseProfileEl = el;
    }
    if (selected) {
      onProfileClick(profile.title, el);
    }
  };
  for (const profile of plugin.settings.profiles) {
    addProfile(profile, profile.title === plugin.settings.activeProfile);
  }
  const addButton = new import_obsidian.ExtraButtonComponent(profilesContainer).onClick(() => {
    if (state.profilesMap.size > 5) {
      new import_obsidian.Notice("You can only have 6 profiles at most.");
      return;
    }
    new StringInputModal(app, (value) => {
      if (state.profilesMap.has(value))
        return false;
      if (value === void 0)
        return true;
      state.profilesMap.set(value, "");
      state.editedProfile.add(value);
      profilesContainer.removeChild(addButton.extraSettingsEl);
      addProfile({ title: value, content: "" }, true);
      profilesContainer.appendChild(addButton.extraSettingsEl);
      return true;
    }).open();
  });
  addButton.extraSettingsEl.addClass("rules-profile-button");
  addButton.extraSettingsEl.setText("+");
  return convertRulesEditor;
}
var StringInputModal = class extends import_obsidian.Modal {
  constructor(app2, onSubmit) {
    super(app2);
    this.submitEnterCallback = (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        this.submit();
      }
    };
    this.onSubmit = onSubmit;
  }
  submit() {
    if (this.onSubmit(this.result))
      this.close();
    else
      this.err.setText("Profile already exists!");
  }
  onOpen() {
    const { titleEl, contentEl } = this;
    titleEl.setText("Profile Name");
    const container = contentEl.createDiv();
    const textComponent = new import_obsidian.TextComponent(container);
    this.err = container.createEl("p");
    textComponent.inputEl.style.width = "100%";
    textComponent.onChange((value) => this.result = value).inputEl.addEventListener("keydown", this.submitEnterCallback);
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Submit").setCta().onClick(() => this.submit()));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var ConfirmationModal = class extends import_obsidian.Modal {
  constructor(app2, prompt, conformCb) {
    super(app2);
    this.contentEl.createEl("p", { text: prompt });
    new import_obsidian.Setting(this.contentEl).addButton(
      (button) => button.setButtonText("Conform").onClick(() => __async(this, null, function* () {
        yield conformCb(true);
        this.close();
      }))
    ).addButton(
      (button) => button.setButtonText("Cancel").onClick(() => __async(this, null, function* () {
        yield conformCb(false);
        this.close();
      }))
    );
  }
};

// src/global_commands.ts
var import_obsidian2 = require("obsidian");
function getAllCommands(plugin) {
  const format = {
    id: "typing-trans-toggle-format",
    name: "Toggle Auto Formatting",
    editorCallback: (_e, _v) => __async(this, null, function* () {
      return yield plugin.toggleAutoFormat();
    })
  };
  const zone = {
    id: "typing-trans-toggle-zone-indicator",
    name: "Toggle Auto Formatting Zone Indicator",
    editorCallback: (_e, _v) => __async(this, null, function* () {
      return yield plugin.toggleIndicator();
    })
  };
  const ret = [format, zone];
  const useProfileX = (i) => __async(this, null, function* () {
    const profs = plugin.settings.profiles;
    if (i >= profs.length) {
      new import_obsidian2.Notice(`Profile ${i} doesn't exist`);
      return;
    }
    const { title, content: content2 } = profs[i];
    if (plugin.settings.activeProfile === title)
      return;
    const newRule = title === BaseProfileName ? content2 : profs[0].content + "\n" + content2;
    plugin.configureProfile(title, newRule);
  });
  for (let i = 0; i < 6; i++) {
    const useProfileCommand = {
      id: "typing-trans-p" + i.toString(),
      name: "apply profile " + i.toString() + (i === 0 ? " (global)" : ""),
      editorCallback: (_e, _v) => __async(this, null, function* () {
        yield useProfileX(i);
      })
    };
    ret.push(useProfileCommand);
  }
  return ret;
}

// src/main.ts
var ProgramTxn = import_state2.Annotation.define();
var deubgExt = import_state2.StateField.define({
  create: (_state) => {
    return 0;
  },
  update: (value, tr) => {
    if (tr.docChanged) {
      tr.changes.iterChanges((a, b, c, d, insert) => {
        console.log(a, b, c, d, insert.sliceString(0));
      });
    }
    return value;
  }
});
var TypingTransformer = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.configureProfile = (title, ruleString) => __async(this, null, function* () {
      this.settings.activeProfile = title;
      this.settings.convertRules = ruleString;
      this.configureRules(ruleString);
      this.updateProfileStatus();
      yield this.saveSettings();
    });
    this.configureRules = (ruleString) => {
      this.rules = new Rules(ruleString);
    };
    this.checkRules = (ruleString) => {
      return new Rules(ruleString, true).errors;
    };
    this.configureActiveExtsFromSettings = () => {
      const activeIds = [1 /* Conversion */, 0 /* SideInsert */];
      const { debug, zoneIndicatorOn, autoFormatOn } = this.settings;
      debug ? activeIds.push(4 /* Debug */) : null;
      zoneIndicatorOn ? activeIds.push(2 /* ZoneIndicator */) : null;
      autoFormatOn ? activeIds.push(3 /* AutoFormat */) : null;
      this.activeExts.forEach((_ext, idx) => this.activeExts[idx] = []);
      activeIds.forEach((extid) => this.activeExts[extid] = this.availablExts[extid]);
    };
    this.toggleAutoFormat = () => __async(this, null, function* () {
      this.settings.autoFormatOn = !this.settings.autoFormatOn;
      yield this.saveAndReloadPlugin();
    });
    this.toggleIndicator = () => __async(this, null, function* () {
      this.settings.zoneIndicatorOn = !this.settings.zoneIndicatorOn;
      yield this.saveAndReloadPlugin();
    });
    this.saveAndReloadPlugin = () => __async(this, null, function* () {
      yield this.saveSettings();
      this.configureActiveExtsFromSettings();
      this.app.workspace.updateOptions();
    });
    this.spotLibertyZone = ({ view, docChanged }) => {
      if (!docChanged) {
        return;
      }
      const state = view.state;
      const mainSel = state.selection.asSingle().main;
      if (mainSel.anchor != mainSel.head) {
        return;
      }
      const line = state.doc.lineAt(mainSel.anchor);
      const from = line.from;
      const to = mainSel.anchor;
      if (from == to) {
        return;
      }
      for (const pos of this.specialSections) {
        if (pos.start.line <= line.number - 1 && line.number - 1 <= pos.end.line) {
          return;
        }
      }
      const checkInBlock = (blocks2, offset) => {
        for (let i = blocks2.length - 2; i > -1; i -= 2) {
          if (blocks2[i] < offset && offset <= blocks2[i + 1]) {
            return { exist: true, from: blocks2[i], to: blocks2[i + 1] };
          }
        }
        return { exist: false, from: 0, to: 0 };
      };
      const blocks = getBlockRanges(line.text, to - from);
      const r = checkInBlock(blocks.emphasis, to - from);
      if (r.exist) {
        const txt2 = state.sliceDoc(from + r.from, from + r.to);
        let i;
        for (i = 0; txt2[i] == txt2[0] && i < r.to; i++) {
          log("format: skip emphasis head", i, txt2[i]);
        }
        return { from: from + r.from + i, to };
      }
      const spBlocks = blocks.special;
      if (checkInBlock(spBlocks, to - from).exist) {
        return;
      }
      const txt = state.sliceDoc(from, to);
      for (let i = txt.length - 2; i > 0; i--) {
        const ch = txt[i];
        if (ch != " " && PUNCTS.has(ch) && !checkInBlock(spBlocks, i).exist) {
          return { from: from + i, to };
        }
      }
      return { from, to };
    };
    this.addLiberty = (update) => {
      const range = this.spotLibertyZone(update);
      if (range === void 0 || !update.selectionSet) {
        return;
      }
      const from = range.from, to = range.to;
      const toUpdate = update.view.state.doc.sliceString(from, to);
      if (PUNCTS.has(toUpdate.charAt(toUpdate.length - 1))) {
        const trimmed = toUpdate.trim();
        if (trimmed === "") {
          return;
        }
        const lspace = toUpdate.length - toUpdate.trimStart().length;
        const rspace = toUpdate.length - toUpdate.trimEnd().length;
        log(
          "foramt: trigger char: %s, toUpdate: %s, lspace: %d, rspace: %d",
          toUpdate.charAt(toUpdate.length - 1),
          toUpdate,
          lspace,
          rspace
        );
        update.view.dispatch({ changes: { from: from + lspace, to: to - rspace, insert: formatLine(trimmed) }, annotations: ProgramTxn.of(true) });
      }
    };
    this.convertFilter = (tr) => {
      if (!tr.docChanged || tr.annotation(ProgramTxn)) {
        return tr;
      }
      let shouldHijack = true;
      const changes = [];
      tr.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
        if (!shouldHijack) {
          return;
        }
        const { insertTrigSet, deleteTrigSet, lmax, rmax } = this.rules;
        let char;
        if (fromA === toA && fromB + 1 === toB) {
          char = inserted.sliceString(0);
          if (!insertTrigSet.has(char)) {
            shouldHijack = false;
          }
        } else if (fromA + 1 === toA && fromB === toB) {
          const delChar = tr.startState.sliceDoc(fromA, toA);
          if (!deleteTrigSet.has(delChar)) {
            shouldHijack = false;
          }
          char = DEL_TRIG;
          fromA = toA;
          fromB += 1;
          toB = fromB + 1;
        } else {
          shouldHijack = false;
        }
        if (!shouldHijack) {
          return;
        }
        let leftIdx = fromB - lmax;
        let insertPosFromLineHead = lmax;
        if (leftIdx < 0) {
          insertPosFromLineHead = lmax + leftIdx;
          leftIdx = 0;
        }
        const input = tr.startState.sliceDoc(leftIdx, fromB + rmax);
        const rule = this.rules.match(input, char, insertPosFromLineHead);
        if (rule != null) {
          log("hit covert rule: %s", rule.left.join(""));
          const change = rule.mapToChanges(fromB);
          change.annotations = ProgramTxn.of(true);
          changes.push(change);
        } else {
          shouldHijack = false;
        }
      });
      if (shouldHijack) {
        tr = tr.startState.update(...changes);
      }
      return tr;
    };
    this.sidesInsertFilter = (tr) => {
      if (!tr.docChanged || tr.annotation(ProgramTxn)) {
        return tr;
      }
      let shouldHijack = true;
      const changes = [];
      tr.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
        const char = inserted.sliceString(0);
        if (!shouldHijack || fromA == toA || toB != fromB + 1 || !this.rules.sideInsertMap.has(char)) {
          shouldHijack = false;
          return;
        }
        const insert = this.rules.sideInsertMap.get(char);
        changes.push({ changes: { from: fromA, insert: insert.l }, annotations: ProgramTxn.of(true) });
        changes.push({ changes: { from: toA, insert: insert.r }, annotations: ProgramTxn.of(true) });
      });
      if (shouldHijack) {
        tr = tr.startState.update(...changes);
      }
      return tr;
    };
    this.updateProfileStatus = () => {
      this.profileStatus.setText(`Active Profile: ${this.settings.activeProfile}`);
    };
  }
  onload() {
    return __async(this, null, function* () {
      console.log("loading typing transformer plugin");
      yield this.loadSettings();
      initLog(this.settings);
      yield charliberty_default(charliberty_bg_default);
      this.specialSections = [];
      this.activeExts = [];
      this.availablExts = [
        import_state2.EditorState.transactionFilter.of(this.sidesInsertFilter),
        import_state2.EditorState.transactionFilter.of(this.convertFilter),
        libertyZone(this.spotLibertyZone),
        import_view3.EditorView.updateListener.of(this.addLiberty),
        deubgExt
      ];
      this.availablExts.forEach((_, idx) => this.activeExts[idx] = []);
      this.configureRules(this.settings.convertRules);
      this.configureActiveExtsFromSettings();
      this.registerEditorExtension(this.activeExts);
      this.registerEvent(this.app.metadataCache.on("changed", (_f, _d, meta2) => {
        var _a;
        this.specialSections.length = 0;
        (_a = meta2.sections) == null ? void 0 : _a.forEach((sec) => {
          if (sec.type == "code" || sec.type == "match") {
            this.specialSections.push(sec.position);
          }
        });
      }));
      this.addSettingTab(new SettingTab(this.app, this));
      for (const cmd of getAllCommands(this)) {
        this.addCommand(cmd);
      }
      this.profileStatus = this.addStatusBarItem();
      this.updateProfileStatus();
    });
  }
  onunload() {
    console.log("unloading typing transformer plugin");
  }
  loadSettings() {
    return __async(this, null, function* () {
      const data = yield this.loadData();
      let defaultSource = DEFAULT_SETTINGS;
      if (data && !data.hasOwnProperty("profiles") && data.convertRules != DEFAULT_SETTINGS.convertRules) {
        const cloned = structuredClone(DEFAULT_SETTINGS);
        cloned.profiles[0].content = data.convertRules;
        defaultSource = cloned;
      }
      this.settings = Object.assign({}, defaultSource, data);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
