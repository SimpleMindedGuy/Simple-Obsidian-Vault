/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CrossbowPlugin
});
module.exports = __toCommonJS(main_exports);

// src/view/view.ts
var import_obsidian3 = require("obsidian");

// src/controllers/viewController.ts
var import_obsidian2 = require("obsidian");

// src/services/loggingService.ts
var _CrossbowLoggingService = class {
  constructor(settingsService) {
    this.settingsService = settingsService;
  }
  debugLog(message) {
    this.settingsService.getSettings().useLogging && console.log(_CrossbowLoggingService.LOGGER_PREFIX + message);
  }
  debugWarn(message) {
    this.settingsService.getSettings().useLogging && console.warn(_CrossbowLoggingService.LOGGER_PREFIX + message);
  }
  static forceLog(type, message) {
    console[type](_CrossbowLoggingService.LOGGER_PREFIX + message);
  }
};
var CrossbowLoggingService = _CrossbowLoggingService;
CrossbowLoggingService.LOGGER_PREFIX = "\u{1F3F9}: ";

// src/view/treeItem.ts
var import_obsidian = require("obsidian");
var registerTreeItemElements = () => {
  TreeItem.register();
  TreeItemLeaf.register();
};
var TreeItemLeaf = class extends HTMLElement {
  constructor(value) {
    super();
    this.buttons = [];
    this.value = value;
    this.addClass("tree-item");
    this.mainWrapper = this.createDiv({
      cls: "tree-item-self is-clickable"
    });
    this.inner = this.mainWrapper.createDiv({
      cls: "tree-item-inner cb-tree-item-inner-extensions",
      text: this.text
    });
    this.flairWrapper = this.mainWrapper.createDiv({
      cls: "tree-item-flair-outer"
    });
    this.suffix = this.inner.createEl("span", {
      cls: "cb-tree-item-inner-suffix"
    });
    this.flair = this.flairWrapper.createEl("span", {
      cls: "tree-item-flair"
    });
  }
  get hash() {
    return this.value.hash;
  }
  get text() {
    return this.value.text;
  }
  static register() {
    customElements.define("crossbow-tree-item-leaf", TreeItemLeaf);
  }
  setDisable() {
    this.mainWrapper.style.textDecoration = "line-through";
    this.buttons.forEach((button) => button.setDisabled(true));
  }
  addOnClick(listener) {
    this.mainWrapper.addEventListener("click", listener);
  }
  addFlair(text) {
    this.flair.innerText = text;
  }
  addTextSuffix(text) {
    this.suffix.innerText = text;
  }
  addButton(label, iconName, onclick) {
    const button = new import_obsidian.ButtonComponent(this.mainWrapper);
    button.setTooltip(label);
    button.setIcon(iconName);
    button.setClass("cb-tree-item-button");
    button.onClick(onclick);
    this.buttons.push(button);
  }
};
var TreeItem = class extends TreeItemLeaf {
  constructor(value, childrenFactory) {
    super(value);
    this.childrenFactory = null;
    this.childrenFactory = childrenFactory;
    this.addClass("is-collapsed");
    this.mainWrapper.addClass("mod-collapsible");
    this.childrenWrapper = this.createDiv({ cls: "tree-item-children" });
    this.childrenWrapper.style.display = "none";
    this.iconWrapper = this.createDiv({
      cls: ["tree-item-icon", "collapse-icon"]
    });
    this.iconWrapper.appendChild((0, import_obsidian.getIcon)("right-triangle"));
    this.appendChild(this.childrenWrapper);
    this.mainWrapper.prepend(this.iconWrapper);
    this.mainWrapper.addEventListener("click", () => this.isCollapsed() ? this.expand() : this.collapse());
  }
  static register() {
    customElements.define("crossbow-tree-item", TreeItem);
  }
  isCollapsed() {
    return this.hasClass("is-collapsed");
  }
  expand() {
    if (this.childrenFactory) {
      this.addTreeItems(this.childrenFactory(this));
      this.childrenFactory = null;
    }
    this.removeClass("is-collapsed");
    this.childrenWrapper.style.display = "block";
  }
  collapse() {
    this.addClass("is-collapsed");
    this.childrenWrapper.style.display = "none";
  }
  setDisable() {
    super.setDisable();
    this.mainWrapper.style.textDecoration = "line-through";
    this.buttons.forEach((button) => button.disabled = true);
    this.getTreeItems().forEach((child) => child.setDisable());
  }
  addTreeItems(children) {
    this.childrenWrapper.replaceChildren(...children);
  }
  getTreeItems() {
    return Array.from(this.childrenWrapper.children);
  }
};

// src/controllers/viewController.ts
var _CrossbowViewController = class {
  constructor(settingsService) {
    this.settingsService = settingsService;
  }
  async revealOrCreateView() {
    const existing = app.workspace.getLeavesOfType(CrossbowView.viewType);
    if (existing.length) {
      app.workspace.revealLeaf(existing[0]);
      return;
    }
    await app.workspace.getRightLeaf(false).setViewState({
      type: CrossbowView.viewType,
      active: true
    });
    app.workspace.revealLeaf(app.workspace.getLeavesOfType(CrossbowView.viewType)[0]);
  }
  doesCrossbowViewExist() {
    return app.workspace.getLeavesOfType(CrossbowView.viewType).length > 0;
  }
  unloadView() {
    var _a;
    (_a = this.getCrossbowView()) == null ? void 0 : _a.unload();
  }
  getCrossbowView() {
    var _a;
    return (_a = app.workspace.getLeavesOfType(CrossbowView.viewType)[0]) == null ? void 0 : _a.view;
  }
  addOrUpdateSuggestions(suggestions, targetEditor, fileHasChanged) {
    const view = this.getCrossbowView();
    if (!view)
      return;
    if (fileHasChanged)
      view.clear();
    const showManualRefreshButton = !this.settingsService.getSettings().useAutoRefresh;
    view.update(suggestions, targetEditor, showManualRefreshButton);
  }
  static createManualRefreshButton(parentEl, onClick) {
    const button = new import_obsidian2.ButtonComponent(parentEl);
    button.buttonEl.id = _CrossbowViewController.MANUAL_REFRESH_BUTTON_ID;
    button.setTooltip("Refresh suggestions");
    button.setIcon("lucide-rotate-cw");
    button.setClass("cb-tree-item-button");
    button.onClick(onClick);
    return button;
  }
  static createSuggestionTreeItem(suggestion, targetEditor) {
    const lazySuggestionChildrenBuilder = () => _CrossbowViewController.createOccurrenceTreeItems(suggestion, targetEditor);
    const suggestionTreeItem = new TreeItem(suggestion, lazySuggestionChildrenBuilder);
    const ranks = /* @__PURE__ */ new Set();
    suggestion.matches.forEach((match) => ranks.add(match.cacheMatch.rank));
    const availableMatchRanks = Array.from(ranks).sort((a, b) => a.codePointAt(0) - b.codePointAt(0)).join("");
    suggestionTreeItem.addFlair(availableMatchRanks);
    suggestionTreeItem.addTextSuffix(`(${suggestion.occurrences.length.toString()})`);
    return suggestionTreeItem;
  }
  static createOccurrenceTreeItems(suggestion, targetEditor) {
    return suggestion.occurrences.map((occurrence) => {
      const occurrenceEnd = {
        ch: occurrence.editorPosition.ch + suggestion.word.length,
        line: occurrence.editorPosition.line
      };
      const lazyOccurrenceChildrenBuilder = (self) => _CrossbowViewController.createMatchTreeItems(suggestion.word, self, occurrenceEnd, targetEditor);
      const occurrenceTreeItem = new TreeItem(occurrence, lazyOccurrenceChildrenBuilder);
      const scrollIntoView = () => {
        targetEditor.setSelection(occurrence.editorPosition, occurrenceEnd);
        targetEditor.scrollIntoView({ from: occurrence.editorPosition, to: occurrenceEnd }, true);
      };
      occurrenceTreeItem.addButton("Scroll into View", "lucide-scroll" /* Scroll */, (ev) => {
        scrollIntoView();
        ev.preventDefault();
        ev.stopPropagation();
      });
      occurrenceTreeItem.addOnClick(() => {
        if (!occurrenceTreeItem.isCollapsed())
          scrollIntoView();
      });
      return occurrenceTreeItem;
    });
  }
  static createMatchTreeItems(word, occurrenceTreeItem, occurrenceEnd, targetEditor) {
    return occurrenceTreeItem.value.matches.map((match) => {
      const matchTreeItem = new TreeItemLeaf(match);
      const link = match.cacheMatch.item ? app.fileManager.generateMarkdownLink(match.cacheMatch.file, match.cacheMatch.text, "#" + match.cacheMatch.text, word) : app.fileManager.generateMarkdownLink(match.cacheMatch.file, match.cacheMatch.text, void 0, word);
      matchTreeItem.addButton("Use", "lucide-inspect" /* Inspect */, () => {
        occurrenceTreeItem.setDisable();
        targetEditor.replaceRange(link, occurrenceTreeItem.value.editorPosition, occurrenceEnd);
      });
      matchTreeItem.addButton("Go To Source", "lucide-search" /* Search */, () => {
        const leaf = app.workspace.getLeaf(true);
        app.workspace.setActiveLeaf(leaf);
        leaf.openFile(match.cacheMatch.file).then(() => {
          var _a;
          if (leaf.view instanceof import_obsidian2.MarkdownView) {
            if ((_a = match.cacheMatch.item) == null ? void 0 : _a.position) {
              const { line, col } = match.cacheMatch.item.position.start;
              leaf.view.editor.setCursor(line, col);
            }
          } else {
            CrossbowLoggingService.forceLog("warn", "Could not go to source, not a markdown file");
          }
        });
      });
      matchTreeItem.addTextSuffix(match.cacheMatch.type);
      return matchTreeItem;
    });
  }
};
var CrossbowViewController = _CrossbowViewController;
CrossbowViewController.MANUAL_REFRESH_BUTTON_ID = "cb-refresh-button";

// src/view/view.ts
var _CrossbowView = class extends import_obsidian3.ItemView {
  constructor(leaf, onManualRefreshButtonClick) {
    super(leaf);
    this.onManualRefreshButtonClick = onManualRefreshButtonClick;
    this.controlsEl = this.contentEl.createDiv({ cls: "cb-view-controls" });
    this.treeEl = this.contentEl.createDiv({ cls: "cb-view-tree" });
    CrossbowViewController.createManualRefreshButton(this.controlsEl, this.onManualRefreshButtonClick);
    this.treeEl.createSpan({ text: "Open a note to run crossbow", cls: "cb-view-empty" });
  }
  getViewType() {
    return _CrossbowView.viewType;
  }
  getDisplayText() {
    return "Crossbow";
  }
  getIcon() {
    return "crossbow";
  }
  load() {
    super.load();
    this.navigation = false;
  }
  clear() {
    this.treeEl.empty();
  }
  update(suggestions, targetEditor, showManualRefreshButton) {
    showManualRefreshButton ? this.getManualRefreshButton().show() : this.getManualRefreshButton().hide();
    this.addOrUpdateSuggestions(suggestions, targetEditor);
  }
  addOrUpdateSuggestions(suggestions, targetEditor) {
    const currentSuggestionTreeItems = this.getCurrentSuggestions();
    suggestions.forEach((suggestion) => {
      const index = currentSuggestionTreeItems.findIndex((item) => item.hash === suggestion.hash);
      const existingSuggestion = index !== -1 ? currentSuggestionTreeItems.splice(index, 1)[0] : void 0;
      const suggestionTreeItem = CrossbowViewController.createSuggestionTreeItem(suggestion, targetEditor);
      if (existingSuggestion) {
        const expandedOccurrencesHashes = existingSuggestion.getTreeItems().filter((item) => !item.isCollapsed()).map((item) => item.hash);
        suggestionTreeItem.getTreeItems().forEach((occurrence) => {
          if (expandedOccurrencesHashes.includes(occurrence.hash)) {
            occurrence.expand();
          }
        });
        this.treeEl.insertAfter(suggestionTreeItem, existingSuggestion);
        existingSuggestion.isCollapsed() ? suggestionTreeItem.collapse() : suggestionTreeItem.expand();
        existingSuggestion.remove();
      } else {
        const index2 = currentSuggestionTreeItems.findIndex((item) => suggestion.hash.localeCompare(item.hash) < 0);
        if (index2 === -1) {
          this.treeEl.appendChild(suggestionTreeItem);
        } else {
          this.treeEl.insertBefore(suggestionTreeItem, currentSuggestionTreeItems[index2]);
        }
      }
    });
    currentSuggestionTreeItems.forEach((item) => item.remove());
  }
  getManualRefreshButton() {
    return this.controlsEl.querySelector("#" + CrossbowViewController.MANUAL_REFRESH_BUTTON_ID);
  }
  getCurrentSuggestions() {
    return this.treeEl.children.length > 0 ? Array.from(this.treeEl.children) : [];
  }
};
var CrossbowView = _CrossbowView;
CrossbowView.viewType = "crossbow-toolbar";

// src/icons.ts
var import_obsidian4 = require("obsidian");
var crossbowIcon = {
  name: "crossbow",
  svg: `
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.002 512.002" xmlns:v="https://vecta.io/nano" fill="currentColor">
    <path d="M505.753 354.901l-15.083-15.083c-19.702-19.702-49.044-23.859-72.839-12.5l-43.878-43.878-13.906-208.61 23.327-23.327c8.331-8.331 8.331-21.839 0-30.17s-21.839-8.331-30.17 0l-30.165 30.165c-16.716 16.716-68.646 36.398-92.869 41.533-11.745 2.518-23.28 6.645-34.556 12.071l-53.605-53.605c-8.332-8.332-21.842-8.331-30.173.003l-15.08 15.086-23.91-23.91h8.819c11.782 0 21.333-9.551 21.333-21.333S93.447.01 81.665.01H21.513a21.41 21.41 0 0 0-4.441.428c-.103.021-.201.052-.304.074-.578.126-1.152.268-1.72.442-.134.041-.263.094-.395.138-.528.174-1.054.358-1.57.575-.12.05-.234.111-.353.164-.517.228-1.029.467-1.53.737-.091.049-.177.107-.268.158-.511.285-1.017.584-1.509.916-.061.041-.116.088-.177.13-1.052.726-2.061 1.54-2.996 2.476-.885.885-1.655 1.838-2.351 2.826-.09.127-.189.245-.275.374-.281.418-.53.849-.779 1.282-.099.172-.208.336-.302.511-.218.406-.407.822-.597 1.238-.101.221-.212.435-.306.66-.161.389-.295.785-.432 1.18-.093.266-.197.527-.279.798-.117.384-.204.773-.299 1.162-.071.291-.154.577-.213.872-.086.431-.14.866-.199 1.301-.035.258-.086.511-.111.771-.07.703-.107 1.409-.107 2.114v60.335c0 11.782 9.551 21.333 21.333 21.333s21.333-9.551 21.333-21.333v-8.836L66.591 96.76l-15.086 15.091c-8.329 8.332-8.327 21.838.003 30.168l53.066 53.062c-4.78 9.663-8.35 19.301-10.444 28.877a92.9 92.9 0 0 0-1.378 7.89c-1.967 15.328-24.484 74.421-41.245 91.182l-30.165 30.165c-8.331 8.331-8.331 21.839 0 30.17s21.839 8.331 30.17 0l23.318-23.318 208.628 13.906 43.863 43.86c-11.366 23.793-7.209 53.155 12.495 72.859l15.083 15.083c8.331 8.331 21.839 8.331 30.17 0l120.683-120.683c8.332-8.332 8.332-21.84.001-30.171zM158.582 188.747c2.639-3.559 5.336-6.989 8.038-10.208 2.747-3.272 4.819-5.561 5.868-6.653.571-.543 2.88-2.632 6.269-5.428 3.156-2.604 6.54-5.211 10.105-7.768l148.811 148.811.018.018 47.378 47.378-30.161 30.161-196.326-196.311zm80.484-53.987c7.095-1.504 28.104-7.881 46.173-14.729 12.532-4.75 23.942-9.708 34.064-14.941l8.834 132.535-99.868-99.868c3.626-1.223 7.23-2.232 10.797-2.997zm-127.433-22.707c.072-.07.15-.129.221-.2s.131-.151.202-.223l14.871-14.876 31.395 31.395c-6.755 5.127-12.201 9.867-16.113 13.686-4.056 4.209-8.919 9.76-14.107 16.434L96.761 126.93l14.872-14.877zm-6.789 207.232c15.579-29.378 28.148-65.788 30.226-81.986.174-1.348.423-2.765.743-4.228a64.51 64.51 0 0 1 1.427-5.328l100.401 100.394-132.797-8.852zm265.141 141.214c-8.315-8.317-8.325-21.807-.035-30.139.015-.015.032-.028.047-.043l60.331-60.331c.013-.013.024-.028.037-.041a21.35 21.35 0 0 1 30.132.041l-90.512 90.513z"/>
  </svg>
  `
};
var registerCrossbowIcons = () => {
  (0, import_obsidian4.addIcon)(crossbowIcon.name, crossbowIcon.svg);
};

// src/main.ts
var import_obsidian6 = require("obsidian");

// src/settings.ts
var import_obsidian5 = require("obsidian");
var CrossbowSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app2, plugin, settingsService) {
    super(app2, plugin);
    this.settingsService = settingsService;
    this.updateSettingValue = async (key, value) => {
      const settings = this.settingsService.getSettings();
      settings[key] = value;
      await this.settingsService.saveSettings(settings);
    };
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Crossbow Settings \u{1F3F9}" });
    this.addIndexingSettings(containerEl);
    this.addSuggestionsSettings(containerEl);
    this.addAutoRefreshSettings(containerEl);
    this.addLoggingSettings(containerEl);
  }
  addIndexingSettings(containerEl) {
    containerEl.createEl("h3", { text: "Indexing" });
    new import_obsidian5.Setting(containerEl).setName("Ignored Words").setDesc("A case-sensitive, comma separated list of words to ignore when searching for items (Headers, tags). (Whitepaces will be trimmed)").addTextArea((textArea) => {
      var _a, _b;
      textArea.setValue((_b = (_a = this.settingsService.getSettings().ignoredWordsCaseSensisitve) == null ? void 0 : _a.join(", ")) != null ? _b : "").onChange(async (value) => await this.updateSettingValue("ignoredWordsCaseSensisitve", value.split(",").map((word) => word.trim())));
      textArea.inputEl.setAttr("style", "height: 10vh; width: 25vw;");
    });
  }
  addSuggestionsSettings(containerEl) {
    containerEl.createEl("h3", { text: "Suggestions" });
    new import_obsidian5.Setting(containerEl).setName("Ignore occurrences which start with a lowercase letter").setDesc("If checked, occurrences (Words in the active editor) which start with a lowercase letter will be ignored").addToggle((toggle) => toggle.setValue(this.settingsService.getSettings().ignoreOccurrencesWhichStartWithLowercaseLetter).onChange(async (value) => await this.updateSettingValue("ignoreOccurrencesWhichStartWithLowercaseLetter", value)));
    new import_obsidian5.Setting(containerEl).setName("Ignore suggestions which start with a lowercase letter").setDesc("If checked, suggestions which start with a lowercase letter will be ignored").addToggle((toggle) => toggle.setValue(this.settingsService.getSettings().ignoreSuggestionsWhichStartWithLowercaseLetter).onChange(async (value) => await this.updateSettingValue("ignoreSuggestionsWhichStartWithLowercaseLetter", value)));
    new import_obsidian5.Setting(containerEl).setName("Make suggestions to items in the same file").setDesc("If checked, suggestions to items (Headers, Tags) in the same file be created").addToggle((toggle) => toggle.setValue(this.settingsService.getSettings().suggestInSameFile).onChange(async (value) => await this.updateSettingValue("suggestInSameFile", value)));
    new import_obsidian5.Setting(containerEl).setName("Minimum word length of suggestions").setDisabled(!this.settingsService.getSettings().useAutoRefresh).setDesc("Defines the min. length an item (Header, Tag) must have for it to be considered a suggestion").addSlider((slider) => {
      slider.setLimits(1, 20, 1).setValue(this.settingsService.getSettings().minimumSuggestionWordLength).onChange(async (value) => await this.updateSettingValue("minimumSuggestionWordLength", value)).setDynamicTooltip();
    });
  }
  addLoggingSettings(containerEl) {
    containerEl.createEl("h3", { text: "Debug" });
    new import_obsidian5.Setting(containerEl).setName("Enable logging").setDesc("If checked, debug logs will be printed to the console").addToggle((toggle) => toggle.setValue(this.settingsService.getSettings().useLogging).onChange(async (value) => await this.updateSettingValue("useLogging", value)));
  }
  addAutoRefreshSettings(containerEl) {
    containerEl.createEl("h3", { text: "Auto refresh" });
    const autoRefreshSetting = new import_obsidian5.Setting(containerEl).setName("Enable auto refresh").setDesc("If checked, crossbow will automatically refresh if the current note has been edited");
    const autoRefreshDelaySetting = new import_obsidian5.Setting(containerEl).setName("Auto refresh delay").setDesc("A delay in ms after which crossbow will refresh if the current note has been edited");
    let autoRefreshSettingUpdateTimeout = void 0;
    autoRefreshSetting.addToggle((toggle) => toggle.setValue(this.settingsService.getSettings().useAutoRefresh).onChange(async (value) => {
      autoRefreshDelaySetting.setDisabled(!value);
      await this.updateSettingValue("useAutoRefresh", value);
    }));
    autoRefreshDelaySetting.addSlider((slider) => {
      slider.setLimits(2600, 2e4, 100).setValue(this.settingsService.getSettings().autoRefreshDelayMs).onChange(async (value) => {
        if (autoRefreshSettingUpdateTimeout) {
          clearTimeout(autoRefreshSettingUpdateTimeout);
        }
        autoRefreshSettingUpdateTimeout = setTimeout(async () => {
          await this.updateSettingValue("autoRefreshDelayMs", value);
        }, 1e3);
      }).setDynamicTooltip();
    });
  }
};

// src/services/settingsService.ts
var DEFAULT_SETTINGS = {
  ignoredWordsCaseSensisitve: ["image", "the", "always", "some"],
  suggestInSameFile: false,
  ignoreSuggestionsWhichStartWithLowercaseLetter: true,
  ignoreOccurrencesWhichStartWithLowercaseLetter: false,
  minimumSuggestionWordLength: 3,
  useLogging: false,
  useAutoRefresh: true,
  autoRefreshDelayMs: 2600
};
var CrossbowSettingsService = class {
  constructor(onSettingsChange) {
    this.onSettingsChange = onSettingsChange;
    this.settings = DEFAULT_SETTINGS;
  }
  getSettings() {
    return this.settings;
  }
  setSettings(settings) {
    this.settings = settings;
  }
  async saveSettings(settings) {
    this.settings = settings != null ? settings : this.settings;
    await this.onSettingsChange(this.settings);
  }
};

// src/services/indexingService.ts
var CrossbowIndexingService = class {
  constructor(settingsService) {
    this.settingsService = settingsService;
    this.crossbowCache = {};
  }
  addOrUpdateCacheEntry(entry) {
    this.crossbowCache[entry.text] = entry;
  }
  getCache() {
    return this.crossbowCache;
  }
  indexVault(vault) {
    const files = vault.getFiles();
    files.forEach((file) => this.indexFile(file));
  }
  indexFile(file, cache) {
    if (file.extension !== "md")
      return;
    const metadata = cache ? cache : app.metadataCache.getFileCache(file);
    if (file.basename.length >= this.settingsService.getSettings().minimumSuggestionWordLength)
      this.addOrUpdateCacheEntry({ file, text: file.basename, type: "File" });
    if (metadata) {
      if (metadata.headings)
        metadata.headings.forEach((headingCache) => this.addOrUpdateCacheEntry({
          item: headingCache,
          file,
          text: headingCache.heading,
          type: "Heading"
        }));
      if (metadata.tags)
        metadata.tags.forEach((tagCache) => this.addOrUpdateCacheEntry({
          item: tagCache,
          file,
          text: tagCache.tag,
          type: "Tag"
        }));
    }
  }
  clearCache() {
    Object.assign(this.crossbowCache, {});
  }
};

// src/services/tokenizationService.ts
var OBSIDIAN_METADATA_REGEX = /^\n*?---[\s\S]+?---/g;
var OBSIDIAN_TAG_REGEX = /#+([a-zA-Z0-9_/]+)/g;
var OBSIDIAN_LINKS_REGEX = /\[([^\]]+)\]+/g;
var HTML_COMMENT_REGEX = /<!--[\s\S]+?-->/g;
var HTML_TAG_REGEX = /<\/?[\w\s="/.':;#-\/\?]+>/gm;
var MARKDOWN_LATEX_BLOCK_REGEX = /\$\$([^$]+)\$\$/g;
var MARKDOWN_LATEX_INLINE_REGEX = /\$([^$]+)\$/g;
var MARKDOWN_LINKS_AND_IMAGES_REGEX = /!?\[([^\]]+)\]\((?:<.*>)?\s*([^\s)]+)\s*\)/gm;
var MARKDOWN_CODE_BLOCK_REGEX = /```[\s\S]+?```/g;
var CrossbowTokenizationService = class {
  constructor() {
    this.SKIP_REGEX = /\s/;
  }
  getWordLookupFromEditor(targetEditor) {
    if (!targetEditor)
      return {};
    const wordLookup = {};
    const rawText = targetEditor.getValue();
    const plainText = CrossbowTokenizationService.redactText(rawText);
    for (let i = 0; i < plainText.length; i++) {
      if (plainText[i].match(this.SKIP_REGEX))
        continue;
      else {
        let word = "";
        let pos = targetEditor.offsetToPos(i);
        while (plainText[i] && !plainText[i].match(this.SKIP_REGEX))
          word += plainText[i++];
        word = CrossbowTokenizationService.cleanWord(word);
        if (word.length <= 0)
          continue;
        if (word in wordLookup)
          wordLookup[word].push(pos);
        else
          wordLookup[word] = [pos];
      }
    }
    return wordLookup;
  }
  static redactText(text) {
    const muteString = (str) => str.replace(/[^\r\n]+/g, (m) => " ".repeat(m.length));
    return text.replace(MARKDOWN_CODE_BLOCK_REGEX, (m) => muteString(m)).replace(MARKDOWN_LATEX_BLOCK_REGEX, (m) => muteString(m)).replace(MARKDOWN_LATEX_INLINE_REGEX, (m) => muteString(m)).replace(MARKDOWN_LINKS_AND_IMAGES_REGEX, (m) => muteString(m)).replace(OBSIDIAN_METADATA_REGEX, (m) => muteString(m)).replace(OBSIDIAN_TAG_REGEX, (m) => muteString(m)).replace(OBSIDIAN_LINKS_REGEX, (m) => muteString(m)).replace(HTML_COMMENT_REGEX, (m) => muteString(m)).replace(HTML_TAG_REGEX, (m) => muteString(m));
  }
  static cleanWord(word) {
    return word.replace(/[^a-z0-9äöü'-]/gi, "").replace(/^[’'-]+|[’'-]+$/gi, "");
  }
};

// src/model/suggestion.ts
var Suggestion = class {
  constructor(word, occurrences) {
    this.word = word;
    this.occurrences = occurrences;
  }
  get hash() {
    return this.word;
  }
  get text() {
    return this.word;
  }
  get matches() {
    return this.occurrences[0].matches;
  }
  sortChildren() {
    this.occurrences.sort((a, b) => a.editorPosition.line - b.editorPosition.line).forEach((occ) => occ.sortChildren());
  }
};
var Occurrence = class {
  constructor(editorPosition, matches) {
    this.editorPosition = editorPosition;
    this.matches = matches;
  }
  get hash() {
    return `${this.editorPosition.line}:${this.editorPosition.ch}`;
  }
  get text() {
    return `On line ${this.editorPosition.line}:${this.editorPosition.ch}`;
  }
  sortChildren() {
    this.matches.sort((a, b) => a.cacheMatch.rank.codePointAt(0) - b.cacheMatch.rank.codePointAt(0));
  }
};
var Match = class {
  constructor(cacheMatch) {
    this.cacheMatch = cacheMatch;
  }
  get hash() {
    return `${this.cacheMatch.text}|${this.cacheMatch.file.path}`;
  }
  get text() {
    return `${this.cacheMatch.rank} ${this.cacheMatch.text}`;
  }
  sortChildren() {
  }
};

// src/services/suggestionsService.ts
var CrossbowSuggestionsService = class {
  constructor(settingsService, indexingService) {
    this.settingsService = settingsService;
    this.indexingService = indexingService;
  }
  getSuggestionsFromWordlookup(wordLookup, currentFile) {
    if (!wordLookup)
      return [];
    const result = [];
    const cache = this.indexingService.getCache();
    Object.entries(wordLookup).forEach((entry) => {
      const [word, editorPositions] = entry;
      const matchSet = /* @__PURE__ */ new Set();
      Object.keys(cache).forEach((cacheKey) => {
        const lowercaseWord = word.toLowerCase();
        const lowercaseCacheKey = cacheKey.toLowerCase();
        if (!this.settingsService.getSettings().suggestInSameFile && cache[cacheKey].file === currentFile)
          return;
        if (cacheKey === word) {
          matchSet.add({ ...cache[cacheKey], rank: "\u{1F3C6}" });
          return;
        }
        if (this.settingsService.getSettings().ignoredWordsCaseSensisitve.includes(word))
          return;
        if (word.length <= 3)
          return;
        if (cacheKey.length <= this.settingsService.getSettings().minimumSuggestionWordLength)
          return;
        if ((lowercaseCacheKey.includes(lowercaseWord) || lowercaseWord.includes(lowercaseCacheKey)) === false)
          return;
        if (this.settingsService.getSettings().ignoreOccurrencesWhichStartWithLowercaseLetter && cacheKey[0] === lowercaseCacheKey[0])
          return;
        if (this.settingsService.getSettings().ignoreSuggestionsWhichStartWithLowercaseLetter && word[0] === lowercaseWord[0])
          return;
        if (lowercaseCacheKey === lowercaseWord) {
          matchSet.add({ ...cache[cacheKey], rank: "\u{1F947}" });
          return;
        }
        if (1 / cacheKey.length * word.length <= 0.2) {
          matchSet.add({ ...cache[cacheKey], rank: "\u{1F949}" });
          return;
        }
        matchSet.add({ ...cache[cacheKey], rank: "\u{1F948}" });
      });
      if (matchSet.size > 0) {
        const matches = Array.from(matchSet).map((m) => new Match(m));
        const occurrences = editorPositions.map((p) => new Occurrence(p, matches));
        result.push(new Suggestion(word, occurrences));
      }
    });
    result.sort((a, b) => a.hash.localeCompare(b.hash)).forEach((suggestion) => suggestion.sortChildren());
    return result;
  }
};

// src/main.ts
var CrossbowPlugin = class extends import_obsidian6.Plugin {
  constructor(app2, manifest) {
    super(app2, manifest);
    this.onMetadataChange = (file, data, cache) => {
      if (this.metadataChangedTimeout)
        clearTimeout(this.metadataChangedTimeout);
      if (!this.settingsService.getSettings().useAutoRefresh)
        return;
      if (!this.viewController.doesCrossbowViewExist())
        return;
      this.metadataChangedTimeout = setTimeout(() => {
        this.indexingService.indexFile(file, cache);
        this.runWithoutCacheUpdate(false);
        this.loggingService.debugLog(`Metadata cache updated for ${file.basename}.`);
      }, this.settingsService.getSettings().autoRefreshDelayMs);
    };
    this.onFileOpen = () => {
      if (!this.viewController.doesCrossbowViewExist())
        return;
      const prevCurrentFile = this.currentFile;
      this.setActiveFile();
      this.loggingService.debugLog("File opened.");
      if (this.fileOpenTimeout)
        clearTimeout(this.fileOpenTimeout);
      this.fileOpenTimeout = setTimeout(() => {
        if (!prevCurrentFile)
          this.runWithCacheUpdate(true);
        else if (this.currentFile !== prevCurrentFile)
          this.runWithoutCacheUpdate(true);
      }, 100);
    };
    this.onSettingsChanged = async (settings) => {
      this.loggingService.debugLog("Settings saved.");
      await this.saveData(settings);
      this.runWithCacheUpdate(true);
    };
    this.onManualRefreshButtonClick = () => {
      this.loggingService.debugLog("Manually triggered update.");
      this.runWithoutCacheUpdate(true);
    };
    this.settingsService = new CrossbowSettingsService(this.onSettingsChanged);
    this.loggingService = new CrossbowLoggingService(this.settingsService);
    this.indexingService = new CrossbowIndexingService(this.settingsService);
    this.tokenizationService = new CrossbowTokenizationService();
    this.suggestionsService = new CrossbowSuggestionsService(this.settingsService, this.indexingService);
    this.viewController = new CrossbowViewController(this.settingsService);
  }
  async onload() {
    const settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.settingsService.setSettings(settings);
    registerCrossbowIcons();
    registerTreeItemElements();
    this.registerView(CrossbowView.viewType, (leaf) => new CrossbowView(leaf, this.onManualRefreshButtonClick));
    this.addRibbonIcon("crossbow", "Crossbow", async (ev) => {
      await this.viewController.revealOrCreateView();
      this.setActiveFile();
      this.runWithCacheUpdate(true);
    });
    this.addSettingTab(new CrossbowSettingTab(this.app, this, this.settingsService));
    this.registerEvent(this.app.workspace.on("file-open", this.onFileOpen));
    this.registerEvent(this.app.metadataCache.on("changed", this.onMetadataChange));
    this.loggingService.debugLog("Crossbow is ready.");
  }
  onunload() {
    this.viewController.unloadView();
    this.indexingService.clearCache();
    this.loggingService.debugLog("Unloaded Crossbow.");
  }
  runWithCacheUpdate(fileHasChanged) {
    this.indexingService.indexVault(this.app.vault);
    this.runWithoutCacheUpdate(fileHasChanged);
  }
  runWithoutCacheUpdate(fileHasChanged) {
    var _a;
    const targetEditor = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor;
    if (!targetEditor)
      return;
    const wordLookup = this.tokenizationService.getWordLookupFromEditor(targetEditor);
    const suggestions = this.suggestionsService.getSuggestionsFromWordlookup(wordLookup, this.currentFile);
    this.viewController.addOrUpdateSuggestions(suggestions, targetEditor, fileHasChanged);
  }
  setActiveFile() {
    const leaf = this.app.workspace.getMostRecentLeaf();
    if ((leaf == null ? void 0 : leaf.view) instanceof import_obsidian6.MarkdownView) {
      this.currentFile = leaf.view.file;
    } else
      console.warn("\u{1F3F9}: Unable to determine current editor.");
  }
};
