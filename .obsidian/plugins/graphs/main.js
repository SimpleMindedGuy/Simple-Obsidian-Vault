/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianGraphs
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// node_modules/jsxgraph/src/jxg.js
var jxg = {};
try {
  if (typeof JXG === "object" && !JXG.extend) {
    jxg = JXG;
  }
} catch (e) {
}
jxg.extend = function(object, extension, onlyOwn, toLower) {
  var e, e2;
  onlyOwn = onlyOwn || false;
  toLower = toLower || false;
  for (e in extension) {
    if (!onlyOwn || onlyOwn && extension.hasOwnProperty(e)) {
      if (toLower) {
        e2 = e.toLowerCase();
      } else {
        e2 = e;
      }
      object[e2] = extension[e];
    }
  }
};
jxg.defineConstant = function(object, name, value, ignoreRedefine) {
  ignoreRedefine = ignoreRedefine || false;
  if (ignoreRedefine && jxg.exists(object[name])) {
    return;
  }
  Object.defineProperty(object, name, {
    value,
    writable: false,
    enumerable: true,
    configurable: false
  });
};
jxg.extendConstants = function(object, constants2, onlyOwn, toUpper) {
  var e, e2;
  onlyOwn = onlyOwn || false;
  toUpper = toUpper || false;
  for (e in constants2) {
    if (!onlyOwn || onlyOwn && constants2.hasOwnProperty(e)) {
      if (toUpper) {
        e2 = e.toUpperCase();
      } else {
        e2 = e;
      }
      this.defineConstant(object, e2, constants2[e]);
    }
  }
};
jxg.extend(
  jxg,
  /** @lends JXG */
  {
    /**
     * Store a reference to every board in this central list. This will at some point
     * replace JXG.JSXGraph.boards.
     * @type Object
     */
    boards: {},
    /**
     * Store the available file readers in this structure.
     * @type Object
     */
    readers: {},
    /**
     * Associative array that keeps track of all constructable elements registered
     * via {@link JXG.registerElement}.
     * @type Object
     */
    elements: {},
    /**
     * This registers a new construction element to JSXGraph for the construction via the {@link JXG.Board.create}
     * interface.
     * @param {String} element The elements name. This is case-insensitive, existing elements with the same name
     * will be overwritten.
     * @param {Function} creator A reference to a function taking three parameters: First the board, the element is
     * to be created on, a parent element array, and an attributes object. See {@link JXG.createPoint} or any other
     * <tt>JXG.create...</tt> function for an example.
     */
    registerElement: function(element, creator) {
      element = element.toLowerCase();
      this.elements[element] = creator;
    },
    /**
     * Register a file reader.
     * @param {function} reader A file reader. This object has to provide two methods: <tt>prepareString()</tt>
     * and <tt>read()</tt>.
     * @param {Array} ext
     */
    registerReader: function(reader, ext) {
      var i2, e;
      for (i2 = 0; i2 < ext.length; i2++) {
        e = ext[i2].toLowerCase();
        if (typeof this.readers[e] !== "function") {
          this.readers[e] = reader;
        }
      }
    },
    /**
     * Creates a shortcut to a method, e.g. {@link JXG.Board#createElement} is a shortcut to {@link JXG.Board#create}.
     * Sometimes the target is undefined by the time you want to define the shortcut so we need this little helper.
     * @param {Object} object The object the method we want to create a shortcut for belongs to.
     * @param {String} fun The method we want to create a shortcut for.
     * @returns {Function} A function that calls the given method.
     */
    shortcut: function(object, fun2) {
      return function() {
        return object[fun2].apply(this, arguments);
      };
    },
    /**
     * s may be a string containing the name or id of an element or even a reference
     * to the element itself. This function returns a reference to the element. Search order: id, name.
     * @param {JXG.Board} board Reference to the board the element belongs to.
     * @param {String} s String or reference to a JSXGraph element.
     * @returns {Object} Reference to the object given in parameter object
     * @deprecated Use {@link JXG.Board#select}
     */
    getRef: function(board, s) {
      jxg.deprecated("JXG.getRef()", "Board.select()");
      return board.select(s);
    },
    /**
     * This is just a shortcut to {@link JXG.getRef}.
     * @deprecated Use {@link JXG.Board#select}.
     */
    getReference: function(board, s) {
      jxg.deprecated("JXG.getReference()", "Board.select()");
      return board.select(s);
    },
    /**
     * s may be the string containing the id of an HTML tag that hosts a JSXGraph board.
     * This function returns the reference to the board.
     * @param  {String} s String of an HTML tag that hosts a JSXGraph board
     * @returns {Object} Reference to the board or null.
     */
    getBoardByContainerId: function(s) {
      var b;
      for (b in JXG.boards) {
        if (JXG.boards.hasOwnProperty(b) && JXG.boards[b].container === s) {
          return JXG.boards[b];
        }
      }
      return null;
    },
    /**
     * This method issues a warning to the developer that the given function is deprecated
     * and, if available, offers an alternative to the deprecated function.
     * @param {String} what Describes the function that is deprecated
     * @param {String} [replacement] The replacement that should be used instead.
     */
    deprecated: function(what, replacement) {
      var warning = what + " is deprecated.";
      if (replacement) {
        warning += " Please use " + replacement + " instead.";
      }
      jxg.warn(warning);
    },
    /**
     * Outputs a warning via console.warn(), if available. If console.warn() is
     * unavailable this function will look for an HTML element with the id 'warning'
     * and append the warning to this element's innerHTML.
     * @param {String} warning The warning text
     */
    warn: function(warning) {
      if (typeof window === "object" && window.console && console.warn) {
        console.warn("WARNING:", warning);
      } else if (typeof document === "object" && document.getElementById("warning")) {
        document.getElementById("debug").innerHTML += "WARNING: " + warning + "<br />";
      }
    },
    /**
     * Add something to the debug log. If available a JavaScript debug console is used. Otherwise
     * we're looking for a HTML div with id "debug". If this doesn't exist, too, the output is omitted.
     * @param s An arbitrary number of parameters.
     * @see JXG#debugWST
     */
    debugInt: function(s) {
      var i2, p;
      for (i2 = 0; i2 < arguments.length; i2++) {
        p = arguments[i2];
        if (typeof window === "object" && window.console && console.log) {
          console.log(p);
        } else if (typeof document === "object" && document.getElementById("debug")) {
          document.getElementById("debug").innerHTML += p + "<br/>";
        }
      }
    },
    /**
     * Add something to the debug log. If available a JavaScript debug console is used. Otherwise
     * we're looking for a HTML div with id "debug". If this doesn't exist, too, the output is omitted.
     * This method adds a stack trace (if available).
     * @param s An arbitrary number of parameters.
     * @see JXG#debug
     */
    debugWST: function(s) {
      var e = new Error();
      jxg.debugInt.apply(this, arguments);
      if (e && e.stack) {
        jxg.debugInt("stacktrace");
        jxg.debugInt(e.stack.split("\n").slice(1).join("\n"));
      }
    },
    /**
     * Add something to the debug log. If available a JavaScript debug console is used. Otherwise
     * we're looking for a HTML div with id "debug". If this doesn't exist, too, the output is omitted.
     * This method adds a line of the stack trace (if available).
     *
     * @param s An arbitrary number of parameters.
     * @see JXG#debug
     */
    debugLine: function(s) {
      var e = new Error();
      jxg.debugInt.apply(this, arguments);
      if (e && e.stack) {
        jxg.debugInt("Called from", e.stack.split("\n").slice(2, 3).join("\n"));
      }
    },
    /**
     * Add something to the debug log. If available a JavaScript debug console is used. Otherwise
     * we're looking for a HTML div with id "debug". If this doesn't exist, too, the output is omitted.
     * @param s An arbitrary number of parameters.
     * @see JXG#debugWST
     * @see JXG#debugLine
     * @see JXG#debugInt
     */
    debug: function(s) {
      jxg.debugInt.apply(this, arguments);
    },
    themes: {}
  }
);
var jxg_default = jxg;

// node_modules/jsxgraph/src/base/constants.js
var major = 1;
var minor = 8;
var patch = 0;
var add = "";
var version = major + "." + minor + "." + patch + (add ? "-" + add : "");
var constants;
constants = /** @lends JXG */
{
  /**
   * Constant: the currently used JSXGraph version.
   *
   * @name JXG.version
   * @type String
   */
  version,
  /**
   * Constant: the small gray version indicator in the top left corner of every JSXGraph board (if
   * showCopyright is not set to false on board creation).
   *
   * @name JXG.licenseText
   * @type String
   */
  licenseText: "JSXGraph v" + version + " Copyright (C) see https://jsxgraph.org",
  /**
   *  Constant: user coordinates relative to the coordinates system defined by the bounding box.
   *  @name JXG.COORDS_BY_USER
   *  @type Number
   */
  COORDS_BY_USER: 1,
  /**
   *  Constant: screen coordinates in pixel relative to the upper left corner of the div element.
   *  @name JXG.COORDS_BY_SCREEN
   *  @type Number
   */
  COORDS_BY_SCREEN: 2,
  // object types
  OBJECT_TYPE_ARC: 1,
  OBJECT_TYPE_ARROW: 2,
  OBJECT_TYPE_AXIS: 3,
  OBJECT_TYPE_AXISPOINT: 4,
  OBJECT_TYPE_TICKS: 5,
  OBJECT_TYPE_CIRCLE: 6,
  OBJECT_TYPE_CONIC: 7,
  OBJECT_TYPE_CURVE: 8,
  OBJECT_TYPE_GLIDER: 9,
  OBJECT_TYPE_IMAGE: 10,
  OBJECT_TYPE_LINE: 11,
  OBJECT_TYPE_POINT: 12,
  OBJECT_TYPE_SLIDER: 13,
  OBJECT_TYPE_CAS: 14,
  OBJECT_TYPE_GXTCAS: 15,
  OBJECT_TYPE_POLYGON: 16,
  OBJECT_TYPE_SECTOR: 17,
  OBJECT_TYPE_TEXT: 18,
  OBJECT_TYPE_ANGLE: 19,
  OBJECT_TYPE_INTERSECTION: 20,
  OBJECT_TYPE_TURTLE: 21,
  OBJECT_TYPE_VECTOR: 22,
  OBJECT_TYPE_OPROJECT: 23,
  OBJECT_TYPE_GRID: 24,
  OBJECT_TYPE_TANGENT: 25,
  OBJECT_TYPE_HTMLSLIDER: 26,
  OBJECT_TYPE_CHECKBOX: 27,
  OBJECT_TYPE_INPUT: 28,
  OBJECT_TYPE_BUTTON: 29,
  OBJECT_TYPE_TRANSFORMATION: 30,
  OBJECT_TYPE_FOREIGNOBJECT: 31,
  OBJECT_TYPE_VIEW3D: 32,
  OBJECT_TYPE_POINT3D: 33,
  OBJECT_TYPE_LINE3D: 34,
  OBJECT_TYPE_PLANE3D: 35,
  OBJECT_TYPE_CURVE3D: 36,
  OBJECT_TYPE_SURFACE3D: 37,
  OBJECT_TYPE_MEASUREMENT: 38,
  // IMPORTANT:
  // ----------
  // For being able to differentiate between the (sketchometry specific) SPECIAL_OBJECT_TYPEs and
  // (core specific) OBJECT_TYPEs, the non-sketchometry types MUST NOT be changed
  // to values > 100.
  // object classes
  OBJECT_CLASS_POINT: 1,
  OBJECT_CLASS_LINE: 2,
  OBJECT_CLASS_CIRCLE: 3,
  OBJECT_CLASS_CURVE: 4,
  OBJECT_CLASS_AREA: 5,
  OBJECT_CLASS_OTHER: 6,
  OBJECT_CLASS_TEXT: 7,
  OBJECT_CLASS_3D: 8
};
jxg_default.extendConstants(jxg_default, constants);
var constants_default = constants;

// node_modules/jsxgraph/src/math/math.js
var undef;
var memoizer = function(f) {
  var cache, join;
  if (f.memo) {
    return f.memo;
  }
  cache = {};
  join = Array.prototype.join;
  f.memo = function() {
    var key = join.call(arguments);
    return cache[key] !== undef ? cache[key] : cache[key] = f.apply(this, arguments);
  };
  return f.memo;
};
jxg_default.Math = {
  /**
   * eps defines the closeness to zero. If the absolute value of a given number is smaller
   * than eps, it is considered to be equal to zero.
   * @type Number
   */
  eps: 1e-6,
  /**
   * Determine the relative difference between two numbers.
   * @param  {Number} a First number
   * @param  {Number} b Second number
   * @returns {Number}  Relative difference between a and b: |a-b| / max(|a|, |b|)
   */
  relDif: function(a, b) {
    var c = Math.abs(a), d = Math.abs(b);
    d = Math.max(c, d);
    return d === 0 ? 0 : Math.abs(a - b) / d;
  },
  /**
   * The JavaScript implementation of the % operator returns the symmetric modulo.
   * mod and "%" are both identical if a >= 0 and m >= 0 but the results differ if a or m < 0.
   * @param {Number} a
   * @param {Number} m
   * @returns {Number} Mathematical modulo <tt>a mod m</tt>
   */
  mod: function(a, m) {
    return a - Math.floor(a / m) * m;
  },
  /**
   * Initializes a vector of size <tt>n</tt> wih coefficients set to the init value (default 0)
   * @param {Number} n Length of the vector
   * @param {Number} [init=0] Initial value for each coefficient
   * @returns {Array} An array of length <tt>n</tt>
   */
  vector: function(n, init2) {
    var r, i2;
    init2 = init2 || 0;
    r = [];
    for (i2 = 0; i2 < n; i2++) {
      r[i2] = init2;
    }
    return r;
  },
  /**
   * Initializes a matrix as an array of rows with the given value.
   * @param {Number} n Number of rows
   * @param {Number} [m=n] Number of columns
   * @param {Number} [init=0] Initial value for each coefficient
   * @returns {Array} A <tt>n</tt> times <tt>m</tt>-matrix represented by a
   * two-dimensional array. The inner arrays hold the columns, the outer array holds the rows.
   */
  matrix: function(n, m, init2) {
    var r, i2, j;
    init2 = init2 || 0;
    m = m || n;
    r = [];
    for (i2 = 0; i2 < n; i2++) {
      r[i2] = [];
      for (j = 0; j < m; j++) {
        r[i2][j] = init2;
      }
    }
    return r;
  },
  /**
   * Generates an identity matrix. If n is a number and m is undefined or not a number, a square matrix is generated,
   * if n and m are both numbers, an nxm matrix is generated.
   * @param {Number} n Number of rows
   * @param {Number} [m=n] Number of columns
   * @returns {Array} A square matrix of length <tt>n</tt> with all coefficients equal to 0 except a_(i,i), i out of (1, ..., n), if <tt>m</tt> is undefined or not a number
   * or a <tt>n</tt> times <tt>m</tt>-matrix with a_(i,j) = 0 and a_(i,i) = 1 if m is a number.
   */
  identity: function(n, m) {
    var r, i2;
    if (m === undef && typeof m !== "number") {
      m = n;
    }
    r = this.matrix(n, m);
    for (i2 = 0; i2 < Math.min(n, m); i2++) {
      r[i2][i2] = 1;
    }
    return r;
  },
  /**
   * Generates a 4x4 matrix for 3D to 2D projections.
   * @param {Number} l Left
   * @param {Number} r Right
   * @param {Number} t Top
   * @param {Number} b Bottom
   * @param {Number} n Near
   * @param {Number} f Far
   * @returns {Array} 4x4 Matrix
   */
  frustum: function(l, r, b, t, n, f) {
    var ret = this.matrix(4, 4);
    ret[0][0] = n * 2 / (r - l);
    ret[0][1] = 0;
    ret[0][2] = (r + l) / (r - l);
    ret[0][3] = 0;
    ret[1][0] = 0;
    ret[1][1] = n * 2 / (t - b);
    ret[1][2] = (t + b) / (t - b);
    ret[1][3] = 0;
    ret[2][0] = 0;
    ret[2][1] = 0;
    ret[2][2] = -(f + n) / (f - n);
    ret[2][3] = -(f * n * 2) / (f - n);
    ret[3][0] = 0;
    ret[3][1] = 0;
    ret[3][2] = -1;
    ret[3][3] = 0;
    return ret;
  },
  /**
   * Generates a 4x4 matrix for 3D to 2D projections.
   * @param {Number} fov Field of view in vertical direction, given in rad.
   * @param {Number} ratio Aspect ratio of the projection plane.
   * @param {Number} n Near
   * @param {Number} f Far
   * @returns {Array} 4x4 Projection Matrix
   */
  projection: function(fov, ratio, n, f) {
    var t = n * Math.tan(fov / 2), r = t * ratio;
    return this.frustum(-r, r, -t, t, n, f);
  },
  /**
   * Multiplies a vector vec to a matrix mat: mat * vec. The matrix is interpreted by this function as an array of rows. Please note: This
   * function does not check if the dimensions match.
   * @param {Array} mat Two dimensional array of numbers. The inner arrays describe the columns, the outer ones the matrix' rows.
   * @param {Array} vec Array of numbers
   * @returns {Array} Array of numbers containing the result
   * @example
   * var A = [[2, 1],
   *          [1, 3]],
   *     b = [4, 5],
   *     c;
   * c = JXG.Math.matVecMult(A, b)
   * // c === [13, 19];
   */
  matVecMult: function(mat, vec) {
    var i2, s, k, m = mat.length, n = vec.length, res = [];
    if (n === 3) {
      for (i2 = 0; i2 < m; i2++) {
        res[i2] = mat[i2][0] * vec[0] + mat[i2][1] * vec[1] + mat[i2][2] * vec[2];
      }
    } else {
      for (i2 = 0; i2 < m; i2++) {
        s = 0;
        for (k = 0; k < n; k++) {
          s += mat[i2][k] * vec[k];
        }
        res[i2] = s;
      }
    }
    return res;
  },
  /**
   * Computes the product of the two matrices mat1*mat2.
   * @param {Array} mat1 Two dimensional array of numbers
   * @param {Array} mat2 Two dimensional array of numbers
   * @returns {Array} Two dimensional Array of numbers containing result
   */
  matMatMult: function(mat1, mat2) {
    var i2, j, s, k, m = mat1.length, n = m > 0 ? mat2[0].length : 0, m2 = mat2.length, res = this.matrix(m, n);
    for (i2 = 0; i2 < m; i2++) {
      for (j = 0; j < n; j++) {
        s = 0;
        for (k = 0; k < m2; k++) {
          s += mat1[i2][k] * mat2[k][j];
        }
        res[i2][j] = s;
      }
    }
    return res;
  },
  /**
   * Transposes a matrix given as a two dimensional array.
   * @param {Array} M The matrix to be transposed
   * @returns {Array} The transpose of M
   */
  transpose: function(M) {
    var MT, i2, j, m, n;
    m = M.length;
    n = M.length > 0 ? M[0].length : 0;
    MT = this.matrix(n, m);
    for (i2 = 0; i2 < n; i2++) {
      for (j = 0; j < m; j++) {
        MT[i2][j] = M[j][i2];
      }
    }
    return MT;
  },
  /**
   * Compute the inverse of an nxn matrix with Gauss elimination.
   * @param {Array} Ain
   * @returns {Array} Inverse matrix of Ain
   */
  inverse: function(Ain) {
    var i2, j, k, s, ma, r, swp, n = Ain.length, A = [], p = [], hv = [];
    for (i2 = 0; i2 < n; i2++) {
      A[i2] = [];
      for (j = 0; j < n; j++) {
        A[i2][j] = Ain[i2][j];
      }
      p[i2] = i2;
    }
    for (j = 0; j < n; j++) {
      ma = Math.abs(A[j][j]);
      r = j;
      for (i2 = j + 1; i2 < n; i2++) {
        if (Math.abs(A[i2][j]) > ma) {
          ma = Math.abs(A[i2][j]);
          r = i2;
        }
      }
      if (ma <= this.eps) {
        return [];
      }
      if (r > j) {
        for (k = 0; k < n; k++) {
          swp = A[j][k];
          A[j][k] = A[r][k];
          A[r][k] = swp;
        }
        swp = p[j];
        p[j] = p[r];
        p[r] = swp;
      }
      s = 1 / A[j][j];
      for (i2 = 0; i2 < n; i2++) {
        A[i2][j] *= s;
      }
      A[j][j] = s;
      for (k = 0; k < n; k++) {
        if (k !== j) {
          for (i2 = 0; i2 < n; i2++) {
            if (i2 !== j) {
              A[i2][k] -= A[i2][j] * A[j][k];
            }
          }
          A[j][k] = -s * A[j][k];
        }
      }
    }
    for (i2 = 0; i2 < n; i2++) {
      for (k = 0; k < n; k++) {
        hv[p[k]] = A[i2][k];
      }
      for (k = 0; k < n; k++) {
        A[i2][k] = hv[k];
      }
    }
    return A;
  },
  /**
   * Inner product of two vectors a and b. n is the length of the vectors.
   * @param {Array} a Vector
   * @param {Array} b Vector
   * @param {Number} [n] Length of the Vectors. If not given the length of the first vector is taken.
   * @returns {Number} The inner product of a and b.
   */
  innerProduct: function(a, b, n) {
    var i2, s = 0;
    if (n === undef || !type_default.isNumber(n)) {
      n = a.length;
    }
    for (i2 = 0; i2 < n; i2++) {
      s += a[i2] * b[i2];
    }
    return s;
  },
  /**
   * Calculates the cross product of two vectors both of length three.
   * In case of homogeneous coordinates this is either
   * <ul>
   * <li>the intersection of two lines</li>
   * <li>the line through two points</li>
   * </ul>
   * @param {Array} c1 Homogeneous coordinates of line or point 1
   * @param {Array} c2 Homogeneous coordinates of line or point 2
   * @returns {Array} vector of length 3: homogeneous coordinates of the resulting point / line.
   */
  crossProduct: function(c1, c2) {
    return [
      c1[1] * c2[2] - c1[2] * c2[1],
      c1[2] * c2[0] - c1[0] * c2[2],
      c1[0] * c2[1] - c1[1] * c2[0]
    ];
  },
  /**
   * Euclidean norm of a vector.
   *
   * @param {Array} a Array containing a vector.
   * @param {Number} n (Optional) length of the array.
   * @returns {Number} Euclidean norm of the vector.
   */
  norm: function(a, n) {
    var i2, sum = 0;
    if (n === undef || !type_default.isNumber(n)) {
      n = a.length;
    }
    for (i2 = 0; i2 < n; i2++) {
      sum += a[i2] * a[i2];
    }
    return Math.sqrt(sum);
  },
  /**
   * Compute a * x + y for a scalar a and vectors x and y.
   *
   * @param {Number} a
   * @param {Array} x
   * @param {Array} y
   * @returns
   */
  axpy: function(a, x, y) {
    var i2, le = x.length, p = [];
    for (i2 = 0; i2 < le; i2++) {
      p[i2] = a * x[i2] + y[i2];
    }
    return p;
  },
  /**
   * Compute the factorial of a positive integer. If a non-integer value
   * is given, the fraction will be ignored.
   * @function
   * @param {Number} n
   * @returns {Number} n! = n*(n-1)*...*2*1
   */
  factorial: memoizer(function(n) {
    if (n < 0) {
      return NaN;
    }
    n = Math.floor(n);
    if (n === 0 || n === 1) {
      return 1;
    }
    return n * this.factorial(n - 1);
  }),
  /**
   * Computes the binomial coefficient n over k.
   * @function
   * @param {Number} n Fraction will be ignored
   * @param {Number} k Fraction will be ignored
   * @returns {Number} The binomial coefficient n over k
   */
  binomial: memoizer(function(n, k) {
    var b, i2;
    if (k > n || k < 0) {
      return NaN;
    }
    k = Math.round(k);
    n = Math.round(n);
    if (k === 0 || k === n) {
      return 1;
    }
    b = 1;
    for (i2 = 0; i2 < k; i2++) {
      b *= n - i2;
      b /= i2 + 1;
    }
    return b;
  }),
  /**
   * Calculates the cosine hyperbolicus of x.
   * @function
   * @param {Number} x The number the cosine hyperbolicus will be calculated of.
   * @returns {Number} Cosine hyperbolicus of the given value.
   */
  cosh: Math.cosh || function(x) {
    return (Math.exp(x) + Math.exp(-x)) * 0.5;
  },
  /**
   * Sine hyperbolicus of x.
   * @function
   * @param {Number} x The number the sine hyperbolicus will be calculated of.
   * @returns {Number} Sine hyperbolicus of the given value.
   */
  sinh: Math.sinh || function(x) {
    return (Math.exp(x) - Math.exp(-x)) * 0.5;
  },
  /**
   * Hyperbolic arc-cosine of a number.
   *
   * @param {Number} x
   * @returns {Number}
   */
  acosh: Math.acosh || function(x) {
    return Math.log(x + Math.sqrt(x * x - 1));
  },
  /**
   * Hyperbolic arcsine of a number
   * @param {Number} x
   * @returns {Number}
   */
  asinh: Math.asinh || function(x) {
    if (x === -Infinity) {
      return x;
    }
    return Math.log(x + Math.sqrt(x * x + 1));
  },
  /**
   * Computes the cotangent of x.
   * @function
   * @param {Number} x The number the cotangent will be calculated of.
   * @returns {Number} Cotangent of the given value.
   */
  cot: function(x) {
    return 1 / Math.tan(x);
  },
  /**
   * Computes the inverse cotangent of x.
   * @param {Number} x The number the inverse cotangent will be calculated of.
   * @returns {Number} Inverse cotangent of the given value.
   */
  acot: function(x) {
    return (x >= 0 ? 0.5 : -0.5) * Math.PI - Math.atan(x);
  },
  /**
   * Compute n-th real root of a real number. n must be strictly positive integer.
   * If n is odd, the real n-th root exists and is negative.
   * For n even, for negative valuees of x NaN is returned
   * @param  {Number} x radicand. Must be non-negative, if n even.
   * @param  {Number} n index of the root. must be strictly positive integer.
   * @returns {Number} returns real root or NaN
   *
   * @example
   * nthroot(16, 4): 2
   * nthroot(-27, 3): -3
   * nthroot(-4, 2): NaN
   */
  nthroot: function(x, n) {
    var inv = 1 / n;
    if (n <= 0 || Math.floor(n) !== n) {
      return NaN;
    }
    if (x === 0) {
      return 0;
    }
    if (x > 0) {
      return Math.exp(inv * Math.log(x));
    }
    if (n % 2 === 1) {
      return -Math.exp(inv * Math.log(-x));
    }
    return NaN;
  },
  /**
   * Computes cube root of real number
   * Polyfill for Math.cbrt().
   *
   * @function
   * @param  {Number} x Radicand
   * @returns {Number} Cube root of x.
   */
  cbrt: Math.cbrt || function(x) {
    return this.nthroot(x, 3);
  },
  /**
   * Compute base to the power of exponent.
   * @param {Number} base
   * @param {Number} exponent
   * @returns {Number} base to the power of exponent.
   */
  pow: function(base, exponent) {
    if (base === 0) {
      if (exponent === 0) {
        return 1;
      }
      return 0;
    }
    if (Math.floor(exponent) === exponent) {
      return Math.pow(base, exponent);
    }
    if (base > 0) {
      return Math.exp(exponent * Math.log(base));
    }
    return NaN;
  },
  /**
   * Compute base to the power of the rational exponent m / n.
   * This function first reduces the fraction m/n and then computes
   * JXG.Math.pow(base, m/n).
   *
   * This function is necessary to have the same results for e.g.
   * (-8)^(1/3) = (-8)^(2/6) = -2
   * @param {Number} base
   * @param {Number} m numerator of exponent
   * @param {Number} n denominator of exponent
   * @returns {Number} base to the power of exponent.
   */
  ratpow: function(base, m, n) {
    var g;
    if (m === 0) {
      return 1;
    }
    if (n === 0) {
      return NaN;
    }
    g = this.gcd(m, n);
    return this.nthroot(this.pow(base, m / g), n / g);
  },
  /**
   * Logarithm to base 10.
   * @param {Number} x
   * @returns {Number} log10(x) Logarithm of x to base 10.
   */
  log10: function(x) {
    return Math.log(x) / Math.log(10);
  },
  /**
   * Logarithm to base 2.
   * @param {Number} x
   * @returns {Number} log2(x) Logarithm of x to base 2.
   */
  log2: function(x) {
    return Math.log(x) / Math.log(2);
  },
  /**
   * Logarithm to arbitrary base b. If b is not given, natural log is taken, i.e. b = e.
   * @param {Number} x
   * @param {Number} b base
   * @returns {Number} log(x, b) Logarithm of x to base b, that is log(x)/log(b).
   */
  log: function(x, b) {
    if (b !== void 0 && type_default.isNumber(b)) {
      return Math.log(x) / Math.log(b);
    }
    return Math.log(x);
  },
  /**
   * The sign() function returns the sign of a number, indicating whether the number is positive, negative or zero.
   *
   * @function
   * @param  {Number} x A Number
   * @returns {Number}  This function has 5 kinds of return values,
   *    1, -1, 0, -0, NaN, which represent "positive number", "negative number", "positive zero", "negative zero"
   *    and NaN respectively.
   */
  sign: Math.sign || function(x) {
    x = +x;
    if (x === 0 || isNaN(x)) {
      return x;
    }
    return x > 0 ? 1 : -1;
  },
  /**
   * A square & multiply algorithm to compute base to the power of exponent.
   * Implementated by Wolfgang Riedl.
   *
   * @param {Number} base
   * @param {Number} exponent
   * @returns {Number} Base to the power of exponent
   */
  squampow: function(base, exponent) {
    var result;
    if (Math.floor(exponent) === exponent) {
      result = 1;
      if (exponent < 0) {
        base = 1 / base;
        exponent *= -1;
      }
      while (exponent !== 0) {
        if (exponent & 1) {
          result *= base;
        }
        exponent >>= 1;
        base *= base;
      }
      return result;
    }
    return this.pow(base, exponent);
  },
  /**
   * Greatest common divisor (gcd) of two numbers.
   * @see <a href="https://rosettacode.org/wiki/Greatest_common_divisor#JavaScript">rosettacode.org</a>
   *
   * @param  {Number} a First number
   * @param  {Number} b Second number
   * @returns {Number}   gcd(a, b) if a and b are numbers, NaN else.
   */
  gcd: function(a, b) {
    var tmp, endless = true;
    a = Math.abs(a);
    b = Math.abs(b);
    if (!(type_default.isNumber(a) && type_default.isNumber(b))) {
      return NaN;
    }
    if (b > a) {
      tmp = a;
      a = b;
      b = tmp;
    }
    while (endless) {
      a %= b;
      if (a === 0) {
        return b;
      }
      b %= a;
      if (b === 0) {
        return a;
      }
    }
  },
  /**
   * Least common multiple (lcm) of two numbers.
   *
   * @param  {Number} a First number
   * @param  {Number} b Second number
   * @returns {Number}   lcm(a, b) if a and b are numbers, NaN else.
   */
  lcm: function(a, b) {
    var ret;
    if (!(type_default.isNumber(a) && type_default.isNumber(b))) {
      return NaN;
    }
    ret = a * b;
    if (ret !== 0) {
      return ret / this.gcd(a, b);
    }
    return 0;
  },
  /**
   * Special use of Math.round function to round not only to integers but also to chosen decimal values.
   *
   * @param {Number} value Value to be rounded.
   * @param {Number} step Distance between the values to be rounded to. (default: 1.0)
   * @param {Number} [min] If set, it will be returned the maximum of value and min.
   * @param {Number} [max] If set, it will be returned the minimum of value and max.
   * @returns {Number} Fitted value.
   */
  roundToStep: function(value, step, min, max) {
    var n = value, tmp, minOr0;
    if (!type_default.exists(step) && !type_default.exists(min) && !type_default.exists(max)) {
      return n;
    }
    if (jxg_default.exists(max)) {
      n = Math.min(n, max);
    }
    if (jxg_default.exists(min)) {
      n = Math.max(n, min);
    }
    minOr0 = min || 0;
    if (jxg_default.exists(step)) {
      tmp = (n - minOr0) / step;
      if (Number.isInteger(tmp)) {
        return n;
      }
      tmp = Math.round(tmp);
      n = minOr0 + tmp * step;
    }
    if (jxg_default.exists(max)) {
      n = Math.min(n, max);
    }
    if (jxg_default.exists(min)) {
      n = Math.max(n, min);
    }
    return n;
  },
  /**
   *  Error function, see {@link https://en.wikipedia.org/wiki/Error_function}.
   *
   * @see JXG.Math.PropFunc.erf
   * @param  {Number} x
   * @returns {Number}
   */
  erf: function(x) {
    return this.ProbFuncs.erf(x);
  },
  /**
   * Complementary error function, i.e. 1 - erf(x).
   *
   * @see JXG.Math.erf
   * @see JXG.Math.PropFunc.erfc
   * @param  {Number} x
   * @returns {Number}
   */
  erfc: function(x) {
    return this.ProbFuncs.erfc(x);
  },
  /**
   * Inverse of error function
   *
   * @see JXG.Math.erf
   * @see JXG.Math.PropFunc.erfi
   * @param  {Number} x
   * @returns {Number}
   */
  erfi: function(x) {
    return this.ProbFuncs.erfi(x);
  },
  /**
   * Normal distribution function
   *
   * @see JXG.Math.PropFunc.ndtr
   * @param  {Number} x
   * @returns {Number}
   */
  ndtr: function(x) {
    return this.ProbFuncs.ndtr(x);
  },
  /**
   * Inverse of normal distribution function
   *
   * @see JXG.Math.ndtr
   * @see JXG.Math.PropFunc.ndtri
   * @param  {Number} x
   * @returns {Number}
   */
  ndtri: function(x) {
    return this.ProbFuncs.ndtri(x);
  },
  /**
   * Returns sqrt(a * a + b * b) for a variable number of arguments.
   * This is a naive implementation which might be faster than Math.hypot.
   * The latter is numerically more stable.
   *
   * @param {Number} a Variable number of arguments.
   * @returns Number
   */
  hypot: function() {
    var i2, le, a, sum;
    le = arguments.length;
    for (i2 = 0, sum = 0; i2 < le; i2++) {
      a = arguments[i2];
      sum += a * a;
    }
    return Math.sqrt(sum);
  },
  /**
   * Heaviside unit step function. Returns 0 for x &lt;, 1 for x &gt; 0, and 0.5 for x == 0.
   *
   * @param {Number} x
   * @returns Number
   */
  hstep: function(x) {
    return x > 0 ? 1 : x < 0 ? 0 : 0.5;
  },
  /* ********************  Comparisons and logical operators ************** */
  /**
   * Logical test: a < b?
   *
   * @param {Number} a
   * @param {Number} b
   * @returns {Boolean}
   */
  lt: function(a, b) {
    return a < b;
  },
  /**
   * Logical test: a <= b?
   *
   * @param {Number} a
   * @param {Number} b
   * @returns {Boolean}
   */
  leq: function(a, b) {
    return a <= b;
  },
  /**
   * Logical test: a > b?
   *
   * @param {Number} a
   * @param {Number} b
   * @returns {Boolean}
   */
  gt: function(a, b) {
    return a > b;
  },
  /**
   * Logical test: a >= b?
   *
   * @param {Number} a
   * @param {Number} b
   * @returns {Boolean}
   */
  geq: function(a, b) {
    return a >= b;
  },
  /**
   * Logical test: a === b?
   *
   * @param {Number} a
   * @param {Number} b
   * @returns {Boolean}
   */
  eq: function(a, b) {
    return a === b;
  },
  /**
   * Logical test: a !== b?
   *
   * @param {Number} a
   * @param {Number} b
   * @returns {Boolean}
   */
  neq: function(a, b) {
    return a !== b;
  },
  /**
   * Logical operator: a && b?
   *
   * @param {Boolean} a
   * @param {Boolean} b
   * @returns {Boolean}
   */
  and: function(a, b) {
    return a && b;
  },
  /**
   * Logical operator: !a?
   *
   * @param {Boolean} a
   * @returns {Boolean}
   */
  not: function(a) {
    return !a;
  },
  /**
   * Logical operator: a || b?
   *
   * @param {Boolean} a
   * @param {Boolean} b
   * @returns {Boolean}
   */
  or: function(a, b) {
    return a || b;
  },
  /**
   * Logical operator: either a or b?
   *
   * @param {Boolean} a
   * @param {Boolean} b
   * @returns {Boolean}
   */
  xor: function(a, b) {
    return (a || b) && !(a && b);
  },
  /**
   *
   * Convert a floating point number to sign + integer + fraction.
   * fraction is given as nominator and denominator.
   * <p>
   * Algorithm: approximate the floating point number
   * by a continued fraction and simultaneously keep track
   * of its convergents.
   * Inspired by {@link https://kevinboone.me/rationalize.html}.
   *
   * @param {Number} x Number which is to be converted
   * @param {Number} [order=0.001] Small number determining the approximation precision.
   * @returns {Array} [sign, leading, nominator, denominator] where sign is 1 or -1.
   * @see JXG#toFraction
   *
   * @example
   * JXG.Math.decToFraction(0.33333333);
   * // Result: [ 1, 0, 1, 3 ]
   *
   * JXG.Math.decToFraction(0);
   * // Result: [ 1, 0, 0, 1 ]
   *
   * JXG.Math.decToFraction(-10.66666666666667);
   * // Result: [-1, 10, 2, 3 ]
  */
  decToFraction: function(x, order) {
    var lead, sign, a, n, n1, n2, d, d1, d2, it = 0, maxit = 20;
    order = type_default.def(order, 1e-3);
    x = Math.round(x * 1e12) * 1e-12;
    sign = x < 0 ? -1 : 1;
    x = Math.abs(x);
    lead = Math.floor(x);
    x -= Math.floor(x);
    a = 0;
    n2 = 1;
    n = n1 = a;
    d2 = 0;
    d = d1 = 1;
    while (x - Math.floor(x) > order && it < maxit) {
      x = 1 / (x - a);
      a = Math.floor(x);
      n = n2 + a * n1;
      d = d2 + a * d1;
      n2 = n1;
      d2 = d1;
      n1 = n;
      d1 = d;
      it++;
    }
    return [sign, lead, n, d];
  },
  /* *************************** Normalize *************************** */
  /**
   * Normalize the standard form [c, b0, b1, a, k, r, q0, q1].
   * @private
   * @param {Array} stdform The standard form to be normalized.
   * @returns {Array} The normalized standard form.
   */
  normalize: function(stdform) {
    var n, signr, a2 = 2 * stdform[3], r = stdform[4] / a2;
    stdform[5] = r;
    stdform[6] = -stdform[1] / a2;
    stdform[7] = -stdform[2] / a2;
    if (!isFinite(r)) {
      n = this.hypot(stdform[1], stdform[2]);
      stdform[0] /= n;
      stdform[1] /= n;
      stdform[2] /= n;
      stdform[3] = 0;
      stdform[4] = 1;
    } else if (Math.abs(r) >= 1) {
      stdform[0] = (stdform[6] * stdform[6] + stdform[7] * stdform[7] - r * r) / (2 * r);
      stdform[1] = -stdform[6] / r;
      stdform[2] = -stdform[7] / r;
      stdform[3] = 1 / (2 * r);
      stdform[4] = 1;
    } else {
      signr = r <= 0 ? -1 : 1;
      stdform[0] = signr * (stdform[6] * stdform[6] + stdform[7] * stdform[7] - r * r) * 0.5;
      stdform[1] = -signr * stdform[6];
      stdform[2] = -signr * stdform[7];
      stdform[3] = signr / 2;
      stdform[4] = signr * r;
    }
    return stdform;
  },
  /**
   * Converts a two dimensional array to a one dimensional Float32Array that can be processed by WebGL.
   * @param {Array} m A matrix in a two dimensional array.
   * @returns {Float32Array} A one dimensional array containing the matrix in column wise notation. Provides a fall
   * back to the default JavaScript Array if Float32Array is not available.
   */
  toGL: function(m) {
    var v, i2, j;
    if (typeof Float32Array === "function") {
      v = new Float32Array(16);
    } else {
      v = new Array(16);
    }
    if (m.length !== 4 && m[0].length !== 4) {
      return v;
    }
    for (i2 = 0; i2 < 4; i2++) {
      for (j = 0; j < 4; j++) {
        v[i2 + 4 * j] = m[i2][j];
      }
    }
    return v;
  },
  /**
   * Theorem of Vieta: Given a set of simple zeroes x_0, ..., x_n
   * of a polynomial f, compute the coefficients s_k, (k=0,...,n-1)
   * of the polynomial of the form. See {@link https://de.wikipedia.org/wiki/Elementarsymmetrisches_Polynom}.
   * <p>
   *  f(x) = (x-x_0)*...*(x-x_n) =
   *  x^n + sum_{k=1}^{n} (-1)^(k) s_{k-1} x^(n-k)
   * </p>
   * @param {Array} x Simple zeroes of the polynomial.
   * @returns {Array} Coefficients of the polynomial.
   *
   */
  Vieta: function(x) {
    var n = x.length, s = [], m, k, y;
    s = x.slice();
    for (m = 1; m < n; ++m) {
      y = s[m];
      s[m] *= s[m - 1];
      for (k = m - 1; k >= 1; --k) {
        s[k] += s[k - 1] * y;
      }
      s[0] += y;
    }
    return s;
  }
};
var math_default = jxg_default.Math;

// node_modules/jsxgraph/src/utils/type.js
jxg_default.extend(
  jxg_default,
  /** @lends JXG */
  {
    /**
     * Checks if the given object is an JSXGraph board.
     * @param {Object} v
     * @returns {Boolean}
     */
    isBoard: function(v) {
      return v !== null && typeof v === "object" && this.isNumber(v.BOARD_MODE_NONE) && this.isObject(v.objects) && this.isObject(v.jc) && this.isFunction(v.update) && !!v.containerObj && this.isString(v.id);
    },
    /**
     * Checks if the given string is an id within the given board.
     * @param {JXG.Board} board
     * @param {String} s
     * @returns {Boolean}
     */
    isId: function(board, s) {
      return typeof s === "string" && !!board.objects[s];
    },
    /**
     * Checks if the given string is a name within the given board.
     * @param {JXG.Board} board
     * @param {String} s
     * @returns {Boolean}
     */
    isName: function(board, s) {
      return typeof s === "string" && !!board.elementsByName[s];
    },
    /**
     * Checks if the given string is a group id within the given board.
     * @param {JXG.Board} board
     * @param {String} s
     * @returns {Boolean}
     */
    isGroup: function(board, s) {
      return typeof s === "string" && !!board.groups[s];
    },
    /**
     * Checks if the value of a given variable is of type string.
     * @param v A variable of any type.
     * @returns {Boolean} True, if v is of type string.
     */
    isString: function(v) {
      return typeof v === "string";
    },
    /**
     * Checks if the value of a given variable is of type number.
     * @param v A variable of any type.
     * @param {Boolean} [acceptStringNumber=false] If set to true, the function returns true for e.g. v='3.1415'.
     * @param {Boolean} [acceptNaN=true] If set to false, the function returns false for v=NaN.
     * @returns {Boolean} True, if v is of type number.
     */
    isNumber: function(v, acceptStringNumber, acceptNaN) {
      var result = typeof v === "number" || Object.prototype.toString.call(v) === "[Object Number]";
      acceptStringNumber = acceptStringNumber || false;
      acceptNaN = acceptNaN === void 0 ? true : acceptNaN;
      if (acceptStringNumber) {
        result = result || "" + parseFloat(v) === v;
      }
      if (!acceptNaN) {
        result = result && !isNaN(v);
      }
      return result;
    },
    /**
     * Checks if a given variable references a function.
     * @param v A variable of any type.
     * @returns {Boolean} True, if v is a function.
     */
    isFunction: function(v) {
      return typeof v === "function";
    },
    /**
     * Checks if a given variable references an array.
     * @param v A variable of any type.
     * @returns {Boolean} True, if v is of type array.
     */
    isArray: function(v) {
      var r;
      if (Array.isArray) {
        r = Array.isArray(v);
      } else {
        r = v !== null && typeof v === "object" && typeof v.splice === "function" && typeof v.join === "function";
      }
      return r;
    },
    /**
     * Tests if the input variable is an Object
     * @param v
     */
    isObject: function(v) {
      return typeof v === "object" && !this.isArray(v);
    },
    /**
     * Tests if the input variable is a DOM Document or DocumentFragment node
     * @param v A variable of any type
     */
    isDocumentOrFragment: function(v) {
      return this.isObject(v) && (v.nodeType === 9 || // Node.DOCUMENT_NODE
      v.nodeType === 11);
    },
    /**
     * Checks if a given variable is a reference of a JSXGraph Point element.
     * @param v A variable of any type.
     * @returns {Boolean} True, if v is of type JXG.Point.
     */
    isPoint: function(v) {
      if (v !== null && typeof v === "object" && this.exists(v.elementClass)) {
        return v.elementClass === constants_default.OBJECT_CLASS_POINT;
      }
      return false;
    },
    isPoint3D: function(v) {
      if (v !== null && typeof v === "object" && this.exists(v.elType)) {
        return v.elType === "point3d";
      }
      return false;
    },
    /**
     * Checks if a given variable is a reference of a JSXGraph Point element or an array of length at least two or
     * a function returning an array of length two or three.
     * @param {JXG.Board} board
     * @param v A variable of any type.
     * @returns {Boolean} True, if v is of type JXG.Point.
     */
    isPointType: function(board, v) {
      var val, p;
      if (this.isArray(v)) {
        return true;
      }
      if (this.isFunction(v)) {
        val = v();
        if (this.isArray(val) && val.length > 1) {
          return true;
        }
      }
      p = board.select(v);
      return this.isPoint(p);
    },
    /**
     * Checks if a given variable is a reference of a JSXGraph transformation element or an array
     * of JSXGraph transformation elements.
     * @param v A variable of any type.
     * @returns {Boolean} True, if v is of type JXG.Transformation.
     */
    isTransformationOrArray: function(v) {
      if (v !== null) {
        if (this.isArray(v) && v.length > 0) {
          return this.isTransformationOrArray(v[0]);
        }
        if (typeof v === "object") {
          return v.type === constants_default.OBJECT_TYPE_TRANSFORMATION;
        }
      }
      return false;
    },
    /**
     * Checks if v is an empty object or empty.
     * @param v {Object|Array}
     * @returns {boolean} True, if v is an empty object or array.
     */
    isEmpty: function(v) {
      return Object.keys(v).length === 0;
    },
    /**
     * Checks if a given variable is neither undefined nor null. You should not use this together with global
     * variables!
     * @param v A variable of any type.
     * @param {Boolean} [checkEmptyString=false] If set to true, it is also checked whether v is not equal to ''.
     * @returns {Boolean} True, if v is neither undefined nor null.
     */
    exists: function(v, checkEmptyString) {
      var result = !(v == void 0 || v === null);
      checkEmptyString = checkEmptyString || false;
      if (checkEmptyString) {
        return result && v !== "";
      }
      return result;
    },
    // exists: (function (undef) {
    //     return function (v, checkEmptyString) {
    //         var result = !(v === undef || v === null);
    //         checkEmptyString = checkEmptyString || false;
    //         if (checkEmptyString) {
    //             return result && v !== '';
    //         }
    //         return result;
    //     };
    // }()),
    /**
     * Handle default parameters.
     * @param v Given value
     * @param d Default value
     * @returns <tt>d</tt>, if <tt>v</tt> is undefined or null.
     */
    def: function(v, d) {
      if (this.exists(v)) {
        return v;
      }
      return d;
    },
    /**
     * Converts a string containing either <strong>true</strong> or <strong>false</strong> into a boolean value.
     * @param {String} s String containing either <strong>true</strong> or <strong>false</strong>.
     * @returns {Boolean} String typed boolean value converted to boolean.
     */
    str2Bool: function(s) {
      if (!this.exists(s)) {
        return true;
      }
      if (typeof s === "boolean") {
        return s;
      }
      if (this.isString(s)) {
        return s.toLowerCase() === "true";
      }
      return false;
    },
    /**
     * Converts a given CSS style string into a JavaScript object.
     * @param {String} styles String containing CSS styles.
     * @returns {Object} Object containing CSS styles.
     */
    cssParse: function(styles) {
      var str2 = styles;
      if (!this.isString(str2))
        return {};
      str2 = str2.replace(/\s*;\s*$/g, "");
      str2 = str2.replace(/\s*;\s*/g, '","');
      str2 = str2.replace(/\s*:\s*/g, '":"');
      str2 = str2.trim();
      str2 = '{"' + str2 + '"}';
      return JSON.parse(str2);
    },
    /**
     * Converts a given object into a CSS style string.
     * @param {Object} styles Object containing CSS styles.
     * @returns {String} String containing CSS styles.
     */
    cssStringify: function(styles) {
      var str2 = "", attr, val;
      if (!this.isObject(styles))
        return "";
      for (attr in styles) {
        if (!styles.hasOwnProperty(attr))
          continue;
        val = styles[attr];
        if (!this.isString(val) && !this.isNumber(val))
          continue;
        str2 += attr + ":" + val + "; ";
      }
      str2 = str2.trim();
      return str2;
    },
    /**
     * Convert a String, a number or a function into a function. This method is used in Transformation.js
     * @param {JXG.Board} board Reference to a JSXGraph board. It is required to resolve dependencies given
     * by a JessieCode string, thus it must be a valid reference only in case one of the param
     * values is of type string.
     * @param {Array} param An array containing strings, numbers, or functions.
     * @param {Number} n Length of <tt>param</tt>.
     * @returns {Function} A function taking one parameter k which specifies the index of the param element
     * to evaluate.
     */
    createEvalFunction: function(board, param, n) {
      var f = [], func, i2, e, deps = {};
      for (i2 = 0; i2 < n; i2++) {
        f[i2] = jxg_default.createFunction(param[i2], board);
        for (e in f[i2].deps) {
          deps[e] = f[i2].deps;
        }
      }
      func = function(k) {
        return f[k]();
      };
      func.deps = deps;
      return func;
    },
    /**
     * Convert a String, number or function into a function.
     * @param {String|Number|Function} term A variable of type string, function or number.
     * @param {JXG.Board} board Reference to a JSXGraph board. It is required to resolve dependencies given
     * by a JessieCode/GEONE<sub>X</sub>T string, thus it must be a valid reference only in case one of the param
     * values is of type string.
     * @param {String} variableName Only required if function is supplied as JessieCode string or evalGeonext is set to true.
     * Describes the variable name of the variable in a JessieCode/GEONE<sub>X</sub>T string given as term.
     * @param {Boolean} [evalGeonext=false] Obsolete and ignored! Set this true
     * if term should be treated as a GEONE<sub>X</sub>T string.
     * @returns {Function} A function evaluating the value given by term or null if term is not of type string,
     * function or number.
     */
    createFunction: function(term, board, variableName, evalGeonext) {
      var f = null;
      if (this.isString(term)) {
        f = board.jc.snippet(term, true, variableName, false);
      } else if (this.isFunction(term)) {
        f = term;
        f.deps = {};
      } else if (this.isNumber(term)) {
        f = function() {
          return term;
        };
        f.deps = {};
      }
      if (f !== null) {
        f.origin = term;
      }
      return f;
    },
    /**
     *  Test if the parents array contains existing points. If instead parents contains coordinate arrays or
     *  function returning coordinate arrays
     *  free points with these coordinates are created.
     *
     * @param {JXG.Board} board Board object
     * @param {Array} parents Array containing parent elements for a new object. This array may contain
     *    <ul>
     *      <li> {@link JXG.Point} objects
     *      <li> {@link JXG.GeometryElement#name} of {@link JXG.Point} objects
     *      <li> {@link JXG.GeometryElement#id} of {@link JXG.Point} objects
     *      <li> Coordinates of points given as array of numbers of length two or three, e.g. [2, 3].
     *      <li> Coordinates of points given as array of functions of length two or three. Each function returns one coordinate, e.g.
     *           [function(){ return 2; }, function(){ return 3; }]
     *      <li> Function returning coordinates, e.g. function() { return [2, 3]; }
     *    </ul>
     *  In the last three cases a new point will be created.
     * @param {String} attrClass Main attribute class of newly created points, see {@link JXG#copyAttributes}
     * @param {Array} attrArray List of subtype attributes for the newly created points. The list of subtypes is mapped to the list of new points.
     * @returns {Array} List of newly created {@link JXG.Point} elements or false if not all returned elements are points.
     */
    providePoints: function(board, parents, attributes, attrClass, attrArray) {
      var i2, j, len, lenAttr = 0, points = [], attr, val;
      if (!this.isArray(parents)) {
        parents = [parents];
      }
      len = parents.length;
      if (this.exists(attrArray)) {
        lenAttr = attrArray.length;
      }
      if (lenAttr === 0) {
        attr = this.copyAttributes(attributes, board.options, attrClass);
      }
      for (i2 = 0; i2 < len; ++i2) {
        if (lenAttr > 0) {
          j = Math.min(i2, lenAttr - 1);
          attr = this.copyAttributes(
            attributes,
            board.options,
            attrClass,
            attrArray[j].toLowerCase()
          );
        }
        if (this.isArray(parents[i2]) && parents[i2].length > 1) {
          points.push(board.create("point", parents[i2], attr));
          points[points.length - 1]._is_new = true;
        } else if (this.isFunction(parents[i2])) {
          val = parents[i2]();
          if (this.isArray(val) && val.length > 1) {
            points.push(board.create("point", [parents[i2]], attr));
            points[points.length - 1]._is_new = true;
          }
        } else {
          points.push(board.select(parents[i2]));
        }
        if (!this.isPoint(points[i2])) {
          return false;
        }
      }
      return points;
    },
    /**
     *  Test if the parents array contains existing points. If instead parents contains coordinate arrays or
     *  function returning coordinate arrays
     *  free points with these coordinates are created.
     *
     * @param {JXG.View3D} view View3D object
     * @param {Array} parents Array containing parent elements for a new object. This array may contain
     *    <ul>
     *      <li> {@link JXG.Point3D} objects
     *      <li> {@link JXG.GeometryElement#name} of {@link JXG.Point3D} objects
     *      <li> {@link JXG.GeometryElement#id} of {@link JXG.Point3D} objects
     *      <li> Coordinates of 3D points given as array of numbers of length three, e.g. [2, 3, 1].
     *      <li> Coordinates of 3D points given as array of functions of length three. Each function returns one coordinate, e.g.
     *           [function(){ return 2; }, function(){ return 3; }, function(){ return 1; }]
     *      <li> Function returning coordinates, e.g. function() { return [2, 3, 1]; }
     *    </ul>
     *  In the last three cases a new 3D point will be created.
     * @param {String} attrClass Main attribute class of newly created 3D points, see {@link JXG#copyAttributes}
     * @param {Array} attrArray List of subtype attributes for the newly created 3D points. The list of subtypes is mapped to the list of new 3D points.
     * @returns {Array} List of newly created {@link JXG.Point3D} elements or false if not all returned elements are 3D points.
     */
    providePoints3D: function(view, parents, attributes, attrClass, attrArray) {
      var i2, j, len, lenAttr = 0, points = [], attr, val;
      if (!this.isArray(parents)) {
        parents = [parents];
      }
      len = parents.length;
      if (this.exists(attrArray)) {
        lenAttr = attrArray.length;
      }
      if (lenAttr === 0) {
        attr = this.copyAttributes(attributes, view.board.options, attrClass);
      }
      for (i2 = 0; i2 < len; ++i2) {
        if (lenAttr > 0) {
          j = Math.min(i2, lenAttr - 1);
          attr = this.copyAttributes(
            attributes,
            view.board.options,
            attrClass,
            attrArray[j]
          );
        }
        if (this.isArray(parents[i2]) && parents[i2].length > 1) {
          points.push(view.create("point3d", parents[i2], attr));
          points[points.length - 1]._is_new = true;
        } else if (this.isFunction(parents[i2])) {
          val = parents[i2]();
          if (this.isArray(val) && val.length > 1) {
            points.push(view.create("point3d", [parents[i2]], attr));
            points[points.length - 1]._is_new = true;
          }
        } else {
          points.push(view.select(parents[i2]));
        }
        if (!this.isPoint3D(points[i2])) {
          return false;
        }
      }
      return points;
    },
    /**
     * Generates a function which calls the function fn in the scope of owner.
     * @param {Function} fn Function to call.
     * @param {Object} owner Scope in which fn is executed.
     * @returns {Function} A function with the same signature as fn.
     */
    bind: function(fn, owner) {
      return function() {
        return fn.apply(owner, arguments);
      };
    },
    /**
     * If <tt>val</tt> is a function, it will be evaluated without giving any parameters, else the input value
     * is just returned.
     * @param val Could be anything. Preferably a number or a function.
     * @returns If <tt>val</tt> is a function, it is evaluated and the result is returned. Otherwise <tt>val</tt> is returned.
     */
    evaluate: function(val) {
      if (this.isFunction(val)) {
        return val();
      }
      return val;
    },
    /**
     * Search an array for a given value.
     * @param {Array} array
     * @param value
     * @param {String} [sub] Use this property if the elements of the array are objects.
     * @returns {Number} The index of the first appearance of the given value, or
     * <tt>-1</tt> if the value was not found.
     */
    indexOf: function(array, value, sub) {
      var i2, s = this.exists(sub);
      if (Array.indexOf && !s) {
        return array.indexOf(value);
      }
      for (i2 = 0; i2 < array.length; i2++) {
        if (s && array[i2][sub] === value || !s && array[i2] === value) {
          return i2;
        }
      }
      return -1;
    },
    /**
     * Eliminates duplicate entries in an array consisting of numbers and strings.
     * @param {Array} a An array of numbers and/or strings.
     * @returns {Array} The array with duplicate entries eliminated.
     */
    eliminateDuplicates: function(a) {
      var i2, len = a.length, result = [], obj = {};
      for (i2 = 0; i2 < len; i2++) {
        obj[a[i2]] = 0;
      }
      for (i2 in obj) {
        if (obj.hasOwnProperty(i2)) {
          result.push(i2);
        }
      }
      return result;
    },
    /**
     * Swaps to array elements.
     * @param {Array} arr
     * @param {Number} i
     * @param {Number} j
     * @returns {Array} Reference to the given array.
     */
    swap: function(arr, i2, j) {
      var tmp;
      tmp = arr[i2];
      arr[i2] = arr[j];
      arr[j] = tmp;
      return arr;
    },
    /**
     * Generates a copy of an array and removes the duplicate entries. The original
     * Array will be altered.
     * @param {Array} arr
     * @returns {Array}
     */
    uniqueArray: function(arr) {
      var i2, j, isArray2, ret = [];
      if (arr.length === 0) {
        return [];
      }
      for (i2 = 0; i2 < arr.length; i2++) {
        isArray2 = this.isArray(arr[i2]);
        if (!this.exists(arr[i2])) {
          arr[i2] = "";
          continue;
        }
        for (j = i2 + 1; j < arr.length; j++) {
          if (isArray2 && jxg_default.cmpArrays(arr[i2], arr[j])) {
            arr[i2] = [];
          } else if (!isArray2 && arr[i2] === arr[j]) {
            arr[i2] = "";
          }
        }
      }
      j = 0;
      for (i2 = 0; i2 < arr.length; i2++) {
        isArray2 = this.isArray(arr[i2]);
        if (!isArray2 && arr[i2] !== "") {
          ret[j] = arr[i2];
          j++;
        } else if (isArray2 && arr[i2].length !== 0) {
          ret[j] = arr[i2].slice(0);
          j++;
        }
      }
      arr = ret;
      return ret;
    },
    /**
     * Checks if an array contains an element equal to <tt>val</tt> but does not check the type!
     * @param {Array} arr
     * @param val
     * @returns {Boolean}
     */
    isInArray: function(arr, val) {
      return jxg_default.indexOf(arr, val) > -1;
    },
    /**
     * Converts an array of {@link JXG.Coords} objects into a coordinate matrix.
     * @param {Array} coords
     * @param {Boolean} split
     * @returns {Array}
     */
    coordsArrayToMatrix: function(coords, split) {
      var i2, x = [], m = [];
      for (i2 = 0; i2 < coords.length; i2++) {
        if (split) {
          x.push(coords[i2].usrCoords[1]);
          m.push(coords[i2].usrCoords[2]);
        } else {
          m.push([coords[i2].usrCoords[1], coords[i2].usrCoords[2]]);
        }
      }
      if (split) {
        m = [x, m];
      }
      return m;
    },
    /**
     * Compare two arrays.
     * @param {Array} a1
     * @param {Array} a2
     * @returns {Boolean} <tt>true</tt>, if the arrays coefficients are of same type and value.
     */
    cmpArrays: function(a1, a2) {
      var i2;
      if (a1 === a2) {
        return true;
      }
      if (a1.length !== a2.length) {
        return false;
      }
      for (i2 = 0; i2 < a1.length; i2++) {
        if (this.isArray(a1[i2]) && this.isArray(a2[i2])) {
          if (!this.cmpArrays(a1[i2], a2[i2])) {
            return false;
          }
        } else if (a1[i2] !== a2[i2]) {
          return false;
        }
      }
      return true;
    },
    /**
     * Removes an element from the given array
     * @param {Array} ar
     * @param el
     * @returns {Array}
     */
    removeElementFromArray: function(ar, el) {
      var i2;
      for (i2 = 0; i2 < ar.length; i2++) {
        if (ar[i2] === el) {
          ar.splice(i2, 1);
          return ar;
        }
      }
      return ar;
    },
    /**
     * Truncate a number <tt>n</tt> after <tt>p</tt> decimals.
     * @param {Number} n
     * @param {Number} p
     * @returns {Number}
     */
    trunc: function(n, p) {
      p = jxg_default.def(p, 0);
      return this.toFixed(n, p);
    },
    /**
     * Decimal adjustment of a number.
     * From https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Math/round
     *
     * @param    {String}    type    The type of adjustment.
     * @param    {Number}    value    The number.
     * @param    {Number}    exp        The exponent (the 10 logarithm of the adjustment base).
     * @returns    {Number}            The adjusted value.
     *
     * @private
     */
    _decimalAdjust: function(type, value, exp) {
      if (exp === void 0 || +exp === 0) {
        return Math[type](value);
      }
      value = +value;
      exp = +exp;
      if (isNaN(value) || !(typeof exp === "number" && exp % 1 === 0)) {
        return NaN;
      }
      value = value.toString().split("e");
      value = Math[type](+(value[0] + "e" + (value[1] ? +value[1] - exp : -exp)));
      value = value.toString().split("e");
      return +(value[0] + "e" + (value[1] ? +value[1] + exp : exp));
    },
    /**
     * Round a number to given number of decimal digits.
     *
     * Example: JXG._toFixed(3.14159, -2) gives 3.14
     * @param  {Number} value Number to be rounded
     * @param  {Number} exp   Number of decimal digits given as negative exponent
     * @return {Number}       Rounded number.
     *
     * @private
     */
    _round10: function(value, exp) {
      return this._decimalAdjust("round", value, exp);
    },
    /**
     * "Floor" a number to given number of decimal digits.
     *
     * Example: JXG._toFixed(3.14159, -2) gives 3.14
     * @param  {Number} value Number to be floored
     * @param  {Number} exp   Number of decimal digits given as negative exponent
     * @return {Number}       "Floored" number.
     *
     * @private
     */
    _floor10: function(value, exp) {
      return this._decimalAdjust("floor", value, exp);
    },
    /**
     * "Ceil" a number to given number of decimal digits.
     *
     * Example: JXG._toFixed(3.14159, -2) gives 3.15
     * @param  {Number} value Number to be ceiled
     * @param  {Number} exp   Number of decimal digits given as negative exponent
     * @return {Number}       "Ceiled" number.
     *
     * @private
     */
    _ceil10: function(value, exp) {
      return this._decimalAdjust("ceil", value, exp);
    },
    /**
     * Replacement of the default toFixed() method.
     * It does a correct rounding (independent of the browser) and
     * returns "0.00" for toFixed(-0.000001, 2) instead of "-0.00" which
     * is returned by JavaScript's toFixed()
     *
     * @memberOf JXG
     * @param  {Number} num    Number tp be rounded
     * @param  {Number} digits Decimal digits
     * @return {String}        Rounded number is returned as string
     */
    toFixed: function(num, digits) {
      return this._round10(num, -digits).toFixed(digits);
    },
    /**
     * Truncate a number <tt>val</tt> automatically.
     * @memberOf JXG
     * @param val
     * @returns {Number}
     */
    autoDigits: function(val) {
      var x = Math.abs(val), str2;
      if (x >= 0.1) {
        str2 = this.toFixed(val, 2);
      } else if (x >= 0.01) {
        str2 = this.toFixed(val, 4);
      } else if (x >= 1e-4) {
        str2 = this.toFixed(val, 6);
      } else {
        str2 = val;
      }
      return str2;
    },
    parseNumber: function(v, percentOfWhat, convertPx, toUnit) {
      var str2;
      if (this.isString(v) && v.indexOf("%") > -1) {
        str2 = v.replace(/\s+%\s+/, "");
        return parseFloat(str2) * percentOfWhat * 0.01;
      }
      if (this.isString(v) && v.indexOf("fr") > -1) {
        str2 = v.replace(/\s+fr\s+/, "");
        return parseFloat(str2) * percentOfWhat;
      }
      if (this.isString(v) && v.indexOf("px") > -1) {
        str2 = v.replace(/\s+px\s+/, "");
        str2 = parseFloat(str2);
        if (this.isFunction(convertPx)) {
          return convertPx(str2);
        } else if (this.isNumber(convertPx)) {
          return str2 * convertPx;
        } else {
          return str2;
        }
      }
      return parseFloat(v);
    },
    parsePosition: function(str2) {
      var a, i2, side = "", pos = "";
      str2 = str2.trim();
      if (str2 !== "") {
        a = str2.split(/[ ,]+/);
        for (i2 = 0; i2 < a.length; i2++) {
          if (a[i2] in ["left", "right"]) {
            side = a[i2];
          } else {
            pos = a[i2];
          }
        }
      }
      return {
        side,
        pos
      };
    },
    /**
     * Extracts the keys of a given object.
     * @param object The object the keys are to be extracted
     * @param onlyOwn If true, hasOwnProperty() is used to verify that only keys are collected
     * the object owns itself and not some other object in the prototype chain.
     * @returns {Array} All keys of the given object.
     */
    keys: function(object, onlyOwn) {
      var keys2 = [], property;
      for (property in object) {
        if (onlyOwn) {
          if (object.hasOwnProperty(property)) {
            keys2.push(property);
          }
        } else {
          keys2.push(property);
        }
      }
      return keys2;
    },
    /**
     * This outputs an object with a base class reference to the given object. This is useful if
     * you need a copy of an e.g. attributes object and want to overwrite some of the attributes
     * without changing the original object.
     * @param {Object} obj Object to be embedded.
     * @returns {Object} An object with a base class reference to <tt>obj</tt>.
     */
    clone: function(obj) {
      var cObj = {};
      cObj.prototype = obj;
      return cObj;
    },
    /**
     * Embeds an existing object into another one just like {@link #clone} and copies the contents of the second object
     * to the new one. Warning: The copied properties of obj2 are just flat copies.
     * @param {Object} obj Object to be copied.
     * @param {Object} obj2 Object with data that is to be copied to the new one as well.
     * @returns {Object} Copy of given object including some new/overwritten data from obj2.
     */
    cloneAndCopy: function(obj, obj2) {
      var r, cObj = function() {
        return void 0;
      };
      cObj.prototype = obj;
      for (r in obj2) {
        cObj[r] = obj2[r];
      }
      return cObj;
    },
    /**
     * Recursively merges obj2 into obj1 in-place. Contrary to {@link JXG#deepCopy} this won't create a new object
     * but instead will overwrite obj1.
     * <p>
     * In contrast to method JXG.mergeAttr, merge recurses into any kind of object, e.g. DOM object and JSXGraph objects.
     * So, please be careful.
     * @param {Object} obj1
     * @param {Object} obj2
     * @returns {Object}
     * @see JXG#mergeAttr
     *
     * @example
     * JXG.Options = JXG.merge(JXG.Options, {
     *     board: {
     *         showNavigation: false,
     *         showInfobox: true
     *     },
     *     point: {
     *         face: 'o',
     *         size: 4,
     *         fillColor: '#eeeeee',
     *         highlightFillColor: '#eeeeee',
     *         strokeColor: 'white',
     *         highlightStrokeColor: 'white',
     *         showInfobox: 'inherit'
     *     }
     * });
     *
     * </pre><div id="JXGc5bf0f2a-bd5a-4612-97c2-09f17b1bbc6b" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGc5bf0f2a-bd5a-4612-97c2-09f17b1bbc6b',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     JXG.Options = JXG.merge(JXG.Options, {
     *         board: {
     *             showNavigation: false,
     *             showInfobox: true
     *         },
     *         point: {
     *             face: 'o',
     *             size: 4,
     *             fillColor: '#eeeeee',
     *             highlightFillColor: '#eeeeee',
     *             strokeColor: 'white',
     *             highlightStrokeColor: 'white',
     *             showInfobox: 'inherit'
     *         }
     *     });
     *
     *
     *     })();
     *
     * <\/script><pre>
     */
    merge: function(obj1, obj2) {
      var i2, j, o, oo;
      for (i2 in obj2) {
        if (obj2.hasOwnProperty(i2)) {
          o = obj2[i2];
          if (this.isArray(o)) {
            if (!obj1[i2]) {
              obj1[i2] = [];
            }
            for (j = 0; j < o.length; j++) {
              oo = obj2[i2][j];
              if (typeof obj2[i2][j] === "object") {
                obj1[i2][j] = this.merge(obj1[i2][j], oo);
              } else {
                obj1[i2][j] = obj2[i2][j];
              }
            }
          } else if (typeof o === "object") {
            if (!obj1[i2]) {
              obj1[i2] = {};
            }
            obj1[i2] = this.merge(obj1[i2], o);
          } else {
            if (typeof obj1 === "boolean") {
              obj1 = {};
            }
            obj1[i2] = o;
          }
        }
      }
      return obj1;
    },
    /**
     * Creates a deep copy of an existing object, i.e. arrays or sub-objects are copied component resp.
     * element-wise instead of just copying the reference. If a second object is supplied, the two objects
     * are merged into one object. The properties of the second object have priority.
     * @param {Object} obj This object will be copied.
     * @param {Object} obj2 This object will merged into the newly created object
     * @param {Boolean} [toLower=false] If true the keys are convert to lower case. This is needed for visProp, see JXG#copyAttributes
     * @returns {Object} copy of obj or merge of obj and obj2.
     */
    deepCopy: function(obj, obj2, toLower) {
      var c, i2, prop, i22;
      toLower = toLower || false;
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      if (this.isArray(obj)) {
        c = [];
        for (i2 = 0; i2 < obj.length; i2++) {
          prop = obj[i2];
          if (prop !== null && typeof prop === "object") {
            if (this.exists(prop.board)) {
              c[i2] = prop.id;
            } else {
              c[i2] = this.deepCopy(prop, {}, toLower);
            }
          } else {
            c[i2] = prop;
          }
        }
      } else {
        c = {};
        for (i2 in obj) {
          if (obj.hasOwnProperty(i2)) {
            i22 = toLower ? i2.toLowerCase() : i2;
            prop = obj[i2];
            if (prop !== null && typeof prop === "object") {
              if (this.exists(prop.board)) {
                c[i22] = prop.id;
              } else {
                c[i22] = this.deepCopy(prop, {}, toLower);
              }
            } else {
              c[i22] = prop;
            }
          }
        }
        for (i2 in obj2) {
          if (obj2.hasOwnProperty(i2)) {
            i22 = toLower ? i2.toLowerCase() : i2;
            prop = obj2[i2];
            if (prop !== null && typeof prop === "object") {
              if (this.isArray(prop) || !this.exists(c[i22])) {
                c[i22] = this.deepCopy(prop, {}, toLower);
              } else {
                c[i22] = this.deepCopy(c[i22], prop, toLower);
              }
            } else {
              c[i22] = prop;
            }
          }
        }
      }
      return c;
    },
    /**
     * In-place (deep) merging of attributes. Allows attributes like `{shadow: {enabled: true...}}`
     * <p>
     * In contrast to method JXG.merge, mergeAttr does not recurse into DOM objects and JSXGraph objects. Instead
     * handles (pointers) to these objects are used.
     *
     * @param {Object} attr Object with attributes - usually containing default options
     * @param {Object} special Special option values which overwrite (recursively) the default options
     * @param {Boolean} [toLower=true] If true the keys are converted to lower case.
     *
     * @see JXG#merge
     *
     */
    mergeAttr: function(attr, special, toLower) {
      var e, e2, o;
      toLower = toLower || true;
      for (e in special) {
        if (special.hasOwnProperty(e)) {
          e2 = toLower ? e.toLowerCase() : e;
          o = special[e];
          if (this.isObject(o) && o !== null && // Do not recurse into a document object or a JSXGraph object
          !this.isDocumentOrFragment(o) && !this.exists(o.board) && // Do not recurse if a string is provided as "new String(...)"
          typeof o.valueOf() !== "string") {
            if (attr[e2] === void 0 || attr[e2] === null || !this.isObject(attr[e2])) {
              attr[e2] = {};
            }
            this.mergeAttr(attr[e2], o, toLower);
          } else {
            attr[e2] = o;
          }
        }
      }
    },
    /**
     * Generates an attributes object that is filled with default values from the Options object
     * and overwritten by the user specified attributes.
     * @param {Object} attributes user specified attributes
     * @param {Object} options defaults options
     * @param {String} s variable number of strings, e.g. 'slider', subtype 'point1'.
     * @returns {Object} The resulting attributes object
     */
    copyAttributes: function(attributes, options, s) {
      var a, i2, len, o, isAvail, primitives = {
        circle: 1,
        curve: 1,
        foreignobject: 1,
        image: 1,
        line: 1,
        point: 1,
        polygon: 1,
        text: 1,
        ticks: 1,
        integral: 1
      };
      len = arguments.length;
      if (len < 3 || primitives[s]) {
        a = jxg_default.deepCopy(options.elements, null, true);
      } else {
        a = {};
      }
      if (len < 4 && this.exists(s) && this.exists(options.layer[s])) {
        a.layer = options.layer[s];
      }
      o = options;
      isAvail = true;
      for (i2 = 2; i2 < len; i2++) {
        if (this.exists(o[arguments[i2]])) {
          o = o[arguments[i2]];
        } else {
          isAvail = false;
          break;
        }
      }
      if (isAvail) {
        a = jxg_default.deepCopy(a, o, true);
      }
      o = typeof attributes === "object" ? attributes : {};
      isAvail = true;
      for (i2 = 3; i2 < len; i2++) {
        if (this.exists(o[arguments[i2]])) {
          o = o[arguments[i2]];
        } else {
          isAvail = false;
          break;
        }
      }
      if (isAvail) {
        this.mergeAttr(a, o, true);
      }
      if (arguments[2] === "board") {
        return a;
      }
      o = options;
      isAvail = true;
      for (i2 = 2; i2 < len; i2++) {
        if (this.exists(o[arguments[i2]])) {
          o = o[arguments[i2]];
        } else {
          isAvail = false;
          break;
        }
      }
      if (isAvail && this.exists(o.label)) {
        a.label = jxg_default.deepCopy(o.label, a.label);
      }
      a.label = jxg_default.deepCopy(options.label, a.label);
      return a;
    },
    /**
     * Copy all prototype methods from object "superObject" to object
     * "subObject". The constructor of superObject will be available
     * in subObject as subObject.constructor[constructorName].
     * @param {Object} subObj A JavaScript object which receives new methods.
     * @param {Object} superObj A JavaScript object which lends its prototype methods to subObject
     * @returns {String} constructorName Under this name the constructor of superObj will be available
     * in subObject.
     * @private
     */
    copyPrototypeMethods: function(subObject, superObject, constructorName) {
      var key;
      subObject.prototype[constructorName] = superObject.prototype.constructor;
      for (key in superObject.prototype) {
        if (superObject.prototype.hasOwnProperty(key)) {
          subObject.prototype[key] = superObject.prototype[key];
        }
      }
    },
    /**
     * Converts a JavaScript object into a JSON string.
     * @param {Object} obj A JavaScript object, functions will be ignored.
     * @param {Boolean} [noquote=false] No quotes around the name of a property.
     * @returns {String} The given object stored in a JSON string.
     */
    toJSON: function(obj, noquote) {
      var list2, prop, i2, s, val;
      noquote = jxg_default.def(noquote, false);
      if (JSON !== void 0 && JSON.stringify && !noquote) {
        try {
          s = JSON.stringify(obj);
          return s;
        } catch (e) {
        }
      }
      switch (typeof obj) {
        case "object":
          if (obj) {
            list2 = [];
            if (this.isArray(obj)) {
              for (i2 = 0; i2 < obj.length; i2++) {
                list2.push(jxg_default.toJSON(obj[i2], noquote));
              }
              return "[" + list2.join(",") + "]";
            }
            for (prop in obj) {
              if (obj.hasOwnProperty(prop)) {
                try {
                  val = jxg_default.toJSON(obj[prop], noquote);
                } catch (e2) {
                  val = "";
                }
                if (noquote) {
                  list2.push(prop + ":" + val);
                } else {
                  list2.push('"' + prop + '":' + val);
                }
              }
            }
            return "{" + list2.join(",") + "} ";
          }
          return "null";
        case "string":
          return "'" + obj.replace(/(["'])/g, "\\$1") + "'";
        case "number":
        case "boolean":
          return obj.toString();
      }
      return "0";
    },
    /**
     * Resets visPropOld.
     * @param {JXG.GeometryElement} el
     * @returns {GeometryElement}
     */
    clearVisPropOld: function(el) {
      el.visPropOld = {
        cssclass: "",
        cssdefaultstyle: "",
        cssstyle: "",
        fillcolor: "",
        fillopacity: "",
        firstarrow: false,
        fontsize: -1,
        lastarrow: false,
        left: -1e5,
        linecap: "",
        shadow: false,
        strokecolor: "",
        strokeopacity: "",
        strokewidth: "",
        tabindex: -1e5,
        transitionduration: 0,
        top: -1e5,
        visible: null
      };
      return el;
    },
    /**
     * Checks if an object contains a key, whose value equals to val.
     * @param {Object} obj
     * @param val
     * @returns {Boolean}
     */
    isInObject: function(obj, val) {
      var el;
      for (el in obj) {
        if (obj.hasOwnProperty(el)) {
          if (obj[el] === val) {
            return true;
          }
        }
      }
      return false;
    },
    /**
     * Replaces all occurences of &amp; by &amp;amp;, &gt; by &amp;gt;, and &lt; by &amp;lt;.
     * @param {String} str
     * @returns {String}
     */
    escapeHTML: function(str2) {
      return str2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    },
    /**
     * Eliminates all substrings enclosed by &lt; and &gt; and replaces all occurences of
     * &amp;amp; by &amp;, &amp;gt; by &gt;, and &amp;lt; by &lt;.
     * @param {String} str
     * @returns {String}
     */
    unescapeHTML: function(str2) {
      return str2.replace(/<\/?[^>]+>/gi, "").replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
    },
    /**
     * Makes a string lower case except for the first character which will be upper case.
     * @param {String} str Arbitrary string
     * @returns {String} The capitalized string.
     */
    capitalize: function(str2) {
      return str2.charAt(0).toUpperCase() + str2.substring(1).toLowerCase();
    },
    /**
     * Make numbers given as strings nicer by removing all unnecessary leading and trailing zeroes.
     * @param {String} str
     * @returns {String}
     */
    trimNumber: function(str2) {
      str2 = str2.replace(/^0+/, "");
      str2 = str2.replace(/0+$/, "");
      if (str2[str2.length - 1] === "." || str2[str2.length - 1] === ",") {
        str2 = str2.slice(0, -1);
      }
      if (str2[0] === "." || str2[0] === ",") {
        str2 = "0" + str2;
      }
      return str2;
    },
    /**
     * Filter an array of elements.
     * @param {Array} list
     * @param {Object|function} filter
     * @returns {Array}
     */
    filterElements: function(list2, filter) {
      var i2, f, item, flower, value, visPropValue, pass, l = list2.length, result = [];
      if (typeof filter !== "function" && typeof filter !== "object") {
        return result;
      }
      for (i2 = 0; i2 < l; i2++) {
        pass = true;
        item = list2[i2];
        if (typeof filter === "object") {
          for (f in filter) {
            if (filter.hasOwnProperty(f)) {
              flower = f.toLowerCase();
              if (typeof item[f] === "function") {
                value = item[f]();
              } else {
                value = item[f];
              }
              if (item.visProp && typeof item.visProp[flower] === "function") {
                visPropValue = item.visProp[flower]();
              } else {
                visPropValue = item.visProp && item.visProp[flower];
              }
              if (typeof filter[f] === "function") {
                pass = filter[f](value) || filter[f](visPropValue);
              } else {
                pass = value === filter[f] || visPropValue === filter[f];
              }
              if (!pass) {
                break;
              }
            }
          }
        } else if (typeof filter === "function") {
          pass = filter(item);
        }
        if (pass) {
          result.push(item);
        }
      }
      return result;
    },
    /**
     * Remove all leading and trailing whitespaces from a given string.
     * @param {String} str
     * @returns {String}
     */
    trim: function(str2) {
      return str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    },
    /**
     * Convert a floating point number to a string integer + fraction.
     * Returns either a string of the form '3 1/3' (in case of useTeX=false)
     * or '3 \\frac{1}{3}' (in case of useTeX=true).
     *
     * @param {Number} x
     * @param {Boolean} [useTeX=false]
     * @param {Number} [order=0.001]
     * @returns {String}
     * @see JXG.Math#decToFraction
     */
    toFraction: function(x, useTeX, order) {
      var arr = math_default.decToFraction(x, order), str2 = "";
      if (arr[1] === 0 && arr[2] === 0) {
        str2 += "0";
      } else {
        if (arr[0] < 0) {
          str2 += "-";
        }
        if (arr[1] !== 0) {
          str2 += arr[1] + " ";
        }
        if (arr[2] !== 0) {
          if (useTeX === true) {
            str2 += "\\frac{" + arr[2] + "}{" + arr[3] + "}";
          } else {
            str2 += arr[2] + "/" + arr[3];
          }
        }
      }
      return str2;
    },
    /**
     * Convert HTML tags to entities or use html_sanitize if the google caja html sanitizer is available.
     * @param {String} str
     * @param {Boolean} caja
     * @returns {String} Sanitized string
     */
    sanitizeHTML: function(str2, caja) {
      if (typeof html_sanitize === "function" && caja) {
        return html_sanitize(
          str2,
          function() {
            return void 0;
          },
          function(id) {
            return id;
          }
        );
      }
      if (str2 && typeof str2 === "string") {
        str2 = str2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      return str2;
    },
    /**
     * If <tt>s</tt> is a slider, it returns the sliders value, otherwise it just returns the given value.
     * @param {*} s
     * @returns {*} s.Value() if s is an element of type slider, s otherwise
     */
    evalSlider: function(s) {
      if (s && s.type === constants_default.OBJECT_TYPE_GLIDER && typeof s.Value === "function") {
        return s.Value();
      }
      return s;
    },
    /**
     * Convert a string containing a MAXIMA /STACK expression into a JSXGraph / JessieCode string
     * or an array of JSXGraph / JessieCode strings.
     *
     * @example
     * console.log( JXG.stack2jsxgraph("%e**x") );
     * // Output:
     * //    "EULER**x"
     *
     * @example
     * console.log( JXG.stack2jsxgraph("[%pi*(x**2 - 1), %phi*(x - 1), %gamma*(x+1)]") );
     * // Output:
     * //    [ "PI*(x**2 - 1)", "1.618033988749895*(x - 1)", "0.5772156649015329*(x+1)" ]
     *
     * @param {String} str
     * @returns String
     */
    stack2jsxgraph: function(str2) {
      var t;
      t = str2.replace(/%pi/g, "PI").replace(/%e/g, "EULER").replace(/%phi/g, "1.618033988749895").replace(/%gamma/g, "0.5772156649015329").trim();
      if (t[0] === "[" && t[t.length - 1] === "]") {
        t = t.slice(1, -1).split(/\s*,\s*/);
      }
      return t;
    }
  }
);
var type_default = jxg_default;

// node_modules/jsxgraph/src/utils/env.js
jxg_default.extendConstants(
  jxg_default,
  /** @lends JXG */
  {
    /**
     * Determines the property that stores the relevant information in the event object.
     * @type String
     * @default 'touches'
     * @private
     */
    touchProperty: "touches"
  }
);
jxg_default.extend(
  jxg_default,
  /** @lends JXG */
  {
    /**
     * Determines whether evt is a touch event.
     * @param evt {Event}
     * @returns {Boolean}
     */
    isTouchEvent: function(evt) {
      return jxg_default.exists(evt[jxg_default.touchProperty]);
    },
    /**
     * Determines whether evt is a pointer event.
     * @param evt {Event}
     * @returns {Boolean}
     */
    isPointerEvent: function(evt) {
      return jxg_default.exists(evt.pointerId);
    },
    /**
     * Determines whether evt is neither a touch event nor a pointer event.
     * @param evt {Event}
     * @returns {Boolean}
     */
    isMouseEvent: function(evt) {
      return !jxg_default.isTouchEvent(evt) && !jxg_default.isPointerEvent(evt);
    },
    /**
     * Determines the number of touch points in a touch event.
     * For other events, -1 is returned.
     * @param evt {Event}
     * @returns {Number}
     */
    getNumberOfTouchPoints: function(evt) {
      var n = -1;
      if (jxg_default.isTouchEvent(evt)) {
        n = evt[jxg_default.touchProperty].length;
      }
      return n;
    },
    /**
     * Checks whether an mouse, pointer or touch event evt is the first event of a multitouch event.
     * Attention: When two or more pointer device types are being used concurrently,
     *            it is only checked whether the passed event is the first one of its type!
     * @param evt {Event}
     * @returns {boolean}
     */
    isFirstTouch: function(evt) {
      var touchPoints = jxg_default.getNumberOfTouchPoints(evt);
      if (jxg_default.isPointerEvent(evt)) {
        return evt.isPrimary;
      }
      return touchPoints === 1;
    },
    /**
     * A document/window environment is available.
     * @type Boolean
     * @default false
     */
    isBrowser: typeof window === "object" && typeof document === "object",
    /**
     * Features of ECMAScript 6+ are available.
     * @type Boolean
     * @default false
     */
    supportsES6: function() {
      try {
        new Function("(a = 0) => a");
        return true;
      } catch (err) {
        return false;
      }
    },
    /**
     * Detect browser support for VML.
     * @returns {Boolean} True, if the browser supports VML.
     */
    supportsVML: function() {
      return this.isBrowser && !!document.namespaces;
    },
    /**
     * Detect browser support for SVG.
     * @returns {Boolean} True, if the browser supports SVG.
     */
    supportsSVG: function() {
      var svgSupport;
      if (!this.isBrowser) {
        return false;
      }
      svgSupport = !!document.createElementNS && !!document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect;
      return svgSupport;
    },
    /**
     * Detect browser support for Canvas.
     * @returns {Boolean} True, if the browser supports HTML canvas.
     */
    supportsCanvas: function() {
      var hasCanvas = false;
      if (this.isNode()) {
        hasCanvas = true;
      }
      return hasCanvas || this.isBrowser && !!document.createElement("canvas").getContext;
    },
    /**
     * True, if run inside a node.js environment.
     * @returns {Boolean}
     */
    isNode: function() {
      return !this.isBrowser && typeof process !== "undefined" && process.release.name.search(/node|io.js/) !== -1;
    },
    /**
     * True if run inside a webworker environment.
     * @returns {Boolean}
     */
    isWebWorker: function() {
      return !this.isBrowser && typeof self === "object" && typeof self.postMessage === "function";
    },
    /**
     * Checks if the environments supports the W3C Pointer Events API {@link https://www.w3.org/TR/pointerevents/}
     * @returns {Boolean}
     */
    supportsPointerEvents: function() {
      return !!(this.isBrowser && window.navigator && (window.PointerEvent || // Chrome/Edge/IE11+
      window.navigator.pointerEnabled || // IE11+
      window.navigator.msPointerEnabled));
    },
    /**
     * Determine if the current browser supports touch events
     * @returns {Boolean} True, if the browser supports touch events.
     */
    isTouchDevice: function() {
      return this.isBrowser && window.ontouchstart !== void 0;
    },
    /**
     * Detects if the user is using an Android powered device.
     * @returns {Boolean}
     */
    isAndroid: function() {
      return type_default.exists(navigator) && navigator.userAgent.toLowerCase().indexOf("android") > -1;
    },
    /**
     * Detects if the user is using the default Webkit browser on an Android powered device.
     * @returns {Boolean}
     */
    isWebkitAndroid: function() {
      return this.isAndroid() && navigator.userAgent.indexOf(" AppleWebKit/") > -1;
    },
    /**
     * Detects if the user is using a Apple iPad / iPhone.
     * @returns {Boolean}
     */
    isApple: function() {
      return type_default.exists(navigator) && (navigator.userAgent.indexOf("iPad") > -1 || navigator.userAgent.indexOf("iPhone") > -1);
    },
    /**
     * Detects if the user is using Safari on an Apple device.
     * @returns {Boolean}
     */
    isWebkitApple: function() {
      return this.isApple() && navigator.userAgent.search(/Mobile\/[0-9A-Za-z.]*Safari/) > -1;
    },
    /**
     * Returns true if the run inside a Windows 8 "Metro" App.
     * @returns {Boolean}
     */
    isMetroApp: function() {
      return typeof window === "object" && window.clientInformation && window.clientInformation.appVersion && window.clientInformation.appVersion.indexOf("MSAppHost") > -1;
    },
    /**
     * Detects if the user is using a Mozilla browser
     * @returns {Boolean}
     */
    isMozilla: function() {
      return type_default.exists(navigator) && navigator.userAgent.toLowerCase().indexOf("mozilla") > -1 && navigator.userAgent.toLowerCase().indexOf("apple") === -1;
    },
    /**
     * Detects if the user is using a firefoxOS powered device.
     * @returns {Boolean}
     */
    isFirefoxOS: function() {
      return type_default.exists(navigator) && navigator.userAgent.toLowerCase().indexOf("android") === -1 && navigator.userAgent.toLowerCase().indexOf("apple") === -1 && navigator.userAgent.toLowerCase().indexOf("mobile") > -1 && navigator.userAgent.toLowerCase().indexOf("mozilla") > -1;
    },
    /**
     * Detects if the user is using a desktop device.
     * @returns {boolean}
     *
     * @see https://stackoverflow.com/a/61073480
     */
    isDesktop: function() {
      return true;
    },
    /**
     * Detects if the user is using a mobile device.
     * @returns {boolean}
     *
     * @see https://stackoverflow.com/questions/25542814/html5-detecting-if-youre-on-mobile-or-pc-with-javascript
     */
    isMobile: function() {
      return true;
    },
    /**
     * Internet Explorer version. Works only for IE > 4.
     * @type Number
     */
    ieVersion: function() {
      var div, all, v = 3;
      if (typeof document !== "object") {
        return 0;
      }
      div = document.createElement("div");
      all = div.getElementsByTagName("i");
      do {
        div.innerHTML = "<!--[if gt IE " + ++v + "]><i></i><![endif]-->";
      } while (all[0]);
      return v > 4 ? v : void 0;
    }(),
    /**
     * Reads the width and height of an HTML element.
     * @param {String|Object} elementId id of or reference to an HTML DOM node.
     * @returns {Object} An object with the two properties width and height.
     */
    getDimensions: function(elementId, doc) {
      var element, display, els, originalVisibility, originalPosition, originalDisplay, originalWidth, originalHeight, style, pixelDimRegExp = /\d+(\.\d*)?px/;
      if (!this.isBrowser || elementId === null) {
        return {
          width: 500,
          height: 500
        };
      }
      doc = doc || document;
      element = type_default.isString(elementId) ? doc.getElementById(elementId) : elementId;
      if (!type_default.exists(element)) {
        throw new Error(
          "\nJSXGraph: HTML container element '" + elementId + "' not found."
        );
      }
      display = element.style.display;
      if (display !== "none" && display !== null) {
        if (element.clientWidth > 0 && element.clientHeight > 0) {
          return { width: element.clientWidth, height: element.clientHeight };
        }
        style = window.getComputedStyle ? window.getComputedStyle(element) : element.style;
        return {
          width: pixelDimRegExp.test(style.width) ? parseFloat(style.width) : 0,
          height: pixelDimRegExp.test(style.height) ? parseFloat(style.height) : 0
        };
      }
      els = element.style;
      originalVisibility = els.visibility;
      originalPosition = els.position;
      originalDisplay = els.display;
      els.visibility = "hidden";
      els.position = "absolute";
      els.display = "block";
      originalWidth = element.clientWidth;
      originalHeight = element.clientHeight;
      els.display = originalDisplay;
      els.position = originalPosition;
      els.visibility = originalVisibility;
      return {
        width: originalWidth,
        height: originalHeight
      };
    },
    /**
     * Adds an event listener to a DOM element.
     * @param {Object} obj Reference to a DOM node.
     * @param {String} type The event to catch, without leading 'on', e.g. 'mousemove' instead of 'onmousemove'.
     * @param {Function} fn The function to call when the event is triggered.
     * @param {Object} owner The scope in which the event trigger is called.
     * @param {Object|Boolean} [options=false] This parameter is passed as the third parameter to the method addEventListener. Depending on the data type it is either
     * an options object or the useCapture Boolean.
     *
     */
    addEvent: function(obj, type, fn, owner, options) {
      var el = function() {
        return fn.apply(owner, arguments);
      };
      el.origin = fn;
      if (typeof owner === "object" && type_default.exists(owner.BOARD_MODE_NONE)) {
        owner["x_internal" + type] = owner["x_internal" + type] || [];
        owner["x_internal" + type].push(el);
      }
      if (type_default.exists(obj) && type_default.exists(obj.addEventListener)) {
        options = options || false;
        obj.addEventListener(type, el, options);
      }
      if (type_default.exists(obj) && type_default.exists(obj.attachEvent)) {
        obj.attachEvent("on" + type, el);
      }
    },
    /**
     * Removes an event listener from a DOM element.
     * @param {Object} obj Reference to a DOM node.
     * @param {String} type The event to catch, without leading 'on', e.g. 'mousemove' instead of 'onmousemove'.
     * @param {Function} fn The function to call when the event is triggered.
     * @param {Object} owner The scope in which the event trigger is called.
     */
    removeEvent: function(obj, type, fn, owner) {
      var i2;
      if (!type_default.exists(owner)) {
        jxg_default.debug("no such owner");
        return;
      }
      if (!type_default.exists(owner["x_internal" + type])) {
        jxg_default.debug("no such type: " + type);
        return;
      }
      if (!type_default.isArray(owner["x_internal" + type])) {
        jxg_default.debug("owner[x_internal + " + type + "] is not an array");
        return;
      }
      i2 = type_default.indexOf(owner["x_internal" + type], fn, "origin");
      if (i2 === -1) {
        jxg_default.debug("removeEvent: no such event function in internal list: " + fn);
        return;
      }
      try {
        if (type_default.exists(obj) && type_default.exists(obj.removeEventListener)) {
          obj.removeEventListener(type, owner["x_internal" + type][i2], false);
        }
        if (type_default.exists(obj) && type_default.exists(obj.detachEvent)) {
          obj.detachEvent("on" + type, owner["x_internal" + type][i2]);
        }
      } catch (e) {
        jxg_default.debug("event not registered in browser: (" + type + " -- " + fn + ")");
      }
      owner["x_internal" + type].splice(i2, 1);
    },
    /**
     * Removes all events of the given type from a given DOM node; Use with caution and do not use it on a container div
     * of a {@link JXG.Board} because this might corrupt the event handling system.
     * @param {Object} obj Reference to a DOM node.
     * @param {String} type The event to catch, without leading 'on', e.g. 'mousemove' instead of 'onmousemove'.
     * @param {Object} owner The scope in which the event trigger is called.
     */
    removeAllEvents: function(obj, type, owner) {
      var i2, len;
      if (owner["x_internal" + type]) {
        len = owner["x_internal" + type].length;
        for (i2 = len - 1; i2 >= 0; i2--) {
          jxg_default.removeEvent(obj, type, owner["x_internal" + type][i2].origin, owner);
        }
        if (owner["x_internal" + type].length > 0) {
          jxg_default.debug("removeAllEvents: Not all events could be removed.");
        }
      }
    },
    /**
     * Cross browser mouse / pointer / touch coordinates retrieval relative to the documents's top left corner.
     * This method might be a bit outdated today, since pointer events and clientX/Y are omnipresent.
     *
     * @param {Object} [e] The browsers event object. If omitted, <tt>window.event</tt> will be used.
     * @param {Number} [index] If <tt>e</tt> is a touch event, this provides the index of the touch coordinates, i.e. it determines which finger.
     * @param {Object} [doc] The document object.
     * @returns {Array} Contains the position as x,y-coordinates in the first resp. second component.
     */
    getPosition: function(e, index, doc) {
      var i2, len, evtTouches, posx = 0, posy = 0;
      if (!e) {
        e = window.event;
      }
      doc = doc || document;
      evtTouches = e[jxg_default.touchProperty];
      if (type_default.exists(evtTouches) && evtTouches.length === 0) {
        evtTouches = e.changedTouches;
      }
      if (type_default.exists(index) && type_default.exists(evtTouches)) {
        if (index === -1) {
          len = evtTouches.length;
          for (i2 = 0; i2 < len; i2++) {
            if (evtTouches[i2]) {
              e = evtTouches[i2];
              break;
            }
          }
        } else {
          e = evtTouches[index];
        }
      }
      if (e.clientX) {
        posx = e.clientX;
        posy = e.clientY;
      }
      return [posx, posy];
    },
    /**
     * Calculates recursively the offset of the DOM element in which the board is stored.
     * @param {Object} obj A DOM element
     * @returns {Array} An array with the elements left and top offset.
     */
    getOffset: function(obj) {
      var cPos, o = obj, o2 = obj, l = o.offsetLeft - o.scrollLeft, t = o.offsetTop - o.scrollTop;
      cPos = this.getCSSTransform([l, t], o);
      l = cPos[0];
      t = cPos[1];
      o = o.offsetParent;
      while (o) {
        l += o.offsetLeft;
        t += o.offsetTop;
        if (o.offsetParent) {
          l += o.clientLeft - o.scrollLeft;
          t += o.clientTop - o.scrollTop;
        }
        cPos = this.getCSSTransform([l, t], o);
        l = cPos[0];
        t = cPos[1];
        o2 = o2.parentNode;
        while (o2 !== o) {
          l += o2.clientLeft - o2.scrollLeft;
          t += o2.clientTop - o2.scrollTop;
          cPos = this.getCSSTransform([l, t], o2);
          l = cPos[0];
          t = cPos[1];
          o2 = o2.parentNode;
        }
        o = o.offsetParent;
      }
      return [l, t];
    },
    /**
     * Access CSS style sheets.
     * @param {Object} obj A DOM element
     * @param {String} stylename The CSS property to read.
     * @returns The value of the CSS property and <tt>undefined</tt> if it is not set.
     */
    getStyle: function(obj, stylename) {
      var r, doc = obj.ownerDocument;
      if (doc.defaultView && doc.defaultView.getComputedStyle) {
        r = doc.defaultView.getComputedStyle(obj, null).getPropertyValue(stylename);
      } else if (obj.currentStyle && jxg_default.ieVersion >= 9) {
        r = obj.currentStyle[stylename];
      } else {
        if (obj.style) {
          stylename = stylename.replace(/-([a-z]|[0-9])/gi, function(all, letter) {
            return letter.toUpperCase();
          });
          r = obj.style[stylename];
        }
      }
      return r;
    },
    /**
     * Reads css style sheets of a given element. This method is a getStyle wrapper and
     * defaults the read value to <tt>0</tt> if it can't be parsed as an integer value.
     * @param {DOMElement} el
     * @param {string} css
     * @returns {number}
     */
    getProp: function(el, css) {
      var n = parseInt(this.getStyle(el, css), 10);
      return isNaN(n) ? 0 : n;
    },
    /**
     * Correct position of upper left corner in case of
     * a CSS transformation. Here, only translations are
     * extracted. All scaling transformations are corrected
     * in {@link JXG.Board#getMousePosition}.
     * @param {Array} cPos Previously determined position
     * @param {Object} obj A DOM element
     * @returns {Array} The corrected position.
     */
    getCSSTransform: function(cPos, obj) {
      var i2, j, str2, arrStr, start, len, len2, arr, t = [
        "transform",
        "webkitTransform",
        "MozTransform",
        "msTransform",
        "oTransform"
      ];
      len = t.length;
      for (i2 = 0, str2 = ""; i2 < len; i2++) {
        if (type_default.exists(obj.style[t[i2]])) {
          str2 = obj.style[t[i2]];
          break;
        }
      }
      if (str2 !== "") {
        start = str2.indexOf("(");
        if (start > 0) {
          len = str2.length;
          arrStr = str2.substring(start + 1, len - 1);
          arr = arrStr.split(",");
          for (j = 0, len2 = arr.length; j < len2; j++) {
            arr[j] = parseFloat(arr[j]);
          }
          if (str2.indexOf("matrix") === 0) {
            cPos[0] += arr[4];
            cPos[1] += arr[5];
          } else if (str2.indexOf("translateX") === 0) {
            cPos[0] += arr[0];
          } else if (str2.indexOf("translateY") === 0) {
            cPos[1] += arr[0];
          } else if (str2.indexOf("translate") === 0) {
            cPos[0] += arr[0];
            cPos[1] += arr[1];
          }
        }
      }
      if (type_default.exists(obj.style.zoom)) {
        str2 = obj.style.zoom;
        if (str2 !== "") {
          cPos[0] *= parseFloat(str2);
          cPos[1] *= parseFloat(str2);
        }
      }
      return cPos;
    },
    /**
     * Scaling CSS transformations applied to the div element containing the JSXGraph constructions
     * are determined. In IE prior to 9, 'rotate', 'skew', 'skewX', 'skewY' are not supported.
     * @returns {Array} 3x3 transformation matrix without translation part. See {@link JXG.Board#updateCSSTransforms}.
     */
    getCSSTransformMatrix: function(obj) {
      var i2, j, str2, arrstr, arr, start, len, len2, st, doc = obj.ownerDocument, t = [
        "transform",
        "webkitTransform",
        "MozTransform",
        "msTransform",
        "oTransform"
      ], mat = [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]
      ];
      if (doc.defaultView && doc.defaultView.getComputedStyle) {
        st = doc.defaultView.getComputedStyle(obj, null);
        str2 = st.getPropertyValue("-webkit-transform") || st.getPropertyValue("-moz-transform") || st.getPropertyValue("-ms-transform") || st.getPropertyValue("-o-transform") || st.getPropertyValue("transform");
      } else {
        len = t.length;
        for (i2 = 0, str2 = ""; i2 < len; i2++) {
          if (type_default.exists(obj.style[t[i2]])) {
            str2 = obj.style[t[i2]];
            break;
          }
        }
      }
      if (str2 !== "") {
        start = str2.indexOf("(");
        if (start > 0) {
          len = str2.length;
          arrstr = str2.substring(start + 1, len - 1);
          arr = arrstr.split(",");
          for (j = 0, len2 = arr.length; j < len2; j++) {
            arr[j] = parseFloat(arr[j]);
          }
          if (str2.indexOf("matrix") === 0) {
            mat = [
              [1, 0, 0],
              [0, arr[0], arr[1]],
              [0, arr[2], arr[3]]
            ];
          } else if (str2.indexOf("scaleX") === 0) {
            mat[1][1] = arr[0];
          } else if (str2.indexOf("scaleY") === 0) {
            mat[2][2] = arr[0];
          } else if (str2.indexOf("scale") === 0) {
            mat[1][1] = arr[0];
            mat[2][2] = arr[1];
          }
        }
      }
      if (type_default.exists(obj.style.zoom)) {
        str2 = obj.style.zoom;
        if (str2 !== "") {
          mat[1][1] *= parseFloat(str2);
          mat[2][2] *= parseFloat(str2);
        }
      }
      return mat;
    },
    /**
     * Process data in timed chunks. Data which takes long to process, either because it is such
     * a huge amount of data or the processing takes some time, causes warnings in browsers about
     * irresponsive scripts. To prevent these warnings, the processing is split into smaller pieces
     * called chunks which will be processed in serial order.
     * Copyright 2009 Nicholas C. Zakas. All rights reserved. MIT Licensed
     * @param {Array} items to do
     * @param {Function} process Function that is applied for every array item
     * @param {Object} context The scope of function process
     * @param {Function} callback This function is called after the last array element has been processed.
     */
    timedChunk: function(items, process2, context, callback) {
      var todo = items.concat(), timerFun = function() {
        var start = +new Date();
        do {
          process2.call(context, todo.shift());
        } while (todo.length > 0 && +new Date() - start < 300);
        if (todo.length > 0) {
          window.setTimeout(timerFun, 1);
        } else {
          callback(items);
        }
      };
      window.setTimeout(timerFun, 1);
    },
    /**
     * Scale and vertically shift a DOM element (usually a JSXGraph div)
     * inside of a parent DOM
     * element which is set to fullscreen.
     * This is realized with a CSS transformation.
     *
     * @param  {String} wrap_id  id of the parent DOM element which is in fullscreen mode
     * @param  {String} inner_id id of the DOM element which is scaled and shifted
     * @param  {Object} doc      document object or shadow root
     * @param  {Number} scale    Relative size of the JSXGraph board in the fullscreen window.
     *
     * @private
     * @see JXG.Board#toFullscreen
     * @see JXG.Board#fullscreenListener
     *
     */
    scaleJSXGraphDiv: function(wrap_id, inner_id, doc, scale) {
      var w, h, b, wi, hi, wo, ho, inner, scale_l, vshift_l, f = scale, ratio, pseudo_keys = [
        ":fullscreen",
        ":-webkit-full-screen",
        ":-moz-full-screen",
        ":-ms-fullscreen"
      ], len_pseudo = pseudo_keys.length, i2;
      b = doc.getElementById(wrap_id).getBoundingClientRect();
      h = b.height;
      w = b.width;
      inner = doc.getElementById(inner_id);
      wo = inner._cssFullscreenStore.w;
      ho = inner._cssFullscreenStore.h;
      ratio = ho / wo;
      if (wo > w * f) {
        wo = w * f;
        ho = wo * ratio;
      }
      if (ho > h * f) {
        ho = h * f;
        wo = ho / ratio;
      }
      wi = wo;
      hi = ho;
      if (ratio > 1) {
        if (ratio < h / w) {
          scale_l = w * f / wo;
        } else {
          scale_l = h * f / ho;
        }
      } else {
        if (ratio < h / w) {
          scale_l = w * f / wo;
        } else {
          scale_l = h * f / ho;
        }
      }
      vshift_l = (h - hi) * 0.5;
      for (i2 = 0; i2 < len_pseudo; i2++) {
        try {
          inner.style.width = wi + "px !important";
          inner.style.height = hi + "px !important";
          inner.style.margin = "0 auto";
          inner.style.transform = inner._cssFullscreenStore.transform + " matrix(" + scale_l + ",0,0," + scale_l + ",0," + vshift_l + ")";
          break;
        } catch (err) {
          jxg_default.debug("JXG.scaleJSXGraphDiv:\n" + err);
        }
      }
      if (i2 === len_pseudo) {
        jxg_default.debug("JXG.scaleJSXGraphDiv: Could not set any CSS property.");
      }
    }
  }
);
var env_default = jxg_default;

// node_modules/jsxgraph/src/utils/xml.js
jxg_default.XML = {
  /**
   * Cleans out unneccessary whitespaces in a chunk of xml.
   * @param {Object} el
   */
  cleanWhitespace: function(el) {
    var cur = el.firstChild;
    while (type_default.exists(cur)) {
      if (cur.nodeType === 3 && !/\S/.test(cur.nodeValue)) {
        el.removeChild(cur);
      } else if (cur.nodeType === 1) {
        this.cleanWhitespace(cur);
      }
      cur = cur.nextSibling;
    }
  },
  /**
   * Converts a given string into a XML tree.
   * @param {String} str
   * @returns {Object} The xml tree represented by the root node.
   */
  parse: function(str2) {
    var parser2, tree, DP;
    if (typeof DOMParser === "function" || typeof DOMParser === "object") {
      DP = DOMParser;
    } else {
      DP = function() {
        this.parseFromString = function(str3) {
          var d;
          if (typeof ActiveXObject === "function") {
            d = new ActiveXObject("MSXML.DomDocument");
            d.loadXML(str3);
          }
          return d;
        };
      };
    }
    parser2 = new DP();
    tree = parser2.parseFromString(str2, "text/xml");
    this.cleanWhitespace(tree);
    return tree;
  }
};
var xml_default = jxg_default.XML;

// node_modules/jsxgraph/src/utils/event.js
jxg_default.EventEmitter = {
  /**
   * Holds the registered event handlers.
   * @type Object
   */
  eventHandlers: {},
  /**
   * Events can be suspended to prevent endless loops.
   * @type Object
   */
  suspended: {},
  /**
   * Triggers all event handlers of this element for a given event.
   * @param {Array} event
   * @param {Array} args The arguments passed onto the event handler
   * @returns Reference to the object.
   */
  trigger: function(event, args2) {
    var i2, j, h, evt, len1, len2;
    len1 = event.length;
    for (j = 0; j < len1; j++) {
      evt = this.eventHandlers[event[j]];
      if (!this.suspended[event[j]]) {
        this.suspended[event[j]] = true;
        if (evt) {
          len2 = evt.length;
          for (i2 = 0; i2 < len2; i2++) {
            h = evt[i2];
            h.handler.apply(h.context, args2);
          }
        }
        this.suspended[event[j]] = false;
      }
    }
    return this;
  },
  /**
   * Register a new event handler. For a list of possible events see documentation
   * of the elements and objects implementing
   * the {@link EventEmitter} interface.
   *
   * As of version 1.5.0, it is only possible to access the element via "this" if the event listener
   * is supplied as regular JavaScript function and not as arrow function.
   *
   * @param {String} event
   * @param {Function} handler
   * @param {Object} [context] The context the handler will be called in, default is the element itself.
   * @returns Reference to the object.
   */
  on: function(event, handler, context) {
    if (!type_default.isArray(this.eventHandlers[event])) {
      this.eventHandlers[event] = [];
    }
    context = type_default.def(context, this);
    this.eventHandlers[event].push({
      handler,
      context
    });
    return this;
  },
  /**
   * Unregister an event handler.
   * @param {String} event
   * @param {Function} [handler]
   * @returns Reference to the object.
   */
  off: function(event, handler) {
    var i2;
    if (!event || !type_default.isArray(this.eventHandlers[event])) {
      return this;
    }
    if (handler) {
      i2 = type_default.indexOf(this.eventHandlers[event], handler, "handler");
      if (i2 > -1) {
        this.eventHandlers[event].splice(i2, 1);
      }
      if (this.eventHandlers[event].length === 0) {
        delete this.eventHandlers[event];
      }
    } else {
      delete this.eventHandlers[event];
    }
    return this;
  },
  /**
   * @description Implements the functionality from this interface in the given object.
   * All objects getting their event handling
   * capabilities from this method should document it by adding
   * the <tt>on, off, triggerEventHandlers</tt> via the
   * borrows tag as methods to their documentation:
   * <pre>@borrows JXG.EventEmitter#on as this.on</pre>
   * @param {Object} o
   */
  eventify: function(o) {
    o.eventHandlers = {
      clicks: 0
      // Needed to handle dblclicks
    };
    o.on = this.on;
    o.off = this.off;
    o.triggerEventHandlers = this.trigger;
    o.trigger = this.trigger;
    o.suspended = {};
  }
};
var event_default = jxg_default.EventEmitter;

// node_modules/jsxgraph/src/base/coords.js
jxg_default.Coords = function(method, coordinates, board, emitter) {
  this.board = board;
  this.usrCoords = [];
  this.scrCoords = [];
  this.emitter = !type_default.exists(emitter) || emitter;
  if (this.emitter) {
    event_default.eventify(this);
  }
  this.setCoordinates(method, coordinates, false, true);
};
jxg_default.extend(
  jxg_default.Coords.prototype,
  /** @lends JXG.Coords.prototype */
  {
    /**
     * Normalize homogeneous coordinates
     * @private
     */
    normalizeUsrCoords: function() {
      if (Math.abs(this.usrCoords[0]) > math_default.eps) {
        this.usrCoords[1] /= this.usrCoords[0];
        this.usrCoords[2] /= this.usrCoords[0];
        this.usrCoords[0] = 1;
      }
    },
    /**
     * Compute screen coordinates out of given user coordinates.
     * @private
     */
    usr2screen: function(doRound) {
      var mround = Math.round, b = this.board, uc = this.usrCoords, oc = b.origin.scrCoords;
      if (doRound === true) {
        this.scrCoords[0] = mround(uc[0]);
        this.scrCoords[1] = mround(uc[0] * oc[1] + uc[1] * b.unitX);
        this.scrCoords[2] = mround(uc[0] * oc[2] - uc[2] * b.unitY);
      } else {
        this.scrCoords[0] = uc[0];
        this.scrCoords[1] = uc[0] * oc[1] + uc[1] * b.unitX;
        this.scrCoords[2] = uc[0] * oc[2] - uc[2] * b.unitY;
      }
    },
    /**
     * Compute user coordinates out of given screen coordinates.
     * @private
     */
    screen2usr: function() {
      var o = this.board.origin.scrCoords, sc = this.scrCoords, b = this.board;
      this.usrCoords[0] = 1;
      this.usrCoords[1] = (sc[1] - o[1]) / b.unitX;
      this.usrCoords[2] = (o[2] - sc[2]) / b.unitY;
    },
    /**
     * Calculate distance of one point to another.
     * @param {Number} coord_type The type of coordinates used here. Possible values are <b>JXG.COORDS_BY_USER</b> and <b>JXG.COORDS_BY_SCREEN</b>.
     * @param {JXG.Coords} coordinates The Coords object to which the distance is calculated.
     * @returns {Number} The distance
     */
    distance: function(coord_type, coordinates) {
      var sum = 0, c, ucr = this.usrCoords, scr = this.scrCoords, f;
      if (coord_type === constants_default.COORDS_BY_USER) {
        c = coordinates.usrCoords;
        f = ucr[0] - c[0];
        sum = f * f;
        if (sum > math_default.eps * math_default.eps) {
          return Number.POSITIVE_INFINITY;
        }
        return math_default.hypot(ucr[1] - c[1], ucr[2] - c[2]);
      } else {
        c = coordinates.scrCoords;
        return math_default.hypot(scr[1] - c[1], scr[2] - c[2]);
      }
    },
    /**
     * Set coordinates by either user coordinates or screen coordinates and recalculate the other one.
     * @param {Number} coord_type The type of coordinates used here. Possible values are <b>COORDS_BY_USER</b> and <b>COORDS_BY_SCREEN</b>.
     * @param {Array} coordinates An array of affine coordinates the Coords object is set to.
     * @param {Boolean} [doRound=true] flag If true or null round the coordinates in usr2screen. This is used in smooth curve plotting.
     * The IE needs rounded coordinates. Id doRound==false we have to round in updatePathString.
     * @param {Boolean} [noevent=false]
     * @returns {JXG.Coords} Reference to the coords object.
     */
    setCoordinates: function(coord_type, coordinates, doRound, noevent) {
      var uc = this.usrCoords, sc = this.scrCoords, ou = [uc[0], uc[1], uc[2]], os = [sc[0], sc[1], sc[2]];
      if (coord_type === constants_default.COORDS_BY_USER) {
        if (coordinates.length === 2) {
          uc[0] = 1;
          uc[1] = coordinates[0];
          uc[2] = coordinates[1];
        } else {
          uc[0] = coordinates[0];
          uc[1] = coordinates[1];
          uc[2] = coordinates[2];
          this.normalizeUsrCoords();
        }
        this.usr2screen(doRound);
      } else {
        if (coordinates.length === 2) {
          sc[1] = coordinates[0];
          sc[2] = coordinates[1];
        } else {
          sc[1] = coordinates[1];
          sc[2] = coordinates[2];
        }
        this.screen2usr();
      }
      if (this.emitter && !noevent && (os[1] !== sc[1] || os[2] !== sc[2])) {
        this.triggerEventHandlers(["update"], [ou, os]);
      }
      return this;
    },
    /**
     * Copy array, either scrCoords or usrCoords
     * Uses slice() in case of standard arrays and set() in case of
     * typed arrays.
     * @private
     * @param {String} obj Either 'scrCoords' or 'usrCoords'
     * @param {Number} offset Offset, defaults to 0 if not given
     * @returns {Array} Returns copy of the coords array either as standard array or as
     *   typed array.
     */
    copy: function(obj, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return this[obj].slice(offset);
    },
    /**
     * Test if one of the usrCoords is NaN or the coordinates are infinite.
     * @returns {Boolean} true if the coordinates are finite, false otherwise.
     */
    isReal: function() {
      return !isNaN(this.usrCoords[1] + this.usrCoords[2]) && Math.abs(this.usrCoords[0]) > math_default.eps;
    },
    /**
     * Triggered whenever the coordinates change.
     * @name JXG.Coords#update
     * @param {Array} ou Old user coordinates
     * @param {Array} os Old screen coordinates
     * @event
     */
    __evt__update: function(ou, os) {
    },
    /**
     * @ignore
     */
    __evt: function() {
    }
  }
);
var coords_default = jxg_default.Coords;

// node_modules/jsxgraph/src/utils/expect.js
jxg_default.Expect = {
  /**
   * Apply an expect method on every element of an array.
   *
   * @param {Array} a
   * @param {function} format
   * @param {Boolean} [copy=false]
   *
   * @returns {Array}
   */
  each: function(a, format, copy) {
    var i2, len, r = [];
    if (type_default.exists(a.length)) {
      len = a.length;
      for (i2 = 0; i2 < len; i2++) {
        r.push(format.call(this, a[i2], copy));
      }
    }
    return r;
  },
  /**
   * Normalize points and coord objects into a coord object.
   *
   * @param {JXG.Point|JXG.Coords} c
   * @param {Boolean} [copy=false] Return a copy, not a reference
   *
   * @returns {JXG.Coords}
   */
  coords: function(c, copy) {
    var coord = c;
    if (c && c.elementClass === constants_default.OBJECT_CLASS_POINT) {
      coord = c.coords;
    } else if (c.usrCoords && c.scrCoords && c.usr2screen) {
      coord = c;
    }
    if (copy) {
      coord = new coords_default(constants_default.COORDS_BY_USER, coord.usrCoords, coord.board);
    }
    return coord;
  },
  /**
   * Normalize points, coordinate arrays and coord objects into a coordinate array.
   *
   * @param {JXG.Point|JXG.Coords|Array} c
   * @param {Boolean} [copy=false] Return a copy, not a reference
   *
   * @returns {Array} Homogeneous coordinates
   */
  coordsArray: function(c, copy) {
    var coord;
    if (!type_default.isArray(c)) {
      coord = this.coords(c).usrCoords;
    } else {
      coord = c;
    }
    if (coord.length < 3) {
      coord.unshift(1);
    }
    if (copy) {
      coord = [coord[0], coord[1], coord[2]];
    }
    return coord;
  }
};
var expect_default = jxg_default.Expect;

// node_modules/jsxgraph/src/math/probfuncs.js
math_default.ProbFuncs = {
  MAXNUM: 17014118346046923e22,
  // 2**127
  SQRTH: 0.7071067811865476,
  // sqrt(2)/2
  SQRT2: 1.4142135623730951,
  // sqrt(2)
  MAXLOG: 708.3964185322641,
  // log 2**1022
  P: [
    2461969814735305e-25,
    0.5641895648310689,
    7.463210564422699,
    48.63719709856814,
    196.5208329560771,
    526.4451949954773,
    934.5285271719576,
    1027.5518868951572,
    557.5353353693994
  ],
  Q: [
    13.228195115474499,
    86.70721408859897,
    354.9377788878199,
    975.7085017432055,
    1823.9091668790973,
    2246.3376081871097,
    1656.6630919416134,
    557.5353408177277
  ],
  R: [
    0.5641895835477551,
    1.275366707599781,
    5.019050422511805,
    6.160210979930536,
    7.4097426995044895,
    2.9788666537210022
  ],
  S: [
    2.2605286322011726,
    9.396035249380015,
    12.048953980809666,
    17.08144507475659,
    9.608968090632859,
    3.369076451000815
  ],
  T: [
    9.604973739870516,
    90.02601972038427,
    2232.005345946843,
    7003.325141128051,
    55592.30130103949
  ],
  U: [
    33.56171416475031,
    521.3579497801527,
    4594.323829709801,
    22629.000061389095,
    49267.39426086359
  ],
  // UTHRESH: 37.519379347,
  M: 128,
  MINV: 78125e-7,
  /**
   *
   *	Exponential of squared argument
   *
   * SYNOPSIS:
   *
   * double x, y, expx2();
   * int sign;
   *
   * y = expx2( x, sign );
   *
   *
   *
   * DESCRIPTION:
   *
   * Computes y = exp(x*x) while suppressing error amplification
   * that would ordinarily arise from the inexactness of the
   * exponential argument x*x.
   *
   * If sign < 0, the result is inverted; i.e., y = exp(-x*x) .
   *
   *
   * ACCURACY:
   *
   *                      Relative error:
   * arithmetic    domain     # trials      peak         rms
   *   IEEE      -26.6, 26.6    10^7       3.9e-16     8.9e-17
   *
   * @private
   * @param  {Number} x
   * @param  {Number} sign (int)
   * @returns {Number}
   */
  expx2: function(x, sign) {
    var u, u1, m, f;
    x = Math.abs(x);
    if (sign < 0) {
      x = -x;
    }
    m = this.MINV * Math.floor(this.M * x + 0.5);
    f = x - m;
    u = m * m;
    u1 = 2 * m * f + f * f;
    if (sign < 0) {
      u = -u;
      u1 = -u1;
    }
    if (u + u1 > this.MAXLOG) {
      return Infinity;
    }
    u = Math.exp(u) * Math.exp(u1);
    return u;
  },
  /**
   *
   *	Evaluate polynomial
   *
   * SYNOPSIS:
   *
   * int N;
   * double x, y, coef[N+1], polevl[];
   *
   * y = polevl( x, coef, N );
   *
   * DESCRIPTION:
   *
   * Evaluates polynomial of degree N:
   *
   *                     2          N
   * y  =  C  + C x + C x  +...+ C x
   *        0    1     2          N
   *
   * Coefficients are stored in reverse order:
   *
   * coef[0] = C  , ..., coef[N] = C  .
   *            N                   0
   *
   *  The function p1evl() assumes that coef[N] = 1.0 and is
   * omitted from the array.  Its calling arguments are
   * otherwise the same as polevl().
   *
   *
   * SPEED:
   *
   * In the interest of speed, there are no checks for out
   * of bounds arithmetic.  This routine is used by most of
   * the functions in the library.  Depending on available
   * equipment features, the user may wish to rewrite the
   * program in microcode or assembly language.
   *
   * @private
   * @param  {Number} x
   * @param  {Number} coef
   * @param  {Number} N
   * @returns {Number}
   */
  polevl: function(x, coef, N) {
    var ans, i2;
    if (type_default.exists(coef.reduce)) {
      return coef.reduce(function(acc, c) {
        return acc * x + c;
      }, 0);
    }
    for (i2 = 0, ans = 0; i2 <= N; i2++) {
      ans = ans * x + coef[i2];
    }
    return ans;
  },
  /**
   * Evaluate polynomial when coefficient of x is 1.0.
   * Otherwise same as polevl.
   *
   * @private
   * @param  {Number} x
   * @param  {Number} coef
   * @param  {Number} N
   * @returns {Number}
   */
  p1evl: function(x, coef, N) {
    var ans, i2;
    if (type_default.exists(coef.reduce)) {
      return coef.reduce(function(acc, c) {
        return acc * x + c;
      }, 1);
    }
    for (i2 = 0, ans = 1; i2 < N; i2++) {
      ans = ans * x + coef[i2];
    }
    return ans;
  },
  /**
   *
   *	Normal distribution function
   *
   * SYNOPSIS:
   *
   * y = ndtr( x );
   *
   * DESCRIPTION:
   *
   * Returns the area under the Gaussian probability density
   * function, integrated from minus infinity to x:
   *
   *                            x
   *                             -
   *                   1        | |          2
   *    ndtr(x)  = ---------    |    exp( - t /2 ) dt
   *               sqrt(2pi)  | |
   *                           -
   *                          -inf.
   *
   *             =  ( 1 + erf(z) ) / 2
   *             =  erfc(z) / 2
   *
   * where z = x/sqrt(2). Computation is via the functions
   * erf and erfc with care to avoid error amplification in computing exp(-x^2).
   *
   *
   * ACCURACY:
   *
   *                      Relative error:
   * arithmetic   domain     # trials      peak         rms
   *    IEEE     -13,0        30000       1.3e-15     2.2e-16
   *
   *
   * ERROR MESSAGES:
   *
   *   message         condition         value returned
   * erfc underflow    x > 37.519379347       0.0
   *
   * @param  {Number} a
   * @returns {Number}
   */
  ndtr: function(a) {
    var x, y, z;
    x = a * this.SQRTH;
    z = Math.abs(x);
    if (z < 1) {
      y = 0.5 + 0.5 * this.erf(x);
    } else {
      y = 0.5 * this.erfce(z);
      z = this.expx2(a, -1);
      y = y * Math.sqrt(z);
      if (x > 0) {
        y = 1 - y;
      }
    }
    return y;
  },
  /**
   * @private
   * @param  {Number} a
   * @returns {Number}
   */
  _underflow: function(a) {
    console.log("erfc", "UNDERFLOW");
    if (a < 0) {
      return 2;
    }
    return 0;
  },
  /**
   *
   *	Complementary error function
   *
   * SYNOPSIS:
   *
   * double x, y, erfc();
   *
   * y = erfc( x );
   *
   *
   *
   * DESCRIPTION:
   *
   *
   *  1 - erf(x) =
   *
   *                           inf.
   *                             -
   *                  2         | |          2
   *   erfc(x)  =  --------     |    exp( - t  ) dt
   *               sqrt(pi)   | |
   *                           -
   *                            x
   *
   *
   * For small x, erfc(x) = 1 - erf(x); otherwise rational
   * approximations are computed.
   *
   * A special function expx2.c is used to suppress error amplification
   * in computing exp(-x^2).
   *
   *
   * ACCURACY:
   *
   *                      Relative error:
   * arithmetic   domain     # trials      peak         rms
   *    IEEE      0,26.6417   30000       1.3e-15     2.2e-16
   *
   *
   * ERROR MESSAGES:
   *
   *   message         condition              value returned
   * erfc underflow    x > 9.231948545 (DEC)       0.0
   *
   * @param  {Number} a
   * @returns {Number}
   */
  erfc: function(a) {
    var p, q, x, y, z;
    if (a < 0) {
      x = -a;
    } else {
      x = a;
    }
    if (x < 1) {
      return 1 - this.erf(a);
    }
    z = -a * a;
    if (z < -this.MAXLOG) {
      return this._underflow(a);
    }
    z = this.expx2(a, -1);
    if (x < 8) {
      p = this.polevl(x, this.P, 8);
      q = this.p1evl(x, this.Q, 8);
    } else {
      p = this.polevl(x, this.R, 5);
      q = this.p1evl(x, this.S, 6);
    }
    y = z * p / q;
    if (a < 0) {
      y = 2 - y;
    }
    if (y === 0) {
      return this._underflow(a);
    }
    return y;
  },
  /**
   * Exponentially scaled erfc function
   *   exp(x^2) erfc(x)
   *   valid for x > 1.
   *   Use with ndtr and expx2.
   *
   * @private
   * @param {Number} x
   * @returns {Number}
   */
  erfce: function(x) {
    var p, q;
    if (x < 8) {
      p = this.polevl(x, this.P, 8);
      q = this.p1evl(x, this.Q, 8);
    } else {
      p = this.polevl(x, this.R, 5);
      q = this.p1evl(x, this.S, 6);
    }
    return p / q;
  },
  /**
   *	Error function
   *
   * SYNOPSIS:
   *
   * double x, y, erf();
   *
   * y = erf( x );
   *
   *
   *
   * DESCRIPTION:
   *
   * The integral is
   *
   *                           x
   *                            -
   *                 2         | |          2
   *   erf(x)  =  --------     |    exp( - t  ) dt.
   *              sqrt(pi)   | |
   *                          -
   *                           0
   *
   * For 0 <= |x| < 1, erf(x) = x * P4(x**2)/Q5(x**2); otherwise
   * erf(x) = 1 - erfc(x).
   *
   *
   * ACCURACY:
   *
   *                      Relative error:
   * arithmetic   domain     # trials      peak         rms
   *    DEC       0,1         14000       4.7e-17     1.5e-17
   *    IEEE      0,1         30000       3.7e-16     1.0e-16
   *
   * @param  {Number} x
   * @returns {Number}
   */
  erf: function(x) {
    var y, z;
    if (Math.abs(x) > 1) {
      return 1 - this.erfc(x);
    }
    z = x * x;
    y = x * this.polevl(z, this.T, 4) / this.p1evl(z, this.U, 5);
    return y;
  },
  s2pi: 2.5066282746310007,
  // sqrt(2pi)
  // approximation for 0 <= |y - 0.5| <= 3/8 */
  P0: [
    -59.96335010141079,
    98.00107541859997,
    -56.67628574690703,
    13.931260938727968,
    -1.2391658386738125
  ],
  Q0: [
    1.9544885833814176,
    4.676279128988815,
    86.36024213908905,
    -225.46268785411937,
    200.26021238006066,
    -82.03722561683334,
    15.90562251262117,
    -1.1833162112133
  ],
  //  Approximation for interval z = sqrt(-2 log y ) between 2 and 8
  //  i.e., y between exp(-2) = .135 and exp(-32) = 1.27e-14.
  P1: [
    4.0554489230596245,
    31.525109459989388,
    57.16281922464213,
    44.08050738932008,
    14.684956192885803,
    2.1866330685079025,
    -0.1402560791713545,
    -0.03504246268278482,
    -8574567851546854e-19
  ],
  Q1: [
    15.779988325646675,
    45.39076351288792,
    41.3172038254672,
    15.04253856929075,
    2.504649462083094,
    -0.14218292285478779,
    -0.03808064076915783,
    -9332594808954574e-19
  ],
  // Approximation for interval z = sqrt(-2 log y ) between 8 and 64
  // i.e., y between exp(-32) = 1.27e-14 and exp(-2048) = 3.67e-890.
  P2: [
    3.2377489177694603,
    6.915228890689842,
    3.9388102529247444,
    1.3330346081580755,
    0.20148538954917908,
    0.012371663481782003,
    30158155350823543e-20,
    26580697468673755e-22,
    6239745391849833e-24
  ],
  Q2: [
    6.02427039364742,
    3.6798356385616087,
    1.3770209948908132,
    0.21623699359449663,
    0.013420400608854318,
    32801446468212774e-20,
    28924786474538068e-22,
    6790194080099813e-24
  ],
  /**
   *
   *	Inverse of Normal distribution function
   *
   * SYNOPSIS:
   *
   * double x, y, ndtri();
   *
   * x = ndtri( y );
   *
   * DESCRIPTION:
   *
   * Returns the argument, x, for which the area under the
   * Gaussian probability density function (integrated from
   * minus infinity to x) is equal to y.
   *
   *
   * For small arguments 0 < y < exp(-2), the program computes
   * z = sqrt( -2.0 * log(y) );  then the approximation is
   * x = z - log(z)/z  - (1/z) P(1/z) / Q(1/z).
   * There are two rational functions P/Q, one for 0 < y < exp(-32)
   * and the other for y up to exp(-2).  For larger arguments,
   * w = y - 0.5, and  x/sqrt(2pi) = w + w**3 R(w**2)/S(w**2)).
   *
   *
   * ACCURACY:
   *
   *                      Relative error:
   * arithmetic   domain        # trials      peak         rms
   *    DEC      0.125, 1         5500       9.5e-17     2.1e-17
   *    DEC      6e-39, 0.135     3500       5.7e-17     1.3e-17
   *    IEEE     0.125, 1        20000       7.2e-16     1.3e-16
   *    IEEE     3e-308, 0.135   50000       4.6e-16     9.8e-17
   *
   *
   * ERROR MESSAGES:
   *
   *   message         condition    value returned
   * ndtri domain       x <= 0        -MAXNUM
   * ndtri domain       x >= 1         MAXNUM
   *
   * @param  {Number} y0
   * @returns {Number}
   */
  ndtri: function(y0) {
    var x, y, z, y2, x0, x1, code;
    if (y0 <= 0) {
      return -Infinity;
    }
    if (y0 >= 1) {
      return Infinity;
    }
    code = 1;
    y = y0;
    if (y > 1 - 0.1353352832366127) {
      y = 1 - y;
      code = 0;
    }
    if (y > 0.1353352832366127) {
      y = y - 0.5;
      y2 = y * y;
      x = y + y * (y2 * this.polevl(y2, this.P0, 4) / this.p1evl(y2, this.Q0, 8));
      x = x * this.s2pi;
      return x;
    }
    x = Math.sqrt(-2 * Math.log(y));
    x0 = x - Math.log(x) / x;
    z = 1 / x;
    if (x < 8) {
      x1 = z * this.polevl(z, this.P1, 8) / this.p1evl(z, this.Q1, 8);
    } else {
      x1 = z * this.polevl(z, this.P2, 8) / this.p1evl(z, this.Q2, 8);
    }
    x = x0 - x1;
    if (code !== 0) {
      x = -x;
    }
    return x;
  },
  /**
   * Inverse of error function erf.
   *
   * @param  {Number} x
   * @returns {Number}
   */
  erfi: function(x) {
    return this.ndtri((x + 1) * 0.5) * this.SQRTH;
  }
};
var probfuncs_default = math_default.ProbFuncs;

// node_modules/jsxgraph/src/math/ia.js
jxg_default.Math.DoubleBits = function() {
  var hasTypedArrays = false, DOUBLE_VIEW = new Float64Array(1), UINT_VIEW = new Uint32Array(DOUBLE_VIEW.buffer), doubleBitsLE, toDoubleLE, lowUintLE, highUintLE, doubleBitsBE, toDoubleBE, lowUintBE, highUintBE, doubleBits2, toDouble, lowUint, highUint;
  if (Float64Array !== void 0) {
    DOUBLE_VIEW[0] = 1;
    hasTypedArrays = true;
    if (UINT_VIEW[1] === 1072693248) {
      doubleBitsLE = function(n) {
        DOUBLE_VIEW[0] = n;
        return [UINT_VIEW[0], UINT_VIEW[1]];
      };
      toDoubleLE = function(lo, hi) {
        UINT_VIEW[0] = lo;
        UINT_VIEW[1] = hi;
        return DOUBLE_VIEW[0];
      };
      lowUintLE = function(n) {
        DOUBLE_VIEW[0] = n;
        return UINT_VIEW[0];
      };
      highUintLE = function(n) {
        DOUBLE_VIEW[0] = n;
        return UINT_VIEW[1];
      };
      this.doubleBits = doubleBitsLE;
      this.pack = toDoubleLE;
      this.lo = lowUintLE;
      this.hi = highUintLE;
    } else if (UINT_VIEW[0] === 1072693248) {
      doubleBitsBE = function(n) {
        DOUBLE_VIEW[0] = n;
        return [UINT_VIEW[1], UINT_VIEW[0]];
      };
      toDoubleBE = function(lo, hi) {
        UINT_VIEW[1] = lo;
        UINT_VIEW[0] = hi;
        return DOUBLE_VIEW[0];
      };
      lowUintBE = function(n) {
        DOUBLE_VIEW[0] = n;
        return UINT_VIEW[1];
      };
      highUintBE = function(n) {
        DOUBLE_VIEW[0] = n;
        return UINT_VIEW[0];
      };
      this.doubleBits = doubleBitsBE;
      this.pack = toDoubleBE;
      this.lo = lowUintBE;
      this.hi = highUintBE;
    } else {
      hasTypedArrays = false;
    }
  }
};
jxg_default.extend(
  jxg_default.Math.DoubleBits.prototype,
  /** @lends JXG.Math.DoubleBits.prototype */
  {
    sign: function(n) {
      return this.hi(n) >>> 31;
    },
    exponent: function(n) {
      var b = this.hi(n);
      return (b << 1 >>> 21) - 1023;
    },
    fraction: function(n) {
      var lo = this.lo(n), hi = this.hi(n), b = hi & (1 << 20) - 1;
      if (hi & 2146435072) {
        b += 1 << 20;
      }
      return [lo, b];
    },
    denormalized: function(n) {
      var hi = this.hi(n);
      return !(hi & 2146435072);
    }
  }
);
var doubleBits = new jxg_default.Math.DoubleBits();
var MatInterval = function(lo, hi) {
  if (lo !== void 0 && hi !== void 0) {
    if (math_default.IntervalArithmetic.isInterval(lo)) {
      if (!math_default.IntervalArithmetic.isSingleton(lo)) {
        throw new TypeError(
          "JXG.Math.IntervalArithmetic: interval `lo` must be a singleton"
        );
      }
      this.lo = lo.lo;
    } else {
      this.lo = lo;
    }
    if (math_default.IntervalArithmetic.isInterval(hi)) {
      if (!math_default.IntervalArithmetic.isSingleton(hi)) {
        throw new TypeError(
          "JXG.Math.IntervalArithmetic: interval `hi` must be a singleton"
        );
      }
      this.hi = hi.hi;
    } else {
      this.hi = hi;
    }
  } else if (lo !== void 0) {
    if (Array.isArray(lo)) {
      return new MatInterval(lo[0], lo[1]);
    }
    return new MatInterval(lo, lo);
  } else {
    this.lo = this.hi = 0;
  }
};
jxg_default.extend(MatInterval.prototype, {
  print: function() {
    console.log("[", this.lo, this.hi, "]");
  },
  set: function(lo, hi) {
    this.lo = lo;
    this.hi = hi;
    return this;
  },
  bounded: function(lo, hi) {
    return this.set(math_default.IntervalArithmetic.prev(lo), math_default.IntervalArithmetic.next(hi));
  },
  boundedSingleton: function(v) {
    return this.bounded(v, v);
  },
  assign: function(lo, hi) {
    if (typeof lo !== "number" || typeof hi !== "number") {
      throw new TypeError("JXG.Math.Interval#assign: arguments must be numbers");
    }
    if (isNaN(lo) || isNaN(hi) || lo > hi) {
      return this.setEmpty();
    }
    return this.set(lo, hi);
  },
  setEmpty: function() {
    return this.set(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
  },
  setWhole: function() {
    return this.set(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
  },
  open: function(lo, hi) {
    return this.assign(math_default.IntervalArithmetic.next(lo), math_default.IntervalArithmetic.prev(hi));
  },
  halfOpenLeft: function(lo, hi) {
    return this.assign(math_default.IntervalArithmetic.next(lo), hi);
  },
  halfOpenRight: function(lo, hi) {
    return this.assign(lo, math_default.IntervalArithmetic.prev(hi));
  },
  toArray: function() {
    return [this.lo, this.hi];
  },
  clone: function() {
    return new MatInterval().set(this.lo, this.hi);
  }
});
jxg_default.Math.IntervalArithmetic = {
  Interval: function(lo, hi) {
    return new MatInterval(lo, hi);
  },
  isInterval: function(i2) {
    return i2 !== null && typeof i2 === "object" && typeof i2.lo === "number" && typeof i2.hi === "number";
  },
  isSingleton: function(i2) {
    return i2.lo === i2.hi;
  },
  /*
   * Arithmetics
   */
  /**
   * Addition
   *
   * @param {JXG.Math.Interval|Number} x
   * @param {JXG.Math.Interval|Number} y
   * @returns JXG.Math.Interval
   */
  add: function(x, y) {
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (type_default.isNumber(y)) {
      y = this.Interval(y);
    }
    return new MatInterval(this.addLo(x.lo, y.lo), this.addHi(x.hi, y.hi));
  },
  /**
   * Subtraction
   *
   * @param {JXG.Math.Interval|Number} x
   * @param {JXG.Math.Interval|Number} y
   * @returns JXG.Math.Interval
   */
  sub: function(x, y) {
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (type_default.isNumber(y)) {
      y = this.Interval(y);
    }
    return new MatInterval(this.subLo(x.lo, y.hi), this.subHi(x.hi, y.lo));
  },
  /**
   * Multiplication
   *
   * @param {JXG.Math.Interval|Number} x
   * @param {JXG.Math.Interval|Number} y
   * @returns JXG.Math.Interval
   */
  mul: function(x, y) {
    var xl, xh, yl, yh, out;
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (type_default.isNumber(y)) {
      y = this.Interval(y);
    }
    if (this.isEmpty(x) || this.isEmpty(y)) {
      return this.EMPTY.clone();
    }
    xl = x.lo;
    xh = x.hi;
    yl = y.lo;
    yh = y.hi;
    out = new MatInterval();
    if (xl < 0) {
      if (xh > 0) {
        if (yl < 0) {
          if (yh > 0) {
            out.lo = Math.min(this.mulLo(xl, yh), this.mulLo(xh, yl));
            out.hi = Math.max(this.mulHi(xl, yl), this.mulHi(xh, yh));
          } else {
            out.lo = this.mulLo(xh, yl);
            out.hi = this.mulHi(xl, yl);
          }
        } else {
          if (yh > 0) {
            out.lo = this.mulLo(xl, yh);
            out.hi = this.mulHi(xh, yh);
          } else {
            out.lo = 0;
            out.hi = 0;
          }
        }
      } else {
        if (yl < 0) {
          if (yh > 0) {
            out.lo = this.mulLo(xl, yh);
            out.hi = this.mulHi(xl, yl);
          } else {
            out.lo = this.mulLo(xh, yh);
            out.hi = this.mulHi(xl, yl);
          }
        } else {
          if (yh > 0) {
            out.lo = this.mulLo(xl, yh);
            out.hi = this.mulHi(xh, yl);
          } else {
            out.lo = 0;
            out.hi = 0;
          }
        }
      }
    } else {
      if (xh > 0) {
        if (yl < 0) {
          if (yh > 0) {
            out.lo = this.mulLo(xh, yl);
            out.hi = this.mulHi(xh, yh);
          } else {
            out.lo = this.mulLo(xh, yl);
            out.hi = this.mulHi(xl, yh);
          }
        } else {
          if (yh > 0) {
            out.lo = this.mulLo(xl, yl);
            out.hi = this.mulHi(xh, yh);
          } else {
            out.lo = 0;
            out.hi = 0;
          }
        }
      } else {
        out.lo = 0;
        out.hi = 0;
      }
    }
    return out;
  },
  /**
   * Division
   *
   * @param {JXG.Math.Interval|Number} x
   * @param {JXG.Math.Interval|Number} y
   * @returns JXG.Math.Interval
   */
  div: function(x, y) {
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (type_default.isNumber(y)) {
      y = this.Interval(y);
    }
    if (this.isEmpty(x) || this.isEmpty(y)) {
      return this.EMPTY.clone();
    }
    if (this.zeroIn(y)) {
      if (y.lo !== 0) {
        if (y.hi !== 0) {
          return this.divZero(x);
        }
        return this.divNegative(x, y.lo);
      }
      if (y.hi !== 0) {
        return this.divPositive(x, y.hi);
      }
      return this.EMPTY.clone();
    }
    return this.divNonZero(x, y);
  },
  /**
   * Return +x (i.e. identity)
   *
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  positive: function(x) {
    return new MatInterval(x.lo, x.hi);
  },
  /**
   * Return -x
   *
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  negative: function(x) {
    if (type_default.isNumber(x)) {
      return new MatInterval(-x);
    }
    return new MatInterval(-x.hi, -x.lo);
  },
  /*
   * Utils
   */
  /**
   * Test if interval is empty set.
   * @param {JXG.Math.Interval} i
   * @returns Boolean
   */
  isEmpty: function(i2) {
    return i2.lo > i2.hi;
  },
  /**
   * Test if interval is (-Infinity, Infinity).
   * @param {JXG.Math.Interval} i
   * @returns Boolean
   */
  isWhole: function(i2) {
    return i2.lo === -Infinity && i2.hi === Infinity;
  },
  /**
   * Test if interval contains 0.
   * @param {JXG.Math.Interval} i
   * @returns Boolean
   */
  zeroIn: function(i2) {
    return this.hasValue(i2, 0);
  },
  /**
   * Test if interval contains a specific value.
   * @param {JXG.Math.Interval} i
   * @param {Number} value
   * @returns Boolean
   */
  hasValue: function(i2, value) {
    if (this.isEmpty(i2)) {
      return false;
    }
    return i2.lo <= value && value <= i2.hi;
  },
  /**
   * Test if interval x contains interval y.
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns Boolean
   */
  hasInterval: function(x, y) {
    if (this.isEmpty(x)) {
      return true;
    }
    return !this.isEmpty(y) && y.lo <= x.lo && x.hi <= y.hi;
  },
  /**
   * Test if intervals x and y have non-zero intersection.
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns Boolean
   */
  intervalsOverlap: function(x, y) {
    if (this.isEmpty(x) || this.isEmpty(y)) {
      return false;
    }
    return x.lo <= y.lo && y.lo <= x.hi || y.lo <= x.lo && x.lo <= y.hi;
  },
  /*
   * Division
   */
  /**
   * @private
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns JXG.Math.Interval
   */
  divNonZero: function(x, y) {
    var xl = x.lo, xh = x.hi, yl = y.lo, yh = y.hi, out = new MatInterval();
    if (xh < 0) {
      if (yh < 0) {
        out.lo = this.divLo(xh, yl);
        out.hi = this.divHi(xl, yh);
      } else {
        out.lo = this.divLo(xl, yl);
        out.hi = this.divHi(xh, yh);
      }
    } else if (xl < 0) {
      if (yh < 0) {
        out.lo = this.divLo(xh, yh);
        out.hi = this.divHi(xl, yh);
      } else {
        out.lo = this.divLo(xl, yl);
        out.hi = this.divHi(xh, yl);
      }
    } else {
      if (yh < 0) {
        out.lo = this.divLo(xh, yh);
        out.hi = this.divHi(xl, yl);
      } else {
        out.lo = this.divLo(xl, yh);
        out.hi = this.divHi(xh, yl);
      }
    }
    return out;
  },
  /**
   * @private
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns JXG.Math.Interval
   */
  divPositive: function(x, v) {
    if (x.lo === 0 && x.hi === 0) {
      return x;
    }
    if (this.zeroIn(x)) {
      return this.WHOLE;
    }
    if (x.hi < 0) {
      return new MatInterval(Number.NEGATIVE_INFINITY, this.divHi(x.hi, v));
    }
    return new MatInterval(this.divLo(x.lo, v), Number.POSITIVE_INFINITY);
  },
  /**
   * @private
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns JXG.Math.Interval
   */
  divNegative: function(x, v) {
    if (x.lo === 0 && x.hi === 0) {
      return x;
    }
    if (this.zeroIn(x)) {
      return this.WHOLE;
    }
    if (x.hi < 0) {
      return new MatInterval(this.divLo(x.hi, v), Number.POSITIVE_INFINITY);
    }
    return new MatInterval(Number.NEGATIVE_INFINITY, this.divHi(x.lo, v));
  },
  /**
   * @private
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  divZero: function(x) {
    if (x.lo === 0 && x.hi === 0) {
      return x;
    }
    return this.WHOLE;
  },
  /*
   * Algebra
   */
  /**
   * x mod y:  x - n * y
   * @param {JXG.Math.Interval|Number} x
   * @param {JXG.Math.Interval|Number} y
   * @returns JXG.Math.Interval
   */
  fmod: function(x, y) {
    var yb, n;
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (type_default.isNumber(y)) {
      y = this.Interval(y);
    }
    if (this.isEmpty(x) || this.isEmpty(y)) {
      return this.EMPTY.clone();
    }
    yb = x.lo < 0 ? y.lo : y.hi;
    n = x.lo / yb;
    if (n < 0) {
      n = Math.ceil(n);
    } else {
      n = Math.floor(n);
    }
    return this.sub(x, this.mul(y, new MatInterval(n)));
  },
  /**
   * 1 / x
   * @param {JXG.Math.Interval|Number} x
   * @returns JXG.Math.Interval
   */
  multiplicativeInverse: function(x) {
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (this.isEmpty(x)) {
      return this.EMPTY.clone();
    }
    if (this.zeroIn(x)) {
      if (x.lo !== 0) {
        if (x.hi !== 0) {
          return this.WHOLE;
        }
        return new MatInterval(Number.NEGATIVE_INFINITY, this.divHi(1, x.lo));
      }
      if (x.hi !== 0) {
        return new MatInterval(this.divLo(1, x.hi), Number.POSITIVE_INFINITY);
      }
      return this.EMPTY.clone();
    }
    return new MatInterval(this.divLo(1, x.hi), this.divHi(1, x.lo));
  },
  /**
   * x<sup>power</sup>
   * @param {JXG.Math.Interval|Number} x
   * @param {JXG.Math.Interval|Number} power
   * @returns JXG.Math.Interval
   */
  pow: function(x, power) {
    var yl, yh;
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (this.isEmpty(x)) {
      return this.EMPTY.clone();
    }
    if (this.isInterval(power)) {
      if (!this.isSingleton(power)) {
        return this.EMPTY.clone();
      }
      power = power.lo;
    }
    if (power === 0) {
      if (x.lo === 0 && x.hi === 0) {
        return this.EMPTY.clone();
      }
      return this.ONE.clone();
    }
    if (power < 0) {
      return this.pow(this.multiplicativeInverse(x), -power);
    }
    if (power % 1 === 0) {
      if (x.hi < 0) {
        yl = this.powLo(-x.hi, power);
        yh = this.powHi(-x.lo, power);
        if ((power & 1) === 1) {
          return new MatInterval(-yh, -yl);
        }
        return new MatInterval(yl, yh);
      }
      if (x.lo < 0) {
        if ((power & 1) === 1) {
          return new MatInterval(-this.powLo(-x.lo, power), this.powHi(x.hi, power));
        }
        return new MatInterval(0, this.powHi(Math.max(-x.lo, x.hi), power));
      }
      return new MatInterval(this.powLo(x.lo, power), this.powHi(x.hi, power));
    }
    console.warn(
      "power is not an integer, you should use nth-root instead, returning an empty interval"
    );
    return this.EMPTY.clone();
  },
  /**
   * sqrt(x)
   * @param {JXG.Math.Interval|Number} x
   * @returns JXG.Math.Interval
   */
  sqrt: function(x) {
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    return this.nthRoot(x, 2);
  },
  /**
   * x<sup>1/n</sup>
   * @param {JXG.Math.Interval|Number} x
   * @param {Number} n
   * @returns JXG.Math.Interval
   */
  nthRoot: function(x, n) {
    var power, yl, yh, yp, yn;
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (this.isEmpty(x) || n < 0) {
      return this.EMPTY.clone();
    }
    if (this.isInterval(n)) {
      if (!this.isSingleton(n)) {
        return this.EMPTY.clone();
      }
      n = n.lo;
    }
    power = 1 / n;
    if (x.hi < 0) {
      if (n % 1 === 0 && (n & 1) === 1) {
        yl = this.powHi(-x.lo, power);
        yh = this.powLo(-x.hi, power);
        return new MatInterval(-yl, -yh);
      }
      return this.EMPTY.clone();
    }
    if (x.lo < 0) {
      yp = this.powHi(x.hi, power);
      if (n % 1 === 0 && (n & 1) === 1) {
        yn = -this.powHi(-x.lo, power);
        return new MatInterval(yn, yp);
      }
      return new MatInterval(0, yp);
    }
    return new MatInterval(this.powLo(x.lo, power), this.powHi(x.hi, power));
  },
  /*
   * Misc
   */
  /**
   *
   * @param {JXG.Math.Interval|Number} x
   * @returns JXG.Math.Interval
   */
  exp: function(x) {
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (this.isEmpty(x)) {
      return this.EMPTY.clone();
    }
    return new MatInterval(this.expLo(x.lo), this.expHi(x.hi));
  },
  /**
   * Natural log
   * @param {JXG.Math.Interval|Number} x
   * @returns JXG.Math.Interval
   */
  log: function(x) {
    var l;
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (this.isEmpty(x)) {
      return this.EMPTY.clone();
    }
    l = x.lo <= 0 ? Number.NEGATIVE_INFINITY : this.logLo(x.lo);
    return new MatInterval(l, this.logHi(x.hi));
  },
  /**
   * Natural log, alias for {@link JXG.Math.IntervalArithmetic#log}.
   * @param {JXG.Math.Interval|Number} x
   * @returns JXG.Math.Interval
   */
  ln: function(x) {
    return this.log(x);
  },
  // export const LOG_EXP_10 = this.log(new MatInterval(10, 10))
  // export const LOG_EXP_2 = log(new MatInterval(2, 2))
  /**
   * Logarithm to base 10.
   * @param {JXG.Math.Interval|Number} x
   * @returns JXG.Math.Interval
   */
  log10: function(x) {
    if (this.isEmpty(x)) {
      return this.EMPTY.clone();
    }
    return this.div(this.log(x), this.log(new MatInterval(10, 10)));
  },
  /**
   * Logarithm to base 2.
   * @param {JXG.Math.Interval|Number} x
   * @returns JXG.Math.Interval
   */
  log2: function(x) {
    if (this.isEmpty(x)) {
      return this.EMPTY.clone();
    }
    return this.div(this.log(x), this.log(new MatInterval(2, 2)));
  },
  /**
   * Hull of intervals x and y
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns JXG.Math.Interval
   */
  hull: function(x, y) {
    var badX = this.isEmpty(x), badY = this.isEmpty(y);
    if (badX && badY) {
      return this.EMPTY.clone();
    }
    if (badX) {
      return y.clone();
    }
    if (badY) {
      return x.clone();
    }
    return new MatInterval(Math.min(x.lo, y.lo), Math.max(x.hi, y.hi));
  },
  /**
   * Intersection of intervals x and y
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns JXG.Math.Interval
   */
  intersection: function(x, y) {
    var lo, hi;
    if (this.isEmpty(x) || this.isEmpty(y)) {
      return this.EMPTY.clone();
    }
    lo = Math.max(x.lo, y.lo);
    hi = Math.min(x.hi, y.hi);
    if (lo <= hi) {
      return new MatInterval(lo, hi);
    }
    return this.EMPTY.clone();
  },
  /**
   * Union of overlapping intervals x and y
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns JXG.Math.Interval
   */
  union: function(x, y) {
    if (!this.intervalsOverlap(x, y)) {
      throw new Error("Interval#unions do not overlap");
    }
    return new MatInterval(Math.min(x.lo, y.lo), Math.max(x.hi, y.hi));
  },
  /**
   * Difference of overlapping intervals x and y
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns JXG.Math.Interval
   */
  difference: function(x, y) {
    if (this.isEmpty(x) || this.isWhole(y)) {
      return this.EMPTY.clone();
    }
    if (this.intervalsOverlap(x, y)) {
      if (x.lo < y.lo && y.hi < x.hi) {
        throw new Error("Interval.difference: difference creates multiple intervals");
      }
      if (y.lo <= x.lo && y.hi === Infinity || y.hi >= x.hi && y.lo === -Infinity) {
        return this.EMPTY.clone();
      }
      if (y.lo <= x.lo) {
        return new MatInterval().halfOpenLeft(y.hi, x.hi);
      }
      return new MatInterval().halfOpenRight(x.lo, y.lo);
    }
    return x.clone();
  },
  /**
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  width: function(x) {
    if (this.isEmpty(x)) {
      return 0;
    }
    return this.subHi(x.hi, x.lo);
  },
  /**
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  abs: function(x) {
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (this.isEmpty(x)) {
      return this.EMPTY.clone();
    }
    if (x.lo >= 0) {
      return x.clone();
    }
    if (x.hi <= 0) {
      return this.negative(x);
    }
    return new MatInterval(0, Math.max(-x.lo, x.hi));
  },
  /**
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns JXG.Math.Interval
   */
  max: function(x, y) {
    var badX = this.isEmpty(x), badY = this.isEmpty(y);
    if (badX && badY) {
      return this.EMPTY.clone();
    }
    if (badX) {
      return y.clone();
    }
    if (badY) {
      return x.clone();
    }
    return new MatInterval(Math.max(x.lo, y.lo), Math.max(x.hi, y.hi));
  },
  /**
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns JXG.Math.Interval
   */
  min: function(x, y) {
    var badX = this.isEmpty(x), badY = this.isEmpty(y);
    if (badX && badY) {
      return this.EMPTY.clone();
    }
    if (badX) {
      return y.clone();
    }
    if (badY) {
      return x.clone();
    }
    return new MatInterval(Math.min(x.lo, y.lo), Math.min(x.hi, y.hi));
  },
  /*
   * Trigonometric
   */
  onlyInfinity: function(x) {
    return !isFinite(x.lo) && x.lo === x.hi;
  },
  _handleNegative: function(interval) {
    var n;
    if (interval.lo < 0) {
      if (interval.lo === -Infinity) {
        interval.lo = 0;
        interval.hi = Infinity;
      } else {
        n = Math.ceil(-interval.lo / this.piTwiceLow);
        interval.lo += this.piTwiceLow * n;
        interval.hi += this.piTwiceLow * n;
      }
    }
    return interval;
  },
  /**
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  cos: function(x) {
    var cache, pi2, t, cosv, lo, hi, rlo, rhi;
    if (this.isEmpty(x) || this.onlyInfinity(x)) {
      return this.EMPTY.clone();
    }
    cache = new MatInterval().set(x.lo, x.hi);
    this._handleNegative(cache);
    pi2 = this.PI_TWICE;
    t = this.fmod(cache, pi2);
    if (this.width(t) >= pi2.lo) {
      return new MatInterval(-1, 1);
    }
    if (t.lo >= this.piHigh) {
      cosv = this.cos(this.sub(t, this.PI));
      return this.negative(cosv);
    }
    lo = t.lo;
    hi = t.hi;
    rlo = this.cosLo(hi);
    rhi = this.cosHi(lo);
    if (hi <= this.piLow) {
      return new MatInterval(rlo, rhi);
    }
    if (hi <= pi2.lo) {
      return new MatInterval(-1, Math.max(rlo, rhi));
    }
    return new MatInterval(-1, 1);
  },
  /**
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  sin: function(x) {
    if (this.isEmpty(x) || this.onlyInfinity(x)) {
      return this.EMPTY.clone();
    }
    return this.cos(this.sub(x, this.PI_HALF));
  },
  /**
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  tan: function(x) {
    var cache, t, pi;
    if (this.isEmpty(x) || this.onlyInfinity(x)) {
      return this.EMPTY.clone();
    }
    cache = new MatInterval().set(x.lo, x.hi);
    this._handleNegative(cache);
    pi = this.PI;
    t = this.fmod(cache, pi);
    if (t.lo >= this.piHalfLow) {
      t = this.sub(t, pi);
    }
    if (t.lo <= -this.piHalfLow || t.hi >= this.piHalfLow) {
      return this.WHOLE.clone();
    }
    return new MatInterval(this.tanLo(t.lo), this.tanHi(t.hi));
  },
  /**
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  asin: function(x) {
    var lo, hi;
    if (this.isEmpty(x) || x.hi < -1 || x.lo > 1) {
      return this.EMPTY.clone();
    }
    lo = x.lo <= -1 ? -this.piHalfHigh : this.asinLo(x.lo);
    hi = x.hi >= 1 ? this.piHalfHigh : this.asinHi(x.hi);
    return new MatInterval(lo, hi);
  },
  /**
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  acos: function(x) {
    var lo, hi;
    if (this.isEmpty(x) || x.hi < -1 || x.lo > 1) {
      return this.EMPTY.clone();
    }
    lo = x.hi >= 1 ? 0 : this.acosLo(x.hi);
    hi = x.lo <= -1 ? this.piHigh : this.acosHi(x.lo);
    return new MatInterval(lo, hi);
  },
  /**
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  acot: function(x) {
    if (this.isEmpty(x)) {
      return this.EMPTY.clone();
    }
    return new MatInterval(this.acotLo(x.lo), this.acotHi(x.hi));
  },
  /**
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  atan: function(x) {
    if (this.isEmpty(x)) {
      return this.EMPTY.clone();
    }
    return new MatInterval(this.atanLo(x.lo), this.atanHi(x.hi));
  },
  /**
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  sinh: function(x) {
    if (this.isEmpty(x)) {
      return this.EMPTY.clone();
    }
    return new MatInterval(this.sinhLo(x.lo), this.sinhHi(x.hi));
  },
  /**
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  cosh: function(x) {
    if (this.isEmpty(x)) {
      return this.EMPTY.clone();
    }
    if (x.hi < 0) {
      return new MatInterval(this.coshLo(x.hi), this.coshHi(x.lo));
    }
    if (x.lo >= 0) {
      return new MatInterval(this.coshLo(x.lo), this.coshHi(x.hi));
    }
    return new MatInterval(1, this.coshHi(-x.lo > x.hi ? x.lo : x.hi));
  },
  /**
   * @param {JXG.Math.Interval} x
   * @returns JXG.Math.Interval
   */
  tanh: function(x) {
    if (this.isEmpty(x)) {
      return this.EMPTY.clone();
    }
    return new MatInterval(this.tanhLo(x.lo), this.tanhHi(x.hi));
  },
  /*
   * Relational
   */
  /**
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns Boolean
   */
  equal: function(x, y) {
    if (this.isEmpty(x)) {
      return this.isEmpty(y);
    }
    return !this.isEmpty(y) && x.lo === y.lo && x.hi === y.hi;
  },
  // almostEqual: function(x, y): void {
  //     x = Array.isArray(x) ? x : x.toArray();
  //     y = Array.isArray(y) ? y : y.toArray();
  //     assertEps(x[0], y[0])
  //     assertEps(x[1], y[1])
  // },
  /**
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns Boolean
   */
  notEqual: function(x, y) {
    if (this.isEmpty(x)) {
      return !this.isEmpty(y);
    }
    return this.isEmpty(y) || x.hi < y.lo || x.lo > y.hi;
  },
  /**
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns Boolean
   */
  lt: function(x, y) {
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (type_default.isNumber(y)) {
      y = this.Interval(y);
    }
    if (this.isEmpty(x) || this.isEmpty(y)) {
      return false;
    }
    return x.hi < y.lo;
  },
  /**
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns Boolean
   */
  gt: function(x, y) {
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (type_default.isNumber(y)) {
      y = this.Interval(y);
    }
    if (this.isEmpty(x) || this.isEmpty(y)) {
      return false;
    }
    return x.lo > y.hi;
  },
  /**
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns Boolean
   */
  leq: function(x, y) {
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (type_default.isNumber(y)) {
      y = this.Interval(y);
    }
    if (this.isEmpty(x) || this.isEmpty(y)) {
      return false;
    }
    return x.hi <= y.lo;
  },
  /**
   * @param {JXG.Math.Interval} x
   * @param {JXG.Math.Interval} y
   * @returns Boolean
   */
  geq: function(x, y) {
    if (type_default.isNumber(x)) {
      x = this.Interval(x);
    }
    if (type_default.isNumber(y)) {
      y = this.Interval(y);
    }
    if (this.isEmpty(x) || this.isEmpty(y)) {
      return false;
    }
    return x.lo >= y.hi;
  },
  /*
   * Constants
   */
  piLow: (3373259426 + 273688 / (1 << 21)) / (1 << 30),
  piHigh: (3373259426 + 273689 / (1 << 21)) / (1 << 30),
  piHalfLow: (3373259426 + 273688 / (1 << 21)) / (1 << 30) * 0.5,
  piHalfHigh: (3373259426 + 273689 / (1 << 21)) / (1 << 30) * 0.5,
  piTwiceLow: (3373259426 + 273688 / (1 << 21)) / (1 << 30) * 2,
  piTwiceHigh: (3373259426 + 273689 / (1 << 21)) / (1 << 30) * 2,
  /*
   * Round
   * Rounding functions for numbers
   */
  identity: function(v) {
    return v;
  },
  _prev: function(v) {
    if (v === Infinity) {
      return v;
    }
    return this.nextafter(v, -Infinity);
  },
  _next: function(v) {
    if (v === -Infinity) {
      return v;
    }
    return this.nextafter(v, Infinity);
  },
  prev: function(v) {
    return this._prev(v);
  },
  next: function(v) {
    return this._next(v);
  },
  toInteger: function(x) {
    return x < 0 ? Math.ceil(x) : Math.floor(x);
  },
  addLo: function(x, y) {
    return this.prev(x + y);
  },
  addHi: function(x, y) {
    return this.next(x + y);
  },
  subLo: function(x, y) {
    return this.prev(x - y);
  },
  subHi: function(x, y) {
    return this.next(x - y);
  },
  mulLo: function(x, y) {
    return this.prev(x * y);
  },
  mulHi: function(x, y) {
    return this.next(x * y);
  },
  divLo: function(x, y) {
    return this.prev(x / y);
  },
  divHi: function(x, y) {
    return this.next(x / y);
  },
  intLo: function(x) {
    return this.toInteger(this.prev(x));
  },
  intHi: function(x) {
    return this.toInteger(this.next(x));
  },
  logLo: function(x) {
    return this.prev(Math.log(x));
  },
  logHi: function(x) {
    return this.next(Math.log(x));
  },
  expLo: function(x) {
    return this.prev(Math.exp(x));
  },
  expHi: function(x) {
    return this.next(Math.exp(x));
  },
  sinLo: function(x) {
    return this.prev(Math.sin(x));
  },
  sinHi: function(x) {
    return this.next(Math.sin(x));
  },
  cosLo: function(x) {
    return this.prev(Math.cos(x));
  },
  cosHi: function(x) {
    return this.next(Math.cos(x));
  },
  tanLo: function(x) {
    return this.prev(Math.tan(x));
  },
  tanHi: function(x) {
    return this.next(Math.tan(x));
  },
  asinLo: function(x) {
    return this.prev(Math.asin(x));
  },
  asinHi: function(x) {
    return this.next(Math.asin(x));
  },
  acosLo: function(x) {
    return this.prev(Math.acos(x));
  },
  acosHi: function(x) {
    return this.next(Math.acos(x));
  },
  acotLo: function(x) {
    return this.prev(math_default.acot(x));
  },
  acotHi: function(x) {
    return this.next(math_default.acot(x));
  },
  atanLo: function(x) {
    return this.prev(Math.atan(x));
  },
  atanHi: function(x) {
    return this.next(Math.atan(x));
  },
  sinhLo: function(x) {
    return this.prev(math_default.sinh(x));
  },
  sinhHi: function(x) {
    return this.next(math_default.sinh(x));
  },
  coshLo: function(x) {
    return this.prev(math_default.cosh(x));
  },
  coshHi: function(x) {
    return this.next(math_default.cosh(x));
  },
  tanhLo: function(x) {
    return this.prev(math_default.tanh(x));
  },
  tanhHi: function(x) {
    return this.next(math_default.tanh(x));
  },
  sqrtLo: function(x) {
    return this.prev(Math.sqrt(x));
  },
  sqrtHi: function(x) {
    return this.next(Math.sqrt(x));
  },
  powLo: function(x, power) {
    var y;
    if (power % 1 !== 0) {
      return this.prev(Math.pow(x, power));
    }
    y = (power & 1) === 1 ? x : 1;
    power >>= 1;
    while (power > 0) {
      x = this.mulLo(x, x);
      if ((power & 1) === 1) {
        y = this.mulLo(x, y);
      }
      power >>= 1;
    }
    return y;
  },
  powHi: function(x, power) {
    var y;
    if (power % 1 !== 0) {
      return this.next(Math.pow(x, power));
    }
    y = (power & 1) === 1 ? x : 1;
    power >>= 1;
    while (power > 0) {
      x = this.mulHi(x, x);
      if ((power & 1) === 1) {
        y = this.mulHi(x, y);
      }
      power >>= 1;
    }
    return y;
  },
  /**
   * @ignore
   * @private
   */
  disable: function() {
    this.next = this.prev = this.identity;
  },
  /**
   * @ignore
   * @private
   */
  enable: function() {
    this.prev = function(v) {
      return this._prev(v);
    };
    this.next = function(v) {
      return this._next(v);
    };
  },
  /*
   * nextafter
   */
  SMALLEST_DENORM: Math.pow(2, -1074),
  UINT_MAX: -1 >>> 0,
  nextafter: function(x, y) {
    var lo, hi;
    if (isNaN(x) || isNaN(y)) {
      return NaN;
    }
    if (x === y) {
      return x;
    }
    if (x === 0) {
      if (y < 0) {
        return -this.SMALLEST_DENORM;
      }
      return this.SMALLEST_DENORM;
    }
    hi = doubleBits.hi(x);
    lo = doubleBits.lo(x);
    if (y > x === x > 0) {
      if (lo === this.UINT_MAX) {
        hi += 1;
        lo = 0;
      } else {
        lo += 1;
      }
    } else {
      if (lo === 0) {
        lo = this.UINT_MAX;
        hi -= 1;
      } else {
        lo -= 1;
      }
    }
    return doubleBits.pack(lo, hi);
  }
};
jxg_default.Math.IntervalArithmetic.PI = new MatInterval(
  math_default.IntervalArithmetic.piLow,
  math_default.IntervalArithmetic.piHigh
);
jxg_default.Math.IntervalArithmetic.PI_HALF = new MatInterval(
  math_default.IntervalArithmetic.piHalfLow,
  math_default.IntervalArithmetic.piHalfHigh
);
jxg_default.Math.IntervalArithmetic.PI_TWICE = new MatInterval(
  math_default.IntervalArithmetic.piTwiceLow,
  math_default.IntervalArithmetic.piTwiceHigh
);
jxg_default.Math.IntervalArithmetic.ZERO = new MatInterval(0);
jxg_default.Math.IntervalArithmetic.ONE = new MatInterval(1);
jxg_default.Math.IntervalArithmetic.WHOLE = new MatInterval().setWhole();
jxg_default.Math.IntervalArithmetic.EMPTY = new MatInterval().setEmpty();
var ia_default = jxg_default.Math.IntervalArithmetic;

// node_modules/jsxgraph/src/math/extrapolate.js
math_default.Extrapolate = {
  upper: 15,
  infty: 1e4,
  /**
   * Wynn's epsilon algorithm. Ported from the FORTRAN version in
   * Ernst Joachim Weniger, "Nonlinear sequence transformations for the acceleration of convergence
   * and the summation of divergent series", Computer Physics Reports Vol. 10, 189-371 (1989).
   *
   * @param {Number} s_n next value of sequence, i.e. n-th element of sequence
   * @param {Number} n index of s_n in the sequence
   * @param {Array} e One-dimensional array containing the extrapolation data. Has to be supplied by the calling routine.
   * @returns {Number} New estimate of the limit of the sequence.
   *
   * @memberof JXG.Math.Extrapolate
   */
  wynnEps: function(s_n, n, e) {
    var HUGE = 1e20, TINY = 1e-15, f0 = 1, f, j, aux1, aux2, diff, estlim;
    e[n] = s_n;
    if (n === 0) {
      estlim = s_n;
    } else {
      aux2 = 0;
      for (j = n; j > 0; j--) {
        aux1 = aux2;
        aux2 = e[j - 1];
        diff = e[j] - aux2;
        if (Math.abs(diff) <= TINY) {
          e[j - 1] = HUGE;
        } else {
          f = (n - j + 1) % 2 === 1 ? f0 : 1;
          e[j - 1] = aux1 * f + 1 / diff;
        }
      }
      estlim = e[n % 2];
    }
    return estlim;
  },
  // wynnRho: function(s_n, n, e) {
  //     var HUGE = 1.e+20,
  //         TINY = 1.e-15,
  //         j, f,
  //         aux1, aux2, diff, estlim;
  //     e[n] = s_n;
  //     if (n === 0) {
  //         estlim = s_n;
  //     } else {
  //         aux2 = 0.0;
  //         for (j = n; j >= 1; j--) {
  //             aux1 = aux2;
  //             aux2 = e[j - 1];
  //             diff = e[j] - aux2;
  //             if (Math.abs(diff) <= TINY) {
  //                 e[j - 1] = HUGE;
  //             } else {
  //                 f = ((n - j + 1) % 2 === 1) ? n - j + 1  : 1;
  //                 e[j - 1] = aux1 + f / diff;
  //             }
  //         }
  //         estlim = e[n % 2];
  //     }
  //     return estlim;
  // },
  /**
   * Aitken transformation. Ported from the FORTRAN version in
   * Ernst Joachim Weniger, "Nonlinear sequence transformations for the acceleration of convergence
   * and the summation of divergent series", Computer Physics Reports Vol. 10, 189-371 (1989).
   *
   * @param {Number} s_n next value of sequence, i.e. n-th element of sequence
   * @param {Number} n index of s_n in the sequence
   * @param {Array} a One-dimensional array containing the extrapolation data. Has to be supplied by the calling routine.
   * @returns {Number} New estimate of the limit of the sequence.
   *
   * @memberof JXG.Math.Extrapolate
   */
  aitken: function(s_n, n, a) {
    var estlim, HUGE = 1e20, TINY = 1e-15, denom, v, lowmax, j, m;
    a[n] = s_n;
    if (n < 2) {
      estlim = s_n;
    } else {
      lowmax = n / 2;
      for (j = 1; j <= lowmax; j++) {
        m = n - 2 * j;
        denom = a[m + 2] - 2 * a[m + 1] + a[m];
        if (Math.abs(denom) < TINY) {
          a[m] = HUGE;
        } else {
          v = a[m] - a[m + 1];
          a[m] -= v * v / denom;
        }
      }
      estlim = a[n % 2];
    }
    return estlim;
  },
  /**
   * Iterated Brezinski transformation. Ported from the FORTRAN version in
   * Ernst Joachim Weniger, "Nonlinear sequence transformations for the acceleration of convergence
   * and the summation of divergent series", Computer Physics Reports Vol. 10, 189-371 (1989).
   *
   * @param {Number} s_n next value of sequence, i.e. n-th element of sequence
   * @param {Number} n index of s_n in the sequence
   * @param {Array} a One-dimensional array containing the extrapolation data. Has to be supplied by the calling routine.
   * @returns {Number} New estimate of the limit of the sequence.
   *
   * @memberof JXG.Math.Extrapolate
   */
  brezinski: function(s_n, n, a) {
    var estlim, HUGE = 1e20, TINY = 1e-15, denom, d0, d1, d2, lowmax, j, m;
    a[n] = s_n;
    if (n < 3) {
      estlim = s_n;
    } else {
      lowmax = n / 3;
      m = n;
      for (j = 1; j <= lowmax; j++) {
        m -= 3;
        d0 = a[m + 1] - a[m];
        d1 = a[m + 2] - a[m + 1];
        d2 = a[m + 3] - a[m + 2];
        denom = d2 * (d1 - d0) - d0 * (d2 - d1);
        if (Math.abs(denom) < TINY) {
          a[m] = HUGE;
        } else {
          a[m] = a[m + 1] - d0 * d1 * (d2 - d1) / denom;
        }
      }
      estlim = a[n % 3];
    }
    return estlim;
  },
  /**
   * Extrapolated iteration to approximate the value f(x_0).
   *
   * @param {Number} x0 Value for which the limit of f is to be determined. f(x0) may or may not exist.
   * @param {Number} h0 Initial (signed) distance from x0.
   * @param {Function} f Function for which the limit at x0 is to be determined
   * @param {String} method String to choose the method. Available values: "wynnEps", "aitken", "brezinski"
   * @param {Number} step_type Approximation method. step_type = 0 uses the sequence x0 + h0/n; step_type = 1 uses the sequence x0 + h0 * 2^(-n)
   *
   * @returns {Array} Array of length 3. Position 0: estimated value for f(x0), position 1: 'finite', 'infinite', or 'NaN'.
   * Position 2: value between 0 and 1 judging the reliability of the result (1: high, 0: not successful).
   *
   * @memberof JXG.Math.Extrapolate
   * @see JXG.Math.Extrapolate.limit
   * @see JXG.Math.Extrapolate.wynnEps
   * @see JXG.Math.Extrapolate.aitken
   * @see JXG.Math.Extrapolate.brezinski
   */
  iteration: function(x0, h0, f, method, step_type) {
    var n, v, w, estlim = NaN, diff, r = 0.5, E = [], result = "finite", h = h0;
    step_type = step_type || 0;
    for (n = 1; n <= this.upper; n++) {
      h = step_type === 0 ? h0 / (n + 1) : h * r;
      v = f(x0 + h, true);
      w = this[method](v, n - 1, E);
      if (isNaN(w)) {
        result = "NaN";
        break;
      }
      if (v !== 0 && w / v > this.infty) {
        estlim = w;
        result = "infinite";
        break;
      }
      diff = w - estlim;
      if (Math.abs(diff) < 1e-7) {
        break;
      }
      estlim = w;
    }
    return [estlim, result, 1 - (n - 1) / this.upper];
  },
  /**
   * Levin transformation. See Numerical Recipes, ed. 3.
   * Not yet ready for use.
   *
   * @param {Number} s_n next value of sequence, i.e. n-th element of sequence
   * @param {Number} n index of s_n in the sequence
   * @param {Array} numer One-dimensional array containing the extrapolation data for the numerator. Has to be supplied by the calling routine.
   * @param {Array} denom One-dimensional array containing the extrapolation data for the denominator. Has to be supplied by the calling routine.
   *
   * @memberof JXG.Math.Extrapolate
   */
  levin: function(s_n, n, omega, beta, numer, denom) {
    var HUGE = 1e20, TINY = 1e-15, j, fact, ratio, term, estlim;
    term = 1 / (beta + n);
    numer[n] = s_n / omega;
    denom[n] = 1 / omega;
    if (n > 0) {
      numer[n - 1] = numer[n] - numer[n - 1];
      denom[n - 1] = denom[n] - denom[n - 1];
      if (n > 1) {
        ratio = (beta + n - 1) * term;
        for (j = 2; j <= n; j++) {
          fact = (beta + n - j) * Math.pow(ratio, j - 2) * term;
          numer[n - j] = numer[n - j + 1] - fact * numer[n - j];
          denom[n - j] = denom[n - j + 1] - fact * denom[n - j];
          term *= ratio;
        }
      }
    }
    if (Math.abs(denom[0]) < TINY) {
      estlim = HUGE;
    } else {
      estlim = numer[0] / denom[0];
    }
    return estlim;
  },
  iteration_levin: function(x0, h0, f, step_type) {
    var n, v, w, estlim = NaN, v_prev, delta, diff, omega, beta = 1, r = 0.5, numer = [], denom = [], result = "finite", h = h0, transform = "u";
    step_type = step_type || 0;
    v_prev = f(x0 + h0, true);
    for (n = 1; n <= this.upper; n++) {
      h = step_type === 0 ? h0 / (n + 1) : h * r;
      v = f(x0 + h, true);
      delta = v - v_prev;
      if (Math.abs(delta) < 1) {
        transform = "u";
      } else {
        transform = "t";
      }
      if (transform === "u") {
        omega = (beta + n) * delta;
      } else {
        omega = delta;
      }
      v_prev = v;
      w = this.levin(v, n - 1, omega, beta, numer, denom);
      diff = w - estlim;
      if (isNaN(w)) {
        result = "NaN";
        break;
      }
      if (v !== 0 && w / v > this.infty) {
        estlim = w;
        result = "infinite";
        break;
      }
      if (Math.abs(diff) < 1e-7) {
        break;
      }
      estlim = w;
    }
    return [estlim, result, 1 - (n - 1) / this.upper];
  },
  /**
   *
   * @param {Number} x0 Value for which the limit of f is to be determined. f(x0) may or may not exist.
   * @param {Number} h0 Initial (signed) distance from x0.
   * @param {Function} f Function for which the limit at x0 is to be determined
   *
   * @returns {Array} Array of length 3. Position 0: estimated value for f(x0), position 1: 'finite', 'infinite', or 'NaN'.
   * Position 2: value between 0 and 1 judging the reliability of the result (1: high, 0: not successful).
   * In case that the extrapolation fails, position 1 and 2 contain 'direct' and 0.
   *
   * @example
   * var f1 = (x) => Math.log(x),
   *     f2 = (x) => Math.tan(x - Math.PI * 0.5),
   *     f3 = (x) => 4 / x;
   *
   * var x0 = 0.0000001;
   * var h = 0.1;
   * for (let f of [f1, f2, f3]) {
   *     console.log("x0=", x0, f.toString());
   *     console.log(JXG.Math.Extrapolate.limit(x0, h, f));
   *  }
   *
   * </pre><div id="JXG5e8c6a7e-eeae-43fb-a669-26b5c9e40cab" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXG5e8c6a7e-eeae-43fb-a669-26b5c9e40cab',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *     var f1 = (x) => Math.log(x),
   *         f2 = (x) => Math.tan(x - Math.PI * 0.5),
   *         f3 = (x) => 4 / x;
   *
   *     var x0 = 0.0000001;
   *     var h = 0.1;
   *     for (let f of [f1, f2, f3]) {
   *         console.log("x0=", x0, f.toString());
   *         console.log(JXG.Math.Extrapolate.limit(x0, h, f));
   *      }
   *
   *     })();
   *
   * <\/script><pre>
   *
   *
   * @see JXG.Math.Extrapolate.iteration
   * @memberof JXG.Math.Extrapolate
   */
  limit: function(x0, h0, f) {
    return this.iteration_levin(x0, h0, f, 0);
  }
};
var extrapolate_default = math_default.Extrapolate;

// node_modules/jsxgraph/src/math/numerics.js
var predefinedButcher = {
  rk4: {
    s: 4,
    A: [
      [0, 0, 0, 0],
      [0.5, 0, 0, 0],
      [0, 0.5, 0, 0],
      [0, 0, 1, 0]
    ],
    b: [1 / 6, 1 / 3, 1 / 3, 1 / 6],
    c: [0, 0.5, 0.5, 1]
  },
  heun: {
    s: 2,
    A: [
      [0, 0],
      [1, 0]
    ],
    b: [0.5, 0.5],
    c: [0, 1]
  },
  euler: {
    s: 1,
    A: [[0]],
    b: [1],
    c: [0]
  }
};
math_default.Numerics = {
  //JXG.extend(Mat.Numerics, /** @lends JXG.Math.Numerics */ {
  /**
   * Solves a system of linear equations given by A and b using the Gauss-Jordan-elimination.
   * The algorithm runs in-place. I.e. the entries of A and b are changed.
   * @param {Array} A Square matrix represented by an array of rows, containing the coefficients of the lineare equation system.
   * @param {Array} b A vector containing the linear equation system's right hand side.
   * @throws {Error} If a non-square-matrix is given or if b has not the right length or A's rank is not full.
   * @returns {Array} A vector that solves the linear equation system.
   * @memberof JXG.Math.Numerics
   */
  Gauss: function(A, b) {
    var i2, j, k, Acopy, x, eps = math_default.eps, n = A.length > 0 ? A[0].length : 0;
    if (n !== b.length || n !== A.length) {
      throw new Error(
        "JXG.Math.Numerics.Gauss: Dimensions don't match. A must be a square matrix and b must be of the same length as A."
      );
    }
    Acopy = [];
    x = b.slice(0, n);
    for (i2 = 0; i2 < n; i2++) {
      Acopy[i2] = A[i2].slice(0, n);
    }
    for (j = 0; j < n; j++) {
      for (i2 = n - 1; i2 > j; i2--) {
        if (Math.abs(Acopy[i2][j]) > eps) {
          if (Math.abs(Acopy[j][j]) < eps) {
            type_default.swap(Acopy, i2, j);
            type_default.swap(x, i2, j);
          } else {
            Acopy[i2][j] /= Acopy[j][j];
            x[i2] -= Acopy[i2][j] * x[j];
            for (k = j + 1; k < n; k++) {
              Acopy[i2][k] -= Acopy[i2][j] * Acopy[j][k];
            }
          }
        }
      }
      if (Math.abs(Acopy[j][j]) < eps) {
        throw new Error(
          "JXG.Math.Numerics.Gauss(): The given matrix seems to be singular."
        );
      }
    }
    this.backwardSolve(Acopy, x, true);
    return x;
  },
  /**
   * Solves a system of linear equations given by the right triangular matrix R and vector b.
   * @param {Array} R Right triangular matrix represented by an array of rows. All entries a_(i,j) with i &lt; j are ignored.
   * @param {Array} b Right hand side of the linear equation system.
   * @param {Boolean} [canModify=false] If true, the right hand side vector is allowed to be changed by this method.
   * @returns {Array} An array representing a vector that solves the system of linear equations.
   * @memberof JXG.Math.Numerics
   */
  backwardSolve: function(R, b, canModify) {
    var x, m, n, i2, j;
    if (canModify) {
      x = b;
    } else {
      x = b.slice(0, b.length);
    }
    m = R.length;
    n = R.length > 0 ? R[0].length : 0;
    for (i2 = m - 1; i2 >= 0; i2--) {
      for (j = n - 1; j > i2; j--) {
        x[i2] -= R[i2][j] * x[j];
      }
      x[i2] /= R[i2][i2];
    }
    return x;
  },
  /**
   *  Gauss-Bareiss algorithm to compute the
   *  determinant of matrix without fractions.
   *  See Henri Cohen, "A Course in Computational
   *  Algebraic Number Theory (Graduate texts
   *  in mathematics; 138)", Springer-Verlag,
   *  ISBN 3-540-55640-0 / 0-387-55640-0
   *  Third, Corrected Printing 1996
   *  "Algorithm 2.2.6", pg. 52-53
   *
   * @param {Array} mat Matrix
   * @returns Number
   * @private
   * @memberof JXG.Math.Numerics
   */
  gaussBareiss: function(mat) {
    var k, c, s, i2, j, p, n, M, t, eps = math_default.eps;
    n = mat.length;
    if (n <= 0) {
      return 0;
    }
    if (mat[0].length < n) {
      n = mat[0].length;
    }
    M = [];
    for (i2 = 0; i2 < n; i2++) {
      M[i2] = mat[i2].slice(0, n);
    }
    c = 1;
    s = 1;
    for (k = 0; k < n - 1; k++) {
      p = M[k][k];
      if (Math.abs(p) < eps) {
        for (i2 = k + 1; i2 < n; i2++) {
          if (Math.abs(M[i2][k]) >= eps) {
            break;
          }
        }
        if (i2 === n) {
          return 0;
        }
        for (j = k; j < n; j++) {
          t = M[i2][j];
          M[i2][j] = M[k][j];
          M[k][j] = t;
        }
        s = -s;
        p = M[k][k];
      }
      for (i2 = k + 1; i2 < n; i2++) {
        for (j = k + 1; j < n; j++) {
          t = p * M[i2][j] - M[i2][k] * M[k][j];
          M[i2][j] = t / c;
        }
      }
      c = p;
    }
    return s * M[n - 1][n - 1];
  },
  /**
   * Computes the determinant of a square nxn matrix with the
   * Gauss-Bareiss algorithm.
   * @param {Array} mat Matrix.
   * @returns {Number} The determinant pf the matrix mat.
   *                   The empty matrix returns 0.
   * @memberof JXG.Math.Numerics
   */
  det: function(mat) {
    var n = mat.length;
    if (n === 2 && mat[0].length === 2) {
      return mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];
    }
    return this.gaussBareiss(mat);
  },
  /**
   * Compute the Eigenvalues and Eigenvectors of a symmetric 3x3 matrix with the Jacobi method
   * Adaption of a FORTRAN program by Ed Wilson, Dec. 25, 1990
   * @param {Array} Ain A symmetric 3x3 matrix.
   * @returns {Array} [A,V] the matrices A and V. The diagonal of A contains the Eigenvalues, V contains the Eigenvectors.
   * @memberof JXG.Math.Numerics
   */
  Jacobi: function(Ain) {
    var i2, j, k, aa, si, co, tt, ssum, amax, eps = math_default.eps * math_default.eps, sum = 0, n = Ain.length, V = [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0]
    ], A = [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0]
    ], nloops = 0;
    for (i2 = 0; i2 < n; i2++) {
      for (j = 0; j < n; j++) {
        V[i2][j] = 0;
        A[i2][j] = Ain[i2][j];
        sum += Math.abs(A[i2][j]);
      }
      V[i2][i2] = 1;
    }
    if (n === 1) {
      return [A, V];
    }
    if (sum <= 0) {
      return [A, V];
    }
    sum /= n * n;
    do {
      ssum = 0;
      amax = 0;
      for (j = 1; j < n; j++) {
        for (i2 = 0; i2 < j; i2++) {
          aa = Math.abs(A[i2][j]);
          if (aa > amax) {
            amax = aa;
          }
          ssum += aa;
          if (aa >= eps) {
            aa = Math.atan2(2 * A[i2][j], A[i2][i2] - A[j][j]) * 0.5;
            si = Math.sin(aa);
            co = Math.cos(aa);
            for (k = 0; k < n; k++) {
              tt = A[k][i2];
              A[k][i2] = co * tt + si * A[k][j];
              A[k][j] = -si * tt + co * A[k][j];
              tt = V[k][i2];
              V[k][i2] = co * tt + si * V[k][j];
              V[k][j] = -si * tt + co * V[k][j];
            }
            A[i2][i2] = co * A[i2][i2] + si * A[j][i2];
            A[j][j] = -si * A[i2][j] + co * A[j][j];
            A[i2][j] = 0;
            for (k = 0; k < n; k++) {
              A[i2][k] = A[k][i2];
              A[j][k] = A[k][j];
            }
          }
        }
      }
      nloops += 1;
    } while (Math.abs(ssum) / sum > eps && nloops < 2e3);
    return [A, V];
  },
  /**
   * Calculates the integral of function f over interval using Newton-Cotes-algorithm.
   * @param {Array} interval The integration interval, e.g. [0, 3].
   * @param {function} f A function which takes one argument of type number and returns a number.
   * @param {Object} [config] The algorithm setup. Accepted properties are number_of_nodes of type number and integration_type
   * with value being either 'trapez', 'simpson', or 'milne'.
   * @param {Number} [config.number_of_nodes=28]
   * @param {String} [config.integration_type='milne'] Possible values are 'milne', 'simpson', 'trapez'
   * @returns {Number} Integral value of f over interval
   * @throws {Error} If config.number_of_nodes doesn't match config.integration_type an exception is thrown. If you want to use
   * simpson rule respectively milne rule config.number_of_nodes must be dividable by 2 respectively 4.
   * @example
   * function f(x) {
   *   return x*x;
   * }
   *
   * // calculates integral of <tt>f</tt> from 0 to 2.
   * var area1 = JXG.Math.Numerics.NewtonCotes([0, 2], f);
   *
   * // the same with an anonymous function
   * var area2 = JXG.Math.Numerics.NewtonCotes([0, 2], function (x) { return x*x; });
   *
   * // use trapez rule with 16 nodes
   * var area3 = JXG.Math.Numerics.NewtonCotes([0, 2], f,
   *                                   {number_of_nodes: 16, integration_type: 'trapez'});
   * @memberof JXG.Math.Numerics
   */
  NewtonCotes: function(interval, f, config) {
    var evaluation_point, i2, number_of_intervals, integral_value = 0, number_of_nodes = config && type_default.isNumber(config.number_of_nodes) ? config.number_of_nodes : 28, available_types = { trapez: true, simpson: true, milne: true }, integration_type = config && config.integration_type && available_types.hasOwnProperty(config.integration_type) && available_types[config.integration_type] ? config.integration_type : "milne", step_size = (interval[1] - interval[0]) / number_of_nodes;
    switch (integration_type) {
      case "trapez":
        integral_value = (f(interval[0]) + f(interval[1])) * 0.5;
        evaluation_point = interval[0];
        for (i2 = 0; i2 < number_of_nodes - 1; i2++) {
          evaluation_point += step_size;
          integral_value += f(evaluation_point);
        }
        integral_value *= step_size;
        break;
      case "simpson":
        if (number_of_nodes % 2 > 0) {
          throw new Error(
            "JSXGraph:  INT_SIMPSON requires config.number_of_nodes dividable by 2."
          );
        }
        number_of_intervals = number_of_nodes / 2;
        integral_value = f(interval[0]) + f(interval[1]);
        evaluation_point = interval[0];
        for (i2 = 0; i2 < number_of_intervals - 1; i2++) {
          evaluation_point += 2 * step_size;
          integral_value += 2 * f(evaluation_point);
        }
        evaluation_point = interval[0] - step_size;
        for (i2 = 0; i2 < number_of_intervals; i2++) {
          evaluation_point += 2 * step_size;
          integral_value += 4 * f(evaluation_point);
        }
        integral_value *= step_size / 3;
        break;
      default:
        if (number_of_nodes % 4 > 0) {
          throw new Error(
            "JSXGraph: Error in INT_MILNE: config.number_of_nodes must be a multiple of 4"
          );
        }
        number_of_intervals = number_of_nodes * 0.25;
        integral_value = 7 * (f(interval[0]) + f(interval[1]));
        evaluation_point = interval[0];
        for (i2 = 0; i2 < number_of_intervals - 1; i2++) {
          evaluation_point += 4 * step_size;
          integral_value += 14 * f(evaluation_point);
        }
        evaluation_point = interval[0] - 3 * step_size;
        for (i2 = 0; i2 < number_of_intervals; i2++) {
          evaluation_point += 4 * step_size;
          integral_value += 32 * (f(evaluation_point) + f(evaluation_point + 2 * step_size));
        }
        evaluation_point = interval[0] - 2 * step_size;
        for (i2 = 0; i2 < number_of_intervals; i2++) {
          evaluation_point += 4 * step_size;
          integral_value += 12 * f(evaluation_point);
        }
        integral_value *= 2 * step_size / 45;
    }
    return integral_value;
  },
  /**
   * Calculates the integral of function f over interval using Romberg iteration.
   * @param {Array} interval The integration interval, e.g. [0, 3].
   * @param {function} f A function which takes one argument of type number and returns a number.
   * @param {Object} [config] The algorithm setup. Accepted properties are max_iterations of type number and precision eps.
   * @param {Number} [config.max_iterations=20]
   * @param {Number} [config.eps=0.0000001]
   * @returns {Number} Integral value of f over interval
   * @example
   * function f(x) {
   *   return x*x;
   * }
   *
   * // calculates integral of <tt>f</tt> from 0 to 2.
   * var area1 = JXG.Math.Numerics.Romberg([0, 2], f);
   *
   * // the same with an anonymous function
   * var area2 = JXG.Math.Numerics.Romberg([0, 2], function (x) { return x*x; });
   *
   * // use trapez rule with maximum of 16 iterations or stop if the precision 0.0001 has been reached.
   * var area3 = JXG.Math.Numerics.Romberg([0, 2], f,
   *                                   {max_iterations: 16, eps: 0.0001});
   * @memberof JXG.Math.Numerics
   */
  Romberg: function(interval, f, config) {
    var a, b, h, s, n, k, i2, q, p = [], integral = 0, last = Infinity, m = config && type_default.isNumber(config.max_iterations) ? config.max_iterations : 20, eps = config && type_default.isNumber(config.eps) ? config.eps : config.eps || 1e-7;
    a = interval[0];
    b = interval[1];
    h = b - a;
    n = 1;
    p[0] = 0.5 * h * (f(a) + f(b));
    for (k = 0; k < m; ++k) {
      s = 0;
      h *= 0.5;
      n *= 2;
      q = 1;
      for (i2 = 1; i2 < n; i2 += 2) {
        s += f(a + i2 * h);
      }
      p[k + 1] = 0.5 * p[k] + s * h;
      integral = p[k + 1];
      for (i2 = k - 1; i2 >= 0; --i2) {
        q *= 4;
        p[i2] = p[i2 + 1] + (p[i2 + 1] - p[i2]) / (q - 1);
        integral = p[i2];
      }
      if (Math.abs(integral - last) < eps * Math.abs(integral)) {
        break;
      }
      last = integral;
    }
    return integral;
  },
  /**
   * Calculates the integral of function f over interval using Gauss-Legendre quadrature.
   * @param {Array} interval The integration interval, e.g. [0, 3].
   * @param {function} f A function which takes one argument of type number and returns a number.
   * @param {Object} [config] The algorithm setup. Accepted property is the order n of type number. n is allowed to take
   * values between 2 and 18, default value is 12.
   * @param {Number} [config.n=16]
   * @returns {Number} Integral value of f over interval
   * @example
   * function f(x) {
   *   return x*x;
   * }
   *
   * // calculates integral of <tt>f</tt> from 0 to 2.
   * var area1 = JXG.Math.Numerics.GaussLegendre([0, 2], f);
   *
   * // the same with an anonymous function
   * var area2 = JXG.Math.Numerics.GaussLegendre([0, 2], function (x) { return x*x; });
   *
   * // use 16 point Gauss-Legendre rule.
   * var area3 = JXG.Math.Numerics.GaussLegendre([0, 2], f,
   *                                   {n: 16});
   * @memberof JXG.Math.Numerics
   */
  GaussLegendre: function(interval, f, config) {
    var a, b, i2, m, xp, xm, result = 0, table_xi = [], table_w = [], xi, w, n = config && type_default.isNumber(config.n) ? config.n : 12;
    if (n > 18) {
      n = 18;
    }
    table_xi[2] = [0.5773502691896257];
    table_w[2] = [1];
    table_xi[4] = [0.33998104358485626, 0.8611363115940526];
    table_w[4] = [0.6521451548625461, 0.34785484513745385];
    table_xi[6] = [
      0.2386191860831969,
      0.6612093864662645,
      0.932469514203152
    ];
    table_w[6] = [
      0.46791393457269104,
      0.3607615730481386,
      0.17132449237917036
    ];
    table_xi[8] = [
      0.1834346424956498,
      0.525532409916329,
      0.7966664774136267,
      0.9602898564975363
    ];
    table_w[8] = [
      0.362683783378362,
      0.31370664587788727,
      0.22238103445337448,
      0.10122853629037626
    ];
    table_xi[10] = [
      0.14887433898163122,
      0.4333953941292472,
      0.6794095682990244,
      0.8650633666889845,
      0.9739065285171717
    ];
    table_w[10] = [
      0.29552422471475287,
      0.26926671930999635,
      0.21908636251598204,
      0.1494513491505806,
      0.06667134430868814
    ];
    table_xi[12] = [
      0.1252334085114689,
      0.3678314989981802,
      0.5873179542866175,
      0.7699026741943047,
      0.9041172563704749,
      0.9815606342467192
    ];
    table_w[12] = [
      0.24914704581340277,
      0.2334925365383548,
      0.20316742672306592,
      0.16007832854334622,
      0.10693932599531843,
      0.04717533638651183
    ];
    table_xi[14] = [
      0.10805494870734367,
      0.31911236892788974,
      0.5152486363581541,
      0.6872929048116855,
      0.827201315069765,
      0.9284348836635735,
      0.9862838086968123
    ];
    table_w[14] = [
      0.2152638534631578,
      0.2051984637212956,
      0.18553839747793782,
      0.15720316715819355,
      0.12151857068790319,
      0.08015808715976021,
      0.03511946033175186
    ];
    table_xi[16] = [
      0.09501250983763744,
      0.2816035507792589,
      0.45801677765722737,
      0.6178762444026438,
      0.755404408355003,
      0.8656312023878318,
      0.9445750230732326,
      0.9894009349916499
    ];
    table_w[16] = [
      0.1894506104550685,
      0.18260341504492358,
      0.16915651939500254,
      0.14959598881657674,
      0.12462897125553388,
      0.09515851168249279,
      0.062253523938647894,
      0.027152459411754096
    ];
    table_xi[18] = [
      0.0847750130417353,
      0.2518862256915055,
      0.41175116146284263,
      0.5597708310739475,
      0.6916870430603532,
      0.8037049589725231,
      0.8926024664975557,
      0.9558239495713977,
      0.9915651684209309
    ];
    table_w[18] = [
      0.1691423829631436,
      0.16427648374583273,
      0.15468467512626524,
      0.14064291467065065,
      0.12255520671147846,
      0.10094204410628717,
      0.07642573025488905,
      0.0497145488949698,
      0.02161601352648331
    ];
    table_xi[3] = [0, 0.7745966692414834];
    table_w[3] = [0.8888888888888888, 0.5555555555555556];
    table_xi[5] = [0, 0.5384693101056831, 0.906179845938664];
    table_w[5] = [
      0.5688888888888889,
      0.47862867049936647,
      0.23692688505618908
    ];
    table_xi[7] = [
      0,
      0.4058451513773972,
      0.7415311855993945,
      0.9491079123427585
    ];
    table_w[7] = [
      0.4179591836734694,
      0.3818300505051189,
      0.27970539148927664,
      0.1294849661688697
    ];
    table_xi[9] = [
      0,
      0.3242534234038089,
      0.6133714327005904,
      0.8360311073266358,
      0.9681602395076261
    ];
    table_w[9] = [
      0.3302393550012598,
      0.31234707704000286,
      0.26061069640293544,
      0.1806481606948574,
      0.08127438836157441
    ];
    table_xi[11] = [
      0,
      0.26954315595234496,
      0.5190961292068118,
      0.7301520055740494,
      0.8870625997680953,
      0.978228658146057
    ];
    table_w[11] = [
      0.2729250867779006,
      0.26280454451024665,
      0.23319376459199048,
      0.18629021092773426,
      0.1255803694649046,
      0.05566856711617366
    ];
    table_xi[13] = [
      0,
      0.2304583159551348,
      0.44849275103644687,
      0.6423493394403402,
      0.8015780907333099,
      0.9175983992229779,
      0.9841830547185881
    ];
    table_w[13] = [
      0.2325515532308739,
      0.22628318026289723,
      0.2078160475368885,
      0.17814598076194574,
      0.13887351021978725,
      0.09212149983772845,
      0.04048400476531588
    ];
    table_xi[15] = [
      0,
      0.20119409399743451,
      0.3941513470775634,
      0.5709721726085388,
      0.7244177313601701,
      0.8482065834104272,
      0.937273392400706,
      0.9879925180204854
    ];
    table_w[15] = [
      0.2025782419255613,
      0.19843148532711158,
      0.1861610000155622,
      0.16626920581699392,
      0.13957067792615432,
      0.10715922046717194,
      0.07036604748810812,
      0.03075324199611727
    ];
    table_xi[17] = [
      0,
      0.17848418149584785,
      0.3512317634538763,
      0.5126905370864769,
      0.6576711592166907,
      0.7815140038968014,
      0.8802391537269859,
      0.9506755217687678,
      0.9905754753144174
    ];
    table_w[17] = [
      0.17944647035620653,
      0.17656270536699264,
      0.16800410215645004,
      0.15404576107681028,
      0.13513636846852548,
      0.11188384719340397,
      0.08503614831717918,
      0.0554595293739872,
      0.02414830286854793
    ];
    a = interval[0];
    b = interval[1];
    m = n + 1 >> 1;
    xi = table_xi[n];
    w = table_w[n];
    xm = 0.5 * (b - a);
    xp = 0.5 * (b + a);
    if (n & true) {
      result = w[0] * f(xp);
      for (i2 = 1; i2 < m; ++i2) {
        result += w[i2] * (f(xp + xm * xi[i2]) + f(xp - xm * xi[i2]));
      }
    } else {
      result = 0;
      for (i2 = 0; i2 < m; ++i2) {
        result += w[i2] * (f(xp + xm * xi[i2]) + f(xp - xm * xi[i2]));
      }
    }
    return xm * result;
  },
  /**
   * Scale error in Gauss Kronrod quadrature.
   * Internal method used in {@link JXG.Math.Numerics._gaussKronrod}.
   * @private
   */
  _rescale_error: function(err, result_abs, result_asc) {
    var scale, min_err, DBL_MIN = 22250738585072014e-324, DBL_EPS = 2220446049250313e-31;
    err = Math.abs(err);
    if (result_asc !== 0 && err !== 0) {
      scale = Math.pow(200 * err / result_asc, 1.5);
      if (scale < 1) {
        err = result_asc * scale;
      } else {
        err = result_asc;
      }
    }
    if (result_abs > DBL_MIN / (50 * DBL_EPS)) {
      min_err = 50 * DBL_EPS * result_abs;
      if (min_err > err) {
        err = min_err;
      }
    }
    return err;
  },
  /**
   * Generic Gauss-Kronrod quadrature algorithm.
   * Internal method used in {@link JXG.Math.Numerics.GaussKronrod15},
   * {@link JXG.Math.Numerics.GaussKronrod21},
   * {@link JXG.Math.Numerics.GaussKronrod31}.
   * Taken from QUADPACK.
   *
   * @param {Array} interval The integration interval, e.g. [0, 3].
   * @param {function} f A function which takes one argument of type number and returns a number.
   * @param {Number} n order
   * @param {Array} xgk Kronrod quadrature abscissae
   * @param {Array} wg Weights of the Gauss rule
   * @param {Array} wgk Weights of the Kronrod rule
   * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc.
   * See the library QUADPACK for an explanation.
   *
   * @returns {Number} Integral value of f over interval
   *
   * @private
   */
  _gaussKronrod: function(interval, f, n, xgk, wg, wgk, resultObj) {
    var a = interval[0], b = interval[1], up, result, center = 0.5 * (a + b), half_length = 0.5 * (b - a), abs_half_length = Math.abs(half_length), f_center = f(center), result_gauss = 0, result_kronrod = f_center * wgk[n - 1], result_abs = Math.abs(result_kronrod), result_asc = 0, mean = 0, err = 0, j, jtw, abscissa, fval1, fval2, fsum, jtwm1, fv1 = [], fv2 = [];
    if (n % 2 === 0) {
      result_gauss = f_center * wg[n / 2 - 1];
    }
    up = Math.floor((n - 1) / 2);
    for (j = 0; j < up; j++) {
      jtw = j * 2 + 1;
      abscissa = half_length * xgk[jtw];
      fval1 = f(center - abscissa);
      fval2 = f(center + abscissa);
      fsum = fval1 + fval2;
      fv1[jtw] = fval1;
      fv2[jtw] = fval2;
      result_gauss += wg[j] * fsum;
      result_kronrod += wgk[jtw] * fsum;
      result_abs += wgk[jtw] * (Math.abs(fval1) + Math.abs(fval2));
    }
    up = Math.floor(n / 2);
    for (j = 0; j < up; j++) {
      jtwm1 = j * 2;
      abscissa = half_length * xgk[jtwm1];
      fval1 = f(center - abscissa);
      fval2 = f(center + abscissa);
      fv1[jtwm1] = fval1;
      fv2[jtwm1] = fval2;
      result_kronrod += wgk[jtwm1] * (fval1 + fval2);
      result_abs += wgk[jtwm1] * (Math.abs(fval1) + Math.abs(fval2));
    }
    mean = result_kronrod * 0.5;
    result_asc = wgk[n - 1] * Math.abs(f_center - mean);
    for (j = 0; j < n - 1; j++) {
      result_asc += wgk[j] * (Math.abs(fv1[j] - mean) + Math.abs(fv2[j] - mean));
    }
    err = (result_kronrod - result_gauss) * half_length;
    result_kronrod *= half_length;
    result_abs *= abs_half_length;
    result_asc *= abs_half_length;
    result = result_kronrod;
    resultObj.abserr = this._rescale_error(err, result_abs, result_asc);
    resultObj.resabs = result_abs;
    resultObj.resasc = result_asc;
    return result;
  },
  /**
   * 15 point Gauss-Kronrod quadrature algorithm, see the library QUADPACK
   * @param {Array} interval The integration interval, e.g. [0, 3].
   * @param {function} f A function which takes one argument of type number and returns a number.
   * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc. See the library
   *  QUADPACK for an explanation.
   *
   * @returns {Number} Integral value of f over interval
   *
   * @memberof JXG.Math.Numerics
   */
  GaussKronrod15: function(interval, f, resultObj) {
    var xgk = (
      /* abscissae of the 15-point kronrod rule */
      [
        0.9914553711208126,
        0.9491079123427585,
        0.8648644233597691,
        0.7415311855993945,
        0.5860872354676911,
        0.4058451513773972,
        0.20778495500789848,
        0
      ]
    ), wg = (
      /* weights of the 7-point gauss rule */
      [
        0.1294849661688697,
        0.27970539148927664,
        0.3818300505051189,
        0.4179591836734694
      ]
    ), wgk = (
      /* weights of the 15-point kronrod rule */
      [
        0.022935322010529224,
        0.06309209262997856,
        0.10479001032225019,
        0.14065325971552592,
        0.1690047266392679,
        0.19035057806478542,
        0.20443294007529889,
        0.20948214108472782
      ]
    );
    return this._gaussKronrod(interval, f, 8, xgk, wg, wgk, resultObj);
  },
  /**
   * 21 point Gauss-Kronrod quadrature algorithm, see the library QUADPACK
   * @param {Array} interval The integration interval, e.g. [0, 3].
   * @param {function} f A function which takes one argument of type number and returns a number.
   * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc. See the library
   *  QUADPACK for an explanation.
   *
   * @returns {Number} Integral value of f over interval
   *
   * @memberof JXG.Math.Numerics
   */
  GaussKronrod21: function(interval, f, resultObj) {
    var xgk = (
      /* abscissae of the 21-point kronrod rule */
      [
        0.9956571630258081,
        0.9739065285171717,
        0.9301574913557082,
        0.8650633666889845,
        0.7808177265864169,
        0.6794095682990244,
        0.5627571346686047,
        0.4333953941292472,
        0.2943928627014602,
        0.14887433898163122,
        0
      ]
    ), wg = (
      /* weights of the 10-point gauss rule */
      [
        0.06667134430868814,
        0.1494513491505806,
        0.21908636251598204,
        0.26926671930999635,
        0.29552422471475287
      ]
    ), wgk = (
      /* weights of the 21-point kronrod rule */
      [
        0.011694638867371874,
        0.032558162307964725,
        0.054755896574351995,
        0.07503967481091996,
        0.0931254545836976,
        0.10938715880229764,
        0.12349197626206584,
        0.13470921731147334,
        0.14277593857706009,
        0.14773910490133849,
        0.1494455540029169
      ]
    );
    return this._gaussKronrod(interval, f, 11, xgk, wg, wgk, resultObj);
  },
  /**
   * 31 point Gauss-Kronrod quadrature algorithm, see the library QUADPACK
   * @param {Array} interval The integration interval, e.g. [0, 3].
   * @param {function} f A function which takes one argument of type number and returns a number.
   * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc. See the library
   *  QUADPACK for an explanation.
   *
   * @returns {Number} Integral value of f over interval
   *
   * @memberof JXG.Math.Numerics
   */
  GaussKronrod31: function(interval, f, resultObj) {
    var xgk = (
      /* abscissae of the 21-point kronrod rule */
      [
        0.9980022986933971,
        0.9879925180204854,
        0.9677390756791391,
        0.937273392400706,
        0.8972645323440819,
        0.8482065834104272,
        0.790418501442466,
        0.7244177313601701,
        0.650996741297417,
        0.5709721726085388,
        0.4850818636402397,
        0.3941513470775634,
        0.29918000715316884,
        0.20119409399743451,
        0.1011420669187175,
        0
      ]
    ), wg = (
      /* weights of the 10-point gauss rule */
      [
        0.03075324199611727,
        0.07036604748810812,
        0.10715922046717194,
        0.13957067792615432,
        0.16626920581699392,
        0.1861610000155622,
        0.19843148532711158,
        0.2025782419255613
      ]
    ), wgk = (
      /* weights of the 21-point kronrod rule */
      [
        0.005377479872923349,
        0.015007947329316122,
        0.02546084732671532,
        0.03534636079137585,
        0.04458975132476488,
        0.05348152469092809,
        0.06200956780067064,
        0.06985412131872826,
        0.07684968075772038,
        0.08308050282313302,
        0.08856444305621176,
        0.09312659817082532,
        0.09664272698362368,
        0.09917359872179196,
        0.10076984552387559,
        0.10133000701479154
      ]
    );
    return this._gaussKronrod(interval, f, 16, xgk, wg, wgk, resultObj);
  },
  /**
   * Generate workspace object for {@link JXG.Math.Numerics.Qag}.
   * @param {Array} interval The integration interval, e.g. [0, 3].
   * @param {Number} n Max. limit
   * @returns {Object} Workspace object
   *
   * @private
   * @memberof JXG.Math.Numerics
   */
  _workspace: function(interval, n) {
    return {
      limit: n,
      size: 0,
      nrmax: 0,
      i: 0,
      alist: [interval[0]],
      blist: [interval[1]],
      rlist: [0],
      elist: [0],
      order: [0],
      level: [0],
      qpsrt: function() {
        var last = this.size - 1, limit = this.limit, errmax, errmin, i2, k, top, i_nrmax = this.nrmax, i_maxerr = this.order[i_nrmax];
        if (last < 2) {
          this.order[0] = 0;
          this.order[1] = 1;
          this.i = i_maxerr;
          return;
        }
        errmax = this.elist[i_maxerr];
        while (i_nrmax > 0 && errmax > this.elist[this.order[i_nrmax - 1]]) {
          this.order[i_nrmax] = this.order[i_nrmax - 1];
          i_nrmax--;
        }
        if (last < limit / 2 + 2) {
          top = last;
        } else {
          top = limit - last + 1;
        }
        i2 = i_nrmax + 1;
        while (i2 < top && errmax < this.elist[this.order[i2]]) {
          this.order[i2 - 1] = this.order[i2];
          i2++;
        }
        this.order[i2 - 1] = i_maxerr;
        errmin = this.elist[last];
        k = top - 1;
        while (k > i2 - 2 && errmin >= this.elist[this.order[k]]) {
          this.order[k + 1] = this.order[k];
          k--;
        }
        this.order[k + 1] = last;
        i_maxerr = this.order[i_nrmax];
        this.i = i_maxerr;
        this.nrmax = i_nrmax;
      },
      set_initial_result: function(result, error) {
        this.size = 1;
        this.rlist[0] = result;
        this.elist[0] = error;
      },
      update: function(a1, b1, area1, error1, a2, b2, area2, error2) {
        var i_max = this.i, i_new = this.size, new_level = this.level[this.i] + 1;
        if (error2 > error1) {
          this.alist[i_max] = a2;
          this.rlist[i_max] = area2;
          this.elist[i_max] = error2;
          this.level[i_max] = new_level;
          this.alist[i_new] = a1;
          this.blist[i_new] = b1;
          this.rlist[i_new] = area1;
          this.elist[i_new] = error1;
          this.level[i_new] = new_level;
        } else {
          this.blist[i_max] = b1;
          this.rlist[i_max] = area1;
          this.elist[i_max] = error1;
          this.level[i_max] = new_level;
          this.alist[i_new] = a2;
          this.blist[i_new] = b2;
          this.rlist[i_new] = area2;
          this.elist[i_new] = error2;
          this.level[i_new] = new_level;
        }
        this.size++;
        if (new_level > this.maximum_level) {
          this.maximum_level = new_level;
        }
        this.qpsrt();
      },
      retrieve: function() {
        var i2 = this.i;
        return {
          a: this.alist[i2],
          b: this.blist[i2],
          r: this.rlist[i2],
          e: this.elist[i2]
        };
      },
      sum_results: function() {
        var nn = this.size, k, result_sum = 0;
        for (k = 0; k < nn; k++) {
          result_sum += this.rlist[k];
        }
        return result_sum;
      },
      subinterval_too_small: function(a1, a2, b2) {
        var e = 2220446049250313e-31, u = 22250738585072014e-324, tmp = (1 + 100 * e) * (Math.abs(a2) + 1e3 * u);
        return Math.abs(a1) <= tmp && Math.abs(b2) <= tmp;
      }
    };
  },
  /**
   * Quadrature algorithm qag from QUADPACK.
   * Internal method used in {@link JXG.Math.Numerics.GaussKronrod15},
   * {@link JXG.Math.Numerics.GaussKronrod21},
   * {@link JXG.Math.Numerics.GaussKronrod31}.
   *
   * @param {Array} interval The integration interval, e.g. [0, 3].
   * @param {function} f A function which takes one argument of type number and returns a number.
   * @param {Object} [config] The algorithm setup. Accepted propert are max. recursion limit of type number,
   * and epsrel and epsabs, the relative and absolute required precision of type number. Further,
   * q the internal quadrature sub-algorithm of type function.
   * @param {Number} [config.limit=15]
   * @param {Number} [config.epsrel=0.0000001]
   * @param {Number} [config.epsabs=0.0000001]
   * @param {Number} [config.q=JXG.Math.Numerics.GaussKronrod15]
   * @returns {Number} Integral value of f over interval
   *
   * @example
   * function f(x) {
   *   return x*x;
   * }
   *
   * // calculates integral of <tt>f</tt> from 0 to 2.
   * var area1 = JXG.Math.Numerics.Qag([0, 2], f);
   *
   * // the same with an anonymous function
   * var area2 = JXG.Math.Numerics.Qag([0, 2], function (x) { return x*x; });
   *
   * // use JXG.Math.Numerics.GaussKronrod31 rule as sub-algorithm.
   * var area3 = JXG.Math.Numerics.Quag([0, 2], f,
   *                                   {q: JXG.Math.Numerics.GaussKronrod31});
   * @memberof JXG.Math.Numerics
   */
  Qag: function(interval, f, config) {
    var DBL_EPS = 2220446049250313e-31, ws = this._workspace(interval, 1e3), limit = config && type_default.isNumber(config.limit) ? config.limit : 15, epsrel = config && type_default.isNumber(config.epsrel) ? config.epsrel : 1e-7, epsabs = config && type_default.isNumber(config.epsabs) ? config.epsabs : 1e-7, q = config && type_default.isFunction(config.q) ? config.q : this.GaussKronrod15, resultObj = {}, area, errsum, result0, abserr0, resabs0, resasc0, result, tolerance, iteration = 0, roundoff_type1 = 0, roundoff_type2 = 0, error_type = 0, round_off, a1, b1, a2, b2, a_i, b_i, r_i, e_i, area1 = 0, area2 = 0, area12 = 0, error1 = 0, error2 = 0, error12 = 0, resasc1, resasc2, wsObj, delta;
    if (limit > ws.limit) {
      jxg_default.warn("iteration limit exceeds available workspace");
    }
    if (epsabs <= 0 && (epsrel < 50 * math_default.eps || epsrel < 5e-29)) {
      jxg_default.warn("tolerance cannot be acheived with given epsabs and epsrel");
    }
    result0 = q.apply(this, [interval, f, resultObj]);
    abserr0 = resultObj.abserr;
    resabs0 = resultObj.resabs;
    resasc0 = resultObj.resasc;
    ws.set_initial_result(result0, abserr0);
    tolerance = Math.max(epsabs, epsrel * Math.abs(result0));
    round_off = 50 * DBL_EPS * resabs0;
    if (abserr0 <= round_off && abserr0 > tolerance) {
      result = result0;
      jxg_default.warn("cannot reach tolerance because of roundoff error on first attempt");
      return -Infinity;
    }
    if (abserr0 <= tolerance && abserr0 !== resasc0 || abserr0 === 0) {
      result = result0;
      return result;
    }
    if (limit === 1) {
      result = result0;
      jxg_default.warn("a maximum of one iteration was insufficient");
      return -Infinity;
    }
    area = result0;
    errsum = abserr0;
    iteration = 1;
    do {
      area1 = 0;
      area2 = 0;
      area12 = 0;
      error1 = 0;
      error2 = 0;
      error12 = 0;
      wsObj = ws.retrieve();
      a_i = wsObj.a;
      b_i = wsObj.b;
      r_i = wsObj.r;
      e_i = wsObj.e;
      a1 = a_i;
      b1 = 0.5 * (a_i + b_i);
      a2 = b1;
      b2 = b_i;
      area1 = q.apply(this, [[a1, b1], f, resultObj]);
      error1 = resultObj.abserr;
      resasc1 = resultObj.resasc;
      area2 = q.apply(this, [[a2, b2], f, resultObj]);
      error2 = resultObj.abserr;
      resasc2 = resultObj.resasc;
      area12 = area1 + area2;
      error12 = error1 + error2;
      errsum += error12 - e_i;
      area += area12 - r_i;
      if (resasc1 !== error1 && resasc2 !== error2) {
        delta = r_i - area12;
        if (Math.abs(delta) <= 1e-5 * Math.abs(area12) && error12 >= 0.99 * e_i) {
          roundoff_type1++;
        }
        if (iteration >= 10 && error12 > e_i) {
          roundoff_type2++;
        }
      }
      tolerance = Math.max(epsabs, epsrel * Math.abs(area));
      if (errsum > tolerance) {
        if (roundoff_type1 >= 6 || roundoff_type2 >= 20) {
          error_type = 2;
        }
        if (ws.subinterval_too_small(a1, a2, b2)) {
          error_type = 3;
        }
      }
      ws.update(a1, b1, area1, error1, a2, b2, area2, error2);
      wsObj = ws.retrieve();
      a_i = wsObj.a_i;
      b_i = wsObj.b_i;
      r_i = wsObj.r_i;
      e_i = wsObj.e_i;
      iteration++;
    } while (iteration < limit && !error_type && errsum > tolerance);
    result = ws.sum_results();
    return result;
  },
  /**
   * Integral of function f over interval.
   * @param {Array} interval The integration interval, e.g. [0, 3].
   * @param {function} f A function which takes one argument of type number and returns a number.
   * @returns {Number} The value of the integral of f over interval
   * @see JXG.Math.Numerics.NewtonCotes
   * @see JXG.Math.Numerics.Romberg
   * @see JXG.Math.Numerics.Qag
   * @memberof JXG.Math.Numerics
   */
  I: function(interval, f) {
    return this.Qag(interval, f, {
      q: this.GaussKronrod15,
      limit: 15,
      epsrel: 1e-7,
      epsabs: 1e-7
    });
  },
  /**
   * Newton's method to find roots of a funtion in one variable.
   * @param {function} f We search for a solution of f(x)=0.
   * @param {Number} x initial guess for the root, i.e. start value.
   * @param {Object} context optional object that is treated as "this" in the function body. This is useful if
   * the function is a method of an object and contains a reference to its parent object via "this".
   * @returns {Number} A root of the function f.
   * @memberof JXG.Math.Numerics
   */
  Newton: function(f, x, context) {
    var df, i2 = 0, h = math_default.eps, newf = f.apply(context, [x]);
    if (type_default.isArray(x)) {
      x = x[0];
    }
    while (i2 < 50 && Math.abs(newf) > h) {
      df = this.D(f, context)(x);
      if (Math.abs(df) > h) {
        x -= newf / df;
      } else {
        x += Math.random() * 0.2 - 1;
      }
      newf = f.apply(context, [x]);
      i2 += 1;
    }
    return x;
  },
  /**
   * Abstract method to find roots of univariate functions, which - for the time being -
   * is an alias for {@link JXG.Math.Numerics.chandrupatla}.
   * @param {function} f We search for a solution of f(x)=0.
   * @param {Number|Array} x initial guess for the root, i.e. starting value, or start interval enclosing the root.
   * @param {Object} context optional object that is treated as "this" in the function body. This is useful if
   * the function is a method of an object and contains a reference to its parent object via "this".
   * @returns {Number} A root of the function f.
   *
   * @see JXG.Math.Numerics.chandrupatla
   * @see JXG.Math.Numerics.fzero
   * @memberof JXG.Math.Numerics
   */
  root: function(f, x, context) {
    return this.chandrupatla(f, x, context);
  },
  /**
   * Compute an intersection of the curves c1 and c2
   * with a generalized Newton method.
   * We want to find values t1, t2 such that
   * c1(t1) = c2(t2), i.e.
   * (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2)) = (0,0).
   * We set
   * (e,f) := (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2))
   *
   * The Jacobian J is defined by
   * J = (a, b)
   *     (c, d)
   * where
   * a = c1_x'(t1)
   * b = -c2_x'(t2)
   * c = c1_y'(t1)
   * d = -c2_y'(t2)
   *
   * The inverse J^(-1) of J is equal to
   *  (d, -b)/
   *  (-c, a) / (ad-bc)
   *
   * Then, (t1new, t2new) := (t1,t2) - J^(-1)*(e,f).
   * If the function meetCurveCurve possesses the properties
   * t1memo and t2memo then these are taken as start values
   * for the Newton algorithm.
   * After stopping of the Newton algorithm the values of t1 and t2 are stored in
   * t1memo and t2memo.
   *
   * @param {JXG.Curve} c1 Curve, Line or Circle
   * @param {JXG.Curve} c2 Curve, Line or Circle
   * @param {Number} t1ini start value for t1
   * @param {Number} t2ini start value for t2
   * @returns {JXG.Coords} intersection point
   * @memberof JXG.Math.Numerics
   */
  generalizedNewton: function(c1, c2, t1ini, t2ini) {
    var t1, t2, a, b, c, d, disc, e, f, F, D00, D01, D10, D11, count = 0;
    if (this.generalizedNewton.t1memo) {
      t1 = this.generalizedNewton.t1memo;
      t2 = this.generalizedNewton.t2memo;
    } else {
      t1 = t1ini;
      t2 = t2ini;
    }
    e = c1.X(t1) - c2.X(t2);
    f = c1.Y(t1) - c2.Y(t2);
    F = e * e + f * f;
    D00 = this.D(c1.X, c1);
    D01 = this.D(c2.X, c2);
    D10 = this.D(c1.Y, c1);
    D11 = this.D(c2.Y, c2);
    while (F > math_default.eps && count < 10) {
      a = D00(t1);
      b = -D01(t2);
      c = D10(t1);
      d = -D11(t2);
      disc = a * d - b * c;
      t1 -= (d * e - b * f) / disc;
      t2 -= (a * f - c * e) / disc;
      e = c1.X(t1) - c2.X(t2);
      f = c1.Y(t1) - c2.Y(t2);
      F = e * e + f * f;
      count += 1;
    }
    this.generalizedNewton.t1memo = t1;
    this.generalizedNewton.t2memo = t2;
    if (Math.abs(t1) < Math.abs(t2)) {
      return [c1.X(t1), c1.Y(t1)];
    }
    return [c2.X(t2), c2.Y(t2)];
  },
  /**
   * Returns the Lagrange polynomials for curves with equidistant nodes, see
   * Jean-Paul Berrut, Lloyd N. Trefethen: Barycentric Lagrange Interpolation,
   * SIAM Review, Vol 46, No 3, (2004) 501-517.
   * The graph of the parametric curve [x(t),y(t)] runs through the given points.
   * @param {Array} p Array of JXG.Points
   * @returns {Array} An array consisting of two functions x(t), y(t) which define a parametric curve
   * f(t) = (x(t), y(t)), a number x1 (which equals 0) and a function x2 defining the curve's domain.
   * That means the curve is defined between x1 and x2(). x2 returns the (length of array p minus one).
   * @memberof JXG.Math.Numerics
   *
   * @example
   * var p = [];
   *
   * p[0] = board.create('point', [0, -2], {size:2, name: 'C(a)'});
   * p[1] = board.create('point', [-1.5, 5], {size:2, name: ''});
   * p[2] = board.create('point', [1, 4], {size:2, name: ''});
   * p[3] = board.create('point', [3, 3], {size:2, name: 'C(b)'});
   *
   * // Curve
   * var fg = JXG.Math.Numerics.Neville(p);
   * var graph = board.create('curve', fg, {strokeWidth:3, strokeOpacity:0.5});
   *
   * </pre><div id="JXG88a8b3a8-6561-44f5-a678-76bca13fd484" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXG88a8b3a8-6561-44f5-a678-76bca13fd484',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *     var p = [];
   *
   *     p[0] = board.create('point', [0, -2], {size:2, name: 'C(a)'});
   *     p[1] = board.create('point', [-1.5, 5], {size:2, name: ''});
   *     p[2] = board.create('point', [1, 4], {size:2, name: ''});
   *     p[3] = board.create('point', [3, 3], {size:2, name: 'C(b)'});
   *
   *     // Curve
   *     var fg = JXG.Math.Numerics.Neville(p);
   *     var graph = board.create('curve', fg, {strokeWidth:3, strokeOpacity:0.5});
   *
   *     })();
   *
   * <\/script><pre>
   *
   */
  Neville: function(p) {
    var w = [], makeFct = function(fun2) {
      return function(t, suspendedUpdate) {
        var i2, d, s, bin = math_default.binomial, len = p.length, len1 = len - 1, num = 0, denom = 0;
        if (!suspendedUpdate) {
          s = 1;
          for (i2 = 0; i2 < len; i2++) {
            w[i2] = bin(len1, i2) * s;
            s *= -1;
          }
        }
        d = t;
        for (i2 = 0; i2 < len; i2++) {
          if (d === 0) {
            return p[i2][fun2]();
          }
          s = w[i2] / d;
          d -= 1;
          num += p[i2][fun2]() * s;
          denom += s;
        }
        return num / denom;
      };
    }, xfct = makeFct("X"), yfct = makeFct("Y");
    return [
      xfct,
      yfct,
      0,
      function() {
        return p.length - 1;
      }
    ];
  },
  /**
   * Calculates second derivatives at the given knots.
   * @param {Array} x x values of knots
   * @param {Array} y y values of knots
   * @returns {Array} Second derivatives of the interpolated function at the knots.
   * @see #splineEval
   * @memberof JXG.Math.Numerics
   */
  splineDef: function(x, y) {
    var pair, i2, l, n = Math.min(x.length, y.length), diag = [], z = [], data = [], dx = [], delta = [], F = [];
    if (n === 2) {
      return [0, 0];
    }
    for (i2 = 0; i2 < n; i2++) {
      pair = { X: x[i2], Y: y[i2] };
      data.push(pair);
    }
    data.sort(function(a, b) {
      return a.X - b.X;
    });
    for (i2 = 0; i2 < n; i2++) {
      x[i2] = data[i2].X;
      y[i2] = data[i2].Y;
    }
    for (i2 = 0; i2 < n - 1; i2++) {
      dx.push(x[i2 + 1] - x[i2]);
    }
    for (i2 = 0; i2 < n - 2; i2++) {
      delta.push(
        6 * (y[i2 + 2] - y[i2 + 1]) / dx[i2 + 1] - 6 * (y[i2 + 1] - y[i2]) / dx[i2]
      );
    }
    diag.push(2 * (dx[0] + dx[1]));
    z.push(delta[0]);
    for (i2 = 0; i2 < n - 3; i2++) {
      l = dx[i2 + 1] / diag[i2];
      diag.push(2 * (dx[i2 + 1] + dx[i2 + 2]) - l * dx[i2 + 1]);
      z.push(delta[i2 + 1] - l * z[i2]);
    }
    F[n - 3] = z[n - 3] / diag[n - 3];
    for (i2 = n - 4; i2 >= 0; i2--) {
      F[i2] = (z[i2] - dx[i2 + 1] * F[i2 + 1]) / diag[i2];
    }
    for (i2 = n - 3; i2 >= 0; i2--) {
      F[i2 + 1] = F[i2];
    }
    F[0] = 0;
    F[n - 1] = 0;
    return F;
  },
  /**
   * Evaluate points on spline.
   * @param {Number|Array} x0 A single float value or an array of values to evaluate
   * @param {Array} x x values of knots
   * @param {Array} y y values of knots
   * @param {Array} F Second derivatives at knots, calculated by {@link JXG.Math.Numerics.splineDef}
   * @see #splineDef
   * @returns {Number|Array} A single value or an array, depending on what is given as x0.
   * @memberof JXG.Math.Numerics
   */
  splineEval: function(x0, x, y, F) {
    var i2, j, a, b, c, d, x_, n = Math.min(x.length, y.length), l = 1, asArray = false, y0 = [];
    if (type_default.isArray(x0)) {
      l = x0.length;
      asArray = true;
    } else {
      x0 = [x0];
    }
    for (i2 = 0; i2 < l; i2++) {
      if (x0[i2] < x[0] || x[i2] > x[n - 1]) {
        return NaN;
      }
      for (j = 1; j < n; j++) {
        if (x0[i2] <= x[j]) {
          break;
        }
      }
      j -= 1;
      a = y[j];
      b = (y[j + 1] - y[j]) / (x[j + 1] - x[j]) - (x[j + 1] - x[j]) / 6 * (F[j + 1] + 2 * F[j]);
      c = F[j] / 2;
      d = (F[j + 1] - F[j]) / (6 * (x[j + 1] - x[j]));
      x_ = x0[i2] - x[j];
      y0.push(a + (b + (c + d * x_) * x_) * x_);
    }
    if (asArray) {
      return y0;
    }
    return y0[0];
  },
  /**
   * Generate a string containing the function term of a polynomial.
   * @param {Array} coeffs Coefficients of the polynomial. The position i belongs to x^i.
   * @param {Number} deg Degree of the polynomial
   * @param {String} varname Name of the variable (usually 'x')
   * @param {Number} prec Precision
   * @returns {String} A string containg the function term of the polynomial.
   * @memberof JXG.Math.Numerics
   */
  generatePolynomialTerm: function(coeffs, deg, varname, prec) {
    var i2, t = [];
    for (i2 = deg; i2 >= 0; i2--) {
      t = t.concat(["(", coeffs[i2].toPrecision(prec), ")"]);
      if (i2 > 1) {
        t = t.concat(["*", varname, "<sup>", i2, "<", "/sup> + "]);
      } else if (i2 === 1) {
        t = t.concat(["*", varname, " + "]);
      }
    }
    return t.join("");
  },
  /**
   * Computes the polynomial through a given set of coordinates in Lagrange form.
   * Returns the Lagrange polynomials, see
   * Jean-Paul Berrut, Lloyd N. Trefethen: Barycentric Lagrange Interpolation,
   * SIAM Review, Vol 46, No 3, (2004) 501-517.
   * <p>
   * It possesses the method getTerm() which returns the string containing the function term of the polynomial.
   * @param {Array} p Array of JXG.Points
   * @returns {function} A function of one parameter which returns the value of the polynomial, whose graph runs through the given points.
   * @memberof JXG.Math.Numerics
   *
   * @example
   * var p = [];
   * p[0] = board.create('point', [-1,2], {size:4});
   * p[1] = board.create('point', [0,3], {size:4});
   * p[2] = board.create('point', [1,1], {size:4});
   * p[3] = board.create('point', [3,-1], {size:4});
   * var f = JXG.Math.Numerics.lagrangePolynomial(p);
   * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
   *
   * </pre><div id="JXGc058aa6b-74d4-41e1-af94-df06169a2d89" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXGc058aa6b-74d4-41e1-af94-df06169a2d89',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *     var p = [];
   *     p[0] = board.create('point', [-1,2], {size:4});
   *     p[1] = board.create('point', [0,3], {size:4});
   *     p[2] = board.create('point', [1,1], {size:4});
   *     p[3] = board.create('point', [3,-1], {size:4});
   *     var f = JXG.Math.Numerics.lagrangePolynomial(p);
   *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
   *
   *     })();
   *
   * <\/script><pre>
   *
   * @example
   * var points = [];
   * points[0] = board.create('point', [-1,2], {size:4});
   * points[1] = board.create('point', [0, 0], {size:4});
   * points[2] = board.create('point', [2, 1], {size:4});
   *
   * var f = JXG.Math.Numerics.lagrangePolynomial(points);
   * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
   * var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});
   * var txt2 = board.create('text', [-3, -6,  () => f.getCoefficients()], {fontSize: 12});
   *
   * </pre><div id="JXG73fdaf12-e257-4374-b488-ae063e4eecbb" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXG73fdaf12-e257-4374-b488-ae063e4eecbb',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *     var points = [];
   *     points[0] = board.create('point', [-1,2], {size:4});
   *     points[1] = board.create('point', [0, 0], {size:4});
   *     points[2] = board.create('point', [2, 1], {size:4});
   *
   *     var f = JXG.Math.Numerics.lagrangePolynomial(points);
   *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
   *     var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});
   *     var txt2 = board.create('text', [-3, -6,  () => f.getCoefficients()], {fontSize: 12});
   *
   *     })();
   *
   * <\/script><pre>
   *
   */
  lagrangePolynomial: function(p) {
    var w = [], that2 = this, fct = function(x, suspendedUpdate) {
      var i2, k, xi, s, len = p.length, num = 0, denom = 0;
      if (!suspendedUpdate) {
        for (i2 = 0; i2 < len; i2++) {
          w[i2] = 1;
          xi = p[i2].X();
          for (k = 0; k < len; k++) {
            if (k !== i2) {
              w[i2] *= xi - p[k].X();
            }
          }
          w[i2] = 1 / w[i2];
        }
      }
      for (i2 = 0; i2 < len; i2++) {
        xi = p[i2].X();
        if (x === xi) {
          return p[i2].Y();
        }
        s = w[i2] / (x - xi);
        denom += s;
        num += s * p[i2].Y();
      }
      return num / denom;
    };
    fct.getTerm = function(digits, param, dot) {
      return that2.lagrangePolynomialTerm(p, digits, param, dot)();
    };
    fct.getCoefficients = function() {
      return that2.lagrangePolynomialCoefficients(p)();
    };
    return fct;
  },
  /**
   * Determine the Lagrange polynomial through an array of points and
   * return the term of the polynomial as string.
   *
   * @param {Array} points Array of JXG.Points
   * @param {Number} digits Number of decimal digits of the coefficients
   * @param {String} param Name of the parameter. Default: 'x'.
   * @param {String} dot Multiplication symbol. Default: ' * '.
   * @returns {Function} returning the Lagrange polynomial term through
   *    the supplied points as string
   * @memberof JXG.Math.Numerics
   *
   * @example
   * var points = [];
   * points[0] = board.create('point', [-1,2], {size:4});
   * points[1] = board.create('point', [0, 0], {size:4});
   * points[2] = board.create('point', [2, 1], {size:4});
   *
   * var f = JXG.Math.Numerics.lagrangePolynomial(points);
   * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
   *
   * var f_txt = JXG.Math.Numerics.lagrangePolynomialTerm(points, 2, 't', ' * ');
   * var txt = board.create('text', [-3, -4, f_txt], {fontSize: 16});
   *
   * </pre><div id="JXGd45e9e96-7526-486d-aa43-e1178d5f2baa" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXGd45e9e96-7526-486d-aa43-e1178d5f2baa',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *     var points = [];
   *     points[0] = board.create('point', [-1,2], {size:4});
   *     points[1] = board.create('point', [0, 0], {size:4});
   *     points[2] = board.create('point', [2, 1], {size:4});
   *
   *     var f = JXG.Math.Numerics.lagrangePolynomial(points);
   *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
   *
   *     var f_txt = JXG.Math.Numerics.lagrangePolynomialTerm(points, 2, 't', ' * ');
   *     var txt = board.create('text', [-3, -4, f_txt], {fontSize: 16});
   *
   *     })();
   *
   * <\/script><pre>
   *
   */
  lagrangePolynomialTerm: function(points, digits, param, dot) {
    var that2 = this;
    return function() {
      var len = points.length, coeffs = [], isLeading = true, n, t, j, c;
      param = param || "x";
      if (dot === void 0) {
        dot = " * ";
      }
      n = len - 1;
      coeffs = that2.lagrangePolynomialCoefficients(points)();
      t = "";
      for (j = 0; j < coeffs.length; j++) {
        c = coeffs[j];
        if (Math.abs(c) < math_default.eps) {
          continue;
        }
        if (jxg_default.exists(digits)) {
          c = env_default._round10(c, -digits);
        }
        if (isLeading) {
          t += c > 0 ? c : "-" + -c;
          isLeading = false;
        } else {
          t += c > 0 ? " + " + c : " - " + -c;
        }
        if (n - j > 1) {
          t += dot + param + "^" + (n - j);
        } else if (n - j === 1) {
          t += dot + param;
        }
      }
      return t;
    };
  },
  /**
   * Determine the Lagrange polynomial through an array of points and
   * return the coefficients of the polynomial as array.
   * The leading coefficient is at position 0.
   *
   * @param {Array} points Array of JXG.Points
   * @returns {Function} returning the coefficients of the Lagrange polynomial through
   *    the supplied points.
   * @memberof JXG.Math.Numerics
   *
   * @example
   * var points = [];
   * points[0] = board.create('point', [-1,2], {size:4});
   * points[1] = board.create('point', [0, 0], {size:4});
   * points[2] = board.create('point', [2, 1], {size:4});
   *
   * var f = JXG.Math.Numerics.lagrangePolynomial(points);
   * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
   *
   * var f_arr = JXG.Math.Numerics.lagrangePolynomialCoefficients(points);
   * var txt = board.create('text', [1, -4, f_arr], {fontSize: 10});
   *
   * </pre><div id="JXG1778f0d1-a420-473f-99e8-1755ef4be97e" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXG1778f0d1-a420-473f-99e8-1755ef4be97e',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *     var points = [];
   *     points[0] = board.create('point', [-1,2], {size:4});
   *     points[1] = board.create('point', [0, 0], {size:4});
   *     points[2] = board.create('point', [2, 1], {size:4});
   *
   *     var f = JXG.Math.Numerics.lagrangePolynomial(points);
   *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});
   *
   *     var f_arr = JXG.Math.Numerics.lagrangePolynomialCoefficients(points);
   *     var txt = board.create('text', [1, -4, f_arr], {fontSize: 10});
   *
   *     })();
   *
   * <\/script><pre>
   *
   */
  lagrangePolynomialCoefficients: function(points) {
    return function() {
      var len = points.length, zeroes = [], coeffs = [], coeffs_sum = [], i2, j, c, p;
      for (j = 0; j < len; j++) {
        coeffs_sum[j] = 0;
      }
      for (i2 = 0; i2 < len; i2++) {
        c = points[i2].Y();
        p = points[i2].X();
        zeroes = [];
        for (j = 0; j < len; j++) {
          if (j !== i2) {
            c /= p - points[j].X();
            zeroes.push(points[j].X());
          }
        }
        coeffs = [1].concat(math_default.Vieta(zeroes));
        for (j = 0; j < coeffs.length; j++) {
          coeffs_sum[j] += (j % 2 === 1 ? -1 : 1) * coeffs[j] * c;
        }
      }
      return coeffs_sum;
    };
  },
  /**
   * Determine the coefficients of a cardinal spline polynom, See
   * https://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections
   * @param  {Number} x1 point 1
   * @param  {Number} x2 point 2
   * @param  {Number} t1 tangent slope 1
   * @param  {Number} t2 tangent slope 2
   * @return {Array}    coefficents array c for the polynomial t maps to
   * c[0] + c[1]*t + c[2]*t*t + c[3]*t*t*t
   */
  _initCubicPoly: function(x1, x2, t1, t2) {
    return [x1, t1, -3 * x1 + 3 * x2 - 2 * t1 - t2, 2 * x1 - 2 * x2 + t1 + t2];
  },
  /**
   * Computes the cubic cardinal spline curve through a given set of points. The curve
   * is uniformly parametrized.
   * Two artificial control points at the beginning and the end are added.
   *
   * The implementation (especially the centripetal parametrization) is from
   * https://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections .
   * @param {Array} points Array consisting of JXG.Points.
   * @param {Number|Function} tau The tension parameter, either a constant number or a function returning a number. This number is between 0 and 1.
   * tau=1/2 give Catmull-Rom splines.
   * @param {String} type (Optional) parameter which allows to choose between "uniform" (default) and
   * "centripetal" parameterization. Thus the two possible values are "uniform" or "centripetal".
   * @returns {Array} An Array consisting of four components: Two functions each of one parameter t
   * which return the x resp. y coordinates of the Catmull-Rom-spline curve in t, a zero value,
   * and a function simply returning the length of the points array
   * minus three.
   * @memberof JXG.Math.Numerics
   */
  CardinalSpline: function(points, tau_param, type) {
    var p, coeffs = [], makeFct, tau, _tau, that2 = this;
    if (type_default.isFunction(tau_param)) {
      _tau = tau_param;
    } else {
      _tau = function() {
        return tau_param;
      };
    }
    if (type === void 0) {
      type = "uniform";
    }
    makeFct = function(which) {
      return function(t, suspendedUpdate) {
        var s, c, first, last, t1, t2, dt0, dt1, dt2, len;
        if (points.length < 2) {
          return NaN;
        }
        if (!suspendedUpdate) {
          tau = _tau();
          first = {
            X: function() {
              return 2 * points[0].X() - points[1].X();
            },
            Y: function() {
              return 2 * points[0].Y() - points[1].Y();
            },
            Dist: function(p2) {
              var dx = this.X() - p2.X(), dy = this.Y() - p2.Y();
              return math_default.hypot(dx, dy);
            }
          };
          last = {
            X: function() {
              return 2 * points[points.length - 1].X() - points[points.length - 2].X();
            },
            Y: function() {
              return 2 * points[points.length - 1].Y() - points[points.length - 2].Y();
            },
            Dist: function(p2) {
              var dx = this.X() - p2.X(), dy = this.Y() - p2.Y();
              return math_default.hypot(dx, dy);
            }
          };
          p = [first].concat(points, [last]);
          len = p.length;
          coeffs[which] = [];
          for (s = 0; s < len - 3; s++) {
            if (type === "centripetal") {
              dt0 = p[s].Dist(p[s + 1]);
              dt1 = p[s + 2].Dist(p[s + 1]);
              dt2 = p[s + 3].Dist(p[s + 2]);
              dt0 = Math.sqrt(dt0);
              dt1 = Math.sqrt(dt1);
              dt2 = Math.sqrt(dt2);
              if (dt1 < math_default.eps) {
                dt1 = 1;
              }
              if (dt0 < math_default.eps) {
                dt0 = dt1;
              }
              if (dt2 < math_default.eps) {
                dt2 = dt1;
              }
              t1 = (p[s + 1][which]() - p[s][which]()) / dt0 - (p[s + 2][which]() - p[s][which]()) / (dt1 + dt0) + (p[s + 2][which]() - p[s + 1][which]()) / dt1;
              t2 = (p[s + 2][which]() - p[s + 1][which]()) / dt1 - (p[s + 3][which]() - p[s + 1][which]()) / (dt2 + dt1) + (p[s + 3][which]() - p[s + 2][which]()) / dt2;
              t1 *= dt1;
              t2 *= dt1;
              coeffs[which][s] = that2._initCubicPoly(
                p[s + 1][which](),
                p[s + 2][which](),
                tau * t1,
                tau * t2
              );
            } else {
              coeffs[which][s] = that2._initCubicPoly(
                p[s + 1][which](),
                p[s + 2][which](),
                tau * (p[s + 2][which]() - p[s][which]()),
                tau * (p[s + 3][which]() - p[s + 1][which]())
              );
            }
          }
        }
        if (isNaN(t)) {
          return NaN;
        }
        len = points.length;
        if (t <= 0) {
          return points[0][which]();
        }
        if (t >= len) {
          return points[len - 1][which]();
        }
        s = Math.floor(t);
        if (s === t) {
          return points[s][which]();
        }
        t -= s;
        c = coeffs[which][s];
        if (c === void 0) {
          return NaN;
        }
        return ((c[3] * t + c[2]) * t + c[1]) * t + c[0];
      };
    };
    return [
      makeFct("X"),
      makeFct("Y"),
      0,
      function() {
        return points.length - 1;
      }
    ];
  },
  /**
   * Computes the cubic Catmull-Rom spline curve through a given set of points. The curve
   * is uniformly parametrized. The curve is the cardinal spline curve for tau=0.5.
   * Two artificial control points at the beginning and the end are added.
   * @param {Array} points Array consisting of JXG.Points.
   * @param {String} type (Optional) parameter which allows to choose between "uniform" (default) and
   * "centripetal" parameterization. Thus the two possible values are "uniform" or "centripetal".
   * @returns {Array} An Array consisting of four components: Two functions each of one parameter t
   * which return the x resp. y coordinates of the Catmull-Rom-spline curve in t, a zero value, and a function simply
   * returning the length of the points array minus three.
   * @memberof JXG.Math.Numerics
   */
  CatmullRomSpline: function(points, type) {
    return this.CardinalSpline(points, 0.5, type);
  },
  /**
   * Computes the regression polynomial of a given degree through a given set of coordinates.
   * Returns the regression polynomial function.
   * @param {Number|function|Slider} degree number, function or slider.
   * Either
   * @param {Array} dataX Array containing either the x-coordinates of the data set or both coordinates in
   * an array of {@link JXG.Point}s or {@link JXG.Coords}.
   * In the latter case, the <tt>dataY</tt> parameter will be ignored.
   * @param {Array} dataY Array containing the y-coordinates of the data set,
   * @returns {function} A function of one parameter which returns the value of the regression polynomial of the given degree.
   * It possesses the method getTerm() which returns the string containing the function term of the polynomial.
   * The function returned will throw an exception, if the data set is malformed.
   * @memberof JXG.Math.Numerics
   */
  regressionPolynomial: function(degree, dataX, dataY) {
    var coeffs, deg, dX, dY, inputType, fct, term = "";
    if (type_default.isPoint(degree) && type_default.isFunction(degree.Value)) {
      deg = function() {
        return degree.Value();
      };
    } else if (type_default.isFunction(degree)) {
      deg = degree;
    } else if (type_default.isNumber(degree)) {
      deg = function() {
        return degree;
      };
    } else {
      throw new Error(
        "JSXGraph: Can't create regressionPolynomial from degree of type'" + typeof degree + "'."
      );
    }
    if (arguments.length === 3 && type_default.isArray(dataX) && type_default.isArray(dataY)) {
      inputType = 0;
    } else if (arguments.length === 2 && type_default.isArray(dataX) && dataX.length > 0 && type_default.isPoint(dataX[0])) {
      inputType = 1;
    } else if (arguments.length === 2 && type_default.isArray(dataX) && dataX.length > 0 && dataX[0].usrCoords && dataX[0].scrCoords) {
      inputType = 2;
    } else {
      throw new Error("JSXGraph: Can't create regressionPolynomial. Wrong parameters.");
    }
    fct = function(x, suspendedUpdate) {
      var i2, j, M, MT, y, B, c, s, d, len = dataX.length;
      d = Math.floor(deg());
      if (!suspendedUpdate) {
        if (inputType === 1) {
          dX = [];
          dY = [];
          for (i2 = 0; i2 < len; i2++) {
            dX[i2] = dataX[i2].X();
            dY[i2] = dataX[i2].Y();
          }
        }
        if (inputType === 2) {
          dX = [];
          dY = [];
          for (i2 = 0; i2 < len; i2++) {
            dX[i2] = dataX[i2].usrCoords[1];
            dY[i2] = dataX[i2].usrCoords[2];
          }
        }
        if (inputType === 0) {
          dX = [];
          dY = [];
          for (i2 = 0; i2 < len; i2++) {
            if (type_default.isFunction(dataX[i2])) {
              dX.push(dataX[i2]());
            } else {
              dX.push(dataX[i2]);
            }
            if (type_default.isFunction(dataY[i2])) {
              dY.push(dataY[i2]());
            } else {
              dY.push(dataY[i2]);
            }
          }
        }
        M = [];
        for (j = 0; j < len; j++) {
          M.push([1]);
        }
        for (i2 = 1; i2 <= d; i2++) {
          for (j = 0; j < len; j++) {
            M[j][i2] = M[j][i2 - 1] * dX[j];
          }
        }
        y = dY;
        MT = math_default.transpose(M);
        B = math_default.matMatMult(MT, M);
        c = math_default.matVecMult(MT, y);
        coeffs = math_default.Numerics.Gauss(B, c);
        term = math_default.Numerics.generatePolynomialTerm(coeffs, d, "x", 3);
      }
      s = coeffs[d];
      for (i2 = d - 1; i2 >= 0; i2--) {
        s = s * x + coeffs[i2];
      }
      return s;
    };
    fct.getTerm = function() {
      return term;
    };
    return fct;
  },
  /**
   * Computes the cubic Bezier curve through a given set of points.
   * @param {Array} points Array consisting of 3*k+1 {@link JXG.Points}.
   * The points at position k with k mod 3 = 0 are the data points,
   * points at position k with k mod 3 = 1 or 2 are the control points.
   * @returns {Array} An array consisting of two functions of one parameter t which return the
   * x resp. y coordinates of the Bezier curve in t, one zero value, and a third function accepting
   * no parameters and returning one third of the length of the points.
   * @memberof JXG.Math.Numerics
   */
  bezier: function(points) {
    var len, flen, makeFct = function(which) {
      return function(t, suspendedUpdate) {
        var z = Math.floor(t) * 3, t0 = t % 1, t1 = 1 - t0;
        if (!suspendedUpdate) {
          flen = 3 * Math.floor((points.length - 1) / 3);
          len = Math.floor(flen / 3);
        }
        if (t < 0) {
          return points[0][which]();
        }
        if (t >= len) {
          return points[flen][which]();
        }
        if (isNaN(t)) {
          return NaN;
        }
        return t1 * t1 * (t1 * points[z][which]() + 3 * t0 * points[z + 1][which]()) + (3 * t1 * points[z + 2][which]() + t0 * points[z + 3][which]()) * t0 * t0;
      };
    };
    return [
      makeFct("X"),
      makeFct("Y"),
      0,
      function() {
        return Math.floor(points.length / 3);
      }
    ];
  },
  /**
   * Computes the B-spline curve of order k (order = degree+1) through a given set of points.
   * @param {Array} points Array consisting of JXG.Points.
   * @param {Number} order Order of the B-spline curve.
   * @returns {Array} An Array consisting of four components: Two functions each of one parameter t
   * which return the x resp. y coordinates of the B-spline curve in t, a zero value, and a function simply
   * returning the length of the points array minus one.
   * @memberof JXG.Math.Numerics
   */
  bspline: function(points, order) {
    var knots, _knotVector = function(n, k) {
      var j, kn = [];
      for (j = 0; j < n + k + 1; j++) {
        if (j < k) {
          kn[j] = 0;
        } else if (j <= n) {
          kn[j] = j - k + 1;
        } else {
          kn[j] = n - k + 2;
        }
      }
      return kn;
    }, _evalBasisFuncs = function(t, kn, k, s) {
      var i2, j, a, b, den, N = [];
      if (kn[s] <= t && t < kn[s + 1]) {
        N[s] = 1;
      } else {
        N[s] = 0;
      }
      for (i2 = 2; i2 <= k; i2++) {
        for (j = s - i2 + 1; j <= s; j++) {
          if (j <= s - i2 + 1 || j < 0) {
            a = 0;
          } else {
            a = N[j];
          }
          if (j >= s) {
            b = 0;
          } else {
            b = N[j + 1];
          }
          den = kn[j + i2 - 1] - kn[j];
          if (den === 0) {
            N[j] = 0;
          } else {
            N[j] = (t - kn[j]) / den * a;
          }
          den = kn[j + i2] - kn[j + 1];
          if (den !== 0) {
            N[j] += (kn[j + i2] - t) / den * b;
          }
        }
      }
      return N;
    }, makeFct = function(which) {
      return function(t, suspendedUpdate) {
        var y, j, s, N = [], len = points.length, n = len - 1, k = order;
        if (n <= 0) {
          return NaN;
        }
        if (n + 2 <= k) {
          k = n + 1;
        }
        if (t <= 0) {
          return points[0][which]();
        }
        if (t >= n - k + 2) {
          return points[n][which]();
        }
        s = Math.floor(t) + k - 1;
        knots = _knotVector(n, k);
        N = _evalBasisFuncs(t, knots, k, s);
        y = 0;
        for (j = s - k + 1; j <= s; j++) {
          if (j < len && j >= 0) {
            y += points[j][which]() * N[j];
          }
        }
        return y;
      };
    };
    return [
      makeFct("X"),
      makeFct("Y"),
      0,
      function() {
        return points.length - 1;
      }
    ];
  },
  /**
   * Numerical (symmetric) approximation of derivative. suspendUpdate is piped through,
   * see {@link JXG.Curve#updateCurve}
   * and {@link JXG.Curve#hasPoint}.
   * @param {function} f Function in one variable to be differentiated.
   * @param {object} [obj] Optional object that is treated as "this" in the function body. This is useful, if the function is a
   * method of an object and contains a reference to its parent object via "this".
   * @returns {function} Derivative function of a given function f.
   * @memberof JXG.Math.Numerics
   */
  D: function(f, obj) {
    if (!type_default.exists(obj)) {
      return function(x, suspendedUpdate) {
        var h = 1e-5, h2 = h * 2;
        return (f(x + h, suspendedUpdate) - f(x - h, suspendedUpdate)) / h2;
      };
    }
    return function(x, suspendedUpdate) {
      var h = 1e-5, h2 = h * 2;
      return (f.apply(obj, [x + h, suspendedUpdate]) - f.apply(obj, [x - h, suspendedUpdate])) / h2;
    };
  },
  /**
   * Evaluate the function term for {@see #riemann}.
   * @private
   * @param {Number} x function argument
   * @param {function} f JavaScript function returning a number
   * @param {String} type Name of the Riemann sum type, e.g. 'lower', see {@see #riemann}.
   * @param {Number} delta Width of the bars in user coordinates
   * @returns {Number} Upper (delta > 0) or lower (delta < 0) value of the bar containing x of the Riemann sum.
   *
   * @memberof JXG.Math.Numerics
   */
  _riemannValue: function(x, f, type, delta) {
    var y, y1, x1, delta1;
    if (delta < 0) {
      if (type !== "trapezoidal") {
        x = x + delta;
      }
      delta *= -1;
      if (type === "lower") {
        type = "upper";
      } else if (type === "upper") {
        type = "lower";
      }
    }
    delta1 = delta * 0.01;
    if (type === "right") {
      y = f(x + delta);
    } else if (type === "middle") {
      y = f(x + delta * 0.5);
    } else if (type === "left" || type === "trapezoidal") {
      y = f(x);
    } else if (type === "lower") {
      y = f(x);
      for (x1 = x + delta1; x1 <= x + delta; x1 += delta1) {
        y1 = f(x1);
        if (y1 < y) {
          y = y1;
        }
      }
      y1 = f(x + delta);
      if (y1 < y) {
        y = y1;
      }
    } else if (type === "upper") {
      y = f(x);
      for (x1 = x + delta1; x1 <= x + delta; x1 += delta1) {
        y1 = f(x1);
        if (y1 > y) {
          y = y1;
        }
      }
      y1 = f(x + delta);
      if (y1 > y) {
        y = y1;
      }
    } else if (type === "random") {
      y = f(x + delta * Math.random());
    } else if (type === "simpson") {
      y = (f(x) + 4 * f(x + delta * 0.5) + f(x + delta)) / 6;
    } else {
      y = f(x);
    }
    return y;
  },
  /**
   * Helper function to create curve which displays Riemann sums.
   * Compute coordinates for the rectangles showing the Riemann sum.
   * <p>
   * In case of type "simpson" and "trapezoidal", the horizontal line approximating the function value
   * is replaced by a parabola or a secant. IN case of "simpson",
   * the parabola is approximated visually by a polygonal chain of fixed step width.
   *
   * @param {Function|Array} f Function or array of two functions.
   * If f is a function the integral of this function is approximated by the Riemann sum.
   * If f is an array consisting of two functions the area between the two functions is filled
   * by the Riemann sum bars.
   * @param {Number} n number of rectangles.
   * @param {String} type Type of approximation. Possible values are: 'left', 'right', 'middle', 'lower', 'upper', 'random', 'simpson', or 'trapezoidal'.
   * "simpson" is Simpson's 1/3 rule.
   * @param {Number} start Left border of the approximation interval
   * @param {Number} end Right border of the approximation interval
   * @returns {Array} An array of two arrays containing the x and y coordinates for the rectangles showing the Riemann sum. This
   * array may be used as parent array of a {@link JXG.Curve}. The third parameteris the riemann sum, i.e. the sum of the volumes of all
   * rectangles.
   * @memberof JXG.Math.Numerics
   */
  riemann: function(gf, n, type, start, end) {
    var i2, delta, k, a, b, c, f0, f1, f2, xx, h, steps = 30, xarr = [], yarr = [], x = start, sum = 0, y, f, g;
    if (type_default.isArray(gf)) {
      g = gf[0];
      f = gf[1];
    } else {
      f = gf;
    }
    n = Math.floor(n);
    if (n <= 0) {
      return [xarr, yarr, sum];
    }
    delta = (end - start) / n;
    for (i2 = 0; i2 < n; i2++) {
      if (type === "simpson") {
        sum += this._riemannValue(x, f, type, delta) * delta;
        h = delta * 0.5;
        f0 = f(x);
        f1 = f(x + h);
        f2 = f(x + 2 * h);
        a = (f2 + f0 - 2 * f1) / (h * h) * 0.5;
        b = (f2 - f0) / (2 * h);
        c = f1;
        for (k = 0; k < steps; k++) {
          xx = k * delta / steps - h;
          xarr.push(x + xx + h);
          yarr.push(a * xx * xx + b * xx + c);
        }
        x += delta;
        y = f2;
      } else {
        y = this._riemannValue(x, f, type, delta);
        xarr.push(x);
        yarr.push(y);
        x += delta;
        if (type === "trapezoidal") {
          f2 = f(x);
          sum += (y + f2) * 0.5 * delta;
          y = f2;
        } else {
          sum += y * delta;
        }
        xarr.push(x);
        yarr.push(y);
      }
      xarr.push(x);
      yarr.push(y);
    }
    for (i2 = 0; i2 < n; i2++) {
      if (type === "simpson" && g) {
        sum -= this._riemannValue(x, g, type, -delta) * delta;
        h = delta * 0.5;
        f0 = g(x);
        f1 = g(x - h);
        f2 = g(x - 2 * h);
        a = (f2 + f0 - 2 * f1) / (h * h) * 0.5;
        b = (f2 - f0) / (2 * h);
        c = f1;
        for (k = 0; k < steps; k++) {
          xx = k * delta / steps - h;
          xarr.push(x - xx - h);
          yarr.push(a * xx * xx + b * xx + c);
        }
        x -= delta;
        y = f2;
      } else {
        if (g) {
          y = this._riemannValue(x, g, type, -delta);
        } else {
          y = 0;
        }
        xarr.push(x);
        yarr.push(y);
        x -= delta;
        if (g) {
          if (type === "trapezoidal") {
            f2 = g(x);
            sum -= (y + f2) * 0.5 * delta;
            y = f2;
          } else {
            sum -= y * delta;
          }
        }
      }
      xarr.push(x);
      yarr.push(y);
      xarr.push(x);
      yarr.push(f(x));
    }
    return [xarr, yarr, sum];
  },
  /**
   * Approximate the integral by Riemann sums.
   * Compute the area described by the riemann sum rectangles.
   *
   * If there is an element of type {@link Riemannsum}, then it is more efficient
   * to use the method JXG.Curve.Value() of this element instead.
   *
   * @param {Function_Array} f Function or array of two functions.
   * If f is a function the integral of this function is approximated by the Riemann sum.
   * If f is an array consisting of two functions the area between the two functions is approximated
   * by the Riemann sum.
   * @param {Number} n number of rectangles.
   * @param {String} type Type of approximation. Possible values are: 'left', 'right', 'middle', 'lower', 'upper', 'random', 'simpson' or 'trapezoidal'.
   *
   * @param {Number} start Left border of the approximation interval
   * @param {Number} end Right border of the approximation interval
   * @returns {Number} The sum of the areas of the rectangles.
   * @memberof JXG.Math.Numerics
   */
  riemannsum: function(f, n, type, start, end) {
    jxg_default.deprecated("Numerics.riemannsum()", "Numerics.riemann()[2]");
    return this.riemann(f, n, type, start, end)[2];
  },
  /**
   * Solve initial value problems numerically using <i>explicit</i> Runge-Kutta methods.
   * See {@link https://en.wikipedia.org/wiki/Runge-Kutta_methods} for more information on the algorithm.
   * @param {object|String} butcher Butcher tableau describing the Runge-Kutta method to use. This can be either a string describing
   * a Runge-Kutta method with a Butcher tableau predefined in JSXGraph like 'euler', 'heun', 'rk4' or an object providing the structure
   * <pre>
   * {
   *     s: &lt;Number&gt;,
   *     A: &lt;matrix&gt;,
   *     b: &lt;Array&gt;,
   *     c: &lt;Array&gt;
   * }
   * </pre>
   * which corresponds to the Butcher tableau structure
   * shown here: https://en.wikipedia.org/w/index.php?title=List_of_Runge%E2%80%93Kutta_methods&oldid=357796696 .
   * <i>Default</i> is 'euler'.
   * @param {Array} x0 Initial value vector. Even if the problem is one-dimensional, the initial value has to be given in an array.
   * @param {Array} I Interval on which to integrate.
   * @param {Number} N Number of integration intervals, i.e. there are <i>N+1</i> evaluation points.
   * @param {function} f Function describing the right hand side of the first order ordinary differential equation, i.e. if the ode
   * is given by the equation <pre>dx/dt = f(t, x(t))</pre>. So, f has to take two parameters, a number <tt>t</tt> and a
   * vector <tt>x</tt>, and has to return a vector of the same length as <tt>x</tt> has.
   * @returns {Array} An array of vectors describing the solution of the ode on the given interval I.
   * @example
   * // A very simple autonomous system dx(t)/dt = x(t);
   * var f = function(t, x) {
   *     return [x[0]];
   * }
   *
   * // Solve it with initial value x(0) = 1 on the interval [0, 2]
   * // with 20 evaluation points.
   * var data = JXG.Math.Numerics.rungeKutta('heun', [1], [0, 2], 20, f);
   *
   * // Prepare data for plotting the solution of the ode using a curve.
   * var dataX = [];
   * var dataY = [];
   * var h = 0.1;        // (I[1] - I[0])/N  = (2-0)/20
   * var i;
   * for(i=0; i&lt;data.length; i++) {
   *     dataX[i] = i*h;
   *     dataY[i] = data[i][0];
   * }
   * var g = board.create('curve', [dataX, dataY], {strokeWidth:'2px'});
   * </pre><div class="jxgbox" id="JXGd2432d04-4ef7-4159-a90b-a2eb8d38c4f6" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   * var board = JXG.JSXGraph.initBoard('JXGd2432d04-4ef7-4159-a90b-a2eb8d38c4f6', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});
   * var f = function(t, x) {
   *     // we have to copy the value.
   *     // return x; would just return the reference.
   *     return [x[0]];
   * }
   * var data = JXG.Math.Numerics.rungeKutta('heun', [1], [0, 2], 20, f);
   * var dataX = [];
   * var dataY = [];
   * var h = 0.1;
   * for(var i=0; i<data.length; i++) {
   *     dataX[i] = i*h;
   *     dataY[i] = data[i][0];
   * }
   * var g = board.create('curve', [dataX, dataY], {strokeColor:'red', strokeWidth:'2px'});
   * <\/script><pre>
   * @memberof JXG.Math.Numerics
   */
  rungeKutta: function(butcher, x0, I, N, f) {
    var e, i2, j, k, l, s, x = [], y = [], h = (I[1] - I[0]) / N, t = I[0], dim = x0.length, result = [], r = 0;
    if (type_default.isString(butcher)) {
      butcher = predefinedButcher[butcher] || predefinedButcher.euler;
    }
    s = butcher.s;
    x = x0.slice();
    for (i2 = 0; i2 <= N; i2++) {
      result[r] = x.slice();
      r++;
      k = [];
      for (j = 0; j < s; j++) {
        for (e = 0; e < dim; e++) {
          y[e] = 0;
        }
        for (l = 0; l < j; l++) {
          for (e = 0; e < dim; e++) {
            y[e] += butcher.A[j][l] * h * k[l][e];
          }
        }
        for (e = 0; e < dim; e++) {
          y[e] += x[e];
        }
        k.push(f(t + butcher.c[j] * h, y));
      }
      for (e = 0; e < dim; e++) {
        y[e] = 0;
      }
      for (l = 0; l < s; l++) {
        for (e = 0; e < dim; e++) {
          y[e] += butcher.b[l] * k[l][e];
        }
      }
      for (e = 0; e < dim; e++) {
        x[e] = x[e] + h * y[e];
      }
      t += h;
    }
    return result;
  },
  /**
   * Maximum number of iterations in {@link JXG.Math.Numerics.fzero} and
   * {@link JXG.Math.Numerics.chandrupatla}
   * @type Number
   * @default 80
   * @memberof JXG.Math.Numerics
   */
  maxIterationsRoot: 80,
  /**
   * Maximum number of iterations in {@link JXG.Math.Numerics.fminbr}
   * @type Number
   * @default 500
   * @memberof JXG.Math.Numerics
   */
  maxIterationsMinimize: 500,
  /**
   * Given a value x_0, this function tries to find a second value x_1 such that
   * the function f has opposite signs at x_0 and x_1.
   * The return values have to be tested if the method succeeded.
   *
   * @param {Function} f Function, whose root is to be found
   * @param {Number} x0 Start value
   * @param {Object} object Parent object in case f is method of it
   * @returns {Array} [x_0, f(x_0), x_1, f(x_1)] in case that x_0 <= x_1
   *   or [x_1, f(x_1), x_0, f(x_0)] in case that x_1 < x_0.
   *
   * @see JXG.Math.Numerics.fzero
   * @see JXG.Math.Numerics.chandrupatla
   *
   * @memberof JXG.Math.Numerics
   */
  findBracket: function(f, x0, object) {
    var a, aa, fa, blist, b, fb, u, fu, i2, len;
    if (type_default.isArray(x0)) {
      return x0;
    }
    a = x0;
    fa = f.call(object, a);
    aa = a === 0 ? 1 : a;
    blist = [
      a - 0.1 * aa,
      a + 0.1 * aa,
      a - 1,
      a + 1,
      a - 0.5 * aa,
      a + 0.5 * aa,
      a - 0.6 * aa,
      a + 0.6 * aa,
      a - 1 * aa,
      a + 1 * aa,
      a - 2 * aa,
      a + 2 * aa,
      a - 5 * aa,
      a + 5 * aa,
      a - 10 * aa,
      a + 10 * aa,
      a - 50 * aa,
      a + 50 * aa,
      a - 100 * aa,
      a + 100 * aa
    ];
    len = blist.length;
    for (i2 = 0; i2 < len; i2++) {
      b = blist[i2];
      fb = f.call(object, b);
      if (fa * fb <= 0) {
        break;
      }
    }
    if (b < a) {
      u = a;
      a = b;
      b = u;
      fu = fa;
      fa = fb;
      fb = fu;
    }
    return [a, fa, b, fb];
  },
  /**
   *
   * Find zero of an univariate function f.
   * @param {function} f Function, whose root is to be found
   * @param {Array|Number} x0  Start value or start interval enclosing the root
   * @param {Object} object Parent object in case f is method of it
   * @returns {Number} the approximation of the root
   * Algorithm:
   *  Brent's root finder from
   *  G.Forsythe, M.Malcolm, C.Moler, Computer methods for mathematical
   *  computations. M., Mir, 1980, p.180 of the Russian edition
   *  https://www.netlib.org/c/brent.shar
   *
   * If x0 is an array containing lower and upper bound for the zero
   * algorithm 748 is applied. Otherwise, if x0 is a number,
   * the algorithm tries to bracket a zero of f starting from x0.
   * If this fails, we fall back to Newton's method.
   *
   * @see JXG.Math.Numerics.chandrupatla
   * @see JXG.Math.Numerics.root
   * @memberof JXG.Math.Numerics
   */
  fzero: function(f, x0, object) {
    var a, b, c, fa, fb, fc, res, prev_step, t1, t2, cb, tol_act, p, q, new_step, eps = math_default.eps, maxiter = this.maxIterationsRoot, niter = 0;
    if (type_default.isArray(x0)) {
      if (x0.length < 2) {
        throw new Error(
          "JXG.Math.Numerics.fzero: length of array x0 has to be at least two."
        );
      }
      a = x0[0];
      fa = f.call(object, a);
      b = x0[1];
      fb = f.call(object, b);
    } else {
      res = this.findBracket(f, x0, object);
      a = res[0];
      fa = res[1];
      b = res[2];
      fb = res[3];
    }
    if (Math.abs(fa) <= eps) {
      return a;
    }
    if (Math.abs(fb) <= eps) {
      return b;
    }
    if (fa * fb > 0) {
      if (type_default.isArray(x0)) {
        return this.fminbr(f, [a, b], object);
      }
      return this.Newton(f, a, object);
    }
    c = a;
    fc = fa;
    while (niter < maxiter) {
      prev_step = b - a;
      if (Math.abs(fc) < Math.abs(fb)) {
        a = b;
        b = c;
        c = a;
        fa = fb;
        fb = fc;
        fc = fa;
      }
      tol_act = 2 * eps * Math.abs(b) + eps * 0.5;
      new_step = (c - b) * 0.5;
      if (Math.abs(new_step) <= tol_act || Math.abs(fb) <= eps) {
        return b;
      }
      if (Math.abs(prev_step) >= tol_act && Math.abs(fa) > Math.abs(fb)) {
        cb = c - b;
        if (a === c) {
          t1 = fb / fa;
          p = cb * t1;
          q = 1 - t1;
        } else {
          q = fa / fc;
          t1 = fb / fc;
          t2 = fb / fa;
          p = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1));
          q = (q - 1) * (t1 - 1) * (t2 - 1);
        }
        if (p > 0) {
          q = -q;
        } else {
          p = -p;
        }
        if (p < 0.75 * cb * q - Math.abs(tol_act * q) * 0.5 && p < Math.abs(prev_step * q * 0.5)) {
          new_step = p / q;
        }
      }
      if (Math.abs(new_step) < tol_act) {
        new_step = new_step > 0 ? tol_act : -tol_act;
      }
      a = b;
      fa = fb;
      b += new_step;
      fb = f.call(object, b);
      if (fb > 0 && fc > 0 || fb < 0 && fc < 0) {
        c = a;
        fc = fa;
      }
      niter++;
    }
    return b;
  },
  /**
   * Find zero of an univariate function f.
   * @param {function} f Function, whose root is to be found
   * @param {Array|Number} x0  Start value or start interval enclosing the root
   * @param {Object} object Parent object in case f is method of it
   * @returns {Number} the approximation of the root
   * Algorithm:
   * Chandrupatla's method, see
   * Tirupathi R. Chandrupatla,
   * "A new hybrid quadratic/bisection algorithm for finding the zero of a nonlinear function without using derivatives",
   * Advances in Engineering Software, Volume 28, Issue 3, April 1997, Pages 145-149.
   *
   * If x0 is an array containing lower and upper bound for the zero
   * algorithm 748 is applied. Otherwise, if x0 is a number,
   * the algorithm tries to bracket a zero of f starting from x0.
   * If this fails, we fall back to Newton's method.
   *
   * @see JXG.Math.Numerics.root
   * @see JXG.Math.Numerics.fzero
   * @memberof JXG.Math.Numerics
   */
  chandrupatla: function(f, x0, object) {
    var a, b, fa, fb, res, niter = 0, maxiter = this.maxIterationsRoot, rand = 1 + Math.random() * 1e-3, t = 0.5 * rand, eps = math_default.eps, dlt = 1e-5, x1, x2, x3, x, f1, f2, f3, y, xm, fm, tol, tl, xi, ph, fl, fh, AL, A, B, C, D;
    if (type_default.isArray(x0)) {
      if (x0.length < 2) {
        throw new Error(
          "JXG.Math.Numerics.fzero: length of array x0 has to be at least two."
        );
      }
      a = x0[0];
      fa = f.call(object, a);
      b = x0[1];
      fb = f.call(object, b);
    } else {
      res = this.findBracket(f, x0, object);
      a = res[0];
      fa = res[1];
      b = res[2];
      fb = res[3];
    }
    if (fa * fb > 0) {
      if (type_default.isArray(x0)) {
        return this.fminbr(f, [a, b], object);
      }
      return this.Newton(f, a, object);
    }
    x1 = a;
    x2 = b;
    f1 = fa;
    f2 = fb;
    do {
      x = x1 + t * (x2 - x1);
      y = f.call(object, x);
      if (Math.sign(y) === Math.sign(f1)) {
        x3 = x1;
        x1 = x;
        f3 = f1;
        f1 = y;
      } else {
        x3 = x2;
        x2 = x1;
        f3 = f2;
        f2 = f1;
      }
      x1 = x;
      f1 = y;
      xm = x1;
      fm = f1;
      if (Math.abs(f2) < Math.abs(f1)) {
        xm = x2;
        fm = f2;
      }
      tol = 2 * eps * Math.abs(xm) + 0.5 * dlt;
      tl = tol / Math.abs(x2 - x1);
      if (tl > 0.5 || fm === 0) {
        break;
      }
      xi = (x1 - x2) / (x3 - x2);
      ph = (f1 - f2) / (f3 - f2);
      fl = 1 - Math.sqrt(1 - xi);
      fh = Math.sqrt(xi);
      if (fl < ph && ph < fh) {
        AL = (x3 - x1) / (x2 - x1);
        A = f1 / (f2 - f1);
        B = f3 / (f2 - f3);
        C = f1 / (f3 - f1);
        D = f2 / (f3 - f2);
        t = A * B + C * D * AL;
      } else {
        t = 0.5 * rand;
      }
      if (t < tl) {
        t = tl;
      }
      if (t > 1 - tl) {
        t = 1 - tl;
      }
      niter++;
    } while (niter <= maxiter);
    return xm;
  },
  /**
   *
   * Find minimum of an univariate function f.
   * <p>
   * Algorithm:
   *  G.Forsythe, M.Malcolm, C.Moler, Computer methods for mathematical
   *  computations. M., Mir, 1980, p.180 of the Russian edition
   *
   * @param {function} f Function, whose minimum is to be found
   * @param {Array} x0  Start interval enclosing the minimum
   * @param {Object} context Parent object in case f is method of it
   * @returns {Number} the approximation of the minimum value position
   * @memberof JXG.Math.Numerics
   **/
  fminbr: function(f, x0, context) {
    var a, b, x, v, w, fx, fv, fw, range, middle_range, tol_act, new_step, p, q, t, ft, r = (3 - Math.sqrt(5)) * 0.5, tol = math_default.eps, sqrteps = math_default.eps, maxiter = this.maxIterationsMinimize, niter = 0;
    if (!type_default.isArray(x0) || x0.length < 2) {
      throw new Error(
        "JXG.Math.Numerics.fminbr: length of array x0 has to be at least two."
      );
    }
    a = x0[0];
    b = x0[1];
    v = a + r * (b - a);
    fv = f.call(context, v);
    x = v;
    w = v;
    fx = fv;
    fw = fv;
    while (niter < maxiter) {
      range = b - a;
      middle_range = (a + b) * 0.5;
      tol_act = sqrteps * Math.abs(x) + tol / 3;
      if (Math.abs(x - middle_range) + range * 0.5 <= 2 * tol_act) {
        return x;
      }
      new_step = r * (x < middle_range ? b - x : a - x);
      if (Math.abs(x - w) >= tol_act) {
        t = (x - w) * (fx - fv);
        q = (x - v) * (fx - fw);
        p = (x - v) * q - (x - w) * t;
        q = 2 * (q - t);
        if (q > 0) {
          p = -p;
        } else {
          q = -q;
        }
        if (Math.abs(p) < Math.abs(new_step * q) && // If x+p/q falls in [a,b]
        p > q * (a - x + 2 * tol_act) && //  not too close to a and
        p < q * (b - x - 2 * tol_act)) {
          new_step = p / q;
        }
      }
      if (Math.abs(new_step) < tol_act) {
        if (new_step > 0) {
          new_step = tol_act;
        } else {
          new_step = -tol_act;
        }
      }
      t = x + new_step;
      ft = f.call(context, t);
      if (ft <= fx) {
        if (t < x) {
          b = x;
        } else {
          a = x;
        }
        v = w;
        w = x;
        x = t;
        fv = fw;
        fw = fx;
        fx = ft;
      } else {
        if (t < x) {
          a = t;
        } else {
          b = t;
        }
        if (ft <= fw || w === x) {
          v = w;
          w = t;
          fv = fw;
          fw = ft;
        } else if (ft <= fv || v === x || v === w) {
          v = t;
          fv = ft;
        }
      }
      niter += 1;
    }
    return x;
  },
  /**
   *
   *   Purpose:
   *
   *   GLOMIN seeks a global minimum of a function F(X) in an interval [A,B].
   *
   * Discussion:
   *
   *  This function assumes that F(X) is twice continuously differentiable over [A,B]
   * and that F''(X) <= M for all X in [A,B].
   *
   * Licensing:
   *   This code is distributed under the GNU LGPL license.
   *
   * Modified:
   *
   *   17 April 2008
   *
   * Author:
   *
   *   Original FORTRAN77 version by Richard Brent.
   *   C version by John Burkardt.
   *   https://people.math.sc.edu/Burkardt/c_src/brent/brent.c
   *
   * Reference:
   *
   *   Richard Brent,
   *  Algorithms for Minimization Without Derivatives,
   *   Dover, 2002,
   *  ISBN: 0-486-41998-3,
   *   LC: QA402.5.B74.
   *
   * Parameters:
   *
   *   Input, double A, B, the endpoints of the interval.
   *  It must be the case that A < B.
   *
   *   Input, double C, an initial guess for the global
   *  minimizer.  If no good guess is known, C = A or B is acceptable.
   *
   *  Input, double M, the bound on the second derivative.
   *
   *   Input, double MACHEP, an estimate for the relative machine
   *  precision.
   *
   *   Input, double E, a positive tolerance, a bound for the
   *  absolute error in the evaluation of F(X) for any X in [A,B].
   *
   *   Input, double T, a positive error tolerance.
   *
   *    Input, double F (double x ), a user-supplied
   *  function whose global minimum is being sought.
   *
   *   Output, double *X, the estimated value of the abscissa
   *  for which F attains its global minimum value in [A,B].
   *
   *   Output, double GLOMIN, the value F(X).
   */
  glomin: function(f, x0) {
    var a0, a2, a3, d0, d1, d2, h, k, m2, p, q, qs, r, s, sc, y, y0, y1, y2, y3, yb, z0, z1, z2, a, b, c, x, m = 1e7, t = math_default.eps, e = math_default.eps * math_default.eps, machep = math_default.eps * math_default.eps * math_default.eps;
    a = x0[0];
    b = x0[1];
    c = f(a) < f(b) ? a : b;
    a0 = b;
    x = a0;
    a2 = a;
    y0 = f(b);
    yb = y0;
    y2 = f(a);
    y = y2;
    if (y0 < y) {
      y = y0;
    } else {
      x = a;
    }
    if (m <= 0 || b <= a) {
      return y;
    }
    m2 = 0.5 * (1 + 16 * machep) * m;
    if (c <= a || b <= c) {
      sc = 0.5 * (a + b);
    } else {
      sc = c;
    }
    y1 = f(sc);
    k = 3;
    d0 = a2 - sc;
    h = 9 / 11;
    if (y1 < y) {
      x = sc;
      y = y1;
    }
    for (; ; ) {
      d1 = a2 - a0;
      d2 = sc - a0;
      z2 = b - a2;
      z0 = y2 - y1;
      z1 = y2 - y0;
      r = d1 * d1 * z0 - d0 * d0 * z1;
      p = r;
      qs = 2 * (d0 * z1 - d1 * z0);
      q = qs;
      if (k < 1e6 || y2 <= y) {
        for (; ; ) {
          if (q * (r * (yb - y2) + z2 * q * (y2 - y + t)) < z2 * m2 * r * (z2 * q - r)) {
            a3 = a2 + r / q;
            y3 = f(a3);
            if (y3 < y) {
              x = a3;
              y = y3;
            }
          }
          k = 1611 * k % 1048576;
          q = 1;
          r = (b - a) * 1e-5 * k;
          if (z2 <= r) {
            break;
          }
        }
      } else {
        k = 1611 * k % 1048576;
        q = 1;
        r = (b - a) * 1e-5 * k;
        while (r < z2) {
          if (q * (r * (yb - y2) + z2 * q * (y2 - y + t)) < z2 * m2 * r * (z2 * q - r)) {
            a3 = a2 + r / q;
            y3 = f(a3);
            if (y3 < y) {
              x = a3;
              y = y3;
            }
          }
          k = 1611 * k % 1048576;
          q = 1;
          r = (b - a) * 1e-5 * k;
        }
      }
      r = m2 * d0 * d1 * d2;
      s = Math.sqrt((y2 - y + t) / m2);
      h = 0.5 * (1 + h);
      p = h * (p + 2 * r * s);
      q = q + 0.5 * qs;
      r = -0.5 * (d0 + (z0 + 2.01 * e) / (d0 * m2));
      if (r < s || d0 < 0) {
        r = a2 + s;
      } else {
        r = a2 + r;
      }
      if (0 < p * q) {
        a3 = a2 + p / q;
      } else {
        a3 = r;
      }
      for (; ; ) {
        a3 = Math.max(a3, r);
        if (b <= a3) {
          a3 = b;
          y3 = yb;
        } else {
          y3 = f(a3);
        }
        if (y3 < y) {
          x = a3;
          y = y3;
        }
        d0 = a3 - a2;
        if (a3 <= r) {
          break;
        }
        p = 2 * (y2 - y3) / (m * d0);
        if ((1 + 9 * machep) * d0 <= Math.abs(p)) {
          break;
        }
        if (0.5 * m2 * (d0 * d0 + p * p) <= y2 - y + (y3 - y) + 2 * t) {
          break;
        }
        a3 = 0.5 * (a2 + a3);
        h = 0.9 * h;
      }
      if (b <= a3) {
        break;
      }
      a0 = sc;
      sc = a2;
      a2 = a3;
      y0 = y1;
      y1 = y2;
      y2 = y3;
    }
    return [x, y];
  },
  /**
   * Determine all roots of a polynomial with real or complex coefficients by using the
   * iterative method attributed to Weierstrass, Durand, Kerner, Aberth, and Ehrlich. In particular,
   * the iteration method with cubic convergence is used that is usually attributed to Ehrlich-Aberth.
   * <p>
   * The returned roots are sorted with respect to their real values.
   * <p> This method makes use of the JSXGraph classes {@link JXG.Complex} and {@link JXG.C} to handle
   * complex numbers.
   *
   * @param {Array} a Array of coefficients of the polynomial a[0] + a[1]*x+ a[2]*x**2...
   * The coefficients are of type Number or JXG.Complex.
   * @param {Number} [deg] Optional degree of the polynomial. Otherwise all entries are taken, with
   * leading zeros removed.
   * @param {Number} [tol=Number.EPSILON] Approximation tolerance
   * @param {Number} [max_it=30] Maximum number of iterations
   * @param {Array} [initial_values=null] Array of initial values for the roots. If not given,
   * starting values are determined by the method of Ozawa.
   * @returns {Array} Array of complex numbers (of JXG.Complex) approximating the roots of the polynomial.
   * @memberof JXG.Math.Numerics
   * @see JXG.Complex
   * @see JXG.C
   *
   * @example
   * // Polynomial p(z) = -1 + 1z^2
   * var i, roots,
   *     p = [-1, 0, 1];
   *
   * roots = JXG.Math.Numerics.polzeros(p);
   * for (i = 0; i < roots.length; i++) {
   *     console.log(i, roots[i].toString());
   * }
   * // Output:
   *   0 -1 + -3.308722450212111e-24i
   *   1 1 + 0i
   *
   * @example
   * // Polynomial p(z) = -1 + 3z - 9z^2 + z^3 - 8z^6 + 9z^7 - 9z^8 + z^9
   * var i, roots,
   *     p = [-1, 3, -9, 1, 0, 0, -8, 9, -9, 1];
   *
   * roots = JXG.Math.Numerics.polzeros(p);
   * for (i = 0; i < roots.length; i++) {
   *     console.log(i, roots[i].toString());
   * }
   * // Output:
   * 0 -0.7424155888401961 + 0.4950476539211721i
   * 1 -0.7424155888401961 + -0.4950476539211721i
   * 2 0.16674869833354108 + 0.2980502714610669i
   * 3 0.16674869833354108 + -0.29805027146106694i
   * 4 0.21429002063640837 + 1.0682775088132996i
   * 5 0.21429002063640842 + -1.0682775088132999i
   * 6 0.861375497926218 + -0.6259177003583295i
   * 7 0.8613754979262181 + 0.6259177003583295i
   * 8 8.000002743888055 + -1.8367099231598242e-40i
   *
   */
  polzeros: function(coeffs, deg, tol, max_it, initial_values) {
    var i2, le, off, it, debug2 = false, cc = [], obvious = [], roots = [], hornerComplex = function(a, z, derivative) {
      var i3, s, n = a.length - 1;
      derivative = derivative || false;
      if (derivative) {
        s = jxg_default.C.mult(n, a[n]);
        for (i3 = n - 1; i3 > 0; i3--) {
          s.mult(z);
          s.add(jxg_default.C.mult(a[i3], i3));
        }
      } else {
        s = jxg_default.C.copy(a[n]);
        for (i3 = n - 1; i3 >= 0; i3--) {
          s.mult(z);
          s.add(a[i3]);
        }
      }
      return s;
    }, hornerRec = function(a, x, derivative) {
      var i3, s, n = a.length - 1;
      derivative = derivative || false;
      if (derivative) {
        s = jxg_default.C.mult(n, a[0]);
        for (i3 = n - 1; i3 > 0; i3--) {
          s.mult(x);
          s.add(jxg_default.C.mult(a[n - i3], i3));
        }
      } else {
        s = jxg_default.C.copy(a[0]);
        for (i3 = n - 1; i3 >= 0; i3--) {
          s.mult(x);
          s.add(a[n - i3]);
        }
      }
      return s;
    }, horner = function(a, x) {
      var i3, s, n = a.length - 1;
      s = a[n];
      for (i3 = n - 1; i3 >= 0; i3--) {
        s = s * x + a[i3];
      }
      return s;
    }, initial_guess = function(a) {
      var i3, r, n = a.length - 1, alpha1 = Math.PI * 2 / n, alpha0 = Math.PI / n * 0.5, b, z, init2 = [];
      b = jxg_default.C.mult(-1, a[n - 1]);
      b.div(jxg_default.C.mult(n, a[n]));
      z = jxg_default.C.div(hornerComplex(a, b), a[n]);
      r = Math.pow(jxg_default.C.abs(z), 1 / n);
      if (r === 0) {
        r = 1;
      }
      for (i3 = 0; i3 < n; i3++) {
        a = new jxg_default.Complex(r * Math.cos(alpha1 * i3 + alpha0), r * Math.sin(alpha1 * i3 + alpha0));
        init2[i3] = jxg_default.C.add(b, a);
      }
      return init2;
    }, aberthIteration = function(cc2, mu, max_it2, z) {
      var k, i3, j, done = [], cr = [], gamma, x, done_sum = 0, num, denom, s, pp, n = z.length;
      for (i3 = 0; i3 < n; i3++) {
        done.push(false);
      }
      for (i3 = 0; i3 < cc2.length; i3++) {
        cr.push(jxg_default.C.abs(cc2[i3]) * (4 * i3 + 1));
      }
      for (k = 0; k < max_it2 && done_sum < n; k++) {
        for (i3 = 0; i3 < n; i3++) {
          if (done[i3]) {
            continue;
          }
          num = hornerComplex(cc2, z[i3]);
          x = jxg_default.C.abs(z[i3]);
          if (jxg_default.C.abs(num) < mu * horner(cr, x)) {
            done[i3] = true;
            done_sum++;
            if (done_sum === n) {
              break;
            }
            continue;
          }
          if (x > 1) {
            gamma = jxg_default.C.div(1, z[i3]);
            pp = hornerRec(cc2, gamma, true);
            pp.div(hornerRec(cc2, gamma));
            pp.mult(gamma);
            num = jxg_default.C.sub(n, pp);
            num = jxg_default.C.div(z[i3], num);
          } else {
            num.div(hornerComplex(cc2, z[i3], true));
          }
          denom = new jxg_default.Complex(0);
          for (j = 0; j < n; j++) {
            if (j === i3) {
              continue;
            }
            s = jxg_default.C.sub(z[i3], z[j]);
            s = jxg_default.C.div(1, s);
            denom.add(s);
          }
          denom.mult(num);
          denom = jxg_default.C.sub(1, denom);
          num.div(denom);
          z[i3].sub(num);
        }
      }
      return k;
    };
    tol = tol || Number.EPSILON;
    max_it = max_it || 30;
    le = coeffs.length;
    if (jxg_default.isNumber(deg) && deg >= 0 && deg < le - 1) {
      le = deg + 1;
    }
    for (i2 = 0; i2 < le; i2++) {
      cc.push(new jxg_default.Complex(coeffs[i2]));
    }
    for (i2 = 0; i2 < le; i2++) {
      if (cc[i2].real !== 0 || cc[i2].imaginary !== 0) {
        off = i2;
        break;
      }
    }
    for (i2 = 0; i2 < off; i2++) {
      obvious.push(new jxg_default.Complex(0));
    }
    cc = cc.slice(off);
    le = cc.length;
    for (i2 = le - 1; i2 >= 0; i2--) {
      if (cc[i2].real !== 0 || cc[i2].imaginary !== 0) {
        break;
      }
      cc.pop();
    }
    le = cc.length;
    if (le === 0) {
      return [];
    }
    if (initial_values) {
      for (i2 = 0; i2 < le - 1; i2++) {
        roots.push(new jxg_default.Complex(initial_values[i2]));
      }
    } else {
      roots = initial_guess(cc);
    }
    it = aberthIteration(cc, tol, max_it, roots);
    roots = obvious.concat(roots);
    if (debug2) {
      console.log("Iterations:", it);
      console.log("Roots:");
      for (i2 = 0; i2 < roots.length; i2++) {
        console.log(i2, roots[i2].toString(), jxg_default.C.abs(hornerComplex(cc, roots[i2])));
      }
    }
    roots.sort(function(a, b) {
      if (a.real < b.real) {
        return -1;
      }
      if (a.real > b.real) {
        return 1;
      }
      return 0;
    });
    return roots;
  },
  /**
   * Implements the Ramer-Douglas-Peucker algorithm.
   * It discards points which are not necessary from the polygonal line defined by the point array
   * pts. The computation is done in screen coordinates.
   * Average runtime is O(nlog(n)), worst case runtime is O(n^2), where n is the number of points.
   * @param {Array} pts Array of {@link JXG.Coords}
   * @param {Number} eps If the absolute value of a given number <tt>x</tt> is smaller than <tt>eps</tt> it is considered to be equal <tt>0</tt>.
   * @returns {Array} An array containing points which represent an apparently identical curve as the points of pts do, but contains fewer points.
   * @memberof JXG.Math.Numerics
   */
  RamerDouglasPeucker: function(pts, eps) {
    var allPts = [], newPts = [], i2, k, len, endless = true, findSplit = function(pts2, i3, j) {
      var d, k2, ci, cj, ck, x0, y0, x1, y1, den, lbda, eps2 = math_default.eps * math_default.eps, huge = 1e4, dist = 0, f = i3;
      if (j - i3 < 2) {
        return [-1, 0];
      }
      ci = pts2[i3].scrCoords;
      cj = pts2[j].scrCoords;
      if (isNaN(ci[1]) || isNaN(ci[2])) {
        return [NaN, i3];
      }
      if (isNaN(cj[1]) || isNaN(cj[2])) {
        return [NaN, j];
      }
      for (k2 = i3 + 1; k2 < j; k2++) {
        ck = pts2[k2].scrCoords;
        if (isNaN(ck[1]) || isNaN(ck[2])) {
          return [NaN, k2];
        }
        x0 = ck[1] - ci[1];
        y0 = ck[2] - ci[2];
        x1 = cj[1] - ci[1];
        y1 = cj[2] - ci[2];
        x0 = x0 === Infinity ? huge : x0;
        y0 = y0 === Infinity ? huge : y0;
        x1 = x1 === Infinity ? huge : x1;
        y1 = y1 === Infinity ? huge : y1;
        x0 = x0 === -Infinity ? -huge : x0;
        y0 = y0 === -Infinity ? -huge : y0;
        x1 = x1 === -Infinity ? -huge : x1;
        y1 = y1 === -Infinity ? -huge : y1;
        den = x1 * x1 + y1 * y1;
        if (den > eps2) {
          lbda = (x0 * x1 + y0 * y1) / den;
          if (lbda < 0) {
            lbda = 0;
          } else if (lbda > 1) {
            lbda = 1;
          }
          x0 = x0 - lbda * x1;
          y0 = y0 - lbda * y1;
          d = x0 * x0 + y0 * y0;
        } else {
          lbda = 0;
          d = x0 * x0 + y0 * y0;
        }
        if (d > dist) {
          dist = d;
          f = k2;
        }
      }
      return [Math.sqrt(dist), f];
    }, RDP = function(pts2, i3, j, eps2, newPts2) {
      var result = findSplit(pts2, i3, j), k2 = result[1];
      if (isNaN(result[0])) {
        RDP(pts2, i3, k2 - 1, eps2, newPts2);
        newPts2.push(pts2[k2]);
        do {
          ++k2;
        } while (k2 <= j && isNaN(pts2[k2].scrCoords[1] + pts2[k2].scrCoords[2]));
        if (k2 <= j) {
          newPts2.push(pts2[k2]);
        }
        RDP(pts2, k2 + 1, j, eps2, newPts2);
      } else if (result[0] > eps2) {
        RDP(pts2, i3, k2, eps2, newPts2);
        RDP(pts2, k2, j, eps2, newPts2);
      } else {
        newPts2.push(pts2[j]);
      }
    };
    len = pts.length;
    i2 = 0;
    while (endless) {
      while (i2 < len && isNaN(pts[i2].scrCoords[1] + pts[i2].scrCoords[2])) {
        i2 += 1;
      }
      k = i2 + 1;
      while (k < len && !isNaN(pts[k].scrCoords[1] + pts[k].scrCoords[2])) {
        k += 1;
      }
      k--;
      if (i2 < len && k > i2) {
        newPts = [];
        newPts[0] = pts[i2];
        RDP(pts, i2, k, eps, newPts);
        allPts = allPts.concat(newPts);
      }
      if (i2 >= len) {
        break;
      }
      if (k < len - 1) {
        allPts.push(pts[k + 1]);
      }
      i2 = k + 1;
    }
    return allPts;
  },
  /**
   * Old name for the implementation of the Ramer-Douglas-Peucker algorithm.
   * @deprecated Use {@link JXG.Math.Numerics.RamerDouglasPeucker}
   * @memberof JXG.Math.Numerics
   */
  RamerDouglasPeuker: function(pts, eps) {
    jxg_default.deprecated("Numerics.RamerDouglasPeuker()", "Numerics.RamerDouglasPeucker()");
    return this.RamerDouglasPeucker(pts, eps);
  },
  /**
   * Implements the Visvalingam-Whyatt algorithm.
   * See M. Visvalingam, J. D. Whyatt:
   * "Line generalisation by repeated elimination of the smallest area", C.I.S.R.G Discussion paper 10, July 1992
   *
   * The algorithm discards points which are not necessary from the polygonal line defined by the point array
   * pts (consisting of type JXG.Coords).
   * @param {Array} pts Array of {@link JXG.Coords}
   * @param {Number} numPoints Number of remaining intermediate points. The first and the last point of the original points will
   *    be taken in any case.
   * @returns {Array} An array containing points which approximates the curve defined by pts.
   * @memberof JXG.Math.Numerics
   *
   * @example
   *     var i, p = [];
   *     for (i = 0; i < 5; ++i) {
   *         p.push(board.create('point', [Math.random() * 12 - 6, Math.random() * 12 - 6]));
   *     }
   *
   *     // Plot a cardinal spline curve
   *     var splineArr = JXG.Math.Numerics.CardinalSpline(p, 0.5);
   *     var cu1 = board.create('curve', splineArr, {strokeColor: 'green'});
   *
   *     var c = board.create('curve', [[0],[0]], {strokeWidth: 2, strokeColor: 'black'});
   *     c.updateDataArray = function() {
   *         var i, len, points;
   *
   *         // Reduce number of intermediate points with Visvakingam-Whyatt to 6
   *         points = JXG.Math.Numerics.Visvalingam(cu1.points, 6);
   *         // Plot the remaining points
   *         len = points.length;
   *         this.dataX = [];
   *         this.dataY = [];
   *         for (i = 0; i < len; i++) {
   *             this.dataX.push(points[i].usrCoords[1]);
   *             this.dataY.push(points[i].usrCoords[2]);
   *         }
   *     };
   *     board.update();
   *
   * </pre><div id="JXGce0cc55c-b592-11e6-8270-104a7d3be7eb" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXGce0cc55c-b592-11e6-8270-104a7d3be7eb',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *
   *         var i, p = [];
   *         for (i = 0; i < 5; ++i) {
   *             p.push(board.create('point', [Math.random() * 12 - 6, Math.random() * 12 - 6]));
   *         }
   *
   *         // Plot a cardinal spline curve
   *         var splineArr = JXG.Math.Numerics.CardinalSpline(p, 0.5);
   *         var cu1 = board.create('curve', splineArr, {strokeColor: 'green'});
   *
   *         var c = board.create('curve', [[0],[0]], {strokeWidth: 2, strokeColor: 'black'});
   *         c.updateDataArray = function() {
   *             var i, len, points;
   *
   *             // Reduce number of intermediate points with Visvakingam-Whyatt to 6
   *             points = JXG.Math.Numerics.Visvalingam(cu1.points, 6);
   *             // Plot the remaining points
   *             len = points.length;
   *             this.dataX = [];
   *             this.dataY = [];
   *             for (i = 0; i < len; i++) {
   *                 this.dataX.push(points[i].usrCoords[1]);
   *                 this.dataY.push(points[i].usrCoords[2]);
   *             }
   *         };
   *         board.update();
   *
   *     })();
   *
   * <\/script><pre>
   *
   */
  Visvalingam: function(pts, numPoints) {
    var i2, len, vol, lastVol, linkedList = [], heap = [], points = [], lft, rt, lft2, rt2, obj;
    len = pts.length;
    if (len <= 2) {
      return pts;
    }
    linkedList[0] = {
      used: true,
      lft: null,
      node: null
    };
    lft = 0;
    for (i2 = 1; i2 < len - 1; i2++) {
      vol = Math.abs(
        jxg_default.Math.Numerics.det([
          pts[i2 - 1].usrCoords,
          pts[i2].usrCoords,
          pts[i2 + 1].usrCoords
        ])
      );
      if (!isNaN(vol)) {
        obj = {
          v: vol,
          idx: i2
        };
        heap.push(obj);
        linkedList[i2] = {
          used: true,
          lft,
          node: obj
        };
        linkedList[lft].rt = i2;
        lft = i2;
      }
    }
    linkedList[len - 1] = {
      used: true,
      rt: null,
      lft,
      node: null
    };
    linkedList[lft].rt = len - 1;
    lastVol = -Infinity;
    while (heap.length > numPoints) {
      heap.sort(function(a, b) {
        return b.v - a.v;
      });
      i2 = heap.pop().idx;
      linkedList[i2].used = false;
      lastVol = linkedList[i2].node.v;
      lft = linkedList[i2].lft;
      rt = linkedList[i2].rt;
      linkedList[lft].rt = rt;
      linkedList[rt].lft = lft;
      lft2 = linkedList[lft].lft;
      if (lft2 !== null) {
        vol = Math.abs(
          jxg_default.Math.Numerics.det([
            pts[lft2].usrCoords,
            pts[lft].usrCoords,
            pts[rt].usrCoords
          ])
        );
        linkedList[lft].node.v = vol >= lastVol ? vol : lastVol;
      }
      rt2 = linkedList[rt].rt;
      if (rt2 !== null) {
        vol = Math.abs(
          jxg_default.Math.Numerics.det([
            pts[lft].usrCoords,
            pts[rt].usrCoords,
            pts[rt2].usrCoords
          ])
        );
        linkedList[rt].node.v = vol >= lastVol ? vol : lastVol;
      }
    }
    i2 = 0;
    points = [pts[i2]];
    do {
      i2 = linkedList[i2].rt;
      points.push(pts[i2]);
    } while (linkedList[i2].rt !== null);
    return points;
  }
};
var numerics_default = math_default.Numerics;

// node_modules/jsxgraph/src/math/geometry.js
math_default.Geometry = {};
jxg_default.extend(
  math_default.Geometry,
  /** @lends JXG.Math.Geometry */
  {
    /* ***************************************/
    /* *** GENERAL GEOMETRIC CALCULATIONS ****/
    /* ***************************************/
    /**
     * Calculates the angle defined by the points A, B, C.
     * @param {JXG.Point|Array} A A point  or [x,y] array.
     * @param {JXG.Point|Array} B Another point or [x,y] array.
     * @param {JXG.Point|Array} C A circle - no, of course the third point or [x,y] array.
     * @deprecated Use {@link JXG.Math.Geometry.rad} instead.
     * @see #rad
     * @see #trueAngle
     * @returns {Number} The angle in radian measure.
     */
    angle: function(A, B, C) {
      var u, v, s, t, a = [], b = [], c = [];
      jxg_default.deprecated("Geometry.angle()", "Geometry.rad()");
      if (A.coords) {
        a[0] = A.coords.usrCoords[1];
        a[1] = A.coords.usrCoords[2];
      } else {
        a[0] = A[0];
        a[1] = A[1];
      }
      if (B.coords) {
        b[0] = B.coords.usrCoords[1];
        b[1] = B.coords.usrCoords[2];
      } else {
        b[0] = B[0];
        b[1] = B[1];
      }
      if (C.coords) {
        c[0] = C.coords.usrCoords[1];
        c[1] = C.coords.usrCoords[2];
      } else {
        c[0] = C[0];
        c[1] = C[1];
      }
      u = a[0] - b[0];
      v = a[1] - b[1];
      s = c[0] - b[0];
      t = c[1] - b[1];
      return Math.atan2(u * t - v * s, u * s + v * t);
    },
    /**
     * Calculates the angle defined by the three points A, B, C if you're going from A to C around B counterclockwise.
     * @param {JXG.Point|Array} A Point or [x,y] array
     * @param {JXG.Point|Array} B Point or [x,y] array
     * @param {JXG.Point|Array} C Point or [x,y] array
     * @see #rad
     * @returns {Number} The angle in degrees.
     */
    trueAngle: function(A, B, C) {
      return this.rad(A, B, C) * 57.29577951308232;
    },
    /**
     * Calculates the internal angle defined by the three points A, B, C if you're going from A to C around B counterclockwise.
     * @param {JXG.Point|Array} A Point or [x,y] array
     * @param {JXG.Point|Array} B Point or [x,y] array
     * @param {JXG.Point|Array} C Point or [x,y] array
     * @see #trueAngle
     * @returns {Number} Angle in radians.
     */
    rad: function(A, B, C) {
      var ax, ay, bx, by, cx, cy, phi;
      if (A.coords) {
        ax = A.coords.usrCoords[1];
        ay = A.coords.usrCoords[2];
      } else {
        ax = A[0];
        ay = A[1];
      }
      if (B.coords) {
        bx = B.coords.usrCoords[1];
        by = B.coords.usrCoords[2];
      } else {
        bx = B[0];
        by = B[1];
      }
      if (C.coords) {
        cx = C.coords.usrCoords[1];
        cy = C.coords.usrCoords[2];
      } else {
        cx = C[0];
        cy = C[1];
      }
      phi = Math.atan2(cy - by, cx - bx) - Math.atan2(ay - by, ax - bx);
      if (phi < 0) {
        phi += 6.283185307179586;
      }
      return phi;
    },
    /**
     * Calculates a point on the bisection line between the three points A, B, C.
     * As a result, the bisection line is defined by two points:
     * Parameter B and the point with the coordinates calculated in this function.
     * Does not work for ideal points.
     * @param {JXG.Point} A Point
     * @param {JXG.Point} B Point
     * @param {JXG.Point} C Point
     * @param [board=A.board] Reference to the board
     * @returns {JXG.Coords} Coordinates of the second point defining the bisection.
     */
    angleBisector: function(A, B, C, board) {
      var phiA, phiC, phi, Ac = A.coords.usrCoords, Bc = B.coords.usrCoords, Cc = C.coords.usrCoords, x, y;
      if (!type_default.exists(board)) {
        board = A.board;
      }
      if (Bc[0] === 0) {
        return new coords_default(
          constants_default.COORDS_BY_USER,
          [1, (Ac[1] + Cc[1]) * 0.5, (Ac[2] + Cc[2]) * 0.5],
          board
        );
      }
      x = Ac[1] - Bc[1];
      y = Ac[2] - Bc[2];
      phiA = Math.atan2(y, x);
      x = Cc[1] - Bc[1];
      y = Cc[2] - Bc[2];
      phiC = Math.atan2(y, x);
      phi = (phiA + phiC) * 0.5;
      if (phiA > phiC) {
        phi += Math.PI;
      }
      x = Math.cos(phi) + Bc[1];
      y = Math.sin(phi) + Bc[2];
      return new coords_default(constants_default.COORDS_BY_USER, [1, x, y], board);
    },
    // /**
    //  * Calculates a point on the m-section line between the three points A, B, C.
    //  * As a result, the m-section line is defined by two points:
    //  * Parameter B and the point with the coordinates calculated in this function.
    //  * The m-section generalizes the bisector to any real number.
    //  * For example, the trisectors of an angle are simply the 1/3-sector and the 2/3-sector.
    //  * Does not work for ideal points.
    //  * @param {JXG.Point} A Point
    //  * @param {JXG.Point} B Point
    //  * @param {JXG.Point} C Point
    //  * @param {Number} m Number
    //  * @param [board=A.board] Reference to the board
    //  * @returns {JXG.Coords} Coordinates of the second point defining the bisection.
    //  */
    // angleMsector: function (A, B, C, m, board) {
    //     var phiA, phiC, phi,
    //         Ac = A.coords.usrCoords,
    //         Bc = B.coords.usrCoords,
    //         Cc = C.coords.usrCoords,
    //         x, y;
    //     if (!Type.exists(board)) {
    //         board = A.board;
    //     }
    //     // Parallel lines
    //     if (Bc[0] === 0) {
    //         return new Coords(Const.COORDS_BY_USER,
    //             [1, (Ac[1] + Cc[1]) * m, (Ac[2] + Cc[2]) * m], board);
    //     }
    //     // Non-parallel lines
    //     x = Ac[1] - Bc[1];
    //     y = Ac[2] - Bc[2];
    //     phiA =  Math.atan2(y, x);
    //     x = Cc[1] - Bc[1];
    //     y = Cc[2] - Bc[2];
    //     phiC =  Math.atan2(y, x);
    //     phi = phiA + ((phiC - phiA) * m);
    //     if (phiA - phiC > Math.PI) {
    //         phi += 2*m*Math.PI;
    //     }
    //     x = Math.cos(phi) + Bc[1];
    //     y = Math.sin(phi) + Bc[2];
    //     return new Coords(Const.COORDS_BY_USER, [1, x, y], board);
    // },
    /**
     * Reflects the point along the line.
     * @param {JXG.Line} line Axis of reflection.
     * @param {JXG.Point} point Point to reflect.
     * @param [board=point.board] Reference to the board
     * @returns {JXG.Coords} Coordinates of the reflected point.
     */
    reflection: function(line, point, board) {
      var x0, y0, x1, y1, v, w, mu, pc = point.coords.usrCoords, p1c = line.point1.coords.usrCoords, p2c = line.point2.coords.usrCoords;
      if (!type_default.exists(board)) {
        board = point.board;
      }
      v = p2c[1] - p1c[1];
      w = p2c[2] - p1c[2];
      x0 = pc[1] - p1c[1];
      y0 = pc[2] - p1c[2];
      mu = (v * y0 - w * x0) / (v * v + w * w);
      x1 = pc[1] + 2 * mu * w;
      y1 = pc[2] - 2 * mu * v;
      return new coords_default(constants_default.COORDS_BY_USER, [x1, y1], board);
    },
    /**
     * Computes the new position of a point which is rotated
     * around a second point (called rotpoint) by the angle phi.
     * @param {JXG.Point} rotpoint Center of the rotation
     * @param {JXG.Point} point point to be rotated
     * @param {Number} phi rotation angle in arc length
     * @param {JXG.Board} [board=point.board] Reference to the board
     * @returns {JXG.Coords} Coordinates of the new position.
     */
    rotation: function(rotpoint, point, phi, board) {
      var x0, y0, c, s, x1, y1, pc = point.coords.usrCoords, rotpc = rotpoint.coords.usrCoords;
      if (!type_default.exists(board)) {
        board = point.board;
      }
      x0 = pc[1] - rotpc[1];
      y0 = pc[2] - rotpc[2];
      c = Math.cos(phi);
      s = Math.sin(phi);
      x1 = x0 * c - y0 * s + rotpc[1];
      y1 = x0 * s + y0 * c + rotpc[2];
      return new coords_default(constants_default.COORDS_BY_USER, [x1, y1], board);
    },
    /**
     * Calculates the coordinates of a point on the perpendicular to the given line through
     * the given point.
     * @param {JXG.Line} line A line.
     * @param {JXG.Point} point Point which is projected to the line.
     * @param {JXG.Board} [board=point.board] Reference to the board
     * @returns {Array} Array of length two containing coordinates of a point on the perpendicular to the given line
     *                  through the given point and boolean flag "change".
     */
    perpendicular: function(line, point, board) {
      var x, y, change, c, z, A = line.point1.coords.usrCoords, B = line.point2.coords.usrCoords, C = point.coords.usrCoords;
      if (!type_default.exists(board)) {
        board = point.board;
      }
      if (point === line.point1) {
        x = A[1] + B[2] - A[2];
        y = A[2] - B[1] + A[1];
        z = A[0] * B[0];
        if (Math.abs(z) < math_default.eps) {
          x = B[2];
          y = -B[1];
        }
        c = [z, x, y];
        change = true;
      } else if (point === line.point2) {
        x = B[1] + A[2] - B[2];
        y = B[2] - A[1] + B[1];
        z = A[0] * B[0];
        if (Math.abs(z) < math_default.eps) {
          x = A[2];
          y = -A[1];
        }
        c = [z, x, y];
        change = false;
      } else if (Math.abs(math_default.innerProduct(C, line.stdform, 3)) < math_default.eps) {
        x = C[1] + B[2] - C[2];
        y = C[2] - B[1] + C[1];
        z = B[0];
        if (Math.abs(z) < math_default.eps) {
          x = B[2];
          y = -B[1];
        }
        change = true;
        if (Math.abs(z) > math_default.eps && Math.abs(x - C[1]) < math_default.eps && Math.abs(y - C[2]) < math_default.eps) {
          x = C[1] + A[2] - C[2];
          y = C[2] - A[1] + C[1];
          change = false;
        }
        c = [z, x, y];
      } else {
        c = [0, line.stdform[1], line.stdform[2]];
        c = math_default.crossProduct(c, C);
        c = math_default.crossProduct(c, line.stdform);
        change = true;
      }
      return [new coords_default(constants_default.COORDS_BY_USER, c, board), change];
    },
    /**
     * @deprecated Please use {@link JXG.Math.Geometry.circumcenter} instead.
     */
    circumcenterMidpoint: function() {
      jxg_default.deprecated("Geometry.circumcenterMidpoint()", "Geometry.circumcenter()");
      this.circumcenter.apply(this, arguments);
    },
    /**
     * Calculates the center of the circumcircle of the three given points.
     * @param {JXG.Point} point1 Point
     * @param {JXG.Point} point2 Point
     * @param {JXG.Point} point3 Point
     * @param {JXG.Board} [board=point1.board] Reference to the board
     * @returns {JXG.Coords} Coordinates of the center of the circumcircle of the given points.
     */
    circumcenter: function(point1, point2, point3, board) {
      var u, v, m1, m2, A = point1.coords.usrCoords, B = point2.coords.usrCoords, C = point3.coords.usrCoords;
      if (!type_default.exists(board)) {
        board = point1.board;
      }
      u = [B[0] - A[0], -B[2] + A[2], B[1] - A[1]];
      v = [(A[0] + B[0]) * 0.5, (A[1] + B[1]) * 0.5, (A[2] + B[2]) * 0.5];
      m1 = math_default.crossProduct(u, v);
      u = [C[0] - B[0], -C[2] + B[2], C[1] - B[1]];
      v = [(B[0] + C[0]) * 0.5, (B[1] + C[1]) * 0.5, (B[2] + C[2]) * 0.5];
      m2 = math_default.crossProduct(u, v);
      return new coords_default(constants_default.COORDS_BY_USER, math_default.crossProduct(m1, m2), board);
    },
    /**
     * Calculates the Euclidean distance for two given arrays of the same length.
     * @param {Array} array1 Array of Number
     * @param {Array} array2 Array of Number
     * @param {Number} [n] Length of the arrays. Default is the minimum length of the given arrays.
     * @returns {Number} Euclidean distance of the given vectors.
     */
    distance: function(array1, array2, n) {
      var i2, sum = 0;
      if (!n) {
        n = Math.min(array1.length, array2.length);
      }
      for (i2 = 0; i2 < n; i2++) {
        sum += (array1[i2] - array2[i2]) * (array1[i2] - array2[i2]);
      }
      return Math.sqrt(sum);
    },
    /**
     * Calculates Euclidean distance for two given arrays of the same length.
     * If one of the arrays contains a zero in the first coordinate, and the Euclidean distance
     * is different from zero it is a point at infinity and we return Infinity.
     * @param {Array} array1 Array containing elements of type number.
     * @param {Array} array2 Array containing elements of type number.
     * @param {Number} [n] Length of the arrays. Default is the minimum length of the given arrays.
     * @returns {Number} Euclidean (affine) distance of the given vectors.
     */
    affineDistance: function(array1, array2, n) {
      var d;
      d = this.distance(array1, array2, n);
      if (d > math_default.eps && (Math.abs(array1[0]) < math_default.eps || Math.abs(array2[0]) < math_default.eps)) {
        return Infinity;
      }
      return d;
    },
    /**
     * Affine ratio of three collinear points a, b, c: (c - a) / (b - a).
     * If r > 1 or r < 0 then c is outside of the segment ab.
     *
     * @param {Array|JXG.Coords} a
     * @param {Array|JXG.Coords} b
     * @param {Array|JXG.Coords} c
     * @returns {Number} affine ratio (c - a) / (b - a)
     */
    affineRatio: function(a, b, c) {
      var r = 0, dx;
      if (type_default.exists(a.usrCoords)) {
        a = a.usrCoords;
      }
      if (type_default.exists(b.usrCoords)) {
        b = b.usrCoords;
      }
      if (type_default.exists(c.usrCoords)) {
        c = c.usrCoords;
      }
      dx = b[1] - a[1];
      if (Math.abs(dx) > math_default.eps) {
        r = (c[1] - a[1]) / dx;
      } else {
        r = (c[2] - a[2]) / (b[2] - a[2]);
      }
      return r;
    },
    /**
     * Sort vertices counter clockwise starting with the first point.
     *
     * @param {Array} p An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.
     *
     * @returns {Array}
     */
    sortVertices: function(p) {
      var ll, ps = expect_default.each(p, expect_default.coordsArray), N = ps.length, lastPoint = null;
      while (ps[0][0] === ps[N - 1][0] && ps[0][1] === ps[N - 1][1] && ps[0][2] === ps[N - 1][2]) {
        lastPoint = ps.pop();
        N--;
      }
      ll = ps[0];
      ps.sort(function(a, b) {
        var rad1 = a[2] === ll[2] && a[1] === ll[1] ? -Infinity : Math.atan2(a[2] - ll[2], a[1] - ll[1]), rad2 = b[2] === ll[2] && b[1] === ll[1] ? -Infinity : Math.atan2(b[2] - ll[2], b[1] - ll[1]);
        return rad1 - rad2;
      });
      if (lastPoint !== null) {
        ps.push(lastPoint);
      }
      return ps;
    },
    /**
     * Signed triangle area of the three points given.
     *
     * @param {JXG.Point|JXG.Coords|Array} p1
     * @param {JXG.Point|JXG.Coords|Array} p2
     * @param {JXG.Point|JXG.Coords|Array} p3
     *
     * @returns {Number}
     */
    signedTriangle: function(p1, p2, p3) {
      var A = expect_default.coordsArray(p1), B = expect_default.coordsArray(p2), C = expect_default.coordsArray(p3);
      return 0.5 * ((B[1] - A[1]) * (C[2] - A[2]) - (B[2] - A[2]) * (C[1] - A[1]));
    },
    /**
     * Determine the signed area of a non-selfintersecting polygon.
     * Surveyor's Formula
     *
     * @param {Array} p An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.
     * @param {Boolean} [sort=true]
     *
     * @returns {Number}
     */
    signedPolygon: function(p, sort) {
      var i2, N, A = 0, ps = expect_default.each(p, expect_default.coordsArray);
      if (sort === void 0) {
        sort = true;
      }
      if (!sort) {
        ps = this.sortVertices(ps);
      } else {
        ps.unshift(ps[ps.length - 1]);
      }
      N = ps.length;
      for (i2 = 1; i2 < N; i2++) {
        A += ps[i2 - 1][1] * ps[i2][2] - ps[i2][1] * ps[i2 - 1][2];
      }
      return 0.5 * A;
    },
    /**
     * Calculate the complex hull of a point cloud.
     *
     * @param {Array} points An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.
     *
     * @returns {Array}
     */
    GrahamScan: function(points) {
      var i2, M = 1, ps = expect_default.each(points, expect_default.coordsArray), N = ps.length;
      ps = this.sortVertices(ps);
      N = ps.length;
      for (i2 = 2; i2 < N; i2++) {
        while (this.signedTriangle(ps[M - 1], ps[M], ps[i2]) <= 0) {
          if (M > 1) {
            M -= 1;
          } else if (i2 === N - 1) {
            break;
          }
          i2 += 1;
        }
        M += 1;
        ps = type_default.swap(ps, M, i2);
      }
      return ps.slice(0, M);
    },
    /**
     * A line can be a segment, a straight, or a ray. So it is not always delimited by point1 and point2
     * calcStraight determines the visual start point and end point of the line. A segment is only drawn
     * from start to end point, a straight line is drawn until it meets the boards boundaries.
     * @param {JXG.Line} el Reference to a line object, that needs calculation of start and end point.
     * @param {JXG.Coords} point1 Coordinates of the point where line drawing begins. This value is calculated and
     * set by this method.
     * @param {JXG.Coords} point2 Coordinates of the point where line drawing ends. This value is calculated and set
     * by this method.
     * @param {Number} margin Optional margin, to avoid the display of the small sides of lines.
     * @returns null
     * @see Line
     * @see JXG.Line
     */
    calcStraight: function(el, point1, point2, margin) {
      var takePoint1, takePoint2, intersection, intersect1, intersect2, straightFirst, straightLast, c, p1, p2;
      if (!type_default.exists(margin)) {
        margin = 10;
      }
      straightFirst = type_default.evaluate(el.visProp.straightfirst);
      straightLast = type_default.evaluate(el.visProp.straightlast);
      if (Math.abs(point1.scrCoords[0]) < math_default.eps) {
        straightFirst = true;
      }
      if (Math.abs(point2.scrCoords[0]) < math_default.eps) {
        straightLast = true;
      }
      if (!straightFirst && !straightLast) {
        return;
      }
      c = [];
      c[0] = el.stdform[0] - el.stdform[1] * el.board.origin.scrCoords[1] / el.board.unitX + el.stdform[2] * el.board.origin.scrCoords[2] / el.board.unitY;
      c[1] = el.stdform[1] / el.board.unitX;
      c[2] = -el.stdform[2] / el.board.unitY;
      if (isNaN(c[0] + c[1] + c[2])) {
        return;
      }
      takePoint1 = false;
      takePoint2 = false;
      takePoint1 = !straightFirst && Math.abs(point1.usrCoords[0]) >= math_default.eps && point1.scrCoords[1] >= 0 && point1.scrCoords[1] <= el.board.canvasWidth && point1.scrCoords[2] >= 0 && point1.scrCoords[2] <= el.board.canvasHeight;
      takePoint2 = !straightLast && Math.abs(point2.usrCoords[0]) >= math_default.eps && point2.scrCoords[1] >= 0 && point2.scrCoords[1] <= el.board.canvasWidth && point2.scrCoords[2] >= 0 && point2.scrCoords[2] <= el.board.canvasHeight;
      intersection = this.meetLineBoard(c, el.board, margin);
      intersect1 = intersection[0];
      intersect2 = intersection[1];
      if (!takePoint1 && !takePoint2) {
        if (!straightFirst && straightLast && !this.isSameDirection(point1, point2, intersect1) && !this.isSameDirection(point1, point2, intersect2)) {
          return;
        }
        if (straightFirst && !straightLast && !this.isSameDirection(point2, point1, intersect1) && !this.isSameDirection(point2, point1, intersect2)) {
          return;
        }
      }
      if (!takePoint1) {
        if (!takePoint2) {
          if (this.isSameDir(point1, point2, intersect1, intersect2)) {
            p1 = intersect1;
            p2 = intersect2;
          } else {
            p2 = intersect1;
            p1 = intersect2;
          }
        } else {
          if (this.isSameDir(point1, point2, intersect1, intersect2)) {
            p1 = intersect1;
          } else {
            p1 = intersect2;
          }
        }
      } else {
        if (!takePoint2) {
          if (this.isSameDir(point1, point2, intersect1, intersect2)) {
            p2 = intersect2;
          } else {
            p2 = intersect1;
          }
        }
      }
      if (p1) {
        point1.setCoordinates(constants_default.COORDS_BY_USER, p1.usrCoords);
      }
      if (p2) {
        point2.setCoordinates(constants_default.COORDS_BY_USER, p2.usrCoords);
      }
    },
    /**
     * A line can be a segment, a straight, or a ray. so it is not always delimited by point1 and point2.
     *
     * This method adjusts the line's delimiting points taking into account its nature, the viewport defined
     * by the board.
     *
     * A segment is delimited by start and end point, a straight line or ray is delimited until it meets the
     * boards boundaries. However, if the line has infinite ticks, it will be delimited by the projection of
     * the boards vertices onto itself.
     *
     * @param {JXG.Line} el Reference to a line object, that needs calculation of start and end point.
     * @param {JXG.Coords} point1 Coordinates of the point where line drawing begins. This value is calculated and
     * set by this method.
     * @param {JXG.Coords} point2 Coordinates of the point where line drawing ends. This value is calculated and set
     * by this method.
     * @see Line
     * @see JXG.Line
     */
    calcLineDelimitingPoints: function(el, point1, point2) {
      var distP1P2, boundingBox, lineSlope, intersect1, intersect2, straightFirst, straightLast, c, p1, p2, takePoint1 = false, takePoint2 = false;
      straightFirst = type_default.evaluate(el.visProp.straightfirst);
      straightLast = type_default.evaluate(el.visProp.straightlast);
      if (Math.abs(point1.scrCoords[0]) < math_default.eps) {
        straightFirst = true;
      }
      if (Math.abs(point2.scrCoords[0]) < math_default.eps) {
        straightLast = true;
      }
      c = [];
      c[0] = el.stdform[0] - el.stdform[1] * el.board.origin.scrCoords[1] / el.board.unitX + el.stdform[2] * el.board.origin.scrCoords[2] / el.board.unitY;
      c[1] = el.stdform[1] / el.board.unitX;
      c[2] = -el.stdform[2] / el.board.unitY;
      if (isNaN(c[0] + c[1] + c[2])) {
        return;
      }
      takePoint1 = !straightFirst;
      takePoint2 = !straightLast;
      boundingBox = el.board.getBoundingBox();
      lineSlope = el.getSlope();
      if (lineSlope >= 0) {
        intersect1 = this.projectPointToLine(
          { coords: { usrCoords: [1, boundingBox[2], boundingBox[1]] } },
          el,
          el.board
        );
        intersect2 = this.projectPointToLine(
          { coords: { usrCoords: [1, boundingBox[0], boundingBox[3]] } },
          el,
          el.board
        );
      } else {
        intersect1 = this.projectPointToLine(
          { coords: { usrCoords: [1, boundingBox[0], boundingBox[1]] } },
          el,
          el.board
        );
        intersect2 = this.projectPointToLine(
          { coords: { usrCoords: [1, boundingBox[2], boundingBox[3]] } },
          el,
          el.board
        );
      }
      if (!takePoint1 && !takePoint2) {
        if (!straightFirst && !straightLast) {
          distP1P2 = point1.distance(constants_default.COORDS_BY_USER, point2);
          if (Math.abs(
            point1.distance(constants_default.COORDS_BY_USER, intersect1) + intersect1.distance(constants_default.COORDS_BY_USER, point2) - distP1P2
          ) > math_default.eps) {
            return;
          }
          if (Math.abs(
            point1.distance(constants_default.COORDS_BY_USER, intersect2) + intersect2.distance(constants_default.COORDS_BY_USER, point2) - distP1P2
          ) > math_default.eps) {
            return;
          }
        }
        if (!straightFirst && straightLast && !this.isSameDirection(point1, point2, intersect1) && !this.isSameDirection(point1, point2, intersect2)) {
          return;
        }
        if (straightFirst && !straightLast && !this.isSameDirection(point2, point1, intersect1) && !this.isSameDirection(point2, point1, intersect2)) {
          return;
        }
      }
      if (!takePoint1) {
        if (!takePoint2) {
          if (this.isSameDir(point1, point2, intersect1, intersect2)) {
            p1 = intersect1;
            p2 = intersect2;
          } else {
            p2 = intersect1;
            p1 = intersect2;
          }
        } else {
          if (this.isSameDir(point1, point2, intersect1, intersect2)) {
            p1 = intersect1;
          } else {
            p1 = intersect2;
          }
        }
      } else {
        if (!takePoint2) {
          if (this.isSameDir(point1, point2, intersect1, intersect2)) {
            p2 = intersect2;
          } else {
            p2 = intersect1;
          }
        }
      }
      if (p1) {
        point1.setCoordinates(constants_default.COORDS_BY_USER, p1.usrCoords);
      }
      if (p2) {
        point2.setCoordinates(constants_default.COORDS_BY_USER, p2.usrCoords);
      }
    },
    /**
     * Calculates the visProp.position corresponding to a given angle.
     * @param {number} angle angle in radians. Must be in range (-2pi,2pi).
     */
    calcLabelQuadrant: function(angle) {
      var q;
      if (angle < 0) {
        angle += 2 * Math.PI;
      }
      q = Math.floor((angle + Math.PI / 8) / (Math.PI / 4)) % 8;
      return ["rt", "urt", "top", "ulft", "lft", "llft", "lrt"][q];
    },
    /**
     * The vectors <tt>p2-p1</tt> and <tt>i2-i1</tt> are supposed to be collinear. If their cosine is positive
     * they point into the same direction otherwise they point in opposite direction.
     * @param {JXG.Coords} p1
     * @param {JXG.Coords} p2
     * @param {JXG.Coords} i1
     * @param {JXG.Coords} i2
     * @returns {Boolean} True, if <tt>p2-p1</tt> and <tt>i2-i1</tt> point into the same direction
     */
    isSameDir: function(p1, p2, i1, i2) {
      var dpx = p2.usrCoords[1] - p1.usrCoords[1], dpy = p2.usrCoords[2] - p1.usrCoords[2], dix = i2.usrCoords[1] - i1.usrCoords[1], diy = i2.usrCoords[2] - i1.usrCoords[2];
      if (Math.abs(p2.usrCoords[0]) < math_default.eps) {
        dpx = p2.usrCoords[1];
        dpy = p2.usrCoords[2];
      }
      if (Math.abs(p1.usrCoords[0]) < math_default.eps) {
        dpx = -p1.usrCoords[1];
        dpy = -p1.usrCoords[2];
      }
      return dpx * dix + dpy * diy >= 0;
    },
    /**
     * If you're looking from point "start" towards point "s" and you can see the point "p", return true.
     * Otherwise return false.
     * @param {JXG.Coords} start The point you're standing on.
     * @param {JXG.Coords} p The point in which direction you're looking.
     * @param {JXG.Coords} s The point that should be visible.
     * @returns {Boolean} True, if from start the point p is in the same direction as s is, that means s-start = k*(p-start) with k>=0.
     */
    isSameDirection: function(start, p, s) {
      var dx, dy, sx, sy, r = false;
      dx = p.usrCoords[1] - start.usrCoords[1];
      dy = p.usrCoords[2] - start.usrCoords[2];
      sx = s.usrCoords[1] - start.usrCoords[1];
      sy = s.usrCoords[2] - start.usrCoords[2];
      if (Math.abs(dx) < math_default.eps) {
        dx = 0;
      }
      if (Math.abs(dy) < math_default.eps) {
        dy = 0;
      }
      if (Math.abs(sx) < math_default.eps) {
        sx = 0;
      }
      if (Math.abs(sy) < math_default.eps) {
        sy = 0;
      }
      if (dx >= 0 && sx >= 0) {
        r = dy >= 0 && sy >= 0 || dy <= 0 && sy <= 0;
      } else if (dx <= 0 && sx <= 0) {
        r = dy >= 0 && sy >= 0 || dy <= 0 && sy <= 0;
      }
      return r;
    },
    /**
     * Determinant of three points in the Euclidean plane.
     * Zero, if the points are collinear. Used to determine of a point q is left or
     * right to a segment defined by points p1 and p2.
     *
     * @param  {Array} p1 Coordinates of the first point of the segment. Array of length 3. First coordinate is equal to 1.
     * @param  {Array} p2 Coordinates of the second point of the segment. Array of length 3. First coordinate is equal to 1.
     * @param  {Array} q Coordinates of the point. Array of length 3. First coordinate is equal to 1.
     * @return {Number} Signed area of the triangle formed by these three points.
     *
     * @see #windingNumber
     */
    det3p: function(p1, p2, q) {
      return (p1[1] - q[1]) * (p2[2] - q[2]) - (p2[1] - q[1]) * (p1[2] - q[2]);
    },
    /**
     * Winding number of a point in respect to a polygon path.
     *
     * The point is regarded outside if the winding number is zero,
     * inside otherwise. The algorithm tries to find degenerate cases, i.e.
     * if the point is on the path. This is regarded as "outside".
     * If the point is a vertex of the path, it is regarded as "inside".
     *
     * Implementation of algorithm 7 from "The point in polygon problem for
     * arbitrary polygons" by Kai Hormann and Alexander Agathos, Computational Geometry,
     * Volume 20, Issue 3, November 2001, Pages 131-144.
     *
     * @param  {Array} usrCoords Homogenous coordinates of the point
     * @param  {Array} path      Array of points / coords determining a path, i.e. the vertices of the polygon / path. The array elements
     * do not have to be full points, but have to have a subobject "coords" or should be of type JXG.Coords.
     * @param  {Boolean} [doNotClosePath=false] If true the last point of the path is not connected to the first point.
     * This is necessary if the path consists of two or more closed subpaths, e.g. if the figure has a hole.
     *
     * @return {Number}          Winding number of the point. The point is
     *                           regarded outside if the winding number is zero,
     *                           inside otherwise.
     */
    windingNumber: function(usrCoords, path, doNotClosePath) {
      var wn = 0, le = path.length, x = usrCoords[1], y = usrCoords[2], p0, p1, p2, d, sign, i2, off = 0;
      if (le === 0) {
        return 0;
      }
      doNotClosePath = doNotClosePath || false;
      if (doNotClosePath) {
        off = 1;
      }
      if (isNaN(x) || isNaN(y)) {
        return 1;
      }
      if (type_default.exists(path[0].coords)) {
        p0 = path[0].coords;
        p1 = path[le - 1].coords;
      } else {
        p0 = path[0];
        p1 = path[le - 1];
      }
      if (p0.usrCoords[1] === x && p0.usrCoords[2] === y) {
        return 1;
      }
      for (i2 = 0; i2 < le - off; i2++) {
        if (type_default.exists(path[i2].coords)) {
          p1 = path[i2].coords.usrCoords;
          p2 = path[(i2 + 1) % le].coords.usrCoords;
        } else {
          p1 = path[i2].usrCoords;
          p2 = path[(i2 + 1) % le].usrCoords;
        }
        if (p1[0] === 0 || p2[0] === 0 || isNaN(p1[1]) || isNaN(p2[1]) || isNaN(p1[2]) || isNaN(p2[2])) {
          continue;
        }
        if (p2[2] === y) {
          if (p2[1] === x) {
            return 1;
          }
          if (p1[2] === y && p2[1] > x === p1[1] < x) {
            return 0;
          }
        }
        if (p1[2] < y !== p2[2] < y) {
          sign = 2 * (p2[2] > p1[2] ? 1 : 0) - 1;
          if (p1[1] >= x) {
            if (p2[1] > x) {
              wn += sign;
            } else {
              d = this.det3p(p1, p2, usrCoords);
              if (d === 0) {
                return 0;
              }
              if (d > 0 + math_default.eps === p2[2] > p1[2]) {
                wn += sign;
              }
            }
          } else {
            if (p2[1] > x) {
              d = this.det3p(p1, p2, usrCoords);
              if (d > 0 + math_default.eps === p2[2] > p1[2]) {
                wn += sign;
              }
            }
          }
        }
      }
      return wn;
    },
    /**
     * Decides if a point (x,y) is inside of a path / polygon.
     * Does not work correct if the path has hole. In this case, windingNumber is the preferred method.
     * Implements W. Randolf Franklin's pnpoly method.
     *
     * See <a href="https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html">https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html</a>.
     *
     * @param {Number} x_in x-coordinate (screen or user coordinates)
     * @param {Number} y_in y-coordinate (screen or user coordinates)
     * @param  {Array} path  Array of points / coords determining a path, i.e. the vertices of the polygon / path. The array elements
     * do not have to be full points, but have to have a subobject "coords" or should be of type JXG.Coords.
     * @param {Number} [coord_type=JXG.COORDS_BY_SCREEN] Type of coordinates used here.
     *   Possible values are <b>JXG.COORDS_BY_USER</b> and <b>JXG.COORDS_BY_SCREEN</b>.
     *   Default value is JXG.COORDS_BY_SCREEN.
     *
     * @returns {Boolean} if (x_in, y_in) is inside of the polygon.
     * @see JXG.Polygon.hasPoint
     * @see JXG.Polygon.pnpoly
     * @see #windingNumber
     *
     * @example
     * var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);
     * var p = board.create('point', [4, 3]);
     * var txt = board.create('text', [-1, 0.5, function() {
     *   return 'Point A is inside of the polygon = ' +
     *     JXG.Math.Geometry.pnpoly(p.X(), p.Y(), JXG.COORDS_BY_USER, pol.vertices);
     * }]);
     *
     * </pre><div id="JXG4656ed42-f965-4e35-bb66-c334a4529683" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG4656ed42-f965-4e35-bb66-c334a4529683',
     *             {boundingbox: [-2, 5, 5,-2], axis: true, showcopyright: false, shownavigation: false});
     *     var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);
     *     var p = board.create('point', [4, 3]);
     *     var txt = board.create('text', [-1, 0.5, function() {
     *     		return 'Point A is inside of the polygon = ' + JXG.Math.Geometry.pnpoly(p.X(), p.Y(), JXG.COORDS_BY_USER, pol.vertices);
     *     }]);
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    pnpoly: function(x_in, y_in, path, coord_type) {
      var i2, j, vi, vj, len, x, y, crds, v = path, isIn = false;
      if (coord_type === constants_default.COORDS_BY_USER) {
        crds = new coords_default(constants_default.COORDS_BY_USER, [x_in, y_in], this.board);
        x = crds.scrCoords[1];
        y = crds.scrCoords[2];
      } else {
        x = x_in;
        y = y_in;
      }
      len = path.length;
      for (i2 = 0, j = len - 2; i2 < len - 1; j = i2++) {
        vi = type_default.exists(v[i2].coords) ? v[i2].coords : v[i2];
        vj = type_default.exists(v[j].coords) ? v[j].coords : v[j];
        if (vi.scrCoords[2] > y !== vj.scrCoords[2] > y && x < (vj.scrCoords[1] - vi.scrCoords[1]) * (y - vi.scrCoords[2]) / (vj.scrCoords[2] - vi.scrCoords[2]) + vi.scrCoords[1]) {
          isIn = !isIn;
        }
      }
      return isIn;
    },
    /****************************************/
    /****          INTERSECTIONS         ****/
    /****************************************/
    /**
     * Generate the function which computes the coordinates of the intersection point.
     * Primarily used in {@link JXG.Point#createIntersectionPoint}.
     * @param {JXG.Board} board object
     * @param {JXG.Line,JXG.Circle_JXG.Line,JXG.Circle_Number|Function} el1,el2,i The result will be a intersection point on el1 and el2.
     * i determines the intersection point if two points are available: <ul>
     *   <li>i==0: use the positive square root,</li>
     *   <li>i==1: use the negative square root.</li></ul>
     * See further {@link JXG.Point#createIntersectionPoint}.
     * @param {Boolean} alwaysintersect. Flag that determines if segments and arc can have an outer intersection point
     * on their defining line or circle.
     * @returns {Function} Function returning a {@link JXG.Coords} object that determines
     * the intersection point.
     */
    intersectionFunction: function(board, el1, el2, i2, j, alwaysintersect) {
      var func, that2 = this, el1_isArcType = false, el2_isArcType = false;
      el1_isArcType = el1.elementClass === constants_default.OBJECT_CLASS_CURVE && (el1.type === constants_default.OBJECT_TYPE_ARC || el1.type === constants_default.OBJECT_TYPE_SECTOR) ? true : false;
      el2_isArcType = el2.elementClass === constants_default.OBJECT_CLASS_CURVE && (el2.type === constants_default.OBJECT_TYPE_ARC || el2.type === constants_default.OBJECT_TYPE_SECTOR) ? true : false;
      if ((el1.elementClass === constants_default.OBJECT_CLASS_CURVE || el2.elementClass === constants_default.OBJECT_CLASS_CURVE) && (el1.elementClass === constants_default.OBJECT_CLASS_CURVE || el1.elementClass === constants_default.OBJECT_CLASS_CIRCLE) && (el2.elementClass === constants_default.OBJECT_CLASS_CURVE || el2.elementClass === constants_default.OBJECT_CLASS_CIRCLE)) {
        func = function() {
          return that2.meetCurveCurve(el1, el2, i2, j, el1.board);
        };
      } else if (el1.elementClass === constants_default.OBJECT_CLASS_CURVE && !el1_isArcType && el2.elementClass === constants_default.OBJECT_CLASS_LINE || el2.elementClass === constants_default.OBJECT_CLASS_CURVE && !el2_isArcType && el1.elementClass === constants_default.OBJECT_CLASS_LINE) {
        func = function() {
          return that2.meetCurveLine(el1, el2, i2, el1.board, type_default.evaluate(alwaysintersect));
        };
      } else if (el1.type === constants_default.OBJECT_TYPE_POLYGON || el2.type === constants_default.OBJECT_TYPE_POLYGON) {
        if (el1.elementClass === constants_default.OBJECT_CLASS_LINE) {
          func = function() {
            var first1 = type_default.evaluate(el1.visProp.straightfirst), last1 = type_default.evaluate(el1.visProp.straightlast), first2 = type_default.evaluate(el2.visProp.straightfirst), last2 = type_default.evaluate(el2.visProp.straightlast), a_not;
            a_not = !type_default.evaluate(alwaysintersect) && (!first1 || !last1 || !first2 || !last2);
            return that2.meetPolygonLine(el2, el1, i2, el1.board, a_not);
          };
        } else if (el2.elementClass === constants_default.OBJECT_CLASS_LINE) {
          func = function() {
            var first1 = type_default.evaluate(el1.visProp.straightfirst), last1 = type_default.evaluate(el1.visProp.straightlast), first2 = type_default.evaluate(el2.visProp.straightfirst), last2 = type_default.evaluate(el2.visProp.straightlast), a_not;
            a_not = !type_default.evaluate(alwaysintersect) && (!first1 || !last1 || !first2 || !last2);
            return that2.meetPolygonLine(el1, el2, i2, el1.board, a_not);
          };
        } else {
          func = function() {
            return that2.meetPathPath(el1, el2, i2, el1.board);
          };
        }
      } else if (el1.elementClass === constants_default.OBJECT_CLASS_LINE && el2.elementClass === constants_default.OBJECT_CLASS_LINE) {
        func = function() {
          var res, c, first1 = type_default.evaluate(el1.visProp.straightfirst), last1 = type_default.evaluate(el1.visProp.straightlast), first2 = type_default.evaluate(el2.visProp.straightfirst), last2 = type_default.evaluate(el2.visProp.straightlast);
          if (!type_default.evaluate(alwaysintersect) && (!first1 || !last1 || !first2 || !last2)) {
            res = that2.meetSegmentSegment(
              el1.point1.coords.usrCoords,
              el1.point2.coords.usrCoords,
              el2.point1.coords.usrCoords,
              el2.point2.coords.usrCoords
            );
            if (!first1 && res[1] < 0 || !last1 && res[1] > 1 || !first2 && res[2] < 0 || !last2 && res[2] > 1) {
              c = [0, NaN, NaN];
            } else {
              c = res[0];
            }
            return new coords_default(constants_default.COORDS_BY_USER, c, el1.board);
          }
          return that2.meet(el1.stdform, el2.stdform, i2, el1.board);
        };
      } else {
        func = function() {
          var res = that2.meet(el1.stdform, el2.stdform, i2, el1.board), has = true, first, last, r;
          if (type_default.evaluate(alwaysintersect)) {
            return res;
          }
          if (el1.elementClass === constants_default.OBJECT_CLASS_LINE) {
            first = type_default.evaluate(el1.visProp.straightfirst);
            last = type_default.evaluate(el1.visProp.straightlast);
            if (!first || !last) {
              r = that2.affineRatio(el1.point1.coords, el1.point2.coords, res);
              if (!last && r > 1 + math_default.eps || !first && r < 0 - math_default.eps) {
                return new coords_default(jxg_default.COORDS_BY_USER, [0, NaN, NaN], el1.board);
              }
            }
          }
          if (el2.elementClass === constants_default.OBJECT_CLASS_LINE) {
            first = type_default.evaluate(el2.visProp.straightfirst);
            last = type_default.evaluate(el2.visProp.straightlast);
            if (!first || !last) {
              r = that2.affineRatio(el2.point1.coords, el2.point2.coords, res);
              if (!last && r > 1 + math_default.eps || !first && r < 0 - math_default.eps) {
                return new coords_default(jxg_default.COORDS_BY_USER, [0, NaN, NaN], el1.board);
              }
            }
          }
          if (el1_isArcType) {
            has = that2.coordsOnArc(el1, res);
            if (has && el2_isArcType) {
              has = that2.coordsOnArc(el2, res);
            }
            if (!has) {
              return new coords_default(jxg_default.COORDS_BY_USER, [0, NaN, NaN], el1.board);
            }
          }
          return res;
        };
      }
      return func;
    },
    /**
     * Returns true if the coordinates are on the arc element,
     * false otherwise. Usually, coords is an intersection
     * on the circle line. Now it is decided if coords are on the
     * circle restricted to the arc line.
     * @param  {Arc} arc arc or sector element
     * @param  {JXG.Coords} coords Coords object of an intersection
     * @returns {Boolean}
     * @private
     */
    coordsOnArc: function(arc, coords) {
      var angle = this.rad(arc.radiuspoint, arc.center, coords.usrCoords.slice(1)), alpha = 0, beta = this.rad(arc.radiuspoint, arc.center, arc.anglepoint), ev_s = type_default.evaluate(arc.visProp.selection);
      if (ev_s === "minor" && beta > Math.PI || ev_s === "major" && beta < Math.PI) {
        alpha = beta;
        beta = 2 * Math.PI;
      }
      if (angle < alpha || angle > beta) {
        return false;
      }
      return true;
    },
    /**
     * Computes the intersection of a pair of lines, circles or both.
     * It uses the internal data array stdform of these elements.
     * @param {Array} el1 stdform of the first element (line or circle)
     * @param {Array} el2 stdform of the second element (line or circle)
     * @param {Number|Function} i Index of the intersection point that should be returned.
     * @param board Reference to the board.
     * @returns {JXG.Coords} Coordinates of one of the possible two or more intersection points.
     * Which point will be returned is determined by i.
     */
    meet: function(el1, el2, i2, board) {
      var result, eps = math_default.eps;
      if (Math.abs(el1[3]) < eps && Math.abs(el2[3]) < eps) {
        result = this.meetLineLine(el1, el2, i2, board);
      } else if (Math.abs(el1[3]) >= eps && Math.abs(el2[3]) < eps) {
        result = this.meetLineCircle(el2, el1, i2, board);
      } else if (Math.abs(el1[3]) < eps && Math.abs(el2[3]) >= eps) {
        result = this.meetLineCircle(el1, el2, i2, board);
      } else {
        result = this.meetCircleCircle(el1, el2, i2, board);
      }
      return result;
    },
    /**
     * Intersection of the line with the board
     * @param  {Array}     line   stdform of the line in screen coordinates
     * @param  {JXG.Board} board  reference to a board.
     * @param  {Number}    margin optional margin, to avoid the display of the small sides of lines.
     * @returns {Array}            [intersection coords 1, intersection coords 2]
     */
    meetLineBoard: function(line, board, margin) {
      var s = [], intersect1, intersect2, i2, j;
      if (!type_default.exists(margin)) {
        margin = 0;
      }
      s[0] = math_default.crossProduct(line, [margin, 0, 1]);
      s[1] = math_default.crossProduct(line, [margin, 1, 0]);
      s[2] = math_default.crossProduct(line, [-margin - board.canvasHeight, 0, 1]);
      s[3] = math_default.crossProduct(line, [-margin - board.canvasWidth, 1, 0]);
      for (i2 = 0; i2 < 4; i2++) {
        if (Math.abs(s[i2][0]) > math_default.eps) {
          for (j = 2; j > 0; j--) {
            s[i2][j] /= s[i2][0];
          }
          s[i2][0] = 1;
        }
      }
      if (Math.abs(s[1][0]) < math_default.eps) {
        intersect1 = s[0];
        intersect2 = s[2];
      } else if (Math.abs(s[0][0]) < math_default.eps) {
        intersect1 = s[1];
        intersect2 = s[3];
      } else if (s[1][2] < 0) {
        intersect1 = s[0];
        if (s[3][2] > board.canvasHeight) {
          intersect2 = s[2];
        } else {
          intersect2 = s[3];
        }
      } else if (s[1][2] > board.canvasHeight) {
        intersect1 = s[2];
        if (s[3][2] < 0) {
          intersect2 = s[0];
        } else {
          intersect2 = s[3];
        }
      } else {
        intersect1 = s[1];
        if (s[3][2] < 0) {
          intersect2 = s[0];
        } else if (s[3][2] > board.canvasHeight) {
          intersect2 = s[2];
        } else {
          intersect2 = s[3];
        }
      }
      return [
        new coords_default(constants_default.COORDS_BY_SCREEN, intersect1.slice(1), board),
        new coords_default(constants_default.COORDS_BY_SCREEN, intersect2.slice(1), board)
      ];
    },
    /**
     * Intersection of two lines.
     * @param {Array} l1 stdform of the first line
     * @param {Array} l2 stdform of the second line
     * @param {number} i unused
     * @param {JXG.Board} board Reference to the board.
     * @returns {JXG.Coords} Coordinates of the intersection point.
     */
    meetLineLine: function(l1, l2, i2, board) {
      var s = isNaN(l1[5] + l2[5]) ? [0, 0, 0] : math_default.crossProduct(l1, l2);
      if (Math.abs(s[0]) < 1e-14) {
        s[0] = 0;
      }
      return new coords_default(constants_default.COORDS_BY_USER, s, board);
    },
    /**
     * Intersection of line and circle.
     * @param {Array} lin stdform of the line
     * @param {Array} circ stdform of the circle
     * @param {number|function} i number of the returned intersection point.
     *   i==0: use the positive square root,
     *   i==1: use the negative square root.
     * @param {JXG.Board} board Reference to a board.
     * @returns {JXG.Coords} Coordinates of the intersection point
     */
    meetLineCircle: function(lin, circ, i2, board) {
      var a, b, c, d, n, A, B, C, k, t;
      if (circ[4] < math_default.eps) {
        if (Math.abs(math_default.innerProduct([1, circ[6], circ[7]], lin, 3)) < math_default.eps) {
          return new coords_default(constants_default.COORDS_BY_USER, circ.slice(6, 8), board);
        }
        return new coords_default(constants_default.COORDS_BY_USER, [NaN, NaN], board);
      }
      c = circ[0];
      b = circ.slice(1, 3);
      a = circ[3];
      d = lin[0];
      n = lin.slice(1, 3);
      A = a;
      B = b[0] * n[1] - b[1] * n[0];
      C = a * d * d - (b[0] * n[0] + b[1] * n[1]) * d + c;
      k = B * B - 4 * A * C;
      if (k > -math_default.eps * math_default.eps) {
        k = Math.sqrt(Math.abs(k));
        t = [(-B + k) / (2 * A), (-B - k) / (2 * A)];
        return type_default.evaluate(i2) === 0 ? new coords_default(
          constants_default.COORDS_BY_USER,
          [-t[0] * -n[1] - d * n[0], -t[0] * n[0] - d * n[1]],
          board
        ) : new coords_default(
          constants_default.COORDS_BY_USER,
          [-t[1] * -n[1] - d * n[0], -t[1] * n[0] - d * n[1]],
          board
        );
      }
      return new coords_default(constants_default.COORDS_BY_USER, [0, 0, 0], board);
    },
    /**
     * Intersection of two circles.
     * @param {Array} circ1 stdform of the first circle
     * @param {Array} circ2 stdform of the second circle
     * @param {number|function} i number of the returned intersection point.
     *   i==0: use the positive square root,
     *   i==1: use the negative square root.
     * @param {JXG.Board} board Reference to the board.
     * @returns {JXG.Coords} Coordinates of the intersection point
     */
    meetCircleCircle: function(circ1, circ2, i2, board) {
      var radicalAxis;
      if (circ1[4] < math_default.eps) {
        if (Math.abs(this.distance(circ1.slice(6, 2), circ2.slice(6, 8)) - circ2[4]) < math_default.eps) {
          return new coords_default(constants_default.COORDS_BY_USER, circ1.slice(6, 8), board);
        }
        return new coords_default(constants_default.COORDS_BY_USER, [0, 0, 0], board);
      }
      if (circ2[4] < math_default.eps) {
        if (Math.abs(this.distance(circ2.slice(6, 2), circ1.slice(6, 8)) - circ1[4]) < math_default.eps) {
          return new coords_default(constants_default.COORDS_BY_USER, circ2.slice(6, 8), board);
        }
        return new coords_default(constants_default.COORDS_BY_USER, [0, 0, 0], board);
      }
      radicalAxis = [
        circ2[3] * circ1[0] - circ1[3] * circ2[0],
        circ2[3] * circ1[1] - circ1[3] * circ2[1],
        circ2[3] * circ1[2] - circ1[3] * circ2[2],
        0,
        1,
        Infinity,
        Infinity,
        Infinity
      ];
      radicalAxis = math_default.normalize(radicalAxis);
      return this.meetLineCircle(radicalAxis, circ1, i2, board);
    },
    /**
     * Compute an intersection of the curves c1 and c2.
     * We want to find values t1, t2 such that
     * c1(t1) = c2(t2), i.e. (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2)) = (0,0).
     *
     * Methods: segment-wise intersections (default) or generalized Newton method.
     * @param {JXG.Curve} c1 Curve, Line or Circle
     * @param {JXG.Curve} c2 Curve, Line or Circle
     * @param {Number|Function} nr the nr-th intersection point will be returned.
     * @param {Number} t2ini not longer used.
     * @param {JXG.Board} [board=c1.board] Reference to a board object.
     * @param {String} [method='segment'] Intersection method, possible values are 'newton' and 'segment'.
     * @returns {JXG.Coords} intersection point
     */
    meetCurveCurve: function(c1, c2, nr, t2ini, board, method) {
      var co;
      if (type_default.exists(method) && method === "newton") {
        co = numerics_default.generalizedNewton(c1, c2, type_default.evaluate(nr), t2ini);
      } else {
        if (c1.bezierDegree === 3 || c2.bezierDegree === 3) {
          co = this.meetBezierCurveRedBlueSegments(c1, c2, nr);
        } else {
          co = this.meetCurveRedBlueSegments(c1, c2, nr);
        }
      }
      return new coords_default(constants_default.COORDS_BY_USER, co, board);
    },
    /**
     * Intersection of curve with line,
     * Order of input does not matter for el1 and el2.
     * From version 0.99.7 on this method calls
     * {@link JXG.Math.Geometry.meetCurveLineDiscrete}.
     * If higher precision is needed, {@link JXG.Math.Geometry.meetCurveLineContinuous}
     * has to be used.
     *
     * @param {JXG.Curve|JXG.Line} el1 Curve or Line
     * @param {JXG.Curve|JXG.Line} el2 Curve or Line
     * @param {Number|Function} nr the nr-th intersection point will be returned.
     * @param {JXG.Board} [board=el1.board] Reference to a board object.
     * @param {Boolean} alwaysIntersect If false just the segment between the two defining points are tested for intersection
     * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,
     * the ideal point [0,1,0] is returned.
     */
    meetCurveLine: function(el1, el2, nr, board, alwaysIntersect) {
      var v = [0, NaN, NaN], cu, li;
      if (!type_default.exists(board)) {
        board = el1.board;
      }
      if (el1.elementClass === constants_default.OBJECT_CLASS_CURVE) {
        cu = el1;
        li = el2;
      } else {
        cu = el2;
        li = el1;
      }
      v = this.meetCurveLineDiscrete(cu, li, nr, board, !alwaysIntersect);
      return v;
    },
    /**
     * Intersection of line and curve, continuous case.
     * Finds the nr-the intersection point
     * Uses {@link JXG.Math.Geometry.meetCurveLineDiscrete} as a first approximation.
     * A more exact solution is then found with {@link JXG.Math.Numerics.root}.
     *
     * @param {JXG.Curve} cu Curve
     * @param {JXG.Line} li Line
     * @param {NumberFunction} nr Will return the nr-th intersection point.
     * @param {JXG.Board} board
     * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the
     * line defined by the segment
     * @returns {JXG.Coords} Coords object containing the intersection.
     */
    meetCurveLineContinuous: function(cu, li, nr, board, testSegment) {
      var t, func0, func1, v, x, y, z, eps = math_default.eps, epsLow = math_default.eps, steps, delta, tnew, i2, tmin, fmin, ft;
      v = this.meetCurveLineDiscrete(cu, li, nr, board, testSegment);
      x = v.usrCoords[1];
      y = v.usrCoords[2];
      func0 = function(t2) {
        var c1, c2;
        if (t2 > cu.maxX() || t2 < cu.minX()) {
          return Infinity;
        }
        c1 = x - cu.X(t2);
        c2 = y - cu.Y(t2);
        return c1 * c1 + c2 * c2;
      };
      func1 = function(t2) {
        var v2 = li.stdform[0] + li.stdform[1] * cu.X(t2) + li.stdform[2] * cu.Y(t2);
        return v2 * v2;
      };
      steps = 50;
      delta = (cu.maxX() - cu.minX()) / steps;
      tnew = cu.minX();
      fmin = 1e-4;
      tmin = NaN;
      for (i2 = 0; i2 < steps; i2++) {
        t = numerics_default.root(func0, [
          Math.max(tnew, cu.minX()),
          Math.min(tnew + delta, cu.maxX())
        ]);
        ft = Math.abs(func0(t));
        if (ft <= fmin) {
          fmin = ft;
          tmin = t;
          if (fmin < eps) {
            break;
          }
        }
        tnew += delta;
      }
      t = tmin;
      t = numerics_default.root(func1, [
        Math.max(t - delta, cu.minX()),
        Math.min(t + delta, cu.maxX())
      ]);
      ft = func1(t);
      if (isNaN(ft) || Math.abs(ft) > epsLow) {
        z = 0;
      } else {
        z = 1;
      }
      return new coords_default(constants_default.COORDS_BY_USER, [z, cu.X(t), cu.Y(t)], board);
    },
    /**
     * Intersection of line and curve, discrete case.
     * Segments are treated as lines.
     * Finding the nr-th intersection point should work for all nr.
     * @param {JXG.Curve} cu
     * @param {JXG.Line} li
     * @param {Number|Function} nr
     * @param {JXG.Board} board
     * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the
     * line defined by the segment
     *
     * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,
     * the ideal point [0,1,0] is returned.
     */
    meetCurveLineDiscrete: function(cu, li, nr, board, testSegment) {
      var i2, j, n = type_default.evaluate(nr), p1, p2, p, q, lip1 = li.point1.coords.usrCoords, lip2 = li.point2.coords.usrCoords, d, res, cnt = 0, len = cu.numberPoints, ev_sf = type_default.evaluate(li.visProp.straightfirst), ev_sl = type_default.evaluate(li.visProp.straightlast);
      q = new coords_default(constants_default.COORDS_BY_USER, [0, NaN, NaN], board);
      if (lip1[0] === 0) {
        lip1 = [1, lip2[1] + li.stdform[2], lip2[2] - li.stdform[1]];
      } else if (lip2[0] === 0) {
        lip2 = [1, lip1[1] + li.stdform[2], lip1[2] - li.stdform[1]];
      }
      p2 = cu.points[0].usrCoords;
      for (i2 = 1; i2 < len; i2 += cu.bezierDegree) {
        p1 = p2.slice(0);
        p2 = cu.points[i2].usrCoords;
        d = this.distance(p1, p2);
        if (d > math_default.eps) {
          if (cu.bezierDegree === 3) {
            res = this.meetBeziersegmentBeziersegment(
              [
                cu.points[i2 - 1].usrCoords.slice(1),
                cu.points[i2].usrCoords.slice(1),
                cu.points[i2 + 1].usrCoords.slice(1),
                cu.points[i2 + 2].usrCoords.slice(1)
              ],
              [lip1.slice(1), lip2.slice(1)],
              testSegment
            );
          } else {
            res = [this.meetSegmentSegment(p1, p2, lip1, lip2)];
          }
          for (j = 0; j < res.length; j++) {
            p = res[j];
            if (0 <= p[1] && p[1] <= 1) {
              if (cnt === n) {
                if (testSegment && (!ev_sf && p[2] < 0 || !ev_sl && p[2] > 1)) {
                  return q;
                }
                q = new coords_default(constants_default.COORDS_BY_USER, p[0], board);
                return q;
              }
              cnt += 1;
            }
          }
        }
      }
      return q;
    },
    /**
     * Find the n-th intersection point of two curves named red (first parameter) and blue (second parameter).
     * We go through each segment of the red curve and search if there is an intersection with a segemnt of the blue curve.
     * This double loop, i.e. the outer loop runs along the red curve and the inner loop runs along the blue curve, defines
     * the n-th intersection point. The segments are either line segments or Bezier curves of degree 3. This depends on
     * the property bezierDegree of the curves.
     * <p>
     * This method works also for transformed curves, since only the already
     * transformed points are used.
     *
     * @param {JXG.Curve} red
     * @param {JXG.Curve} blue
     * @param {Number|Function} nr
     */
    meetCurveRedBlueSegments: function(red, blue, nr) {
      var i2, j, n = type_default.evaluate(nr), red1, red2, blue1, blue2, m, minX, maxX, iFound = 0, lenBlue = blue.numberPoints, lenRed = red.numberPoints;
      if (lenBlue <= 1 || lenRed <= 1) {
        return [0, NaN, NaN];
      }
      for (i2 = 1; i2 < lenRed; i2++) {
        red1 = red.points[i2 - 1].usrCoords;
        red2 = red.points[i2].usrCoords;
        minX = Math.min(red1[1], red2[1]);
        maxX = Math.max(red1[1], red2[1]);
        blue2 = blue.points[0].usrCoords;
        for (j = 1; j < lenBlue; j++) {
          blue1 = blue2;
          blue2 = blue.points[j].usrCoords;
          if (Math.min(blue1[1], blue2[1]) < maxX && Math.max(blue1[1], blue2[1]) > minX) {
            m = this.meetSegmentSegment(red1, red2, blue1, blue2);
            if (m[1] >= 0 && m[2] >= 0 && // The two segments meet in the interior or at the start points
            (m[1] < 1 && m[2] < 1 || // One of the curve is intersected in the very last point
            i2 === lenRed - 1 && m[1] === 1 || j === lenBlue - 1 && m[2] === 1)) {
              if (iFound === n) {
                return m[0];
              }
              iFound++;
            }
          }
        }
      }
      return [0, NaN, NaN];
    },
    /**
     * (Virtual) Intersection of two segments.
     * @param {Array} p1 First point of segment 1 using normalized homogeneous coordinates [1,x,y]
     * @param {Array} p2 Second point or direction of segment 1 using normalized homogeneous coordinates [1,x,y] or point at infinity [0,x,y], respectively
     * @param {Array} q1 First point of segment 2 using normalized homogeneous coordinates [1,x,y]
     * @param {Array} q2 Second point or direction of segment 2 using normalized homogeneous coordinates [1,x,y] or point at infinity [0,x,y], respectively
     * @returns {Array} [Intersection point, t, u] The first entry contains the homogeneous coordinates
     * of the intersection point. The second and third entry give the position of the intersection with respect
     * to the definiting parameters. For example, the second entry t is defined by: intersection point = p1 + t * deltaP, where
     * deltaP = (p2 - p1) when both parameters are coordinates, and deltaP = p2 if p2 is a point at infinity.
     * If the two segments are collinear, [[0,0,0], Infinity, Infinity] is returned.
     **/
    meetSegmentSegment: function(p1, p2, q1, q2) {
      var t, u, i2, d, li1 = math_default.crossProduct(p1, p2), li2 = math_default.crossProduct(q1, q2), c = math_default.crossProduct(li1, li2);
      if (Math.abs(c[0]) < math_default.eps) {
        return [c, Infinity, Infinity];
      }
      c[1] /= c[0];
      c[2] /= c[0];
      c[0] /= c[0];
      i2 = Math.abs(p2[1] - p2[0] * p1[1]) < math_default.eps ? 2 : 1;
      d = p1[i2] / p1[0];
      t = (c[i2] - d) / (p2[0] !== 0 ? p2[i2] / p2[0] - d : p2[i2]);
      i2 = Math.abs(q2[1] - q2[0] * q1[1]) < math_default.eps ? 2 : 1;
      d = q1[i2] / q1[0];
      u = (c[i2] - d) / (q2[0] !== 0 ? q2[i2] / q2[0] - d : q2[i2]);
      return [c, t, u];
    },
    /**
     * Find the n-th intersection point of two pathes, usually given by polygons. Uses parts of the
     * Greiner-Hormann algorithm in JXG.Math.Clip.
     *
     * @param {JXG.Circle|JXG.Curve|JXG.Polygon} path1
     * @param {JXG.Circle|JXG.Curve|JXG.Polygon} path2
     * @param {Number|Function} n
     * @param {JXG.Board} board
     *
     * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,
     * the ideal point [0,0,0] is returned.
     *
     */
    meetPathPath: function(path1, path2, nr, board) {
      var S, C, len, intersections, n = type_default.evaluate(nr);
      S = jxg_default.Math.Clip._getPath(path1, board);
      len = S.length;
      if (len > 0 && this.distance(S[0].coords.usrCoords, S[len - 1].coords.usrCoords, 3) < math_default.eps) {
        S.pop();
      }
      C = jxg_default.Math.Clip._getPath(path2, board);
      len = C.length;
      if (len > 0 && this.distance(C[0].coords.usrCoords, C[len - 1].coords.usrCoords, 3) < math_default.eps * math_default.eps) {
        C.pop();
      }
      if (nr < 0 || jxg_default.Math.Clip.isEmptyCase(S, C, "intersection")) {
        return new coords_default(constants_default.COORDS_BY_USER, [0, 0, 0], board);
      }
      jxg_default.Math.Clip.makeDoublyLinkedList(S);
      jxg_default.Math.Clip.makeDoublyLinkedList(C);
      intersections = jxg_default.Math.Clip.findIntersections(S, C, board)[0];
      if (n < intersections.length) {
        return intersections[n].coords;
      }
      return new coords_default(constants_default.COORDS_BY_USER, [0, 0, 0], board);
    },
    /**
     * Find the n-th intersection point between a polygon and a line.
     * @param {JXG.Polygon} path
     * @param {JXG.Line} line
     * @param {Number|Function} nr
     * @param {JXG.Board} board
     * @param {Boolean} alwaysIntersect If false just the segment between the two defining points of the line are tested for intersection.
     *
     * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,
     * the ideal point [0,0,0] is returned.
     */
    meetPolygonLine: function(path, line, nr, board, alwaysIntersect) {
      var i2, n = type_default.evaluate(nr), res, border2, crds = [0, 0, 0], len = path.borders.length, intersections = [];
      for (i2 = 0; i2 < len; i2++) {
        border2 = path.borders[i2];
        res = this.meetSegmentSegment(
          border2.point1.coords.usrCoords,
          border2.point2.coords.usrCoords,
          line.point1.coords.usrCoords,
          line.point2.coords.usrCoords
        );
        if ((!alwaysIntersect || res[2] >= 0 && res[2] < 1) && res[1] >= 0 && res[1] < 1) {
          intersections.push(res[0]);
        }
      }
      if (n >= 0 && n < intersections.length) {
        crds = intersections[n];
      }
      return new coords_default(constants_default.COORDS_BY_USER, crds, board);
    },
    /****************************************/
    /****   BEZIER CURVE ALGORITHMS      ****/
    /****************************************/
    /**
     * Splits a Bezier curve segment defined by four points into
     * two Bezier curve segments. Dissection point is t=1/2.
     * @param {Array} curve Array of four coordinate arrays of length 2 defining a
     * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
     * @returns {Array} Array consisting of two coordinate arrays for Bezier curves.
     */
    _bezierSplit: function(curve) {
      var p0, p1, p2, p00, p22, p000;
      p0 = [(curve[0][0] + curve[1][0]) * 0.5, (curve[0][1] + curve[1][1]) * 0.5];
      p1 = [(curve[1][0] + curve[2][0]) * 0.5, (curve[1][1] + curve[2][1]) * 0.5];
      p2 = [(curve[2][0] + curve[3][0]) * 0.5, (curve[2][1] + curve[3][1]) * 0.5];
      p00 = [(p0[0] + p1[0]) * 0.5, (p0[1] + p1[1]) * 0.5];
      p22 = [(p1[0] + p2[0]) * 0.5, (p1[1] + p2[1]) * 0.5];
      p000 = [(p00[0] + p22[0]) * 0.5, (p00[1] + p22[1]) * 0.5];
      return [
        [curve[0], p0, p00, p000],
        [p000, p22, p2, curve[3]]
      ];
    },
    /**
     * Computes the bounding box [minX, maxY, maxX, minY] of a Bezier curve segment
     * from its control points.
     * @param {Array} curve Array of four coordinate arrays of length 2 defining a
     * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
     * @returns {Array} Bounding box [minX, maxY, maxX, minY]
     */
    _bezierBbox: function(curve) {
      var bb = [];
      if (curve.length === 4) {
        bb[0] = Math.min(curve[0][0], curve[1][0], curve[2][0], curve[3][0]);
        bb[1] = Math.max(curve[0][1], curve[1][1], curve[2][1], curve[3][1]);
        bb[2] = Math.max(curve[0][0], curve[1][0], curve[2][0], curve[3][0]);
        bb[3] = Math.min(curve[0][1], curve[1][1], curve[2][1], curve[3][1]);
      } else {
        bb[0] = Math.min(curve[0][0], curve[1][0]);
        bb[1] = Math.max(curve[0][1], curve[1][1]);
        bb[2] = Math.max(curve[0][0], curve[1][0]);
        bb[3] = Math.min(curve[0][1], curve[1][1]);
      }
      return bb;
    },
    /**
     * Decide if two Bezier curve segments overlap by comparing their bounding boxes.
     * @param {Array} bb1 Bounding box of the first Bezier curve segment
     * @param {Array} bb2 Bounding box of the second Bezier curve segment
     * @returns {Boolean} true if the bounding boxes overlap, false otherwise.
     */
    _bezierOverlap: function(bb1, bb2) {
      return bb1[2] >= bb2[0] && bb1[0] <= bb2[2] && bb1[1] >= bb2[3] && bb1[3] <= bb2[1];
    },
    /**
     * Append list of intersection points to a list.
     * @private
     */
    _bezierListConcat: function(L, Lnew, t1, t2) {
      var i2, t2exists = type_default.exists(t2), start = 0, len = Lnew.length, le = L.length;
      if (le > 0 && len > 0 && (L[le - 1][1] === 1 && Lnew[0][1] === 0 || t2exists && L[le - 1][2] === 1 && Lnew[0][2] === 0)) {
        start = 1;
      }
      for (i2 = start; i2 < len; i2++) {
        if (t2exists) {
          Lnew[i2][2] *= 0.5;
          Lnew[i2][2] += t2;
        }
        Lnew[i2][1] *= 0.5;
        Lnew[i2][1] += t1;
        L.push(Lnew[i2]);
      }
    },
    /**
     * Find intersections of two Bezier curve segments by recursive subdivision.
     * Below maxlevel determine intersections by intersection line segments.
     * @param {Array} red Array of four coordinate arrays of length 2 defining the first
     * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
     * @param {Array} blue Array of four coordinate arrays of length 2 defining the second
     * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
     * @param {Number} level Recursion level
     * @returns {Array} List of intersection points (up to nine). Each intersection point is an
     * array of length three (homogeneous coordinates) plus preimages.
     */
    _bezierMeetSubdivision: function(red, blue, level) {
      var bbb, bbr, ar, b0, b1, r0, r1, m, p0, p1, q0, q1, L = [], maxLev = 5;
      bbr = this._bezierBbox(blue);
      bbb = this._bezierBbox(red);
      if (!this._bezierOverlap(bbr, bbb)) {
        return [];
      }
      if (level < maxLev) {
        ar = this._bezierSplit(red);
        r0 = ar[0];
        r1 = ar[1];
        ar = this._bezierSplit(blue);
        b0 = ar[0];
        b1 = ar[1];
        this._bezierListConcat(
          L,
          this._bezierMeetSubdivision(r0, b0, level + 1),
          0,
          0
        );
        this._bezierListConcat(
          L,
          this._bezierMeetSubdivision(r0, b1, level + 1),
          0,
          0.5
        );
        this._bezierListConcat(
          L,
          this._bezierMeetSubdivision(r1, b0, level + 1),
          0.5,
          0
        );
        this._bezierListConcat(
          L,
          this._bezierMeetSubdivision(r1, b1, level + 1),
          0.5,
          0.5
        );
        return L;
      }
      q0 = [1].concat(red[0]);
      q1 = [1].concat(red[3]);
      p0 = [1].concat(blue[0]);
      p1 = [1].concat(blue[3]);
      m = this.meetSegmentSegment(q0, q1, p0, p1);
      if (m[1] >= 0 && m[2] >= 0 && m[1] <= 1 && m[2] <= 1) {
        return [m];
      }
      return [];
    },
    /**
     * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the line defined by the segment
     */
    _bezierLineMeetSubdivision: function(red, blue, level, testSegment) {
      var bbb, bbr, ar, r0, r1, m, p0, p1, q0, q1, L = [], maxLev = 5;
      bbb = this._bezierBbox(blue);
      bbr = this._bezierBbox(red);
      if (testSegment && !this._bezierOverlap(bbr, bbb)) {
        return [];
      }
      if (level < maxLev) {
        ar = this._bezierSplit(red);
        r0 = ar[0];
        r1 = ar[1];
        this._bezierListConcat(
          L,
          this._bezierLineMeetSubdivision(r0, blue, level + 1),
          0
        );
        this._bezierListConcat(
          L,
          this._bezierLineMeetSubdivision(r1, blue, level + 1),
          0.5
        );
        return L;
      }
      q0 = [1].concat(red[0]);
      q1 = [1].concat(red[3]);
      p0 = [1].concat(blue[0]);
      p1 = [1].concat(blue[1]);
      m = this.meetSegmentSegment(q0, q1, p0, p1);
      if (m[1] >= 0 && m[1] <= 1) {
        if (!testSegment || m[2] >= 0 && m[2] <= 1) {
          return [m];
        }
      }
      return [];
    },
    /**
     * Find the nr-th intersection point of two Bezier curve segments.
     * @param {Array} red Array of four coordinate arrays of length 2 defining the first
     * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
     * @param {Array} blue Array of four coordinate arrays of length 2 defining the second
     * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].
     * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the line defined by the segment
     * @returns {Array} Array containing the list of all intersection points as homogeneous coordinate arrays plus
     * preimages [x,y], t_1, t_2] of the two Bezier curve segments.
     *
     */
    meetBeziersegmentBeziersegment: function(red, blue, testSegment) {
      var L, L2, i2;
      if (red.length === 4 && blue.length === 4) {
        L = this._bezierMeetSubdivision(red, blue, 0);
      } else {
        L = this._bezierLineMeetSubdivision(red, blue, 0, testSegment);
      }
      L.sort(function(a, b) {
        return (a[1] - b[1]) * 1e7 + (a[2] - b[2]);
      });
      L2 = [];
      for (i2 = 0; i2 < L.length; i2++) {
        if (i2 === 0 || L[i2][1] !== L[i2 - 1][1] || L[i2][2] !== L[i2 - 1][2]) {
          L2.push(L[i2]);
        }
      }
      return L2;
    },
    /**
     * Find the nr-th intersection point of two Bezier curves, i.e. curves with bezierDegree == 3.
     * @param {JXG.Curve} red Curve with bezierDegree == 3
     * @param {JXG.Curve} blue Curve with bezierDegree == 3
     * @param {Number|Function} nr The number of the intersection point which should be returned.
     * @returns {Array} The homogeneous coordinates of the nr-th intersection point.
     */
    meetBezierCurveRedBlueSegments: function(red, blue, nr) {
      var p, i2, j, k, n = type_default.evaluate(nr), po, tmp, redArr, blueArr, bbr, bbb, intersections, startRed = 0, startBlue = 0, lenBlue, lenRed, L = [];
      if (blue.numberPoints < blue.bezierDegree + 1 || red.numberPoints < red.bezierDegree + 1) {
        return [0, NaN, NaN];
      }
      if (red.bezierDegree === 1 && blue.bezierDegree === 3) {
        tmp = red;
        red = blue;
        blue = tmp;
      }
      lenBlue = blue.numberPoints - blue.bezierDegree;
      lenRed = red.numberPoints - red.bezierDegree;
      if (red.type === constants_default.OBJECT_TYPE_SECTOR) {
        startRed = 3;
        lenRed -= 3;
      }
      if (blue.type === constants_default.OBJECT_TYPE_SECTOR) {
        startBlue = 3;
        lenBlue -= 3;
      }
      for (i2 = startRed; i2 < lenRed; i2 += red.bezierDegree) {
        p = red.points;
        redArr = [p[i2].usrCoords.slice(1), p[i2 + 1].usrCoords.slice(1)];
        if (red.bezierDegree === 3) {
          redArr[2] = p[i2 + 2].usrCoords.slice(1);
          redArr[3] = p[i2 + 3].usrCoords.slice(1);
        }
        bbr = this._bezierBbox(redArr);
        for (j = startBlue; j < lenBlue; j += blue.bezierDegree) {
          p = blue.points;
          blueArr = [p[j].usrCoords.slice(1), p[j + 1].usrCoords.slice(1)];
          if (blue.bezierDegree === 3) {
            blueArr[2] = p[j + 2].usrCoords.slice(1);
            blueArr[3] = p[j + 3].usrCoords.slice(1);
          }
          bbb = this._bezierBbox(blueArr);
          if (this._bezierOverlap(bbr, bbb)) {
            intersections = this.meetBeziersegmentBeziersegment(redArr, blueArr);
            if (intersections.length === 0) {
              continue;
            }
            for (k = 0; k < intersections.length; k++) {
              po = intersections[k];
              if (po[1] < -math_default.eps || po[1] > 1 + math_default.eps || po[2] < -math_default.eps || po[2] > 1 + math_default.eps) {
                continue;
              }
              L.push(po);
            }
            if (L.length > n) {
              return L[n][0];
            }
          }
        }
      }
      if (L.length > n) {
        return L[n][0];
      }
      return [0, NaN, NaN];
    },
    bezierSegmentEval: function(t, curve) {
      var f, x, y, t1 = 1 - t;
      x = 0;
      y = 0;
      f = t1 * t1 * t1;
      x += f * curve[0][0];
      y += f * curve[0][1];
      f = 3 * t * t1 * t1;
      x += f * curve[1][0];
      y += f * curve[1][1];
      f = 3 * t * t * t1;
      x += f * curve[2][0];
      y += f * curve[2][1];
      f = t * t * t;
      x += f * curve[3][0];
      y += f * curve[3][1];
      return [1, x, y];
    },
    /**
     * Generate the defining points of a 3rd degree bezier curve that approximates
     * a circle sector defined by three coordinate points A, B, C, each defined by an array of length three.
     * The coordinate arrays are given in homogeneous coordinates.
     * @param {Array} A First point
     * @param {Array} B Second point (intersection point)
     * @param {Array} C Third point
     * @param {Boolean} withLegs Flag. If true the legs to the intersection point are part of the curve.
     * @param {Number} sgn Wither 1 or -1. Needed for minor and major arcs. In case of doubt, use 1.
     */
    bezierArc: function(A, B, C, withLegs, sgn) {
      var p1, p2, p3, p4, r, phi, beta, PI2 = Math.PI * 0.5, x = B[1], y = B[2], z = B[0], dataX = [], dataY = [], co, si, ax, ay, bx, by, k, v, d, matrix;
      r = this.distance(B, A);
      x /= z;
      y /= z;
      phi = this.rad(A.slice(1), B.slice(1), C.slice(1));
      if (sgn === -1) {
        phi = 2 * Math.PI - phi;
      }
      p1 = A;
      p1[1] /= p1[0];
      p1[2] /= p1[0];
      p1[0] /= p1[0];
      p4 = p1.slice(0);
      if (withLegs) {
        dataX = [x, x + 0.333 * (p1[1] - x), x + 0.666 * (p1[1] - x), p1[1]];
        dataY = [y, y + 0.333 * (p1[2] - y), y + 0.666 * (p1[2] - y), p1[2]];
      } else {
        dataX = [p1[1]];
        dataY = [p1[2]];
      }
      while (phi > math_default.eps) {
        if (phi > PI2) {
          beta = PI2;
          phi -= PI2;
        } else {
          beta = phi;
          phi = 0;
        }
        co = Math.cos(sgn * beta);
        si = Math.sin(sgn * beta);
        matrix = [
          [1, 0, 0],
          [x * (1 - co) + y * si, co, -si],
          [y * (1 - co) - x * si, si, co]
        ];
        v = math_default.matVecMult(matrix, p1);
        p4 = [v[0] / v[0], v[1] / v[0], v[2] / v[0]];
        ax = p1[1] - x;
        ay = p1[2] - y;
        bx = p4[1] - x;
        by = p4[2] - y;
        d = math_default.hypot(ax + bx, ay + by);
        if (Math.abs(by - ay) > math_default.eps) {
          k = (ax + bx) * (r / d - 0.5) / (by - ay) * 8 / 3;
        } else {
          k = (ay + by) * (r / d - 0.5) / (ax - bx) * 8 / 3;
        }
        p2 = [1, p1[1] - k * ay, p1[2] + k * ax];
        p3 = [1, p4[1] + k * by, p4[2] - k * bx];
        dataX = dataX.concat([p2[1], p3[1], p4[1]]);
        dataY = dataY.concat([p2[2], p3[2], p4[2]]);
        p1 = p4.slice(0);
      }
      if (withLegs) {
        dataX = dataX.concat([
          p4[1] + 0.333 * (x - p4[1]),
          p4[1] + 0.666 * (x - p4[1]),
          x
        ]);
        dataY = dataY.concat([
          p4[2] + 0.333 * (y - p4[2]),
          p4[2] + 0.666 * (y - p4[2]),
          y
        ]);
      }
      return [dataX, dataY];
    },
    /****************************************/
    /****           PROJECTIONS          ****/
    /****************************************/
    /**
     * Calculates the coordinates of the projection of a given point on a given circle. I.o.w. the
     * nearest one of the two intersection points of the line through the given point and the circles
     * center.
     * @param {JXG.Point|JXG.Coords} point Point to project or coords object to project.
     * @param {JXG.Circle} circle Circle on that the point is projected.
     * @param {JXG.Board} [board=point.board] Reference to the board
     * @returns {JXG.Coords} The coordinates of the projection of the given point on the given circle.
     */
    projectPointToCircle: function(point, circle, board) {
      var dist, P, x, y, factor, M = circle.center.coords.usrCoords;
      if (!type_default.exists(board)) {
        board = point.board;
      }
      if (type_default.isPoint(point)) {
        dist = point.coords.distance(constants_default.COORDS_BY_USER, circle.center.coords);
        P = point.coords.usrCoords;
      } else {
        dist = point.distance(constants_default.COORDS_BY_USER, circle.center.coords);
        P = point.usrCoords;
      }
      if (Math.abs(dist) < math_default.eps) {
        dist = math_default.eps;
      }
      factor = circle.Radius() / dist;
      x = M[1] + factor * (P[1] - M[1]);
      y = M[2] + factor * (P[2] - M[2]);
      return new coords_default(constants_default.COORDS_BY_USER, [x, y], board);
    },
    /**
     * Calculates the coordinates of the orthogonal projection of a given point on a given line. I.o.w. the
     * intersection point of the given line and its perpendicular through the given point.
     * @param {JXG.Point|JXG.Coords} point Point to project.
     * @param {JXG.Line} line Line on that the point is projected.
     * @param {JXG.Board} [board=point.board|board=line.board] Reference to a board.
     * @returns {JXG.Coords} The coordinates of the projection of the given point on the given line.
     */
    projectPointToLine: function(point, line, board) {
      var v = [0, line.stdform[1], line.stdform[2]], coords;
      if (!type_default.exists(board)) {
        if (type_default.exists(point.coords)) {
          board = point.board;
        } else {
          board = line.board;
        }
      }
      if (type_default.exists(point.coords)) {
        coords = point.coords.usrCoords;
      } else {
        coords = point.usrCoords;
      }
      v = math_default.crossProduct(v, coords);
      return new coords_default(constants_default.COORDS_BY_USER, math_default.crossProduct(v, line.stdform), board);
    },
    /**
     * Calculates the coordinates of the orthogonal projection of a given coordinate array on a given line
     * segment defined by two coordinate arrays.
     * @param {Array} p Point to project.
     * @param {Array} q1 Start point of the line segment on that the point is projected.
     * @param {Array} q2 End point of the line segment on that the point is projected.
     * @returns {Array} The coordinates of the projection of the given point on the given segment
     * and the factor that determines the projected point as a convex combination of the
     * two endpoints q1 and q2 of the segment.
     */
    projectCoordsToSegment: function(p, q1, q2) {
      var t, denom, s = [q2[1] - q1[1], q2[2] - q1[2]], v = [p[1] - q1[1], p[2] - q1[2]];
      if (Math.abs(s[0]) < math_default.eps && Math.abs(s[1]) < math_default.eps) {
        return [q1, 0];
      }
      t = math_default.innerProduct(v, s);
      denom = math_default.innerProduct(s, s);
      t /= denom;
      return [[1, t * s[0] + q1[1], t * s[1] + q1[2]], t];
    },
    /**
     * Finds the coordinates of the closest point on a Bezier segment of a
     * {@link JXG.Curve} to a given coordinate array.
     * @param {Array} pos Point to project in homogeneous coordinates.
     * @param {JXG.Curve} curve Curve of type "plot" having Bezier degree 3.
     * @param {Number} start Number of the Bezier segment of the curve.
     * @returns {Array} The coordinates of the projection of the given point
     * on the given Bezier segment and the preimage of the curve which
     * determines the closest point.
     */
    projectCoordsToBeziersegment: function(pos, curve, start) {
      var t0, minfunc = function(t) {
        var z = [1, curve.X(start + t), curve.Y(start + t)];
        z[1] -= pos[1];
        z[2] -= pos[2];
        return z[1] * z[1] + z[2] * z[2];
      };
      t0 = jxg_default.Math.Numerics.fminbr(minfunc, [0, 1]);
      return [[1, curve.X(t0 + start), curve.Y(t0 + start)], t0];
    },
    /**
     * Calculates the coordinates of the projection of a given point on a given curve.
     * Uses {@link JXG.Math.Geometry.projectCoordsToCurve}.
     *
     * @param {JXG.Point} point Point to project.
     * @param {JXG.Curve} curve Curve on that the point is projected.
     * @param {JXG.Board} [board=point.board] Reference to a board.
     * @see #projectCoordsToCurve
     * @returns {Array} [JXG.Coords, position] The coordinates of the projection of the given
     * point on the given graph and the relative position on the curve (real number).
     */
    projectPointToCurve: function(point, curve, board) {
      if (!type_default.exists(board)) {
        board = point.board;
      }
      var x = point.X(), y = point.Y(), t = point.position || 0, result = this.projectCoordsToCurve(x, y, t, curve, board);
      return result;
    },
    /**
     * Calculates the coordinates of the projection of a coordinates pair on a given curve. In case of
     * function graphs this is the
     * intersection point of the curve and the parallel to y-axis through the given point.
     * @param {Number} x coordinate to project.
     * @param {Number} y coordinate to project.
     * @param {Number} t start value for newtons method
     * @param {JXG.Curve} curve Curve on that the point is projected.
     * @param {JXG.Board} [board=curve.board] Reference to a board.
     * @see #projectPointToCurve
     * @returns {JXG.Coords} Array containing the coordinates of the projection of the given point on the given curve and
     * the position on the curve.
     */
    projectCoordsToCurve: function(x, y, t, curve, board) {
      var newCoords, newCoordsObj, i2, j, mindist, dist, lbda, v, coords, d, p1, p2, res, minfunc, t_new, f_new, f_old, delta, delta1, delta2, steps, minX, maxX, infty = Number.POSITIVE_INFINITY;
      if (!type_default.exists(board)) {
        board = curve.board;
      }
      if (type_default.evaluate(curve.visProp.curvetype) === "plot") {
        t = 0;
        mindist = infty;
        if (curve.numberPoints === 0) {
          newCoords = [0, 1, 1];
        } else {
          newCoords = [curve.Z(0), curve.X(0), curve.Y(0)];
        }
        if (curve.numberPoints > 1) {
          v = [1, x, y];
          if (curve.bezierDegree === 3) {
            j = 0;
          } else {
            p1 = [curve.Z(0), curve.X(0), curve.Y(0)];
          }
          for (i2 = 0; i2 < curve.numberPoints - 1; i2++) {
            if (curve.bezierDegree === 3) {
              res = this.projectCoordsToBeziersegment(v, curve, j);
            } else {
              p2 = [curve.Z(i2 + 1), curve.X(i2 + 1), curve.Y(i2 + 1)];
              res = this.projectCoordsToSegment(v, p1, p2);
            }
            lbda = res[1];
            coords = res[0];
            if (0 <= lbda && lbda <= 1) {
              dist = this.distance(coords, v);
              d = i2 + lbda;
            } else if (lbda < 0) {
              coords = p1;
              dist = this.distance(p1, v);
              d = i2;
            } else if (lbda > 1 && i2 === curve.numberPoints - 2) {
              coords = p2;
              dist = this.distance(coords, v);
              d = curve.numberPoints - 1;
            }
            if (dist < mindist) {
              mindist = dist;
              t = d;
              newCoords = coords;
            }
            if (curve.bezierDegree === 3) {
              j++;
              i2 += 2;
            } else {
              p1 = p2;
            }
          }
        }
        newCoordsObj = new coords_default(constants_default.COORDS_BY_USER, newCoords, board);
      } else {
        minfunc = function(t2) {
          var dx, dy;
          if (t2 < curve.minX() || t2 > curve.maxX()) {
            return Infinity;
          }
          dx = x - curve.X(t2);
          dy = y - curve.Y(t2);
          return dx * dx + dy * dy;
        };
        f_old = minfunc(t);
        steps = 50;
        minX = curve.minX();
        maxX = curve.maxX();
        delta = (maxX - minX) / steps;
        t_new = minX;
        for (i2 = 0; i2 < steps; i2++) {
          f_new = minfunc(t_new);
          if (f_new < f_old || f_old === Infinity || isNaN(f_old)) {
            t = t_new;
            f_old = f_new;
          }
          t_new += delta;
        }
        delta1 = delta;
        for (i2 = 0; i2 < 20 && isNaN(minfunc(t - delta1)); i2++, delta1 *= 0.5)
          ;
        if (isNaN(minfunc(t - delta1))) {
          delta1 = 0;
        }
        delta2 = delta;
        for (i2 = 0; i2 < 20 && isNaN(minfunc(t + delta2)); i2++, delta2 *= 0.5)
          ;
        if (isNaN(minfunc(t + delta2))) {
          delta2 = 0;
        }
        t = numerics_default.fminbr(minfunc, [
          Math.max(t - delta1, minX),
          Math.min(t + delta2, maxX)
        ]);
        t = t < minX ? minX : t;
        t = t > maxX ? maxX : t;
        newCoordsObj = new coords_default(
          constants_default.COORDS_BY_USER,
          [curve.X(t), curve.Y(t)],
          board
        );
      }
      return [curve.updateTransform(newCoordsObj), t];
    },
    /**
     * Calculates the coordinates of the closest orthogonal projection of a given coordinate array onto the
     * border of a polygon.
     * @param {Array} p Point to project.
     * @param {JXG.Polygon} pol Polygon element
     * @returns {Array} The coordinates of the closest projection of the given point to the border of the polygon.
     */
    projectCoordsToPolygon: function(p, pol) {
      var i2, len = pol.vertices.length, d_best = Infinity, d, projection, proj, bestprojection;
      for (i2 = 0; i2 < len - 1; i2++) {
        projection = jxg_default.Math.Geometry.projectCoordsToSegment(
          p,
          pol.vertices[i2].coords.usrCoords,
          pol.vertices[i2 + 1].coords.usrCoords
        );
        if (0 <= projection[1] && projection[1] <= 1) {
          d = jxg_default.Math.Geometry.distance(projection[0], p, 3);
          proj = projection[0];
        } else if (projection[1] < 0) {
          d = jxg_default.Math.Geometry.distance(pol.vertices[i2].coords.usrCoords, p, 3);
          proj = pol.vertices[i2].coords.usrCoords;
        } else {
          d = jxg_default.Math.Geometry.distance(pol.vertices[i2 + 1].coords.usrCoords, p, 3);
          proj = pol.vertices[i2 + 1].coords.usrCoords;
        }
        if (d < d_best) {
          bestprojection = proj.slice(0);
          d_best = d;
        }
      }
      return bestprojection;
    },
    /**
     * Calculates the coordinates of the projection of a given point on a given turtle. A turtle consists of
     * one or more curves of curveType 'plot'. Uses {@link JXG.Math.Geometry.projectPointToCurve}.
     * @param {JXG.Point} point Point to project.
     * @param {JXG.Turtle} turtle on that the point is projected.
     * @param {JXG.Board} [board=point.board] Reference to a board.
     * @returns {Array} [JXG.Coords, position] Array containing the coordinates of the projection of the given point on the turtle and
     * the position on the turtle.
     */
    projectPointToTurtle: function(point, turtle, board) {
      var newCoords, t, x, y, i2, dist, el, minEl, res, newPos, np = 0, npmin = 0, mindist = Number.POSITIVE_INFINITY, len = turtle.objects.length;
      if (!type_default.exists(board)) {
        board = point.board;
      }
      for (i2 = 0; i2 < len; i2++) {
        el = turtle.objects[i2];
        if (el.elementClass === constants_default.OBJECT_CLASS_CURVE) {
          res = this.projectPointToCurve(point, el);
          newCoords = res[0];
          newPos = res[1];
          dist = this.distance(newCoords.usrCoords, point.coords.usrCoords);
          if (dist < mindist) {
            x = newCoords.usrCoords[1];
            y = newCoords.usrCoords[2];
            t = newPos;
            mindist = dist;
            minEl = el;
            npmin = np;
          }
          np += el.numberPoints;
        }
      }
      newCoords = new coords_default(constants_default.COORDS_BY_USER, [x, y], board);
      return [minEl.updateTransform(newCoords), t + npmin];
    },
    /**
     * Trivial projection of a point to another point.
     * @param {JXG.Point} point Point to project (not used).
     * @param {JXG.Point} dest Point on that the point is projected.
     * @returns {JXG.Coords} The coordinates of the projection of the given point on the given circle.
     */
    projectPointToPoint: function(point, dest) {
      return dest.coords;
    },
    /**
     *
     * @param {JXG.Point|JXG.Coords} point
     * @param {JXG.Board} [board]
     */
    projectPointToBoard: function(point, board) {
      var i2, l, c, brd = board || point.board, config = [
        // left
        [1, 1, 0, 0, 3, 0, 1],
        // top
        [-1, 2, 1, 0, 1, 2, 1],
        // right
        [-1, 1, 2, 2, 1, 2, 3],
        // bottom
        [1, 2, 3, 0, 3, 2, 3]
      ], coords = point.coords || point, bbox = brd.getBoundingBox();
      for (i2 = 0; i2 < 4; i2++) {
        c = config[i2];
        if (c[0] * coords.usrCoords[c[1]] < c[0] * bbox[c[2]]) {
          l = math_default.crossProduct(
            [1, bbox[c[3]], bbox[c[4]]],
            [1, bbox[c[5]], bbox[c[6]]]
          );
          l[3] = 0;
          l = math_default.normalize(l);
          coords = this.projectPointToLine({ coords }, { stdform: l }, brd);
        }
      }
      return coords;
    },
    /**
     * Calculates the distance of a point to a line. The point and the line are given by homogeneous
     * coordinates. For lines this can be line.stdform.
     * @param {Array} point Homogeneous coordinates of a point.
     * @param {Array} line Homogeneous coordinates of a line ([C,A,B] where A*x+B*y+C*z=0).
     * @returns {Number} Distance of the point to the line.
     */
    distPointLine: function(point, line) {
      var a = line[1], b = line[2], c = line[0], nom;
      if (Math.abs(a) + Math.abs(b) < math_default.eps) {
        return Number.POSITIVE_INFINITY;
      }
      nom = a * point[1] + b * point[2] + c;
      a *= a;
      b *= b;
      return Math.abs(nom) / Math.sqrt(a + b);
    },
    /**
     * Determine the (Euclidean) distance between a point q and a line segment
     * defined by two points p1 and p2. In case p1 equals p2, the distance to this
     * point is returned.
     *
     * @param {Array} q Homogeneous coordinates of q
     * @param {Array} p1 Homogeneous coordinates of p1
     * @param {Array} p2 Homogeneous coordinates of p2
     * @returns {Number} Distance of q to line segment [p1, p2]
     */
    distPointSegment: function(q, p1, p2) {
      var x, y, dx, dy, den, lbda, eps = math_default.eps * math_default.eps, huge = 1e6;
      x = q[1] - p1[1];
      y = q[2] - p1[2];
      x = x === Infinity ? huge : x === -Infinity ? -huge : x;
      y = y === Infinity ? huge : y === -Infinity ? -huge : y;
      dx = p2[1] - p1[1];
      dy = p2[2] - p1[2];
      dx = dx === Infinity ? huge : dx === -Infinity ? -huge : dx;
      dy = dy === Infinity ? huge : dy === -Infinity ? -huge : dy;
      den = dx * dx + dy * dy;
      if (den > eps) {
        lbda = (x * dx + y * dy) / den;
        if (lbda < 0) {
          lbda = 0;
        } else if (lbda > 1) {
          lbda = 1;
        }
        x -= lbda * dx;
        y -= lbda * dy;
      }
      return math_default.hypot(x, y);
    },
    /**
     * Helper function to create curve which displays a Reuleaux polygons.
     * @param {Array} points Array of points which should be the vertices of the Reuleaux polygon. Typically,
     * these point list is the array vertices of a regular polygon.
     * @param {Number} nr Number of vertices
     * @returns {Array} An array containing the two functions defining the Reuleaux polygon and the two values
     * for the start and the end of the paramtric curve. array may be used as parent array of a
     * {@link JXG.Curve}.
     *
     * @example
     * var A = brd.create('point',[-2,-2]);
     * var B = brd.create('point',[0,1]);
     * var pol = brd.create('regularpolygon',[A,B,3], {withLines:false, fillColor:'none', highlightFillColor:'none', fillOpacity:0.0});
     * var reuleauxTriangle = brd.create('curve', JXG.Math.Geometry.reuleauxPolygon(pol.vertices, 3),
     *                          {strokeWidth:6, strokeColor:'#d66d55', fillColor:'#ad5544', highlightFillColor:'#ad5544'});
     *
     * </pre><div class="jxgbox" id="JXG2543a843-46a9-4372-abc1-94d9ad2db7ac" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * var brd = JXG.JSXGraph.initBoard('JXG2543a843-46a9-4372-abc1-94d9ad2db7ac', {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright:false, shownavigation: false});
     * var A = brd.create('point',[-2,-2]);
     * var B = brd.create('point',[0,1]);
     * var pol = brd.create('regularpolygon',[A,B,3], {withLines:false, fillColor:'none', highlightFillColor:'none', fillOpacity:0.0});
     * var reuleauxTriangle = brd.create('curve', JXG.Math.Geometry.reuleauxPolygon(pol.vertices, 3),
     *                          {strokeWidth:6, strokeColor:'#d66d55', fillColor:'#ad5544', highlightFillColor:'#ad5544'});
     * <\/script><pre>
     */
    reuleauxPolygon: function(points, nr) {
      var beta, pi2 = Math.PI * 2, pi2_n = pi2 / nr, diag = (nr - 1) / 2, d = 0, makeFct = function(which, trig) {
        return function(t, suspendUpdate) {
          var t1 = (t % pi2 + pi2) % pi2, j = Math.floor(t1 / pi2_n) % nr;
          if (!suspendUpdate) {
            d = points[0].Dist(points[diag]);
            beta = math_default.Geometry.rad(
              [points[0].X() + 1, points[0].Y()],
              points[0],
              points[diag % nr]
            );
          }
          if (isNaN(j)) {
            return j;
          }
          t1 = t1 * 0.5 + j * pi2_n * 0.5 + beta;
          return points[j][which]() + d * Math[trig](t1);
        };
      };
      return [makeFct("X", "cos"), makeFct("Y", "sin"), 0, pi2];
    },
    meet3Planes: function(n1, d1, n2, d2, n3, d3) {
      var p = [0, 0, 0], n31, n12, n23, denom, i2;
      n31 = math_default.crossProduct(n3, n1);
      n12 = math_default.crossProduct(n1, n2);
      n23 = math_default.crossProduct(n2, n3);
      denom = math_default.innerProduct(n1, n23, 3);
      for (i2 = 0; i2 < 3; i2++) {
        p[i2] = (d1 * n23[i2] + d2 * n31[i2] + d3 * n12[i2]) / denom;
      }
      return p;
    },
    meetPlanePlane: function(v11, v12, v21, v22) {
      var i2, no1, no2, v = [0, 0, 0], w = [0, 0, 0];
      for (i2 = 0; i2 < 3; i2++) {
        v[i2] = type_default.evaluate(v11[i2]);
        w[i2] = type_default.evaluate(v12[i2]);
      }
      no1 = math_default.crossProduct(v, w);
      for (i2 = 0; i2 < 3; i2++) {
        v[i2] = type_default.evaluate(v21[i2]);
        w[i2] = type_default.evaluate(v22[i2]);
      }
      no2 = math_default.crossProduct(v, w);
      return math_default.crossProduct(no1, no2);
    },
    project3DTo3DPlane: function(point, normal, foot) {
      var sol = [0, 0, 0], le, d1, d2, lbda;
      foot = foot || [0, 0, 0];
      le = math_default.norm(normal);
      d1 = math_default.innerProduct(point, normal, 3);
      d2 = math_default.innerProduct(foot, normal, 3);
      lbda = (d1 - d2) / le;
      sol = math_default.axpy(-lbda, normal, point);
      return sol;
    },
    getPlaneBounds: function(v1, v2, q, s, e) {
      var s1, s2, e1, e2, mat, rhs, sol;
      if (v1[2] + v2[0] !== 0) {
        mat = [
          [v1[0], v2[0]],
          [v1[1], v2[1]]
        ];
        rhs = [s - q[0], s - q[1]];
        sol = numerics_default.Gauss(mat, rhs);
        s1 = sol[0];
        s2 = sol[1];
        rhs = [e - q[0], e - q[1]];
        sol = numerics_default.Gauss(mat, rhs);
        e1 = sol[0];
        e2 = sol[1];
        return [s1, e1, s2, e2];
      }
      return null;
    }
  }
);
var geometry_default = math_default.Geometry;

// node_modules/jsxgraph/src/math/qdt.js
math_default.Quadtree = function(bbox, config, parent) {
  config = config || {
    capacity: 10,
    pointType: "coords"
  };
  this.config = {};
  this.config.capacity = config.capacity || 10;
  this.config.pointType = config.pointType || "coords";
  this.points = [];
  this.xlb = bbox[0];
  this.xub = bbox[2];
  this.ylb = bbox[3];
  this.yub = bbox[1];
  this.parent = parent || null;
  this.northWest = null;
  this.northEast = null;
  this.southEast = null;
  this.southWest = null;
};
type_default.extend(
  math_default.Quadtree.prototype,
  /** @lends JXG.Math.Quadtree.prototype */
  {
    /**
     * Checks if the given coordinates are inside of the boundaries of the quadtree.
     * The quadtree is open to the left and botton and closed to
     * right and top.
     *
     * @param {Number} x
     * @param {Number} y
     * @returns {Boolean}
     */
    contains: function(x, y) {
      return this.xlb < x && x <= this.xub && this.ylb < y && y <= this.yub;
    },
    /**
     * Insert a new point into this quadtree if it is inside of
     * the quadtree's boundaries.
     *
     * @param {JXG.Coords} p
     * @returns {Boolean} true if insert succeeded, false otherwise.
     */
    insert: function(p) {
      switch (this.config.pointType) {
        case "coords":
          if (!this.contains(p.usrCoords[1], p.usrCoords[2])) {
            return false;
          }
          break;
        case "object":
          if (!this.contains(p.x, p.y)) {
            return false;
          }
          break;
      }
      if (this.points.length < this.config.capacity && this.northWest === null) {
        this.points.push(p);
        return true;
      }
      if (this.northWest === null) {
        this.subdivide();
      }
      if (this.northWest.insert(p)) {
        return true;
      }
      if (this.northEast.insert(p)) {
        return true;
      }
      if (this.southEast.insert(p)) {
        return true;
      }
      return !!this.southWest.insert(p);
    },
    /**
     * Subdivide the quadtree.
     */
    subdivide: function() {
      var cx = this.xlb + (this.xub - this.xlb) * 0.5, cy = this.ylb + (this.yub - this.ylb) * 0.5;
      this.northWest = new math_default.Quadtree([this.xlb, this.yub, cx, cy], this.config, this);
      this.northEast = new math_default.Quadtree([cx, this.yub, this.xub, cy], this.config, this);
      this.southEast = new math_default.Quadtree([this.xlb, cy, cx, this.ylb], this.config, this);
      this.southWest = new math_default.Quadtree([cx, cy, this.xub, this.ylb], this.config, this);
    },
    /**
     * Internal _query method that lacks adjustment of the parameter.
     * @name JXG.Math.Quadtree#_query
     * @param {Number} x
     * @param {Number} y
     * @returns {Boolean|JXG.Quadtree} The quadtree if the point is found, false
     * if none of the quadtrees contains the point (i.e. the point is not inside
     * the root tree's AABB,i.e. axis-aligned bounding box).
     * @private
     */
    _query: function(x, y) {
      var r;
      if (this.contains(x, y)) {
        if (this.northWest === null) {
          return this;
        }
        r = this.northWest._query(x, y);
        if (r) {
          return r;
        }
        r = this.northEast._query(x, y);
        if (r) {
          return r;
        }
        r = this.southEast._query(x, y);
        if (r) {
          return r;
        }
        r = this.southWest._query(x, y);
        if (r) {
          return r;
        }
      }
      return false;
    },
    /**
     * Retrieve the smallest quad tree that contains the given coordinate pair.
     * @name JXG.Math.Quadtree#query
     * @param {JXG.Coords|Number} xp
     * @param {Number} y
     * @returns {Boolean|JXG.Quadtree} The quadtree if the point is found, false
     * if none of the quadtrees contains the point (i.e. the point is not inside
     * the root tree's AABB (Axis-Aligned Bounding Box)).
     */
    query: function(xp, y) {
      var _x, _y;
      if (type_default.exists(y)) {
        _x = xp;
        _y = y;
      } else {
        _x = xp.usrCoords[1];
        _y = xp.usrCoords[2];
      }
      return this._query(_x, _y);
    },
    /**
     * Check if the quadtree has a point which is inside of a sphere of
     * radius tol around [x, y].
     * @param {Number} x
     * @param {Number} y
     * @param {Number} tol
     * @returns {Boolean}
     */
    hasPoint: function(x, y, tol) {
      var r, i2, le;
      if (this.contains(x, y)) {
        le = this.points.length;
        switch (this.config.pointType) {
          case "coords":
            for (i2 = 0; i2 < le; i2++) {
              if (geometry_default.distance([x, y], this.points[i2].usrCoords.slice(1), 2) < tol) {
                return true;
              }
            }
            break;
          case "object":
            for (i2 = 0; i2 < le; i2++) {
              if (geometry_default.distance([x, y], [this.points[i2].x, this.points[i2].y], 2) < tol) {
                return true;
              }
            }
            break;
        }
        if (this.northWest === null) {
          return false;
        }
        r = this.northWest.hasPoint(x, y, tol);
        if (r) {
          return r;
        }
        r = this.northEast.hasPoint(x, y, tol);
        if (r) {
          return r;
        }
        r = this.southEast.hasPoint(x, y, tol);
        if (r) {
          return r;
        }
        r = this.southWest.hasPoint(x, y, tol);
        if (r) {
          return r;
        }
      }
      return false;
    },
    /**
     *
     * @returns {Array}
     */
    getAllPoints: function() {
      var pointsList = [];
      this.getAllPointsRecursive(pointsList);
      return pointsList;
    },
    /**
     *
     * @param {Array} pointsList
     * @private
     */
    getAllPointsRecursive(pointsList) {
      Array.prototype.push.apply(pointsList, this.points.slice());
      if (this.northWest === null) {
        return;
      }
      this.northWest.getAllPointsRecursive(pointsList);
      this.northEast.getAllPointsRecursive(pointsList);
      this.southEast.getAllPointsRecursive(pointsList);
      this.southWest.getAllPointsRecursive(pointsList);
    }
  }
);
var qdt_default = math_default.Quadtree;

// node_modules/jsxgraph/src/math/bqdt.js
math_default.BoxQuadtree = function(depth, capacity, bbox) {
  var l, t, r, b;
  depth--;
  this.depth = depth;
  this.capacity = capacity;
  this.items = [];
  this.northWest = null;
  this.northEast = null;
  this.southEast = null;
  this.southWest = null;
  this.bbox = null;
  this.cx = null;
  this.cy = null;
  if (bbox) {
    l = bbox[0];
    t = bbox[1];
    r = bbox[2];
    b = bbox[3];
    this.cx = (l + r) * 0.5;
    this.cy = (t + b) * 0.5;
    this.bbox = [l, t, r, b];
  }
};
type_default.extend(
  math_default.BoxQuadtree.prototype,
  /** @lends JXG.Math.BoxQuadtree.prototype */
  {
    /**
     * Insert an array of items into the box quadtree. An item is an object
     * containing at least the properties
     * <ul>
     *  <li> xlb: lower bound on x
     *  <li> xub: upper bound on x
     *  <li> ylb: lower bound on y
     *  <li> yub: upper bound on y
     * </ul>
     * which define the axis-aligned bounding box (AABB) of that item. Additionally,
     * more properties can be given.
     *
     * @param {Array} items to be inserted
     * @returns {Object} reference to the box quadtree
     */
    insert: function(items) {
      var i2, le, l, t, r, b, it, nw_it = [], ne_it = [], sw_it = [], se_it = [], in_nw, in_ne, in_sw, in_se;
      if (this.bbox === null) {
        le = items.length;
        l = b = Infinity;
        r = t = -Infinity;
        for (i2 = 0; i2 < items.length; i2++) {
          it = items[i2];
          l = it.xlb < l ? it.xlb : l;
          t = it.yub > t ? it.yub : t;
          r = it.xub > r ? it.xub : r;
          b = it.ylb < b ? it.ylb : b;
        }
        this.cx = (l + r) * 0.5;
        this.cy = (t + b) * 0.5;
        this.bbox = [l, t, r, b];
      } else {
        l = this.bbox[0];
        t = this.bbox[1];
        r = this.bbox[2];
        b = this.bbox[3];
      }
      if (this.depth === 0 || this.items.length + items.length < this.capacity) {
        this.items = this.items.concat(items);
        return this;
      }
      le = items.length;
      for (i2 = 0; i2 < le; i2++) {
        it = items[i2];
        in_nw = it.xlb <= this.cx && it.yub > this.cy;
        in_sw = it.xlb <= this.cx && it.ylb <= this.cy;
        in_ne = it.xub > this.cx && it.yub > this.cy;
        in_se = it.xub > this.cx && it.ylb <= this.cy;
        if (in_nw && in_ne && in_se && in_sw) {
          this.items.push(it);
        } else {
          if (in_nw) {
            nw_it.push(it);
          }
          if (in_sw) {
            sw_it.push(it);
          }
          if (in_ne) {
            ne_it.push(it);
          }
          if (in_se) {
            se_it.push(it);
          }
        }
      }
      this.subdivide(nw_it, sw_it, ne_it, se_it, l, t, r, b);
      return this;
    },
    /**
     * Insert an item into the box quadtree, where an item is an object
     * containing at least the properties
     *
     * <ul>
     *  <li> xlb: lower bound on x
     *  <li> xub: upper bound on x
     *  <li> ylb: lower bound on y
     *  <li> yub: upper bound on y
     * </ul>
     * which define the axis-aligned bounding box (AABB) of that item. Additionally,
     * more properties can be given.
     *
     * @param {Object} it Item to be inserted
     * @returns {Object} reference to the box quadtree
     */
    insertItem: function(it) {
      var l, t, r, b, nw_it = [], ne_it = [], sw_it = [], se_it = [], in_nw, in_ne, in_sw, in_se;
      if (this.bbox === null) {
        l = b = Infinity;
        r = t = -Infinity;
        l = it.xlb < l ? it.xlb : l;
        t = it.yub > t ? it.yub : t;
        r = it.xub > r ? it.xub : r;
        b = it.ylb < b ? it.ylb : b;
        this.cx = (l + r) * 0.5;
        this.cy = (t + b) * 0.5;
        this.bbox = [l, t, r, b];
      } else {
        l = this.bbox[0];
        t = this.bbox[1];
        r = this.bbox[2];
        b = this.bbox[3];
      }
      if (this.depth === 0 || this.items.length + 1 < this.capacity) {
        this.items.push(it);
        return this;
      }
      in_nw = it.xlb <= this.cx && it.yub > this.cy;
      in_sw = it.xlb <= this.cx && it.ylb <= this.cy;
      in_ne = it.xub > this.cx && it.yub > this.cy;
      in_se = it.xub > this.cx && it.ylb <= this.cy;
      if (in_nw && in_ne && in_se && in_sw) {
        this.items.push(it);
      } else {
        if (in_nw) {
          nw_it.push(it);
        }
        if (in_sw) {
          sw_it.push(it);
        }
        if (in_ne) {
          ne_it.push(it);
        }
        if (in_se) {
          se_it.push(it);
        }
      }
      this.subdivide(nw_it, sw_it, ne_it, se_it, l, t, r, b);
      return this;
    },
    /**
     * Create the sub-quadrants if necessary, recursively
     * @param {Array} nw_it list of items for northWest subtree
     * @param {Array} sw_it list of items for southWest subtree
     * @param {Array} ne_it list of items for northEast subtree
     * @param {Array} se_it list of items for southEast subtree
     * @param {Number} l bounding box left
     * @param {Number} t bounding box top
     * @param {Number} r bounding box right
     * @param {Number} b bounding box bottom
     * @returns {Object} reference to the box quadtree
     * @private
     */
    subdivide: function(nw_it, sw_it, ne_it, se_it, l, t, r, b) {
      if (nw_it.length > 0) {
        if (this.northWest === null) {
          this.northWest = new JXG.Math.BoxQuadtree(this.depth, this.capacity, [l, t, this.cx, this.cy]);
        }
        this.northWest.insert(nw_it);
      }
      if (sw_it.length > 0) {
        if (this.southWest === null) {
          this.southWest = new JXG.Math.BoxQuadtree(this.depth, this.capacity, [l, this.cy, this.cx, b]);
        }
        this.southWest.insert(sw_it);
      }
      if (ne_it.length > 0) {
        if (this.northEast === null) {
          this.northEast = new JXG.Math.BoxQuadtree(this.depth, this.capacity, [this.cx, t, r, this.cy]);
        }
        this.northEast.insert(ne_it);
      }
      if (se_it.length > 0) {
        if (this.southEast === null) {
          this.southEast = new JXG.Math.BoxQuadtree(this.depth, this.capacity, [this.cx, this.cy, r, b]);
        }
        this.southEast.insert(se_it);
      }
      return this;
    },
    /**
     * Find all entries of the box quadtree which have an overlap
     * with the given rectangle (AABB). Items may appear multiple times.
     *
     * @param {Array} box AABB of the form [l, t, r, b]
     * @returns {Array} list of items overlapping with box
     */
    find: function(box) {
      var overlaps = function(item) {
        return box[2] >= item.xlb && box[0] <= item.xub && box[3] <= item.yub && box[1] >= item.ylb;
      }, hits = [], i2, le;
      le = this.items.length;
      for (i2 = 0; i2 < le; i2++) {
        if (overlaps(this.items[i2])) {
          hits.push(this.items[i2]);
        }
      }
      if (this.northWest !== null && box[0] <= this.cx & box[1] >= this.cy) {
        hits = hits.concat(this.northWest.find(box));
      }
      if (this.southWest !== null && box[0] <= this.cx & box[3] <= this.cy) {
        hits = hits.concat(this.southWest.find(box));
      }
      if (this.northEast !== null && box[2] >= this.cx & box[1] >= this.cy) {
        hits = hits.concat(this.northEast.find(box));
      }
      if (this.southEast !== null && box[2] >= this.cx & box[3] <= this.cy) {
        hits = hits.concat(this.southEast.find(box));
      }
      return hits;
    },
    /**
     * Analyze the box quadtree.
     *
     * @returns {Object} data about the box quadtree
     */
    analyzeTree: function() {
      var stats = {
        number_items: this.items.length,
        depth: 1
      }, tmp;
      if (this.northWest !== null) {
        tmp = this.northWest.analyzeTree();
        stats.number_items += tmp.number_items;
        stats.depth = Math.max(stats.depth, 1 + tmp.depth);
      }
      if (this.southWest !== null) {
        tmp = this.southWest.analyzeTree();
        stats.number_items += tmp.number_items;
        stats.depth = Math.max(stats.depth, 1 + tmp.depth);
      }
      if (this.northEast !== null) {
        tmp = this.northEast.analyzeTree();
        stats.number_items += tmp.number_items;
        stats.depth = Math.max(stats.depth, 1 + tmp.depth);
      }
      if (this.southEast !== null) {
        tmp = this.southEast.analyzeTree();
        stats.number_items += tmp.number_items;
        stats.depth = Math.max(stats.depth, 1 + tmp.depth);
      }
      return stats;
    },
    /**
     * Generate data to plot the box quadtree as curve using updateDataArray.
     *
     * @returns {Array} containing arrays dataX and dataY
     *
     * @example
     *
     * // qdt contains a BoxQuadtree
     *
     * var qdtcurve = board.create('curve', [[], []], { strokeWidth: 1, strokeColor: '#0000ff', strokeOpacity: 0.3 });
     * qdtcurve.updateDataArray = function () {
     *    var ret = qdt.plot();
     *
     *    this.dataX = ret[0];
     *    this.dataY = ret[1];
     *    console.log(qdt.analyzeTree());
     * };
     * board.update();
     */
    plot: function() {
      var dataX = [], dataY = [], ret;
      dataX.push(this.bbox[0]);
      dataY.push(this.bbox[3]);
      dataX.push(this.bbox[2]);
      dataY.push(this.bbox[3]);
      dataX.push(this.bbox[2]);
      dataY.push(this.bbox[1]);
      dataX.push(this.bbox[0]);
      dataY.push(this.bbox[1]);
      dataX.push(this.bbox[0]);
      dataY.push(this.bbox[3]);
      dataX.push(NaN);
      dataY.push(NaN);
      if (this.northWest !== null) {
        ret = this.northWest.plot();
        dataX = dataX.concat(ret[0]);
        dataY = dataY.concat(ret[1]);
      }
      if (this.northEast !== null) {
        ret = this.northEast.plot();
        dataX = dataX.concat(ret[0]);
        dataY = dataY.concat(ret[1]);
      }
      if (this.southEast !== null) {
        ret = this.southEast.plot();
        dataX = dataX.concat(ret[0]);
        dataY = dataY.concat(ret[1]);
      }
      if (this.southWest !== null) {
        ret = this.southWest.plot();
        dataX = dataX.concat(ret[0]);
        dataY = dataY.concat(ret[1]);
      }
      return [dataX, dataY];
    }
  }
);
var bqdt_default = math_default.BoxQuadtree;

// node_modules/jsxgraph/src/math/nlp.js
jxg_default.Math.Nlp = {
  arr: function(n) {
    return new Float64Array(n);
  },
  arr2: function(n, m) {
    var i2 = 0, a = new Array(n);
    while (i2 < n) {
      a[i2] = this.arr(m);
      i2++;
    }
    return a;
  },
  arraycopy: function(x, a, iox, b, n) {
    var i2 = 0;
    while (i2 < n) {
      iox[i2 + b] = x[i2 + a];
      i2++;
    }
  },
  lastNumberOfEvaluations: 0,
  GetLastNumberOfEvaluations: function() {
    return this.lastNumberOfEvaluations;
  },
  // status Variables
  Normal: 0,
  MaxIterationsReached: 1,
  DivergingRoundingErrors: 2,
  /**
   * Minimizes the objective function F with respect to a set of inequality constraints CON,
   * and returns the optimal variable array. F and CON may be non-linear, and should preferably be smooth.
   * Calls {@link JXG.Math.Nlp#cobylb}.
   *
   * @param calcfc Interface implementation for calculating objective function and constraints.
   * @param n Number of variables.
   * @param m Number of constraints.
   * @param x On input initial values of the variables (zero-based array). On output
   * optimal values of the variables obtained in the COBYLA minimization.
   * @param rhobeg Initial size of the simplex.
   * @param rhoend Final value of the simplex.
   * @param iprint Print level, 0 <= iprint <= 3, where 0 provides no output and
   * 3 provides full output to the console.
   * @param maxfun Maximum number of function evaluations before terminating.
   * @param [testForRoundingErrors=false]
   * @returns {Number} Exit status of the COBYLA2 optimization.
   */
  FindMinimum: function(calcfc, n, m, x, rhobeg, rhoend, iprint, maxfun, testForRoundingErrors) {
    var mpp = m + 2, status, iox = this.arr(n + 1), that2 = this, fcalcfc;
    this.lastNumberOfEvaluations = 0;
    if (testForRoundingErrors) {
      console.log("Experimental feature 'testForRoundingErrors' is activated.");
    }
    iox[0] = 0;
    this.arraycopy(x, 0, iox, 1, n);
    fcalcfc = function(n2, m2, thisx, con) {
      var ix = that2.arr(n2), ocon, f;
      that2.lastNumberOfEvaluations = that2.lastNumberOfEvaluations + 1;
      that2.arraycopy(thisx, 1, ix, 0, n2);
      ocon = that2.arr(m2);
      f = calcfc(n2, m2, ix, ocon);
      that2.arraycopy(ocon, 0, con, 1, m2);
      return f;
    };
    status = this.cobylb(fcalcfc, n, m, mpp, iox, rhobeg, rhoend, iprint, maxfun, testForRoundingErrors);
    this.arraycopy(iox, 1, x, 0, n);
    return status;
  },
  //    private static CobylaExitStatus cobylb(Calcfc calcfc, int n, int m, int mpp, double[] x,
  //      double rhobeg, double rhoend, int iprint, int maxfun)
  /**
   * JavaScript implementation of the non-linear optimization method COBYLA.
   * @param {Function} calcfc
   * @param {Number} n
   * @param {Number} m
   * @param {Number} mpp
   * @param {Number} x
   * @param {Number} rhobeg
   * @param {Number} rhoend
   * @param {Number} iprint
   * @param {Number} maxfun
   * @param {Boolean} [testForRoundingErrors=false]
   * @returns {Number} Exit status of the COBYLA2 optimization
   */
  cobylb: function(calcfc, n, m, mpp, x, rhobeg, rhoend, iprint, maxfun, testForRoundingErrors) {
    var status = -1, alpha = 0.25, beta = 2.1, gamma = 0.5, delta = 1.1, f = 0, resmax = 0, total, np = n + 1, mp = m + 1, rho = rhobeg, parmu = 0, iflag = false, ifull = false, parsig = 0, prerec = 0, prerem = 0, con = this.arr(1 + mpp), sim = this.arr2(1 + n, 1 + np), simi = this.arr2(1 + n, 1 + n), datmat = this.arr2(1 + mpp, 1 + np), a = this.arr2(1 + n, 1 + mp), vsig = this.arr(1 + n), veta = this.arr(1 + n), sigbar = this.arr(1 + n), dx = this.arr(1 + n), w = this.arr(1 + n), i2, j, k, l, temp, tempa, nfvals, jdrop, ibrnch, skipVertexIdent, phimin, nbest, error, pareta, wsig, weta, cvmaxp, cvmaxm, dxsign, resnew, barmu, phi, vmold, vmnew, trured, ratio, edgmax, cmin, cmax, denom, endless = true;
    if (iprint >= 2) {
      console.log("The initial value of RHO is " + rho + " and PARMU is set to zero.");
    }
    nfvals = 0;
    temp = 1 / rho;
    for (i2 = 1; i2 <= n; ++i2) {
      sim[i2][np] = x[i2];
      sim[i2][i2] = rho;
      simi[i2][i2] = temp;
    }
    jdrop = np;
    ibrnch = false;
    L_40:
      do {
        if (nfvals >= maxfun && nfvals > 0) {
          status = this.MaxIterationsReached;
          break L_40;
        }
        ++nfvals;
        f = calcfc(n, m, x, con);
        resmax = 0;
        for (k = 1; k <= m; ++k) {
          resmax = Math.max(resmax, -con[k]);
        }
        if (nfvals === iprint - 1 || iprint === 3) {
          this.PrintIterationResult(nfvals, f, resmax, x, n, iprint);
        }
        con[mp] = f;
        con[mpp] = resmax;
        skipVertexIdent = true;
        if (!ibrnch) {
          skipVertexIdent = false;
          for (i2 = 1; i2 <= mpp; ++i2) {
            datmat[i2][jdrop] = con[i2];
          }
          if (nfvals <= np) {
            if (jdrop <= n) {
              if (datmat[mp][np] <= f) {
                x[jdrop] = sim[jdrop][np];
              } else {
                sim[jdrop][np] = x[jdrop];
                for (k = 1; k <= mpp; ++k) {
                  datmat[k][jdrop] = datmat[k][np];
                  datmat[k][np] = con[k];
                }
                for (k = 1; k <= jdrop; ++k) {
                  sim[jdrop][k] = -rho;
                  temp = 0;
                  for (i2 = k; i2 <= jdrop; ++i2) {
                    temp -= simi[i2][k];
                  }
                  simi[jdrop][k] = temp;
                }
              }
            }
            if (nfvals <= n) {
              jdrop = nfvals;
              x[jdrop] += rho;
              continue L_40;
            }
          }
          ibrnch = true;
        }
        L_140:
          do {
            L_550:
              do {
                if (!skipVertexIdent) {
                  phimin = datmat[mp][np] + parmu * datmat[mpp][np];
                  nbest = np;
                  for (j = 1; j <= n; ++j) {
                    temp = datmat[mp][j] + parmu * datmat[mpp][j];
                    if (temp < phimin) {
                      nbest = j;
                      phimin = temp;
                    } else if (temp === phimin && parmu === 0 && datmat[mpp][j] < datmat[mpp][nbest]) {
                      nbest = j;
                    }
                  }
                  if (nbest <= n) {
                    for (i2 = 1; i2 <= mpp; ++i2) {
                      temp = datmat[i2][np];
                      datmat[i2][np] = datmat[i2][nbest];
                      datmat[i2][nbest] = temp;
                    }
                    for (i2 = 1; i2 <= n; ++i2) {
                      temp = sim[i2][nbest];
                      sim[i2][nbest] = 0;
                      sim[i2][np] += temp;
                      tempa = 0;
                      for (k = 1; k <= n; ++k) {
                        sim[i2][k] -= temp;
                        tempa -= simi[k][i2];
                      }
                      simi[nbest][i2] = tempa;
                    }
                  }
                  error = 0;
                  if (testForRoundingErrors) {
                    for (i2 = 1; i2 <= n; ++i2) {
                      for (j = 1; j <= n; ++j) {
                        temp = this.DOT_PRODUCT_ROW_COL(simi, i2, sim, j, 1, n) - (i2 === j ? 1 : 0);
                        error = Math.max(error, Math.abs(temp));
                      }
                    }
                  }
                  if (error > 0.1) {
                    status = this.DivergingRoundingErrors;
                    break L_40;
                  }
                  for (k = 1; k <= mp; ++k) {
                    con[k] = -datmat[k][np];
                    for (j = 1; j <= n; ++j) {
                      w[j] = datmat[k][j] + con[k];
                    }
                    for (i2 = 1; i2 <= n; ++i2) {
                      a[i2][k] = (k === mp ? -1 : 1) * this.DOT_PRODUCT_ROW_COL(w, -1, simi, i2, 1, n);
                    }
                  }
                  iflag = true;
                  parsig = alpha * rho;
                  pareta = beta * rho;
                  for (j = 1; j <= n; ++j) {
                    wsig = 0;
                    weta = 0;
                    for (k = 1; k <= n; ++k) {
                      wsig += simi[j][k] * simi[j][k];
                      weta += sim[k][j] * sim[k][j];
                    }
                    vsig[j] = 1 / Math.sqrt(wsig);
                    veta[j] = Math.sqrt(weta);
                    if (vsig[j] < parsig || veta[j] > pareta) {
                      iflag = false;
                    }
                  }
                  if (!ibrnch && !iflag) {
                    jdrop = 0;
                    temp = pareta;
                    for (j = 1; j <= n; ++j) {
                      if (veta[j] > temp) {
                        jdrop = j;
                        temp = veta[j];
                      }
                    }
                    if (jdrop === 0) {
                      for (j = 1; j <= n; ++j) {
                        if (vsig[j] < temp) {
                          jdrop = j;
                          temp = vsig[j];
                        }
                      }
                    }
                    temp = gamma * rho * vsig[jdrop];
                    for (k = 1; k <= n; ++k) {
                      dx[k] = temp * simi[jdrop][k];
                    }
                    cvmaxp = 0;
                    cvmaxm = 0;
                    total = 0;
                    for (k = 1; k <= mp; ++k) {
                      total = this.DOT_PRODUCT_ROW_COL(dx, -1, a, k, 1, n);
                      if (k < mp) {
                        temp = datmat[k][np];
                        cvmaxp = Math.max(cvmaxp, -total - temp);
                        cvmaxm = Math.max(cvmaxm, total - temp);
                      }
                    }
                    dxsign = parmu * (cvmaxp - cvmaxm) > 2 * total ? -1 : 1;
                    temp = 0;
                    for (i2 = 1; i2 <= n; ++i2) {
                      dx[i2] = dxsign * dx[i2];
                      sim[i2][jdrop] = dx[i2];
                      temp += simi[jdrop][i2] * dx[i2];
                    }
                    for (k = 1; k <= n; ++k) {
                      simi[jdrop][k] /= temp;
                    }
                    for (j = 1; j <= n; ++j) {
                      if (j !== jdrop) {
                        temp = this.DOT_PRODUCT_ROW_COL(simi, j, dx, -1, 1, n);
                        for (k = 1; k <= n; ++k) {
                          simi[j][k] -= temp * simi[jdrop][k];
                        }
                      }
                      x[j] = sim[j][np] + dx[j];
                    }
                    continue L_40;
                  }
                  ifull = this.trstlp(n, m, a, con, rho, dx);
                  if (!ifull) {
                    temp = 0;
                    for (k = 1; k <= n; ++k) {
                      temp += dx[k] * dx[k];
                    }
                    if (temp < 0.25 * rho * rho) {
                      ibrnch = true;
                      break L_550;
                    }
                  }
                  total = 0;
                  resnew = 0;
                  con[mp] = 0;
                  for (k = 1; k <= mp; ++k) {
                    total = con[k] - this.DOT_PRODUCT_ROW_COL(dx, -1, a, k, 1, n);
                    if (k < mp) {
                      resnew = Math.max(resnew, total);
                    }
                  }
                  prerec = datmat[mpp][np] - resnew;
                  barmu = prerec > 0 ? total / prerec : 0;
                  if (parmu < 1.5 * barmu) {
                    parmu = 2 * barmu;
                    if (iprint >= 2) {
                      console.log("Increase in PARMU to " + parmu);
                    }
                    phi = datmat[mp][np] + parmu * datmat[mpp][np];
                    for (j = 1; j <= n; ++j) {
                      temp = datmat[mp][j] + parmu * datmat[mpp][j];
                      if (temp < phi || temp === phi && parmu === 0 && datmat[mpp][j] < datmat[mpp][np]) {
                        continue L_140;
                      }
                    }
                  }
                  prerem = parmu * prerec - total;
                  for (k = 1; k <= n; ++k) {
                    x[k] = sim[k][np] + dx[k];
                  }
                  ibrnch = true;
                  continue L_40;
                }
                skipVertexIdent = false;
                vmold = datmat[mp][np] + parmu * datmat[mpp][np];
                vmnew = f + parmu * resmax;
                trured = vmold - vmnew;
                if (parmu === 0 && f === datmat[mp][np]) {
                  prerem = prerec;
                  trured = datmat[mpp][np] - resmax;
                }
                ratio = trured <= 0 ? 1 : 0;
                jdrop = 0;
                for (j = 1; j <= n; ++j) {
                  temp = Math.abs(this.DOT_PRODUCT_ROW_COL(simi, j, dx, -1, 1, n));
                  if (temp > ratio) {
                    jdrop = j;
                    ratio = temp;
                  }
                  sigbar[j] = temp * vsig[j];
                }
                edgmax = delta * rho;
                l = 0;
                for (j = 1; j <= n; ++j) {
                  if (sigbar[j] >= parsig || sigbar[j] >= vsig[j]) {
                    temp = veta[j];
                    if (trured > 0) {
                      temp = 0;
                      for (k = 1; k <= n; ++k) {
                        temp += Math.pow(dx[k] - sim[k][j], 2);
                      }
                      temp = Math.sqrt(temp);
                    }
                    if (temp > edgmax) {
                      l = j;
                      edgmax = temp;
                    }
                  }
                }
                if (l > 0) {
                  jdrop = l;
                }
                if (jdrop !== 0) {
                  temp = 0;
                  for (i2 = 1; i2 <= n; ++i2) {
                    sim[i2][jdrop] = dx[i2];
                    temp += simi[jdrop][i2] * dx[i2];
                  }
                  for (k = 1; k <= n; ++k) {
                    simi[jdrop][k] /= temp;
                  }
                  for (j = 1; j <= n; ++j) {
                    if (j !== jdrop) {
                      temp = this.DOT_PRODUCT_ROW_COL(simi, j, dx, -1, 1, n);
                      for (k = 1; k <= n; ++k) {
                        simi[j][k] -= temp * simi[jdrop][k];
                      }
                    }
                  }
                  for (k = 1; k <= mpp; ++k) {
                    datmat[k][jdrop] = con[k];
                  }
                  if (trured > 0 && trured >= 0.1 * prerem) {
                    continue L_140;
                  }
                }
              } while (!endless);
            if (!iflag) {
              ibrnch = false;
              continue L_140;
            }
            if (rho <= rhoend) {
              status = this.Normal;
              break L_40;
            }
            cmin = 0;
            cmax = 0;
            rho *= 0.5;
            if (rho <= 1.5 * rhoend) {
              rho = rhoend;
            }
            if (parmu > 0) {
              denom = 0;
              for (k = 1; k <= mp; ++k) {
                cmin = datmat[k][np];
                cmax = cmin;
                for (i2 = 1; i2 <= n; ++i2) {
                  cmin = Math.min(cmin, datmat[k][i2]);
                  cmax = Math.max(cmax, datmat[k][i2]);
                }
                if (k <= m && cmin < 0.5 * cmax) {
                  temp = Math.max(cmax, 0) - cmin;
                  denom = denom <= 0 ? temp : Math.min(denom, temp);
                }
              }
              if (denom === 0) {
                parmu = 0;
              } else if (cmax - cmin < parmu * denom) {
                parmu = (cmax - cmin) / denom;
              }
            }
            if (iprint >= 2) {
              console.log("Reduction in RHO to " + rho + "  and PARMU = " + parmu);
            }
            if (iprint === 2) {
              this.PrintIterationResult(
                nfvals,
                datmat[mp][np],
                datmat[mpp][np],
                this.COL(sim, np),
                n,
                iprint
              );
            }
          } while (endless);
      } while (endless);
    switch (status) {
      case this.Normal:
        if (iprint >= 1) {
          console.log("%nNormal return from subroutine COBYLA%n");
        }
        if (ifull) {
          if (iprint >= 1) {
            this.PrintIterationResult(nfvals, f, resmax, x, n, iprint);
          }
          return status;
        }
        break;
      case this.MaxIterationsReached:
        if (iprint >= 1) {
          console.log(
            "%nReturn from subroutine COBYLA because the MAXFUN limit has been reached.%n"
          );
        }
        break;
      case this.DivergingRoundingErrors:
        if (iprint >= 1) {
          console.log(
            "%nReturn from subroutine COBYLA because rounding errors are becoming damaging.%n"
          );
        }
        break;
    }
    for (k = 1; k <= n; ++k) {
      x[k] = sim[k][np];
    }
    f = datmat[mp][np];
    resmax = datmat[mpp][np];
    if (iprint >= 1) {
      this.PrintIterationResult(nfvals, f, resmax, x, n, iprint);
    }
    return status;
  },
  trstlp: function(n, m, a, b, rho, dx) {
    var temp = 0, nactx = 0, resold = 0, z = this.arr2(1 + n, 1 + n), zdota = this.arr(2 + m), vmultc = this.arr(2 + m), sdirn = this.arr(1 + n), dxnew = this.arr(1 + n), vmultd = this.arr(2 + m), iact = this.arr(2 + m), mcon = m, nact = 0, icon, resmax, i2, k, first, optold, icount, step, stpful, optnew, ratio, isave, vsave, total, kp, kk, sp, alpha, beta, tot, spabs, acca, accb, zdotv, zdvabs, kw, dd, ss, sd, zdotw, zdwabs, kl, sumabs, tempa, endless = true;
    for (i2 = 1; i2 <= n; ++i2) {
      z[i2][i2] = 1;
      dx[i2] = 0;
    }
    icon = 0;
    resmax = 0;
    if (m >= 1) {
      for (k = 1; k <= m; ++k) {
        if (b[k] > resmax) {
          resmax = b[k];
          icon = k;
        }
      }
      for (k = 1; k <= m; ++k) {
        iact[k] = k;
        vmultc[k] = resmax - b[k];
      }
    }
    first = true;
    do {
      L_60:
        do {
          if (!first || first && resmax === 0) {
            mcon = m + 1;
            icon = mcon;
            iact[mcon] = mcon;
            vmultc[mcon] = 0;
          }
          first = false;
          optold = 0;
          icount = 0;
          step = 0;
          stpful = 0;
          L_70:
            do {
              optnew = mcon === m ? resmax : -this.DOT_PRODUCT_ROW_COL(dx, -1, a, mcon, 1, n);
              if (icount === 0 || optnew < optold) {
                optold = optnew;
                nactx = nact;
                icount = 3;
              } else if (nact > nactx) {
                nactx = nact;
                icount = 3;
              } else {
                --icount;
              }
              if (icount === 0) {
                break L_60;
              }
              ratio = 0;
              if (icon <= nact) {
                if (icon < nact) {
                  isave = iact[icon];
                  vsave = vmultc[icon];
                  k = icon;
                  do {
                    kp = k + 1;
                    kk = iact[kp];
                    sp = this.DOT_PRODUCT(
                      this.PART(this.COL(z, k), 1, n),
                      this.PART(this.COL(a, kk), 1, n)
                    );
                    temp = math_default.hypot(sp, zdota[kp]);
                    alpha = zdota[kp] / temp;
                    beta = sp / temp;
                    zdota[kp] = alpha * zdota[k];
                    zdota[k] = temp;
                    for (i2 = 1; i2 <= n; ++i2) {
                      temp = alpha * z[i2][kp] + beta * z[i2][k];
                      z[i2][kp] = alpha * z[i2][k] - beta * z[i2][kp];
                      z[i2][k] = temp;
                    }
                    iact[k] = kk;
                    vmultc[k] = vmultc[kp];
                    k = kp;
                  } while (k < nact);
                  iact[k] = isave;
                  vmultc[k] = vsave;
                }
                --nact;
                if (mcon > m) {
                  temp = 1 / zdota[nact];
                  for (k = 1; k <= n; ++k) {
                    sdirn[k] = temp * z[k][nact];
                  }
                } else {
                  temp = this.DOT_PRODUCT_ROW_COL(sdirn, -1, z, nact + 1, 1, n);
                  for (k = 1; k <= n; ++k) {
                    sdirn[k] -= temp * z[k][nact + 1];
                  }
                }
              } else {
                kk = iact[icon];
                for (k = 1; k <= n; ++k) {
                  dxnew[k] = a[k][kk];
                }
                tot = 0;
                k = n;
                while (k > nact) {
                  sp = 0;
                  spabs = 0;
                  for (i2 = 1; i2 <= n; ++i2) {
                    temp = z[i2][k] * dxnew[i2];
                    sp += temp;
                    spabs += Math.abs(temp);
                  }
                  acca = spabs + 0.1 * Math.abs(sp);
                  accb = spabs + 0.2 * Math.abs(sp);
                  if (spabs >= acca || acca >= accb) {
                    sp = 0;
                  }
                  if (tot === 0) {
                    tot = sp;
                  } else {
                    kp = k + 1;
                    temp = math_default.hypot(sp, tot);
                    alpha = sp / temp;
                    beta = tot / temp;
                    tot = temp;
                    for (i2 = 1; i2 <= n; ++i2) {
                      temp = alpha * z[i2][k] + beta * z[i2][kp];
                      z[i2][kp] = alpha * z[i2][kp] - beta * z[i2][k];
                      z[i2][k] = temp;
                    }
                  }
                  --k;
                }
                if (tot === 0) {
                  ratio = -1;
                  k = nact;
                  do {
                    zdotv = 0;
                    zdvabs = 0;
                    for (i2 = 1; i2 <= n; ++i2) {
                      temp = z[i2][k] * dxnew[i2];
                      zdotv += temp;
                      zdvabs += Math.abs(temp);
                    }
                    acca = zdvabs + 0.1 * Math.abs(zdotv);
                    accb = zdvabs + 0.2 * Math.abs(zdotv);
                    if (zdvabs < acca && acca < accb) {
                      temp = zdotv / zdota[k];
                      if (temp > 0 && iact[k] <= m) {
                        tempa = vmultc[k] / temp;
                        if (ratio < 0 || tempa < ratio) {
                          ratio = tempa;
                        }
                      }
                      if (k >= 2) {
                        kw = iact[k];
                        for (i2 = 1; i2 <= n; ++i2) {
                          dxnew[i2] -= temp * a[i2][kw];
                        }
                      }
                      vmultd[k] = temp;
                    } else {
                      vmultd[k] = 0;
                    }
                  } while (--k > 0);
                  if (ratio < 0) {
                    break L_60;
                  }
                  for (k = 1; k <= nact; ++k) {
                    vmultc[k] = Math.max(0, vmultc[k] - ratio * vmultd[k]);
                  }
                  if (icon < nact) {
                    isave = iact[icon];
                    vsave = vmultc[icon];
                    k = icon;
                    do {
                      kp = k + 1;
                      kw = iact[kp];
                      sp = this.DOT_PRODUCT(
                        this.PART(this.COL(z, k), 1, n),
                        this.PART(this.COL(a, kw), 1, n)
                      );
                      temp = math_default.hypot(sp, zdota[kp]);
                      alpha = zdota[kp] / temp;
                      beta = sp / temp;
                      zdota[kp] = alpha * zdota[k];
                      zdota[k] = temp;
                      for (i2 = 1; i2 <= n; ++i2) {
                        temp = alpha * z[i2][kp] + beta * z[i2][k];
                        z[i2][kp] = alpha * z[i2][k] - beta * z[i2][kp];
                        z[i2][k] = temp;
                      }
                      iact[k] = kw;
                      vmultc[k] = vmultc[kp];
                      k = kp;
                    } while (k < nact);
                    iact[k] = isave;
                    vmultc[k] = vsave;
                  }
                  temp = this.DOT_PRODUCT(
                    this.PART(this.COL(z, nact), 1, n),
                    this.PART(this.COL(a, kk), 1, n)
                  );
                  if (temp === 0) {
                    break L_60;
                  }
                  zdota[nact] = temp;
                  vmultc[icon] = 0;
                  vmultc[nact] = ratio;
                } else {
                  ++nact;
                  zdota[nact] = tot;
                  vmultc[icon] = vmultc[nact];
                  vmultc[nact] = 0;
                }
                iact[icon] = iact[nact];
                iact[nact] = kk;
                if (mcon > m && kk !== mcon) {
                  k = nact - 1;
                  sp = this.DOT_PRODUCT(
                    this.PART(this.COL(z, k), 1, n),
                    this.PART(this.COL(a, kk), 1, n)
                  );
                  temp = math_default.hypot(sp, zdota[nact]);
                  alpha = zdota[nact] / temp;
                  beta = sp / temp;
                  zdota[nact] = alpha * zdota[k];
                  zdota[k] = temp;
                  for (i2 = 1; i2 <= n; ++i2) {
                    temp = alpha * z[i2][nact] + beta * z[i2][k];
                    z[i2][nact] = alpha * z[i2][k] - beta * z[i2][nact];
                    z[i2][k] = temp;
                  }
                  iact[nact] = iact[k];
                  iact[k] = kk;
                  temp = vmultc[k];
                  vmultc[k] = vmultc[nact];
                  vmultc[nact] = temp;
                }
                if (mcon > m) {
                  temp = 1 / zdota[nact];
                  for (k = 1; k <= n; ++k) {
                    sdirn[k] = temp * z[k][nact];
                  }
                } else {
                  kk = iact[nact];
                  temp = (this.DOT_PRODUCT_ROW_COL(sdirn, -1, a, kk, 1, n) - 1) / zdota[nact];
                  for (k = 1; k <= n; ++k) {
                    sdirn[k] -= temp * z[k][nact];
                  }
                }
              }
              dd = rho * rho;
              sd = 0;
              ss = 0;
              for (i2 = 1; i2 <= n; ++i2) {
                if (Math.abs(dx[i2]) >= 1e-6 * rho) {
                  dd -= dx[i2] * dx[i2];
                }
                sd += dx[i2] * sdirn[i2];
                ss += sdirn[i2] * sdirn[i2];
              }
              if (dd <= 0) {
                break L_60;
              }
              temp = Math.sqrt(ss * dd);
              if (Math.abs(sd) >= 1e-6 * temp) {
                temp = Math.sqrt(ss * dd + sd * sd);
              }
              stpful = dd / (temp + sd);
              step = stpful;
              if (mcon === m) {
                acca = step + 0.1 * resmax;
                accb = step + 0.2 * resmax;
                if (step >= acca || acca >= accb) {
                  break L_70;
                }
                step = Math.min(step, resmax);
              }
              for (k = 1; k <= n; ++k) {
                dxnew[k] = dx[k] + step * sdirn[k];
              }
              if (mcon === m) {
                resold = resmax;
                resmax = 0;
                for (k = 1; k <= nact; ++k) {
                  kk = iact[k];
                  temp = b[kk] - this.DOT_PRODUCT_ROW_COL(dxnew, -1, a, kk, 1, n);
                  resmax = Math.max(resmax, temp);
                }
              }
              k = nact;
              do {
                zdotw = 0;
                zdwabs = 0;
                for (i2 = 1; i2 <= n; ++i2) {
                  temp = z[i2][k] * dxnew[i2];
                  zdotw += temp;
                  zdwabs += Math.abs(temp);
                }
                acca = zdwabs + 0.1 * Math.abs(zdotw);
                accb = zdwabs + 0.2 * Math.abs(zdotw);
                if (zdwabs >= acca || acca >= accb) {
                  zdotw = 0;
                }
                vmultd[k] = zdotw / zdota[k];
                if (k >= 2) {
                  kk = iact[k];
                  for (i2 = 1; i2 <= n; ++i2) {
                    dxnew[i2] -= vmultd[k] * a[i2][kk];
                  }
                }
              } while (k-- >= 2);
              if (mcon > m) {
                vmultd[nact] = Math.max(0, vmultd[nact]);
              }
              for (k = 1; k <= n; ++k) {
                dxnew[k] = dx[k] + step * sdirn[k];
              }
              if (mcon > nact) {
                kl = nact + 1;
                for (k = kl; k <= mcon; ++k) {
                  kk = iact[k];
                  total = resmax - b[kk];
                  sumabs = resmax + Math.abs(b[kk]);
                  for (i2 = 1; i2 <= n; ++i2) {
                    temp = a[i2][kk] * dxnew[i2];
                    total += temp;
                    sumabs += Math.abs(temp);
                  }
                  acca = sumabs + 0.1 * Math.abs(total);
                  accb = sumabs + 0.2 * Math.abs(total);
                  if (sumabs >= acca || acca >= accb) {
                    total = 0;
                  }
                  vmultd[k] = total;
                }
              }
              ratio = 1;
              icon = 0;
              for (k = 1; k <= mcon; ++k) {
                if (vmultd[k] < 0) {
                  temp = vmultc[k] / (vmultc[k] - vmultd[k]);
                  if (temp < ratio) {
                    ratio = temp;
                    icon = k;
                  }
                }
              }
              temp = 1 - ratio;
              for (k = 1; k <= n; ++k) {
                dx[k] = temp * dx[k] + ratio * dxnew[k];
              }
              for (k = 1; k <= mcon; ++k) {
                vmultc[k] = Math.max(0, temp * vmultc[k] + ratio * vmultd[k]);
              }
              if (mcon === m) {
                resmax = resold + ratio * (resmax - resold);
              }
            } while (icon > 0);
          if (step === stpful) {
            return true;
          }
        } while (endless);
    } while (mcon === m);
    return false;
  },
  PrintIterationResult: function(nfvals, f, resmax, x, n, iprint) {
    if (iprint > 1) {
      console.log("NFVALS = " + nfvals + "  F = " + f + "  MAXCV = " + resmax);
    }
    if (iprint > 1) {
      console.log("X = " + this.PART(x, 1, n));
    }
  },
  ROW: function(src, rowidx) {
    return src[rowidx].slice();
  },
  COL: function(src, colidx) {
    var row, rows = src.length, dest = [];
    for (row = 0; row < rows; ++row) {
      dest[row] = src[row][colidx];
    }
    return dest;
  },
  PART: function(src, from, to) {
    return src.slice(from, to + 1);
  },
  FORMAT: function(x) {
    return x.join(",");
  },
  DOT_PRODUCT: function(lhs, rhs) {
    var i2, sum = 0, len = lhs.length;
    for (i2 = 0; i2 < len; ++i2) {
      sum += lhs[i2] * rhs[i2];
    }
    return sum;
  },
  DOT_PRODUCT_ROW_COL: function(lhs, row, rhs, col, start, end) {
    var i2, sum = 0;
    if (row === -1) {
      for (i2 = start; i2 <= end; ++i2) {
        sum += lhs[i2] * rhs[i2][col];
      }
    } else {
      if (col === -1) {
        for (i2 = start; i2 <= end; ++i2) {
          sum += lhs[row][i2] * rhs[i2];
        }
      } else {
        for (i2 = start; i2 <= end; ++i2) {
          sum += lhs[row][i2] * rhs[i2][col];
        }
      }
    }
    return sum;
  }
};
var nlp_default = jxg_default.Math.Nlp;

// node_modules/jsxgraph/src/math/statistics.js
math_default.Statistics = {
  /**
   * Sums up all elements of the given array.
   * @param {Array} arr An array of numbers.
   * @returns {Number}
   * @memberof JXG.Math.Statistics
   */
  sum: function(arr) {
    var i2, len = arr.length, res = 0;
    for (i2 = 0; i2 < len; i2++) {
      res += arr[i2];
    }
    return res;
  },
  /**
   * Multiplies all elements of the given array.
   * @param {Array} arr An array of numbers.
   * @returns {Number}
   * @memberof JXG.Math.Statistics
   */
  prod: function(arr) {
    var i2, len = arr.length, res = 1;
    for (i2 = 0; i2 < len; i2++) {
      res *= arr[i2];
    }
    return res;
  },
  /**
   * Determines the mean value of the values given in an array.
   * @param {Array} arr
   * @returns {Number}
   * @memberof JXG.Math.Statistics
   */
  mean: function(arr) {
    if (arr.length > 0) {
      return this.sum(arr) / arr.length;
    }
    return 0;
  },
  /**
   * The median of a finite set of values is the value that divides the set
   * into two equal sized subsets.
   * @param {Array} arr The set of values.
   * @returns {Number}
   * @memberof JXG.Math.Statistics
   */
  median: function(arr) {
    var tmp, len;
    if (arr.length > 0) {
      if (ArrayBuffer.isView(arr)) {
        tmp = new Float64Array(arr);
        tmp.sort();
      } else {
        tmp = arr.slice(0);
        tmp.sort(function(a, b) {
          return a - b;
        });
      }
      len = tmp.length;
      if (len & 1) {
        return tmp[parseInt(len * 0.5, 10)];
      }
      return (tmp[len * 0.5 - 1] + tmp[len * 0.5]) * 0.5;
    }
    return 0;
  },
  /**
   * The P-th percentile ( 0 < P ≤ 100 ) of a list of N ordered values (sorted from least to greatest)
   * is the smallest value in the list such that no more than P percent of the data is strictly less
   * than the value and at least P percent of the data is less than or equal to that value. See {@link https://en.wikipedia.org/wiki/Percentile}.
   *
   * Here, the <i>linear interpolation between closest ranks</i> method is used.
   * @param {Array} arr The set of values, need not be ordered.
   * @param {Number|Array} percentile One or several percentiles
   * @returns {Number|Array} Depending if a number or an array is the input for percentile, a number or an array containing the percentils
   * is returned.
   */
  percentile: function(arr, percentile) {
    var tmp, len, i2, p, res = [], per;
    if (arr.length > 0) {
      if (ArrayBuffer.isView(arr)) {
        tmp = new Float64Array(arr);
        tmp.sort();
      } else {
        tmp = arr.slice(0);
        tmp.sort(function(a, b) {
          return a - b;
        });
      }
      len = tmp.length;
      if (type_default.isArray(percentile)) {
        p = percentile;
      } else {
        p = [percentile];
      }
      for (i2 = 0; i2 < p.length; i2++) {
        per = len * p[i2] * 0.01;
        if (parseInt(per, 10) === per) {
          res.push((tmp[per - 1] + tmp[per]) * 0.5);
        } else {
          res.push(tmp[parseInt(per, 10)]);
        }
      }
      if (type_default.isArray(percentile)) {
        return res;
      } else {
        return res[0];
      }
    }
    return 0;
  },
  /**
   * Bias-corrected sample variance. A variance is a measure of how far a
   * set of numbers are spread out from each other.
   * @param {Array} arr
   * @returns {Number}
   * @memberof JXG.Math.Statistics
   */
  variance: function(arr) {
    var m, res, i2, len = arr.length;
    if (len > 1) {
      m = this.mean(arr);
      res = 0;
      for (i2 = 0; i2 < len; i2++) {
        res += (arr[i2] - m) * (arr[i2] - m);
      }
      return res / (arr.length - 1);
    }
    return 0;
  },
  /**
   * Determines the <strong>s</strong>tandard <strong>d</strong>eviation which shows how much
   * variation there is from the average value of a set of numbers.
   * @param {Array} arr
   * @returns {Number}
   * @memberof JXG.Math.Statistics
   */
  sd: function(arr) {
    return Math.sqrt(this.variance(arr));
  },
  /**
   * Weighted mean value is basically the same as {@link JXG.Math.Statistics.mean} but here the values
   * are weighted, i.e. multiplied with another value called <em>weight</em>. The weight values are given
   * as a second array with the same length as the value array..
   * @throws {Error} If the dimensions of the arrays don't match.
   * @param {Array} arr Set of alues.
   * @param {Array} w Weight values.
   * @returns {Number}
   * @memberof JXG.Math.Statistics
   */
  weightedMean: function(arr, w) {
    if (arr.length !== w.length) {
      throw new Error(
        "JSXGraph error (Math.Statistics.weightedMean): Array dimension mismatch."
      );
    }
    if (arr.length > 0) {
      return this.mean(this.multiply(arr, w));
    }
    return 0;
  },
  /**
   * Extracts the maximum value from the array.
   * @param {Array} arr
   * @returns {Number} The highest number from the array. It returns <tt>NaN</tt> if not every element could be
   * interpreted as a number and <tt>-Infinity</tt> if an empty array is given or no element could be interpreted
   * as a number.
   * @memberof JXG.Math.Statistics
   */
  max: function(arr) {
    return Math.max.apply(this, arr);
  },
  /**
   * Extracts the minimum value from the array.
   * @param {Array} arr
   * @returns {Number} The lowest number from the array. It returns <tt>NaN</tt> if not every element could be
   * interpreted as a number and <tt>Infinity</tt> if an empty array is given or no element could be interpreted
   * as a number.
   * @memberof JXG.Math.Statistics
   */
  min: function(arr) {
    return Math.min.apply(this, arr);
  },
  /**
   * Determines the lowest and the highest value from the given array.
   * @param {Array} arr
   * @returns {Array} The minimum value as the first and the maximum value as the second value.
   * @memberof JXG.Math.Statistics
   */
  range: function(arr) {
    return [this.min(arr), this.max(arr)];
  },
  /**
   * Determines the absolute value of every given value.
   * @param {Array|Number} arr
   * @returns {Array|Number}
   * @memberof JXG.Math.Statistics
   */
  abs: function(arr) {
    var i2, len, res;
    if (type_default.isArray(arr)) {
      if (arr.map) {
        res = arr.map(Math.abs);
      } else {
        len = arr.length;
        res = [];
        for (i2 = 0; i2 < len; i2++) {
          res[i2] = Math.abs(arr[i2]);
        }
      }
    } else if (ArrayBuffer.isView(arr)) {
      res = arr.map(Math.abs);
    } else {
      res = Math.abs(arr);
    }
    return res;
  },
  /**
   * Adds up two (sequences of) values. If one value is an array and the other one is a number the number
   * is added to every element of the array. If two arrays are given and the lengths don't match the shortest
   * length is taken.
   * @param {Array|Number} arr1
   * @param {Array|Number} arr2
   * @returns {Array|Number}
   * @memberof JXG.Math.Statistics
   */
  add: function(arr1, arr2) {
    var i2, len, res = [];
    arr1 = type_default.evalSlider(arr1);
    arr2 = type_default.evalSlider(arr2);
    if (type_default.isArray(arr1) && type_default.isNumber(arr2)) {
      len = arr1.length;
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = arr1[i2] + arr2;
      }
    } else if (type_default.isNumber(arr1) && type_default.isArray(arr2)) {
      len = arr2.length;
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = arr1 + arr2[i2];
      }
    } else if (type_default.isArray(arr1) && type_default.isArray(arr2)) {
      len = Math.min(arr1.length, arr2.length);
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = arr1[i2] + arr2[i2];
      }
    } else {
      res = arr1 + arr2;
    }
    return res;
  },
  /**
   * Divides two (sequences of) values. If two arrays are given and the lengths don't match the shortest length
   * is taken.
   * @param {Array|Number} arr1 Dividend
   * @param {Array|Number} arr2 Divisor
   * @returns {Array|Number}
   * @memberof JXG.Math.Statistics
   */
  div: function(arr1, arr2) {
    var i2, len, res = [];
    arr1 = type_default.evalSlider(arr1);
    arr2 = type_default.evalSlider(arr2);
    if (type_default.isArray(arr1) && type_default.isNumber(arr2)) {
      len = arr1.length;
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = arr1[i2] / arr2;
      }
    } else if (type_default.isNumber(arr1) && type_default.isArray(arr2)) {
      len = arr2.length;
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = arr1 / arr2[i2];
      }
    } else if (type_default.isArray(arr1) && type_default.isArray(arr2)) {
      len = Math.min(arr1.length, arr2.length);
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = arr1[i2] / arr2[i2];
      }
    } else {
      res = arr1 / arr2;
    }
    return res;
  },
  /**
   * @function
   * @deprecated Use {@link JXG.Math.Statistics.div} instead.
   * @memberof JXG.Math.Statistics
   */
  divide: function() {
    jxg_default.deprecated("Statistics.divide()", "Statistics.div()");
    math_default.Statistics.div.apply(math_default.Statistics, arguments);
  },
  /**
   * Divides two (sequences of) values and returns the remainder. If two arrays are given and the lengths don't
   * match the shortest length is taken.
   * @param {Array|Number} arr1 Dividend
   * @param {Array|Number} arr2 Divisor
   * @param {Boolean} [math=false] Mathematical mod or symmetric mod? Default is symmetric, the JavaScript <tt>%</tt> operator.
   * @returns {Array|Number}
   * @memberof JXG.Math.Statistics
   */
  mod: function(arr1, arr2, math) {
    var i2, len, res = [], mod = function(a, m) {
      return a % m;
    };
    math = type_default.def(math, false);
    if (math) {
      mod = math_default.mod;
    }
    arr1 = type_default.evalSlider(arr1);
    arr2 = type_default.evalSlider(arr2);
    if (type_default.isArray(arr1) && type_default.isNumber(arr2)) {
      len = arr1.length;
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = mod(arr1[i2], arr2);
      }
    } else if (type_default.isNumber(arr1) && type_default.isArray(arr2)) {
      len = arr2.length;
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = mod(arr1, arr2[i2]);
      }
    } else if (type_default.isArray(arr1) && type_default.isArray(arr2)) {
      len = Math.min(arr1.length, arr2.length);
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = mod(arr1[i2], arr2[i2]);
      }
    } else {
      res = mod(arr1, arr2);
    }
    return res;
  },
  /**
   * Multiplies two (sequences of) values. If one value is an array and the other one is a number the number
   * is multiplied to every element of the array. If two arrays are given and the lengths don't match the shortest
   * length is taken.
   * @param {Array|Number} arr1
   * @param {Array|Number} arr2
   * @returns {Array|Number}
   * @memberof JXG.Math.Statistics
   */
  multiply: function(arr1, arr2) {
    var i2, len, res = [];
    arr1 = type_default.evalSlider(arr1);
    arr2 = type_default.evalSlider(arr2);
    if (type_default.isArray(arr1) && type_default.isNumber(arr2)) {
      len = arr1.length;
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = arr1[i2] * arr2;
      }
    } else if (type_default.isNumber(arr1) && type_default.isArray(arr2)) {
      len = arr2.length;
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = arr1 * arr2[i2];
      }
    } else if (type_default.isArray(arr1) && type_default.isArray(arr2)) {
      len = Math.min(arr1.length, arr2.length);
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = arr1[i2] * arr2[i2];
      }
    } else {
      res = arr1 * arr2;
    }
    return res;
  },
  /**
   * Subtracts two (sequences of) values. If two arrays are given and the lengths don't match the shortest
   * length is taken.
   * @param {Array|Number} arr1 Minuend
   * @param {Array|Number} arr2 Subtrahend
   * @returns {Array|Number}
   * @memberof JXG.Math.Statistics
   */
  subtract: function(arr1, arr2) {
    var i2, len, res = [];
    arr1 = type_default.evalSlider(arr1);
    arr2 = type_default.evalSlider(arr2);
    if (type_default.isArray(arr1) && type_default.isNumber(arr2)) {
      len = arr1.length;
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = arr1[i2] - arr2;
      }
    } else if (type_default.isNumber(arr1) && type_default.isArray(arr2)) {
      len = arr2.length;
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = arr1 - arr2[i2];
      }
    } else if (type_default.isArray(arr1) && type_default.isArray(arr2)) {
      len = Math.min(arr1.length, arr2.length);
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = arr1[i2] - arr2[i2];
      }
    } else {
      res = arr1 - arr2;
    }
    return res;
  },
  /**
   * The Theil-Sen estimator can be used to determine a more robust linear regression of a set of sample
   * points than least squares regression in {@link JXG.Math.Numerics.regressionPolynomial}.
   *
   * If the function should be applied to an array a of points, a the coords array can be generated with
   * JavaScript array.map:
   *
   * <pre>
   * JXG.Math.Statistics.TheilSenRegression(a.map(el => el.coords));
   * </pre>
   *
   * @param {Array} coords Array of {@link JXG.Coords}.
   * @returns {Array} A stdform array of the regression line.
   * @memberof JXG.Math.Statistics
   *
   * @example
   * var board = JXG.JSXGraph.initBoard('jxgbox', { boundingbox: [-6,6,6,-6], axis : true });
   * var a=[];
   * a[0]=board.create('point', [0,0]);
   * a[1]=board.create('point', [3,0]);
   * a[2]=board.create('point', [0,3]);
   *
   * board.create('line', [
   *     () => JXG.Math.Statistics.TheilSenRegression(a.map(el => el.coords))
   *   ],
   *   {strokeWidth:1, strokeColor:'black'});
   *
   * </pre><div id="JXG0a28be85-91c5-44d3-aae6-114e81217cf0" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXG0a28be85-91c5-44d3-aae6-114e81217cf0',
   *             {boundingbox: [-6,6,6,-6], axis: true, showcopyright: false, shownavigation: false});
   *     var a=[];
   *     a[0]=board.create('point', [0,0]);
   *     a[1]=board.create('point', [3,0]);
   *     a[2]=board.create('point', [0,3]);
   *
   *     board.create('line', [
   *         () => JXG.Math.Statistics.TheilSenRegression(a.map(el => el.coords))
   *       ],
   *       {strokeWidth:1, strokeColor:'black'});
   *
   *     })();
   *
   * <\/script><pre>
   *
   */
  TheilSenRegression: function(coords) {
    var i2, j, slopes = [], tmpslopes = [], yintercepts = [];
    for (i2 = 0; i2 < coords.length; i2++) {
      tmpslopes.length = 0;
      for (j = 0; j < coords.length; j++) {
        if (Math.abs(coords[j].usrCoords[1] - coords[i2].usrCoords[1]) > math_default.eps) {
          tmpslopes[j] = (coords[j].usrCoords[2] - coords[i2].usrCoords[2]) / (coords[j].usrCoords[1] - coords[i2].usrCoords[1]);
        }
      }
      slopes[i2] = this.median(tmpslopes);
      yintercepts.push(coords[i2].usrCoords[2] - slopes[i2] * coords[i2].usrCoords[1]);
    }
    return [this.median(yintercepts), this.median(slopes), -1];
  },
  /**
   * Generate values of a standard normal random variable with the Marsaglia polar method, see
   * https://en.wikipedia.org/wiki/Marsaglia_polar_method .
   *
   * @param {Number} mean mean value of the normal distribution
   * @param {Number} stdDev standard deviation of the normal distribution
   * @returns {Number} value of a standard normal random variable
   */
  generateGaussian: function(mean, stdDev) {
    var u, v, s;
    if (this.hasSpare) {
      this.hasSpare = false;
      return this.spare * stdDev + mean;
    }
    do {
      u = Math.random() * 2 - 1;
      v = Math.random() * 2 - 1;
      s = u * u + v * v;
    } while (s >= 1 || s === 0);
    s = Math.sqrt(-2 * Math.log(s) / s);
    this.spare = v * s;
    this.hasSpare = true;
    return mean + stdDev * u * s;
  }
};
var statistics_default = math_default.Statistics;

// node_modules/jsxgraph/src/math/plot.js
math_default.Plot = {
  /**
   * Check if at least one point on the curve is finite and real.
   **/
  checkReal: function(points) {
    var b = false, i2, p, len = points.length;
    for (i2 = 0; i2 < len; i2++) {
      p = points[i2].usrCoords;
      if (!isNaN(p[1]) && !isNaN(p[2]) && Math.abs(p[0]) > math_default.eps) {
        b = true;
        break;
      }
    }
    return b;
  },
  //----------------------------------------------------------------------
  // Plot algorithm v0
  //----------------------------------------------------------------------
  /**
   * Updates the data points of a parametric curve. This version is used if {@link JXG.Curve#doadvancedplot} is <tt>false</tt>.
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Number} mi Left bound of curve
   * @param {Number} ma Right bound of curve
   * @param {Number} len Number of data points
   * @returns {JXG.Curve} Reference to the curve object.
   */
  updateParametricCurveNaive: function(curve, mi, ma, len) {
    var i2, t, suspendUpdate = false, stepSize = (ma - mi) / len;
    for (i2 = 0; i2 < len; i2++) {
      t = mi + i2 * stepSize;
      curve.points[i2].setCoordinates(
        constants_default.COORDS_BY_USER,
        [curve.X(t, suspendUpdate), curve.Y(t, suspendUpdate)],
        false
      );
      curve.points[i2]._t = t;
      suspendUpdate = true;
    }
    return curve;
  },
  //----------------------------------------------------------------------
  // Plot algorithm v1
  //----------------------------------------------------------------------
  /**
   * Crude and cheap test if the segment defined by the two points <tt>(x0, y0)</tt> and <tt>(x1, y1)</tt> is
   * outside the viewport of the board. All parameters have to be given in screen coordinates.
   *
   * @private
   * @deprecated
   * @param {Number} x0
   * @param {Number} y0
   * @param {Number} x1
   * @param {Number} y1
   * @param {JXG.Board} board
   * @returns {Boolean} <tt>true</tt> if the given segment is outside the visible area.
   */
  isSegmentOutside: function(x0, y0, x1, y1, board) {
    return y0 < 0 && y1 < 0 || y0 > board.canvasHeight && y1 > board.canvasHeight || x0 < 0 && x1 < 0 || x0 > board.canvasWidth && x1 > board.canvasWidth;
  },
  /**
   * Compares the absolute value of <tt>dx</tt> with <tt>MAXX</tt> and the absolute value of <tt>dy</tt>
   * with <tt>MAXY</tt>.
   *
   * @private
   * @deprecated
   * @param {Number} dx
   * @param {Number} dy
   * @param {Number} MAXX
   * @param {Number} MAXY
   * @returns {Boolean} <tt>true</tt>, if <tt>|dx| &lt; MAXX</tt> and <tt>|dy| &lt; MAXY</tt>.
   */
  isDistOK: function(dx, dy, MAXX, MAXY) {
    return Math.abs(dx) < MAXX && Math.abs(dy) < MAXY && !isNaN(dx + dy);
  },
  /**
   * @private
   * @deprecated
   */
  isSegmentDefined: function(x0, y0, x1, y1) {
    return !(isNaN(x0 + y0) && isNaN(x1 + y1));
  },
  /**
   * Updates the data points of a parametric curve. This version is used if {@link JXG.Curve#doadvancedplot} is <tt>true</tt>.
   * Since 0.99 this algorithm is deprecated. It still can be used if {@link JXG.Curve#doadvancedplotold} is <tt>true</tt>.
   *
   * @deprecated
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Number} mi Left bound of curve
   * @param {Number} ma Right bound of curve
   * @returns {JXG.Curve} Reference to the curve object.
   */
  updateParametricCurveOld: function(curve, mi, ma) {
    var i2, t, d, x, y, x0, y0, top, depth, MAX_DEPTH, MAX_XDIST, MAX_YDIST, suspendUpdate = false, po = new coords_default(constants_default.COORDS_BY_USER, [0, 0], curve.board, false), dyadicStack = [], depthStack = [], pointStack = [], divisors = [], distOK = false, j = 0, distFromLine = function(p1, p2, p0) {
      var lbda, x02 = p0[1] - p1[1], y02 = p0[2] - p1[2], x1 = p2[0] - p1[1], y1 = p2[1] - p1[2], den = x1 * x1 + y1 * y1;
      if (den >= math_default.eps) {
        lbda = (x02 * x1 + y02 * y1) / den;
        if (lbda > 0) {
          if (lbda <= 1) {
            x02 -= lbda * x1;
            y02 -= lbda * y1;
          } else {
            x02 -= x1;
            y02 -= y1;
          }
        }
      }
      return math_default.hypot(x02, y02);
    };
    jxg_default.deprecated("Curve.updateParametricCurveOld()");
    if (curve.board.updateQuality === curve.board.BOARD_QUALITY_LOW) {
      MAX_DEPTH = 15;
      MAX_XDIST = 10;
      MAX_YDIST = 10;
    } else {
      MAX_DEPTH = 21;
      MAX_XDIST = 0.7;
      MAX_YDIST = 0.7;
    }
    divisors[0] = ma - mi;
    for (i2 = 1; i2 < MAX_DEPTH; i2++) {
      divisors[i2] = divisors[i2 - 1] * 0.5;
    }
    i2 = 1;
    dyadicStack[0] = 1;
    depthStack[0] = 0;
    t = mi;
    po.setCoordinates(
      constants_default.COORDS_BY_USER,
      [curve.X(t, suspendUpdate), curve.Y(t, suspendUpdate)],
      false
    );
    suspendUpdate = true;
    x0 = po.scrCoords[1];
    y0 = po.scrCoords[2];
    t = ma;
    po.setCoordinates(
      constants_default.COORDS_BY_USER,
      [curve.X(t, suspendUpdate), curve.Y(t, suspendUpdate)],
      false
    );
    x = po.scrCoords[1];
    y = po.scrCoords[2];
    pointStack[0] = [x, y];
    top = 1;
    depth = 0;
    curve.points = [];
    curve.points[j++] = new coords_default(constants_default.COORDS_BY_SCREEN, [x0, y0], curve.board, false);
    do {
      distOK = this.isDistOK(x - x0, y - y0, MAX_XDIST, MAX_YDIST) || this.isSegmentOutside(x0, y0, x, y, curve.board);
      while (depth < MAX_DEPTH && (!distOK || depth < 6) && (depth <= 7 || this.isSegmentDefined(x0, y0, x, y))) {
        dyadicStack[top] = i2;
        depthStack[top] = depth;
        pointStack[top] = [x, y];
        top += 1;
        i2 = 2 * i2 - 1;
        depth++;
        t = mi + i2 * divisors[depth];
        po.setCoordinates(
          constants_default.COORDS_BY_USER,
          [curve.X(t, suspendUpdate), curve.Y(t, suspendUpdate)],
          false,
          true
        );
        x = po.scrCoords[1];
        y = po.scrCoords[2];
        distOK = this.isDistOK(x - x0, y - y0, MAX_XDIST, MAX_YDIST) || this.isSegmentOutside(x0, y0, x, y, curve.board);
      }
      if (j > 1) {
        d = distFromLine(
          curve.points[j - 2].scrCoords,
          [x, y],
          curve.points[j - 1].scrCoords
        );
        if (d < 0.015) {
          j -= 1;
        }
      }
      curve.points[j] = new coords_default(constants_default.COORDS_BY_SCREEN, [x, y], curve.board, false);
      curve.points[j]._t = t;
      j += 1;
      x0 = x;
      y0 = y;
      top -= 1;
      x = pointStack[top][0];
      y = pointStack[top][1];
      depth = depthStack[top] + 1;
      i2 = dyadicStack[top] * 2;
    } while (top > 0 && j < 5e5);
    curve.numberPoints = curve.points.length;
    return curve;
  },
  //----------------------------------------------------------------------
  // Plot algorithm v2
  //----------------------------------------------------------------------
  /**
   * Add a point to the curve plot. If the new point is too close to the previously inserted point,
   * it is skipped.
   * Used in {@link JXG.Curve._plotRecursive}.
   *
   * @private
   * @param {JXG.Coords} pnt Coords to add to the list of points
   */
  _insertPoint_v2: function(curve, pnt, t) {
    var lastReal = !isNaN(this._lastCrds[1] + this._lastCrds[2]), newReal = !isNaN(pnt.scrCoords[1] + pnt.scrCoords[2]), cw = curve.board.canvasWidth, ch = curve.board.canvasHeight, off = 500;
    newReal = newReal && pnt.scrCoords[1] > -off && pnt.scrCoords[2] > -off && pnt.scrCoords[1] < cw + off && pnt.scrCoords[2] < ch + off;
    if (!newReal && lastReal || newReal && (!lastReal || Math.abs(pnt.scrCoords[1] - this._lastCrds[1]) > 0.7 || Math.abs(pnt.scrCoords[2] - this._lastCrds[2]) > 0.7)) {
      pnt._t = t;
      curve.points.push(pnt);
      this._lastCrds = pnt.copy("scrCoords");
    }
  },
  /**
   * Check if there is a single NaN function value at t0.
   * @param {*} curve
   * @param {*} t0
   * @returns {Boolean} true if there is a second NaN point close by, false otherwise
   */
  neighborhood_isNaN_v2: function(curve, t0) {
    var is_undef, pnt = new coords_default(constants_default.COORDS_BY_USER, [0, 0], curve.board, false), t, p;
    t = t0 + math_default.eps;
    pnt.setCoordinates(constants_default.COORDS_BY_USER, [curve.X(t, true), curve.Y(t, true)], false);
    p = pnt.usrCoords;
    is_undef = isNaN(p[1] + p[2]);
    if (!is_undef) {
      t = t0 - math_default.eps;
      pnt.setCoordinates(
        constants_default.COORDS_BY_USER,
        [curve.X(t, true), curve.Y(t, true)],
        false
      );
      p = pnt.usrCoords;
      is_undef = isNaN(p[1] + p[2]);
      if (!is_undef) {
        return false;
      }
    }
    return true;
  },
  /**
   * Investigate a function term at the bounds of intervals where
   * the function is not defined, e.g. log(x) at x = 0.
   *
   * c is between a and b
   * @private
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Array} a Screen coordinates of the left interval bound
   * @param {Array} b Screen coordinates of the right interval bound
   * @param {Array} c Screen coordinates of the bisection point at (ta + tb) / 2
   * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates
   * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates
   * @param {Number} tc (ta + tb) / 2 = tc. Parameter which evaluates to b, i.e. [1, X(tc), Y(tc)] = c in screen coordinates
   * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.
   * @returns {JXG.Boolean} true if the point is inserted and the recursion should stop, false otherwise.
   */
  _borderCase: function(curve, a, b, c, ta, tb, tc, depth) {
    var t, pnt, p, p_good = null, j, max_it = 30, is_undef = false, t_nan, t_real;
    if (depth <= 1) {
      pnt = new coords_default(constants_default.COORDS_BY_USER, [0, 0], curve.board, false);
      if (isNaN(a[1] + a[2]) && !isNaN(c[1] + c[2]) && !this.neighborhood_isNaN_v2(curve, ta)) {
        return false;
      }
      if (isNaN(b[1] + b[2]) && !isNaN(c[1] + c[2]) && !this.neighborhood_isNaN_v2(curve, tb)) {
        return false;
      }
      if (isNaN(c[1] + c[2]) && (!isNaN(a[1] + a[2]) || !isNaN(b[1] + b[2])) && !this.neighborhood_isNaN_v2(curve, tc)) {
        return false;
      }
      j = 0;
      do {
        if (isNaN(a[1] + a[2]) && !isNaN(c[1] + c[2])) {
          t_nan = ta;
          t_real = tc;
        } else if (isNaN(b[1] + b[2]) && !isNaN(c[1] + c[2])) {
          t_nan = tb;
          t_real = tc;
        } else if (isNaN(c[1] + c[2]) && !isNaN(b[1] + b[2])) {
          t_nan = tc;
          t_real = tb;
        } else if (isNaN(c[1] + c[2]) && !isNaN(a[1] + a[2])) {
          t_nan = tc;
          t_real = ta;
        } else {
          return false;
        }
        t = 0.5 * (t_nan + t_real);
        pnt.setCoordinates(
          constants_default.COORDS_BY_USER,
          [curve.X(t, true), curve.Y(t, true)],
          false
        );
        p = pnt.usrCoords;
        is_undef = isNaN(p[1] + p[2]);
        if (is_undef) {
          t_nan = t;
        } else {
          t_real = t;
        }
        ++j;
      } while (is_undef && j < max_it);
      if (j < max_it) {
        p_good = p.slice();
        c = p.slice();
        t_real = t;
      }
      if (p_good !== null) {
        this._insertPoint_v2(
          curve,
          new coords_default(constants_default.COORDS_BY_USER, p_good, curve.board, false)
        );
        return true;
      }
    }
    return false;
  },
  /**
   * Recursive interval bisection algorithm for curve plotting.
   * Used in {@link JXG.Curve.updateParametricCurve}.
   * @private
   * @deprecated
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Array} a Screen coordinates of the left interval bound
   * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates
   * @param {Array} b Screen coordinates of the right interval bound
   * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates
   * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.
   * @param {Number} delta If the distance of the bisection point at (ta + tb) / 2 from the point (a + b) / 2 is less then delta,
   *                 the segment [a,b] is regarded as straight line.
   * @returns {JXG.Curve} Reference to the curve object.
   */
  _plotRecursive_v2: function(curve, a, ta, b, tb, depth, delta) {
    var tc, c, ds, mindepth = 0, isSmooth, isJump, isCusp, cusp_threshold = 0.5, jump_threshold = 0.99, pnt = new coords_default(constants_default.COORDS_BY_USER, [0, 0], curve.board, false);
    if (curve.numberPoints > 65536) {
      return;
    }
    if (depth < this.nanLevel && this._isUndefined(curve, a, ta, b, tb)) {
      return this;
    }
    if (depth < this.nanLevel && this._isOutside(a, ta, b, tb, curve.board)) {
      return this;
    }
    tc = (ta + tb) * 0.5;
    pnt.setCoordinates(constants_default.COORDS_BY_USER, [curve.X(tc, true), curve.Y(tc, true)], false);
    c = pnt.scrCoords;
    if (this._borderCase(curve, a, b, c, ta, tb, tc, depth)) {
      return this;
    }
    ds = this._triangleDists(a, b, c);
    isSmooth = depth < this.smoothLevel && ds[3] < delta;
    isJump = depth <= this.jumpLevel && (isNaN(ds[0]) || isNaN(ds[1]) || isNaN(ds[2])) || depth < this.jumpLevel && (ds[2] > jump_threshold * ds[0] || ds[1] > jump_threshold * ds[0] || ds[0] === Infinity || ds[1] === Infinity || ds[2] === Infinity);
    isCusp = depth < this.smoothLevel + 2 && ds[0] < cusp_threshold * (ds[1] + ds[2]);
    if (isCusp) {
      mindepth = 0;
      isSmooth = false;
    }
    --depth;
    if (isJump) {
      this._insertPoint_v2(
        curve,
        new coords_default(constants_default.COORDS_BY_SCREEN, [NaN, NaN], curve.board, false),
        tc
      );
    } else if (depth <= mindepth || isSmooth) {
      this._insertPoint_v2(curve, pnt, tc);
    } else {
      this._plotRecursive_v2(curve, a, ta, c, tc, depth, delta);
      if (!isNaN(pnt.scrCoords[1] + pnt.scrCoords[2])) {
        this._insertPoint_v2(curve, pnt, tc);
      }
      this._plotRecursive_v2(curve, c, tc, b, tb, depth, delta);
    }
    return this;
  },
  /**
   * Updates the data points of a parametric curve. This version is used if {@link JXG.Curve#plotVersion} is <tt>3</tt>.
   *
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Number} mi Left bound of curve
   * @param {Number} ma Right bound of curve
   * @returns {JXG.Curve} Reference to the curve object.
   */
  updateParametricCurve_v2: function(curve, mi, ma) {
    var ta, tb, a, b, suspendUpdate = false, pa = new coords_default(constants_default.COORDS_BY_USER, [0, 0], curve.board, false), pb = new coords_default(constants_default.COORDS_BY_USER, [0, 0], curve.board, false), depth, delta, w2, bbox, ret_arr;
    if (curve.board.updateQuality === curve.board.BOARD_QUALITY_LOW) {
      depth = type_default.evaluate(curve.visProp.recursiondepthlow) || 13;
      delta = 2;
      this.smoothLevel = depth - 6;
      this.jumpLevel = 3;
    } else {
      depth = type_default.evaluate(curve.visProp.recursiondepthhigh) || 17;
      delta = 2;
      this.smoothLevel = depth - 9;
      this.jumpLevel = 2;
    }
    this.nanLevel = depth - 4;
    curve.points = [];
    if (this.xterm === "x") {
      bbox = curve.board.getBoundingBox();
      w2 = (bbox[2] - bbox[0]) * 0.3;
      ta = Math.max(mi, bbox[0] - w2);
      tb = Math.min(ma, bbox[2] + w2);
    } else {
      ta = mi;
      tb = ma;
    }
    pa.setCoordinates(
      constants_default.COORDS_BY_USER,
      [curve.X(ta, suspendUpdate), curve.Y(ta, suspendUpdate)],
      false
    );
    suspendUpdate = true;
    pb.setCoordinates(
      constants_default.COORDS_BY_USER,
      [curve.X(tb, suspendUpdate), curve.Y(tb, suspendUpdate)],
      false
    );
    ret_arr = this._findStartPoint(curve, pa.scrCoords, ta, pb.scrCoords, tb);
    pa.setCoordinates(constants_default.COORDS_BY_SCREEN, ret_arr[0], false);
    ta = ret_arr[1];
    ret_arr = this._findStartPoint(curve, pb.scrCoords, tb, pa.scrCoords, ta);
    pb.setCoordinates(constants_default.COORDS_BY_SCREEN, ret_arr[0], false);
    tb = ret_arr[1];
    this._visibleArea = [ta, tb];
    a = pa.copy("scrCoords");
    b = pb.copy("scrCoords");
    pa._t = ta;
    curve.points.push(pa);
    this._lastCrds = pa.copy("scrCoords");
    this._plotRecursive_v2(curve, a, ta, b, tb, depth, delta);
    pb._t = tb;
    curve.points.push(pb);
    curve.numberPoints = curve.points.length;
    return curve;
  },
  //----------------------------------------------------------------------
  // Plot algorithm v3
  //----------------------------------------------------------------------
  /**
   *
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {*} pnt
   * @param {*} t
   * @param {*} depth
   * @param {*} limes
   * @private
   */
  _insertLimesPoint: function(curve, pnt, t, depth, limes) {
    var p0, p1, p2;
    if (Math.abs(this._lastUsrCrds[1]) === Infinity && Math.abs(limes.left_x) === Infinity || Math.abs(this._lastUsrCrds[2]) === Infinity && Math.abs(limes.left_y) === Infinity) {
      return;
    }
    p0 = new coords_default(constants_default.COORDS_BY_USER, [limes.left_x, limes.left_y], curve.board);
    p0._t = t;
    curve.points.push(p0);
    if (!isNaN(limes.left_x) && !isNaN(limes.left_y) && !isNaN(limes.right_x) && !isNaN(limes.right_y) && (Math.abs(limes.left_x - limes.right_x) > math_default.eps || Math.abs(limes.left_y - limes.right_y) > math_default.eps)) {
      p1 = new coords_default(constants_default.COORDS_BY_SCREEN, pnt, curve.board);
      p1._t = t;
      curve.points.push(p1);
    }
    p2 = new coords_default(constants_default.COORDS_BY_USER, [limes.right_x, limes.right_y], curve.board);
    p2._t = t;
    curve.points.push(p2);
    this._lastScrCrds = p2.copy("scrCoords");
    this._lastUsrCrds = p2.copy("usrCoords");
  },
  /**
   * Add a point to the curve plot. If the new point is too close to the previously inserted point,
   * it is skipped.
   * Used in {@link JXG.Curve._plotRecursive}.
   *
   * @private
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {JXG.Coords} pnt Coords to add to the list of points
   */
  _insertPoint: function(curve, pnt, t, depth, limes) {
    var last_is_real = !isNaN(this._lastScrCrds[1] + this._lastScrCrds[2]), point_is_real = !isNaN(pnt[1] + pnt[2]), cw = curve.board.canvasWidth, ch = curve.board.canvasHeight, p, near = 0.8, off = 500;
    if (type_default.exists(limes)) {
      this._insertLimesPoint(curve, pnt, t, depth, limes);
      return;
    }
    point_is_real = point_is_real && pnt[1] > -off && pnt[2] > -off && pnt[1] < cw + off && pnt[2] < ch + off;
    if (!last_is_real && !point_is_real) {
      return;
    }
    if (point_is_real && last_is_real && Math.abs(pnt[1] - this._lastScrCrds[1]) < near && Math.abs(pnt[2] - this._lastScrCrds[2]) < near) {
      return;
    }
    if (Math.abs(pnt[1]) === Infinity && Math.abs(this._lastUsrCrds[1]) === Infinity || Math.abs(pnt[2]) === Infinity && Math.abs(this._lastUsrCrds[2]) === Infinity) {
      return;
    }
    p = new coords_default(constants_default.COORDS_BY_SCREEN, pnt, curve.board);
    p._t = t;
    curve.points.push(p);
    this._lastScrCrds = p.copy("scrCoords");
    this._lastUsrCrds = p.copy("usrCoords");
  },
  /**
   * Compute distances in screen coordinates between the points ab,
   * ac, cb, and cd, where d = (a + b)/2.
   * cd is used for the smoothness test, ab, ac, cb are used to detect jumps, cusps and poles.
   *
   * @private
   * @param {Array} a Screen coordinates of the left interval bound
   * @param {Array} b Screen coordinates of the right interval bound
   * @param {Array} c Screen coordinates of the bisection point at (ta + tb) / 2
   * @returns {Array} array of distances in screen coordinates between: ab, ac, cb, and cd.
   */
  _triangleDists: function(a, b, c) {
    var d, d_ab, d_ac, d_cb, d_cd;
    d = [a[0] * b[0], (a[1] + b[1]) * 0.5, (a[2] + b[2]) * 0.5];
    d_ab = geometry_default.distance(a, b, 3);
    d_ac = geometry_default.distance(a, c, 3);
    d_cb = geometry_default.distance(c, b, 3);
    d_cd = geometry_default.distance(c, d, 3);
    return [d_ab, d_ac, d_cb, d_cd];
  },
  /**
   * Test if the function is undefined on an interval:
   * If the interval borders a and b are undefined, 20 random values
   * are tested if they are undefined, too.
   * Only if all values are undefined, we declare the function to be undefined in this interval.
   *
   * @private
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Array} a Screen coordinates of the left interval bound
   * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates
   * @param {Array} b Screen coordinates of the right interval bound
   * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates
   */
  _isUndefined: function(curve, a, ta, b, tb) {
    var t, i2, pnt;
    if (!isNaN(a[1] + a[2]) || !isNaN(b[1] + b[2])) {
      return false;
    }
    pnt = new coords_default(constants_default.COORDS_BY_USER, [0, 0], curve.board, false);
    for (i2 = 0; i2 < 20; ++i2) {
      t = ta + Math.random() * (tb - ta);
      pnt.setCoordinates(
        constants_default.COORDS_BY_USER,
        [curve.X(t, true), curve.Y(t, true)],
        false
      );
      if (!isNaN(pnt.scrCoords[0] + pnt.scrCoords[1] + pnt.scrCoords[2])) {
        return false;
      }
    }
    return true;
  },
  /**
   * Decide if a path segment is too far from the canvas that we do not need to draw it.
   * @private
   * @param  {Array}  a  Screen coordinates of the start point of the segment
   * @param  {Array}  ta Curve parameter of a  (unused).
   * @param  {Array}  b  Screen coordinates of the end point of the segment
   * @param  {Array}  tb Curve parameter of b (unused).
   * @param  {JXG.Board} board
   * @returns {Boolean}   True if the segment is too far away from the canvas, false otherwise.
   */
  _isOutside: function(a, ta, b, tb, board) {
    var off = 500, cw = board.canvasWidth, ch = board.canvasHeight;
    return !!(a[1] < -off && b[1] < -off || a[2] < -off && b[2] < -off || a[1] > cw + off && b[1] > cw + off || a[2] > ch + off && b[2] > ch + off);
  },
  /**
   * Decide if a point of a curve is too far from the canvas that we do not need to draw it.
   * @private
   * @param {Array}  a  Screen coordinates of the point
   * @param {JXG.Board} board
   * @returns {Boolean}  True if the point is too far away from the canvas, false otherwise.
   */
  _isOutsidePoint: function(a, board) {
    var off = 500, cw = board.canvasWidth, ch = board.canvasHeight;
    return !!(a[1] < -off || a[2] < -off || a[1] > cw + off || a[2] > ch + off);
  },
  /**
   * For a curve c(t) defined on the interval [ta, tb] find the first point
   * which is in the visible area of the board (plus some outside margin).
   * <p>
   * This method is necessary to restrict the recursive plotting algorithm
   * {@link JXG.Curve._plotRecursive} to the visible area and not waste
   * recursion to areas far outside of the visible area.
   * <p>
   * This method can also be used to find the last visible point
   * by reversing the input parameters.
   *
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param  {Array}  ta Curve parameter of a.
   * @param  {Array}  b  Screen coordinates of the end point of the segment (unused)
   * @param  {Array}  tb Curve parameter of b
   * @return {Array}  Array of length two containing the screen ccordinates of
   * the starting point and the curve parameter at this point.
   * @private
   */
  _findStartPoint: function(curve, a, ta, b, tb) {
    return [a, ta];
  },
  /**
   * Investigate a function term at the bounds of intervals where
   * the function is not defined, e.g. log(x) at x = 0.
   *
   * c is inbetween a and b
   *
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Array} a Screen coordinates of the left interval bound
   * @param {Array} b Screen coordinates of the right interval bound
   * @param {Array} c Screen coordinates of the bisection point at (ta + tb) / 2
   * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates
   * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates
   * @param {Number} tc (ta + tb) / 2 = tc. Parameter which evaluates to b, i.e. [1, X(tc), Y(tc)] = c in screen coordinates
   * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.
   * @returns {JXG.Boolean} true if the point is inserted and the recursion should stop, false otherwise.
   *
   * @private
   */
  _getBorderPos: function(curve, ta, a, tc, c, tb, b) {
    var t, pnt, p, j, max_it = 30, is_undef = false, t_good, t_bad;
    pnt = new coords_default(constants_default.COORDS_BY_USER, [0, 0], curve.board, false);
    j = 0;
    if (isNaN(a[1] + a[2]) && !isNaN(c[1] + c[2])) {
      t_bad = ta;
      t_good = tc;
    } else if (isNaN(b[1] + b[2]) && !isNaN(c[1] + c[2])) {
      t_bad = tb;
      t_good = tc;
    } else if (isNaN(c[1] + c[2]) && !isNaN(b[1] + b[2])) {
      t_bad = tc;
      t_good = tb;
    } else if (isNaN(c[1] + c[2]) && !isNaN(a[1] + a[2])) {
      t_bad = tc;
      t_good = ta;
    } else {
      return false;
    }
    do {
      t = 0.5 * (t_good + t_bad);
      pnt.setCoordinates(
        constants_default.COORDS_BY_USER,
        [curve.X(t, true), curve.Y(t, true)],
        false
      );
      p = pnt.usrCoords;
      is_undef = isNaN(p[1] + p[2]);
      if (is_undef) {
        t_bad = t;
      } else {
        t_good = t;
      }
      ++j;
    } while (j < max_it && Math.abs(t_good - t_bad) > math_default.eps);
    return t;
  },
  /**
   *
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Number} ta
   * @param {Number} tb
   */
  _getCuspPos: function(curve, ta, tb) {
    var a = [curve.X(ta, true), curve.Y(ta, true)], b = [curve.X(tb, true), curve.Y(tb, true)], max_func = function(t) {
      var c = [curve.X(t, true), curve.Y(t, true)];
      return -(math_default.hypot(a[0] - c[0], a[1] - c[1]) + math_default.hypot(b[0] - c[0], b[1] - c[1]));
    };
    return numerics_default.fminbr(max_func, [ta, tb], curve);
  },
  /**
   *
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Number} ta
   * @param {Number} tb
   */
  _getJumpPos: function(curve, ta, tb) {
    var max_func = function(t) {
      var e = math_default.eps * math_default.eps, c1 = [curve.X(t, true), curve.Y(t, true)], c2 = [curve.X(t + e, true), curve.Y(t + e, true)];
      return -Math.abs((c2[1] - c1[1]) / (c2[0] - c1[0]));
    };
    return numerics_default.fminbr(max_func, [ta, tb], curve);
  },
  /**
   *
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Number} t
   * @private
   */
  _getLimits: function(curve, t) {
    var res, step = 2 / (curve.maxX() - curve.minX()), x_l, x_r, y_l, y_r;
    res = extrapolate_default.limit(t, -step, curve.X);
    x_l = res[0];
    if (res[1] === "infinite") {
      x_l = Math.sign(x_l) * Infinity;
    }
    res = extrapolate_default.limit(t, -step, curve.Y);
    y_l = res[0];
    if (res[1] === "infinite") {
      y_l = Math.sign(y_l) * Infinity;
    }
    res = extrapolate_default.limit(t, step, curve.X);
    x_r = res[0];
    if (res[1] === "infinite") {
      x_r = Math.sign(x_r) * Infinity;
    }
    res = extrapolate_default.limit(t, step, curve.Y);
    y_r = res[0];
    if (res[1] === "infinite") {
      y_r = Math.sign(y_r) * Infinity;
    }
    return {
      left_x: x_l,
      left_y: y_l,
      right_x: x_r,
      right_y: y_r,
      t
    };
  },
  /**
   *
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Array} a
   * @param {Number} tc
   * @param {Array} c
   * @param {Number} tb
   * @param {Array} b
   * @param {String} may_be_special
   * @param {Number} depth
   * @private
   */
  _getLimes: function(curve, ta, a, tc, c, tb, b, may_be_special, depth) {
    var t;
    if (may_be_special === "border") {
      t = this._getBorderPos(curve, ta, a, tc, c, tb, b);
    } else if (may_be_special === "cusp") {
      t = this._getCuspPos(curve, ta, tb);
    } else if (may_be_special === "jump") {
      t = this._getJumpPos(curve, ta, tb);
    }
    return this._getLimits(curve, t);
  },
  /**
   * Recursive interval bisection algorithm for curve plotting.
   * Used in {@link JXG.Curve.updateParametricCurve}.
   * @private
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Array} a Screen coordinates of the left interval bound
   * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates
   * @param {Array} b Screen coordinates of the right interval bound
   * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates
   * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.
   * @param {Number} delta If the distance of the bisection point at (ta + tb) / 2 from the point (a + b) / 2 is less then delta,
   *                 the segment [a,b] is regarded as straight line.
   * @returns {JXG.Curve} Reference to the curve object.
   */
  _plotNonRecursive: function(curve, a, ta, b, tb, d) {
    var tc, c, ds, mindepth = 0, limes = null, a_nan, b_nan, isSmooth = false, may_be_special = "", x, y, oc, depth, ds0, stack = [], stack_length = 0, item;
    oc = curve.board.origin.scrCoords;
    stack[stack_length++] = [a, ta, b, tb, d, Infinity];
    while (stack_length > 0) {
      item = stack[--stack_length];
      a = item[0];
      ta = item[1];
      b = item[2];
      tb = item[3];
      depth = item[4];
      ds0 = item[5];
      isSmooth = false;
      may_be_special = "";
      limes = null;
      if (curve.points.length > 65536) {
        return;
      }
      if (depth < this.nanLevel) {
        if (this._isUndefined(curve, a, ta, b, tb)) {
          continue;
        }
        if (this._isOutside(a, ta, b, tb, curve.board)) {
          continue;
        }
      }
      tc = (ta + tb) * 0.5;
      x = curve.X(tc, true);
      y = curve.Y(tc, true);
      c = [1, oc[1] + x * curve.board.unitX, oc[2] - y * curve.board.unitY];
      ds = this._triangleDists(a, b, c);
      a_nan = isNaN(a[1] + a[2]);
      b_nan = isNaN(b[1] + b[2]);
      if (a_nan && !b_nan || !a_nan && b_nan) {
        may_be_special = "border";
      } else if (ds[0] > 0.66 * ds0 || ds[0] < this.cusp_threshold * (ds[1] + ds[2]) || ds[1] > 5 * ds[2] || ds[2] > 5 * ds[1]) {
        may_be_special = "cusp";
      } else if (ds[2] > this.jump_threshold * ds[0] || ds[1] > this.jump_threshold * ds[0] || ds[0] === Infinity || ds[1] === Infinity || ds[2] === Infinity) {
        may_be_special = "jump";
      }
      isSmooth = may_be_special === "" && depth < this.smoothLevel && ds[3] < this.smooth_threshold;
      if (depth < this.testLevel && !isSmooth) {
        if (may_be_special === "") {
          isSmooth = true;
        } else {
          limes = this._getLimes(curve, ta, a, tc, c, tb, b, may_be_special, depth);
        }
      }
      if (limes !== null) {
        c = [1, NaN, NaN];
        this._insertPoint(curve, c, tc, depth, limes);
      } else if (depth <= mindepth || isSmooth) {
        this._insertPoint(curve, c, tc, depth, null);
      } else {
        stack[stack_length++] = [c, tc, b, tb, depth - 1, ds[0]];
        stack[stack_length++] = [a, ta, c, tc, depth - 1, ds[0]];
      }
    }
    return this;
  },
  /**
   * Updates the data points of a parametric curve. This version is used if {@link JXG.Curve#plotVersion} is <tt>3</tt>.
   * This is an experimental plot version, <b>not recommended</b> to be used.
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Number} mi Left bound of curve
   * @param {Number} ma Right bound of curve
   * @returns {JXG.Curve} Reference to the curve object.
   */
  updateParametricCurve_v3: function(curve, mi, ma) {
    var ta, tb, a, b, suspendUpdate = false, pa = new coords_default(constants_default.COORDS_BY_USER, [0, 0], curve.board, false), pb = new coords_default(constants_default.COORDS_BY_USER, [0, 0], curve.board, false), depth, w2, bbox, ret_arr;
    if (curve.board.updateQuality === curve.board.BOARD_QUALITY_LOW) {
      depth = type_default.evaluate(curve.visProp.recursiondepthlow) || 14;
    } else {
      depth = type_default.evaluate(curve.visProp.recursiondepthhigh) || 17;
    }
    this.smoothLevel = 7;
    this.nanLevel = depth - 4;
    this.testLevel = 4;
    this.cusp_threshold = 0.5;
    this.jump_threshold = 0.99;
    this.smooth_threshold = 2;
    curve.points = [];
    if (curve.xterm === "x") {
      bbox = curve.board.getBoundingBox();
      w2 = (bbox[2] - bbox[0]) * 0.3;
      ta = Math.max(mi, bbox[0] - w2);
      tb = Math.min(ma, bbox[2] + w2);
    } else {
      ta = mi;
      tb = ma;
    }
    pa.setCoordinates(
      constants_default.COORDS_BY_USER,
      [curve.X(ta, suspendUpdate), curve.Y(ta, suspendUpdate)],
      false
    );
    suspendUpdate = true;
    pb.setCoordinates(
      constants_default.COORDS_BY_USER,
      [curve.X(tb, suspendUpdate), curve.Y(tb, suspendUpdate)],
      false
    );
    ret_arr = this._findStartPoint(curve, pa.scrCoords, ta, pb.scrCoords, tb);
    pa.setCoordinates(constants_default.COORDS_BY_SCREEN, ret_arr[0], false);
    ta = ret_arr[1];
    ret_arr = this._findStartPoint(curve, pb.scrCoords, tb, pa.scrCoords, ta);
    pb.setCoordinates(constants_default.COORDS_BY_SCREEN, ret_arr[0], false);
    tb = ret_arr[1];
    this._visibleArea = [ta, tb];
    a = pa.copy("scrCoords");
    b = pb.copy("scrCoords");
    pa._t = ta;
    curve.points.push(pa);
    this._lastScrCrds = pa.copy("scrCoords");
    this._lastUsrCrds = pa.copy("usrCoords");
    this._plotNonRecursive(curve, a, ta, b, tb, depth);
    pb._t = tb;
    curve.points.push(pb);
    curve.numberPoints = curve.points.length;
    return curve;
  },
  //----------------------------------------------------------------------
  // Plot algorithm v4
  //----------------------------------------------------------------------
  _criticalInterval: function(vec, le, level) {
    var i2, j, le1, med, sgn, sgnChange, isGroup = false, abs_vec, last = -Infinity, very_small = false, smooth = false, group = 0, groups = [], types = [], positions = [];
    abs_vec = statistics_default.abs(vec);
    med = statistics_default.median(abs_vec);
    if (med < 1e-7) {
      med = 1e-7;
      very_small = true;
    } else {
      med *= this.criticalThreshold;
    }
    for (i2 = 0; i2 < le; i2++) {
      if (abs_vec[i2] > med) {
        positions.push({ i: i2, v: vec[i2], group });
        last = i2;
        if (!isGroup) {
          isGroup = true;
        }
      } else {
        if (isGroup && i2 > last + 4) {
          if (positions.length > 0) {
            groups.push(positions.slice(0));
          }
          positions = [];
          isGroup = false;
          group++;
        }
      }
    }
    if (isGroup) {
      if (positions.length > 1) {
        groups.push(positions.slice(0));
      }
    }
    if (very_small && groups.length === 0) {
      smooth = true;
    }
    for (j = 0; j < groups.length; j++) {
      types[j] = "point";
      le1 = groups[j].length;
      if (le1 < 64) {
        continue;
      }
      sgnChange = 0;
      sgn = Math.sign(groups[j][0].v);
      for (i2 = 1; i2 < le1; i2++) {
        if (Math.sign(groups[j][i2].v) !== sgn) {
          sgnChange++;
          sgn = Math.sign(groups[j][i2].v);
        }
      }
      if (sgnChange * 6 > le1) {
        types[j] = "interval";
      }
    }
    return { smooth, groups, types };
  },
  Component: function() {
    this.left_isNaN = false;
    this.right_isNaN = false;
    this.left_t = null;
    this.right_t = null;
    this.t_values = [];
    this.x_values = [];
    this.y_values = [];
    this.len = 0;
  },
  findComponents: function(curve, mi, ma, steps) {
    var i2, t, h, x, y, components = [], comp, comp_nr = 0, cnt = 0, cntNaNs = 0, comp_started = false, suspended = false;
    h = (ma - mi) / steps;
    components[comp_nr] = new this.Component();
    comp = components[comp_nr];
    for (i2 = 0, t = mi; i2 <= steps; i2++, t += h) {
      x = curve.X(t, suspended);
      y = curve.Y(t, suspended);
      if (isNaN(x) || isNaN(y)) {
        cntNaNs++;
        if (cntNaNs > 1 && comp_started) {
          comp.right_isNaN = true;
          comp.right_t = t - h;
          comp.len = cnt;
          comp_started = false;
          comp_nr++;
          components[comp_nr] = new this.Component();
          comp = components[comp_nr];
          cntNaNs = 0;
        }
      } else {
        if (!comp_started) {
          comp_started = true;
          cnt = 0;
          if (cntNaNs > 0) {
            comp.left_t = t - h;
            comp.left_isNaN = true;
          }
        }
        cntNaNs = 0;
        comp.t_values[cnt] = t;
        comp.x_values[cnt] = x;
        comp.y_values[cnt] = y;
        cnt++;
      }
      if (i2 === 0) {
        suspended = true;
      }
    }
    if (comp_started) {
      comp.len = cnt;
    } else {
      components.pop();
    }
    return components;
  },
  getPointType: function(curve, pos, t_approx, t_values, x_table, y_table, len) {
    var x_values = x_table[0], y_values = y_table[0], full_len = t_values.length, result = {
      idx: pos,
      t: t_approx,
      //t_values[pos],
      x: x_values[pos],
      y: y_values[pos],
      type: "other"
    };
    if (pos < 5) {
      result.type = "borderleft";
      result.idx = 0;
      result.t = t_values[0];
      result.x = x_values[0];
      result.y = y_values[0];
      return result;
    }
    if (pos > len - 6) {
      result.type = "borderright";
      result.idx = full_len - 1;
      result.t = t_values[full_len - 1];
      result.x = x_values[full_len - 1];
      result.y = y_values[full_len - 1];
      return result;
    }
    return result;
  },
  newtonApprox: function(idx, t, h, level, table) {
    var i2, s = 0;
    for (i2 = level; i2 > 0; i2--) {
      s = (s + table[i2][idx]) * (t - (i2 - 1) * h) / i2;
    }
    return s + table[0][idx];
  },
  thiele: function(t, recip, t_values, idx, degree) {
    var i2, v = 0;
    for (i2 = degree; i2 > 1; i2--) {
      v = (t - t_values[idx + i2]) / (recip[i2][idx + 1] - recip[i2 - 2][idx + 1] + v);
    }
    return recip[0][idx + 1] + (t - t_values[idx + 1]) / (recip[1][idx + 1] + v);
  },
  differenceMethodExperiments: function(component, curve) {
    var i2, level, le, up, t_values = component.t_values, x_values = component.x_values, y_values = component.y_values, x_diffs = [], y_diffs = [], x_slopes = [], y_slopes = [], x_table = [], y_table = [], x_recip = [], y_recip = [], h, numerator, foundCriticalPoint = 0, pos, ma, j, v, groups, criticalPoints = [];
    h = t_values[1] - t_values[0];
    x_table.push([]);
    y_table.push([]);
    x_recip.push([]);
    y_recip.push([]);
    le = y_values.length;
    for (i2 = 0; i2 < le; i2++) {
      x_table[0][i2] = x_values[i2];
      y_table[0][i2] = y_values[i2];
      x_recip[0][i2] = x_values[i2];
      y_recip[0][i2] = y_values[i2];
    }
    x_table.push([]);
    y_table.push([]);
    x_recip.push([]);
    y_recip.push([]);
    numerator = h;
    le = y_values.length - 1;
    for (i2 = 0; i2 < le; i2++) {
      x_diffs[i2] = x_values[i2 + 1] - x_values[i2];
      y_diffs[i2] = y_values[i2 + 1] - y_values[i2];
      x_slopes[i2] = x_diffs[i2];
      y_slopes[i2] = y_diffs[i2];
      x_table[1][i2] = x_diffs[i2];
      y_table[1][i2] = y_diffs[i2];
      x_recip[1][i2] = numerator / x_diffs[i2];
      y_recip[1][i2] = numerator / y_diffs[i2];
    }
    le--;
    up = Math.min(8, y_values.length - 1);
    for (level = 1; level < up; level++) {
      x_table.push([]);
      y_table.push([]);
      x_recip.push([]);
      y_recip.push([]);
      numerator *= h;
      for (i2 = 0; i2 < le; i2++) {
        x_diffs[i2] = x_diffs[i2 + 1] - x_diffs[i2];
        y_diffs[i2] = y_diffs[i2 + 1] - y_diffs[i2];
        x_table[level + 1][i2] = x_diffs[i2];
        y_table[level + 1][i2] = y_diffs[i2];
        x_recip[level + 1][i2] = numerator / (x_recip[level][i2 + 1] - x_recip[level][i2]) + x_recip[level - 1][i2 + 1];
        y_recip[level + 1][i2] = numerator / (y_recip[level][i2 + 1] - y_recip[level][i2]) + y_recip[level - 1][i2 + 1];
      }
      groups = this._criticalPoints(y_diffs, le, level);
      if (groups === false) {
        console.log("Polynomial of degree", level);
        groups = [];
        break;
      }
      if (groups.length > 0) {
        foundCriticalPoint++;
        if (foundCriticalPoint > 1 && level % 2 === 0) {
          break;
        }
      }
      le--;
    }
    for (i2 = 0; i2 < groups.length; i2++) {
      ma = -Infinity;
      for (j = 0; j < groups[i2].length; j++) {
        v = Math.abs(groups[i2][j].v);
        if (v > ma) {
          ma = v;
          pos = j;
        }
      }
      pos = Math.floor(groups[i2][pos].i + level / 2);
      criticalPoints.push(
        this.getPointType(
          curve,
          pos,
          t_values,
          x_values,
          y_values,
          x_slopes,
          y_slopes,
          le + 1
        )
      );
    }
    return [criticalPoints, x_table, y_table, x_recip, y_recip];
  },
  getCenterOfCriticalInterval: function(group, degree, t_values) {
    var ma, j, pos, v, num = 0, den = 0, h = t_values[1] - t_values[0], pos_mean, range = [];
    ma = -Infinity;
    range = [];
    for (j = 0; j < group.length; j++) {
      v = Math.abs(group[j].v);
      if (v > ma) {
        range = [j];
        ma = v;
        pos = j;
      } else if (ma === v) {
        range.push(j);
      }
    }
    if (range.length > 0) {
      pos_mean = range.reduce(function(total, val) {
        return total + val;
      }, 0) / range.length;
      pos = Math.floor(pos_mean);
      pos_mean += group[0].i;
    }
    if (ma < Infinity) {
      for (j = 0; j < group.length; j++) {
        num += Math.abs(group[j].v) * group[j].i;
        den += Math.abs(group[j].v);
      }
      pos_mean = num / den;
    }
    pos_mean += degree / 2;
    return [
      group[pos].i + degree / 2,
      pos_mean,
      t_values[Math.floor(pos_mean)] + h * (pos_mean - Math.floor(pos_mean))
    ];
  },
  differenceMethod: function(component, curve) {
    var i2, level, le, up, t_values = component.t_values, x_values = component.x_values, y_values = component.y_values, x_table = [], y_table = [], foundCriticalPoint = 0, degree_x = -1, degree_y = -1, pos, res, res_x, res_y, t_approx, groups = [], types, criticalPoints = [];
    le = y_values.length;
    x_table.push(new Float64Array(x_values));
    y_table.push(new Float64Array(y_values));
    le--;
    up = Math.min(12, le);
    for (level = 0; level < up; level++) {
      x_table.push(new Float64Array(le));
      y_table.push(new Float64Array(le));
      x_table[level + 1] = x_table[level].map(function(v, idx, arr) {
        return arr[idx + 1] - v;
      });
      y_table[level + 1] = y_table[level].map(function(v, idx, arr) {
        return arr[idx + 1] - v;
      });
      res_y = this._criticalInterval(y_table[level + 1], le, level);
      if (res_y.smooth === true) {
        degree_y = level;
        groups = [];
      }
      res_x = this._criticalInterval(x_table[level + 1], le, level);
      if (degree_x === -1 && res_x.smooth === true) {
        degree_x = level;
      }
      if (degree_y >= 0) {
        break;
      }
      if (res_y.groups.length > 0) {
        foundCriticalPoint++;
        if (foundCriticalPoint > 2 && (level + 1) % 2 === 0) {
          groups = res_y.groups;
          types = res_y.types;
          break;
        }
      }
      le--;
    }
    for (i2 = 0; i2 < groups.length; i2++) {
      if (types[i2] === "interval") {
        continue;
      }
      res = this.getCenterOfCriticalInterval(groups[i2], level + 1, t_values);
      pos = res_y[0];
      pos = Math.floor(res[1]);
      t_approx = res[2];
      criticalPoints.push(
        this.getPointType(curve, pos, t_approx, t_values, x_table, y_table, le + 1)
      );
    }
    return [criticalPoints, x_table, y_table, degree_x, degree_y];
  },
  _insertPoint_v4: function(curve, crds, t, doLog) {
    var p, prev = null, x, y, near = 0.8;
    if (curve.points.length > 0) {
      prev = curve.points[curve.points.length - 1].scrCoords;
    }
    p = new coords_default(constants_default.COORDS_BY_USER, crds, curve.board);
    if (prev !== null) {
      x = p.scrCoords[1] - prev[1];
      y = p.scrCoords[2] - prev[2];
      if (x * x + y * y < near * near) {
        return;
      }
    }
    p._t = t;
    curve.points.push(p);
  },
  getInterval: function(curve, ta, tb) {
    var t_int, x_int, y_int;
    ia_default.disable();
    t_int = ia_default.Interval(ta, tb);
    curve.board.mathLib = ia_default;
    curve.board.mathLibJXG = ia_default;
    x_int = curve.X(t_int, true);
    y_int = curve.Y(t_int, true);
    curve.board.mathLib = Math;
    curve.board.mathLibJXG = jxg_default.Math;
    return y_int;
  },
  sign: function(v) {
    if (v < 0) {
      return -1;
    }
    if (v > 0) {
      return 1;
    }
    return 0;
  },
  handleBorder: function(curve, comp, group, x_table, y_table) {
    var idx = group.idx, t, t1, t2, size2 = 32, y_int, x, y, lo, hi, i2, components2, le, h;
    h = comp.t_values[1] - comp.t_values[0];
    if (group.type === "borderleft") {
      t = comp.left_isNaN ? comp.left_t : group.t - h;
      t1 = t;
      t2 = t1 + h;
    } else if (group.type === "borderright") {
      t = comp.right_isNaN ? comp.right_t : group.t + h;
      t2 = t;
      t1 = t2 - h;
    } else {
      console.log("No bordercase!!!");
    }
    components2 = this.findComponents(curve, t1, t2, size2);
    if (components2.length === 0) {
      return;
    }
    if (group.type === "borderleft") {
      t1 = components2[0].left_t;
      t2 = components2[0].t_values[0];
      h = components2[0].t_values[1] - components2[0].t_values[0];
      t1 = t1 === null ? t2 - h : t1;
      t = t1;
      y_int = this.getInterval(curve, t1, t2);
      if (type_default.isObject(y_int)) {
        lo = y_int.lo;
        hi = y_int.hi;
        x = curve.X(t, true);
        y = y_table[1][idx] < 0 ? hi : lo;
        this._insertPoint_v4(curve, [1, x, y], t);
      }
    }
    le = components2[0].t_values.length;
    for (i2 = 0; i2 < le; i2++) {
      t = components2[0].t_values[i2];
      x = components2[0].x_values[i2];
      y = components2[0].y_values[i2];
      this._insertPoint_v4(curve, [1, x, y], t);
    }
    if (group.type === "borderright") {
      t1 = components2[0].t_values[le - 1];
      t2 = components2[0].right_t;
      h = components2[0].t_values[1] - components2[0].t_values[0];
      t2 = t2 === null ? t1 + h : t2;
      t = t2;
      y_int = this.getInterval(curve, t1, t2);
      if (type_default.isObject(y_int)) {
        lo = y_int.lo;
        hi = y_int.hi;
        x = curve.X(t, true);
        y = y_table[1][idx] > 0 ? hi : lo;
        this._insertPoint_v4(curve, [1, x, y], t);
      }
    }
  },
  _seconditeration_v4: function(curve, comp, group, x_table, y_table) {
    var i2, t1, t2, ret, components2, comp2, idx, groups2, g, x_table2, y_table2, start, le;
    t1 = comp.t_values[group.idx - 2];
    t2 = comp.t_values[group.idx + 2];
    components2 = this.findComponents(curve, t1, t2, 64);
    for (idx = 0; idx < components2.length; idx++) {
      comp2 = components2[idx];
      ret = this.differenceMethod(comp2, curve);
      groups2 = ret[0];
      x_table2 = ret[1];
      y_table2 = ret[2];
      start = 0;
      for (g = 0; g <= groups2.length; g++) {
        if (g === groups2.length) {
          le = comp2.len;
        } else {
          le = groups2[g].idx;
        }
        for (i2 = start; i2 < le; i2++) {
          if (!isNaN(comp2.x_values[i2]) && !isNaN(comp2.y_values[i2])) {
            this._insertPoint_v4(
              curve,
              [1, comp2.x_values[i2], comp2.y_values[i2]],
              comp2.t_values[i2]
            );
          }
        }
        if (g < groups2.length) {
          this.handleSingularity(curve, comp2, groups2[g], x_table2, y_table2);
          start = groups2[g].idx + 1;
        }
      }
      le = comp2.len;
      if (idx < components2.length - 1) {
        this._insertPoint_v4(curve, [1, NaN, NaN], comp2.right_t);
      }
    }
    return this;
  },
  _recurse_v4: function(curve, t1, t2, x1, y1, x2, y2, level) {
    var tol = 2, t = (t1 + t2) * 0.5, x = curve.X(t, true), y = curve.Y(t, true), dx, dy;
    if (level === 0) {
      this._insertPoint_v4(curve, [1, NaN, NaN], t);
      return;
    }
    dx = (x - x1) * curve.board.unitX;
    dy = (y - y1) * curve.board.unitY;
    if (math_default.hypot(dx, dy) > tol) {
      this._recurse_v4(curve, t1, t, x1, y1, x, y, level - 1);
    } else {
      this._insertPoint_v4(curve, [1, x, y], t);
    }
    dx = (x - x2) * curve.board.unitX;
    dy = (y - y2) * curve.board.unitY;
    if (math_default.hypot(dx, dy) > tol) {
      this._recurse_v4(curve, t, t2, x, y, x2, y2, level - 1);
    } else {
      this._insertPoint_v4(curve, [1, x, y], t);
    }
  },
  handleSingularity: function(curve, comp, group, x_table, y_table) {
    var idx = group.idx, t, t1, t2, y_int, i1, i2, x, y, lo, hi, d_lft, d_rgt, d_thresh = 100, di1 = 5, di2 = 3, d1, d2;
    t = group.t;
    console.log("HandleSingularity at t =", t);
    t1 = comp.t_values[idx - di1];
    t2 = comp.t_values[idx + di1];
    y_int = this.getInterval(curve, t1, t2);
    if (type_default.isObject(y_int)) {
      lo = y_int.lo;
      hi = y_int.hi;
    } else {
      if (y_table[0][idx - 1] < y_table[0][idx + 1]) {
        lo = y_table[0][idx - 1];
        hi = y_table[0][idx + 1];
      } else {
        lo = y_table[0][idx + 1];
        hi = y_table[0][idx - 1];
      }
    }
    x = curve.X(t, true);
    d_lft = (y_table[0][idx - di2] - y_table[0][idx - di1]) / (comp.t_values[idx - di2] - comp.t_values[idx - di1]);
    d_rgt = (y_table[0][idx + di2] - y_table[0][idx + di1]) / (comp.t_values[idx + di2] - comp.t_values[idx + di1]);
    console.log(":::", d_lft, d_rgt);
    if (d_lft < -d_thresh) {
      this._insertPoint_v4(curve, [1, x, lo], t, true);
      if (d_rgt <= d_thresh) {
        this._insertPoint_v4(curve, [1, NaN, NaN], t);
      }
    } else if (d_lft > d_thresh) {
      this._insertPoint_v4(curve, [1, x, hi], t);
      if (d_rgt >= -d_thresh) {
        this._insertPoint_v4(curve, [1, NaN, NaN], t);
      }
    } else {
      if (lo === -Infinity) {
        this._insertPoint_v4(curve, [1, x, lo], t, true);
        this._insertPoint_v4(curve, [1, NaN, NaN], t);
      }
      if (hi === Infinity) {
        this._insertPoint_v4(curve, [1, NaN, NaN], t);
        this._insertPoint_v4(curve, [1, x, hi], t, true);
      }
      if (group.t < comp.t_values[idx]) {
        i1 = idx - 1;
        i2 = idx;
      } else {
        i1 = idx;
        i2 = idx + 1;
      }
      t1 = comp.t_values[i1];
      t2 = comp.t_values[i2];
      this._recurse_v4(
        curve,
        t1,
        t2,
        x_table[0][i1],
        y_table[0][i1],
        x_table[0][i2],
        y_table[0][i2],
        10
      );
    }
    if (d_rgt < -d_thresh) {
      this._insertPoint_v4(curve, [1, x, hi], t);
    } else if (d_rgt > d_thresh) {
      this._insertPoint_v4(curve, [1, x, lo], t);
    }
  },
  /**
   * Number of equidistant points where the function is evaluated
   */
  steps: 1021,
  //2053, // 1021,
  /**
   * If the absolute maximum of the set of differences is larger than
   * criticalThreshold * median of these values, it is regarded as critical point.
   * @see JXG.Math.Plot#_criticalInterval
   */
  criticalThreshold: 1e3,
  plot_v4: function(curve, ta, tb, steps) {
    var i2, j, le, components, idx, comp, groups, g, start, ret, x_table, y_table, t, t1, t2, good, bad, x_int, y_int, degree_x, degree_y, h = (tb - ta) / steps, Ypl = function(x) {
      return curve.Y(x, true);
    }, Ymi = function(x) {
      return -curve.Y(x, true);
    }, h2 = h * 0.5;
    components = this.findComponents(curve, ta, tb, steps);
    for (idx = 0; idx < components.length; idx++) {
      comp = components[idx];
      ret = this.differenceMethod(comp, curve);
      groups = ret[0];
      x_table = ret[1];
      y_table = ret[2];
      degree_x = ret[3];
      degree_y = ret[4];
      if (groups.length === 0 || groups[0].type !== "borderleft") {
        groups.unshift({
          idx: 0,
          t: comp.t_values[0],
          x: comp.x_values[0],
          y: comp.y_values[0],
          type: "borderleft"
        });
      }
      if (groups[groups.length - 1].type !== "borderright") {
        le = comp.t_values.length;
        groups.push({
          idx: le - 1,
          t: comp.t_values[le - 1],
          x: comp.x_values[le - 1],
          y: comp.y_values[le - 1],
          type: "borderright"
        });
      }
      start = 0;
      for (g = 0; g <= groups.length; g++) {
        if (g === groups.length) {
          le = comp.len;
        } else {
          le = groups[g].idx - 1;
        }
        good = 0;
        bad = 0;
        for (i2 = start; i2 < le - 2; i2++) {
          this._insertPoint_v4(
            curve,
            [1, comp.x_values[i2], comp.y_values[i2]],
            comp.t_values[i2]
          );
          j = Math.max(0, i2 - 2);
          if (
            //degree_y === -1 && // No polynomial
            i2 >= start + 3 && i2 < le - 3 && // Do not do this if too close to a critical point
            y_table.length > 3 && Math.abs(y_table[2][i2]) > 0.2 * Math.abs(y_table[0][i2])
          ) {
            t = comp.t_values[i2];
            h2 = h * 0.25;
            y_int = this.getInterval(curve, t, t + h);
            if (type_default.isObject(y_int)) {
              if (y_table[2][i2] > 0) {
                this._insertPoint_v4(curve, [1, t + h2, y_int.lo], t + h2);
              } else {
                this._insertPoint_v4(
                  curve,
                  [1, t + h - h2, y_int.hi],
                  t + h - h2
                );
              }
            } else {
              t1 = numerics_default.fminbr(Ypl, [t, t + h]);
              t2 = numerics_default.fminbr(Ymi, [t, t + h]);
              if (t1 < t2) {
                this._insertPoint_v4(
                  curve,
                  [1, curve.X(t1, true), curve.Y(t1, true)],
                  t1
                );
                this._insertPoint_v4(
                  curve,
                  [1, curve.X(t2, true), curve.Y(t2, true)],
                  t2
                );
              } else {
                this._insertPoint_v4(
                  curve,
                  [1, curve.X(t2, true), curve.Y(t2, true)],
                  t2
                );
                this._insertPoint_v4(
                  curve,
                  [1, curve.X(t1, true), curve.Y(t1, true)],
                  t1
                );
              }
            }
            bad++;
          } else {
            good++;
          }
        }
        if (g < groups.length) {
          i2 = groups[g].idx;
          if (groups[g].type === "borderleft" || groups[g].type === "borderright") {
            this.handleBorder(curve, comp, groups[g], x_table, y_table);
          } else {
            this._seconditeration_v4(curve, comp, groups[g], x_table, y_table);
          }
          start = groups[g].idx + 1 + 1;
        }
      }
      le = comp.len;
      if (idx < components.length - 1) {
        this._insertPoint_v4(curve, [1, NaN, NaN], comp.right_t);
      }
    }
  },
  /**
   * Updates the data points of a parametric curve, plotVersion 4. This version is used if {@link JXG.Curve#plotVersion} is <tt>4</tt>.
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Number} mi Left bound of curve
   * @param {Number} ma Right bound of curve
   * @returns {JXG.Curve} Reference to the curve object.
   */
  updateParametricCurve_v4: function(curve, mi, ma) {
    var ta, tb, w2, bbox;
    if (curve.xterm === "x") {
      bbox = curve.board.getBoundingBox();
      w2 = (bbox[2] - bbox[0]) * 0.3;
      ta = Math.max(mi, bbox[0] - w2);
      tb = Math.min(ma, bbox[2] + w2);
    } else {
      ta = mi;
      tb = ma;
    }
    curve.points = [];
    this.plot_v4(curve, ta, tb, this.steps);
    curve.numberPoints = curve.points.length;
  },
  //----------------------------------------------------------------------
  // Plot algorithm alias
  //----------------------------------------------------------------------
  /**
   * Updates the data points of a parametric curve, alias for {@link JXG.Curve#updateParametricCurve_v2}.
   * This is needed for backwards compatibility, if this method has been
   * used directly in an application.
   * @param {JXG.Curve} curve JSXGraph curve element
   * @param {Number} mi Left bound of curve
   * @param {Number} ma Right bound of curve
   * @returns {JXG.Curve} Reference to the curve object.
   *
   * @see JXG.Curve#updateParametricCurve_v2
   */
  updateParametricCurve: function(curve, mi, ma) {
    return this.updateParametricCurve_v2(curve, mi, ma);
  }
};
var plot_default = math_default.Plot;

// node_modules/jsxgraph/src/math/implicitplot.js
math_default.ImplicitPlot = function(bbox, config, f, dfx, dfy) {
  var cfg_default = {
    resolution_out: 5,
    // Distance between vertical lines to search for components
    resolution_in: 5,
    // Distance between vertical lines to search for components
    max_steps: 1024,
    // Max number of points in one call of tracing
    alpha_0: 0.05,
    // Angle between two successive tangents: smoothness of curve
    tol_u0: math_default.eps,
    // Tolerance to find starting points for tracing.
    tol_newton: 1e-7,
    // Tolerance for Newton steps.
    tol_cusp: 0.05,
    // Tolerance for cusp / bifurcation detection
    tol_progress: 1e-4,
    // If two points are closer than this value, we bail out
    qdt_box: 0.2,
    // half of box size to search in qdt
    kappa_0: 0.2,
    // Inverse of planned number of Newton steps
    delta_0: 0.05,
    // Distance of predictor point to curve
    h_initial: 0.1,
    // Initial step width
    h_critical: 1e-3,
    // If h is below this threshold we bail out
    h_max: 1,
    // Maximum value of h (user units)
    loop_dist: 0.09,
    // Allowed distance (multiplied by actual step width) to detect loop
    loop_dir: 0.99,
    // Should be > 0.95
    loop_detection: true,
    // Use Gosper's loop detector
    unitX: 10,
    // unitX of board
    unitY: 10
    // unitX of board
  };
  this.config = type_default.merge(cfg_default, config);
  this.f = f;
  this.dfx = null;
  this.dfy = null;
  if (type_default.isFunction(dfx)) {
    this.dfx = dfx;
  } else {
    this.dfx = function(x, y) {
      var h = math_default.eps * math_default.eps;
      return (this.f(x + h, y) - this.f(x - h, y)) * 0.5 / h;
    };
  }
  if (type_default.isFunction(dfy)) {
    this.dfy = dfy;
  } else {
    this.dfy = function(x, y) {
      var h = math_default.eps * math_default.eps;
      return (this.f(x, y + h) - this.f(x, y - h)) * 0.5 / h;
    };
  }
  this.bbox = bbox;
  this.qdt = new bqdt_default(20, 5, bbox);
  this.components = [];
};
type_default.extend(
  math_default.ImplicitPlot.prototype,
  /** @lends JXG.Math.ImplicitPlot.prototype */
  {
    /**
     * Implicit plotting method.
     *
     * @returns {Array} consisting of [dataX, dataY, number_of_components]
     */
    plot: function() {
      var doVerticalSearch = true, doHorizontalSearch = true, x, y, mi_x, ma_x, mi_y, ma_y, dataX = [], dataY = [], ret = [], num_components = 0, delta, that2 = this, fmi_x = function(t) {
        return that2.f(x, t);
      }, fma_x = function(t) {
        return -that2.f(x, t);
      }, fmi_y = function(t) {
        return that2.f(t, y);
      }, fma_y = function(t) {
        return -that2.f(t, y);
      };
      mi_x = Math.min(this.bbox[0], this.bbox[2]) - math_default.eps;
      ma_x = Math.max(this.bbox[0], this.bbox[2]);
      mi_y = Math.min(this.bbox[1], this.bbox[3]) + math_default.eps;
      ma_y = Math.max(this.bbox[1], this.bbox[3]);
      if (doVerticalSearch) {
        delta = this.config.resolution_out / this.config.unitX;
        delta *= 1 + math_default.eps;
        for (x = mi_x; x < ma_x; x += delta) {
          ret = this.searchLine(
            fmi_x,
            fma_x,
            x,
            [mi_y, ma_y],
            "vertical",
            num_components,
            dataX,
            dataY
          );
          if (ret !== false) {
            dataX = ret[0];
            dataY = ret[1];
            num_components = ret[2];
          }
        }
      }
      if (doHorizontalSearch) {
        delta = this.config.resolution_out / this.config.unitY;
        delta *= 1 + math_default.eps;
        for (y = mi_y; y < ma_y; y += delta) {
          ret = this.searchLine(
            fmi_y,
            fma_y,
            y,
            [mi_x, ma_x],
            "horizontal",
            num_components,
            dataX,
            dataY
          );
          if (ret !== false) {
            dataX = ret[0];
            dataY = ret[1];
            num_components = ret[2];
          }
        }
      }
      return [dataX, dataY, num_components];
    },
    /**
     * Recursively search a horizontal or vertical line for points on the
     * fulfilling the given equation.
     *
     * @param {Function} fmi Minimization function
     * @param {Function} fma Maximization function
     * @param {Number} fix Value of the fixed variable
     * @param {Array} interval Search interval of the free variable
     * @param {String} dir 'vertical' or 'horizontal'
     * @param {Number} num_components Number of components before search
     * @param {Array} dataX x-coordinates of points so far
     * @param {Array} dataY y-coordinates of points so far
     * @returns {Array} consisting of [dataX, dataY, number_of_components]-
     * @private
     */
    searchLine: function(fmi, fma, fix, interval, dir, num_components, dataX, dataY) {
      var t_mi, t_ma, t, ft, mi, ma, tmp, m, is_in, u0, i2, le, ret, offset, delta, eps = this.config.tol_u0, DEBUG = false, b = interval[0], e = interval[1];
      t_mi = numerics_default.fminbr(fmi, [b, e]);
      mi = fmi(t_mi);
      t_ma = numerics_default.fminbr(fma, [b, e]);
      ma = fmi(t_ma);
      if (mi < eps && ma > -eps) {
        tmp = t_mi;
        t_mi = Math.min(tmp, t_ma);
        t_ma = Math.max(tmp, t_ma);
        t = numerics_default.fzero(fmi, [t_mi, t_ma]);
        ft = fmi(t);
        if (Math.abs(ft) > Math.max((ma - mi) * math_default.eps, 1e-3)) {
          return false;
        }
        if (dir === "vertical") {
          u0 = [1, fix, t];
          delta = this.config.resolution_in / this.config.unitY;
        } else {
          u0 = [1, t, fix];
          delta = this.config.resolution_in / this.config.unitX;
        }
        delta *= 1 + math_default.eps;
        is_in = this.curveContainsPoint(
          u0,
          dataX,
          dataY,
          delta * 2,
          // Allowed dist from segment
          this.config.qdt_box
          // 0.5 of box size to search in qdt
        );
        if (is_in) {
          if (DEBUG) {
            console.log("Found in quadtree", u0);
          }
        } else {
          if (DEBUG) {
            console.log("Not in quadtree", u0, dataX.length);
          }
          ret = this.traceComponent(u0, 1);
          if (ret.length > 0) {
            if (num_components > 0) {
              dataX.push(NaN);
              dataY.push(NaN);
            }
            offset = dataX.length;
            le = ret[0].length;
            for (i2 = 1; i2 < le; i2++) {
              this.qdt.insertItem({
                xlb: Math.min(ret[0][i2 - 1], ret[0][i2]),
                xub: Math.max(ret[0][i2 - 1], ret[0][i2]),
                ylb: Math.min(ret[1][i2 - 1], ret[1][i2]),
                yub: Math.max(ret[1][i2 - 1], ret[1][i2]),
                idx1: offset + i2 - 1,
                idx2: offset + i2,
                comp: num_components
              });
            }
            num_components++;
            dataX = dataX.concat(ret[0]);
            dataY = dataY.concat(ret[1]);
          }
        }
        m = t - delta * 0.01;
        if (m - b > delta) {
          ret = this.searchLine(
            fmi,
            fma,
            fix,
            [b, m],
            dir,
            num_components,
            dataX,
            dataY
          );
          if (ret !== false) {
            dataX = ret[0];
            dataY = ret[1];
            num_components = ret[2];
          }
        }
        m = t + delta * 0.01;
        if (e - m > delta) {
          ret = this.searchLine(
            fmi,
            fma,
            fix,
            [m, e],
            dir,
            num_components,
            dataX,
            dataY
          );
          if (ret !== false) {
            dataX = ret[0];
            dataY = ret[1];
            num_components = ret[2];
          }
        }
        return [dataX, dataY, num_components];
      }
      return false;
    },
    /**
     * Test if the data points contain a given coordinate, i.e. if the
     * given coordinate is close enough to the polygonal chain
     * through the data points.
     *
     * @param {Array} p Homogenous coordinates [1, x, y] of the coordinate point
     * @param {Array} dataX x-coordinates of points so far
     * @param {Array} dataY y-coordinates of points so far
     * @param {Number} tol Maximal distance of p from the polygonal chain through the data points
     * @param {Number} eps Helper tolerance used for the quadtree
     * @returns Boolean
     */
    curveContainsPoint: function(p, dataX, dataY, tol, eps) {
      var i2, le, hits, d, x = p[1], y = p[2];
      hits = this.qdt.find([x - eps, y + eps, x + eps, y - eps]);
      le = hits.length;
      for (i2 = 0; i2 < le; i2++) {
        d = geometry_default.distPointSegment(
          p,
          [1, dataX[hits[i2].idx1], dataY[hits[i2].idx1]],
          [1, dataX[hits[i2].idx2], dataY[hits[i2].idx2]]
        );
        if (d < tol) {
          return true;
        }
      }
      return false;
    },
    /**
     * Starting at an initial point the curve is traced with a Euler-Newton method.
     * After tracing in one direction the algorithm stops if the component is a closed loop.
     * Otherwise, the curved is traced in the opposite direction, starting from
     * the same initial point. Finally, the two components are glued together.
     *
     * @param {Array} u0 Initial point in homogenous coordinates [1, x, y].
     * @returns Array [dataX, dataY] containing a new component.
     * @private
     */
    traceComponent: function(u0) {
      var dataX = [], dataY = [], arr = [];
      arr = this.tracing(u0, 1);
      if (arr.length === 0) {
      } else {
        dataX = arr[0];
        dataY = arr[1];
      }
      if (!arr[2]) {
        arr = this.tracing(u0, -1);
        if (arr.length === 0) {
        } else {
          dataX = arr[0].reverse().concat(dataX.slice(1));
          dataY = arr[1].reverse().concat(dataY.slice(1));
        }
      }
      if (dataX.length < 6) {
        dataX.push(dataX[dataX.length - 1]);
        dataY.push(dataY[dataY.length - 1]);
      }
      return [dataX, dataY];
    },
    /**
     * Starting at a point <i>u0</i>, this routine traces the curve <i>f(u)=0</i> until
     * a loop is detected, a critical point is reached, the curve leaves the bounding box,
     * or the maximum number of points is reached.
     * <p>
     * The method is a predictor / corrector method consisting of Euler and Newton steps
     * together with step width adaption.
     * <p>
     * The algorithm is an adaption of the algorithm in
     * Eugene L. Allgower, Kurt Georg: <i>Introduction to Numerical Continuation methods.</i>
     *
     * @param {Array} u0 Starting point in homogenous coordinates  [1, x, y].
     * @param {Number} direction 1 or -1
     * @returns Array [pathX, pathY, loop_closed] or []
     * @private
     */
    tracing: function(u0, direction) {
      var u = [], v = [], v_start = [], w = [], t_u, t_v, t_u_0, A, grad, nrm, dir, steps = 0, k = 0, loop_closed = false, k0, k1, denom, dist, progress, kappa, delta, alpha, factor, point_added = false, quasi = false, cusp_or_bifurc = false, kappa_0 = this.config.kappa_0, delta_0 = this.config.delta_0, alpha_0 = this.config.alpha_0, h = this.config.h_initial, max_steps = this.config.max_steps, omega = direction, pathX = [], pathY = [], T = [], n, m, i2, e;
      u = u0.slice(1);
      pathX.push(u[0]);
      pathY.push(u[1]);
      t_u = this.tangent(u);
      if (t_u === false) {
        return [];
      }
      A = [this.dfx(u[0], u[1]), this.dfy(u[0], u[1])];
      do {
        if (quasi) {
          t_u = this.tangent_A(A);
        } else {
          t_u = this.tangent(u);
        }
        if (t_u === false) {
          u = v.slice();
          pathX.push(u[0]);
          pathY.push(u[1]);
          break;
        }
        if (pathX.length === 1) {
          t_u_0 = t_u.slice();
        } else if (pathX.length === 2) {
          T.push(pathX.length - 1);
        } else if (point_added && pathX.length > 2 && !cusp_or_bifurc) {
          dist = geometry_default.distPointSegment(
            [1, u[0], u[1]],
            [1, pathX[0], pathY[0]],
            [1, pathX[1], pathY[1]]
          );
          if (dist < this.config.loop_dist * h && math_default.innerProduct(t_u, t_u_0, 2) > this.config.loop_dir) {
            u = u0.slice(1);
            pathX.push(u[0]);
            pathY.push(u[1]);
            loop_closed = true;
            break;
          }
          if (this.config.loop_detection) {
            n = pathX.length - 1;
            m = Math.floor(math_default.log2(n));
            for (i2 = 0; i2 <= m; i2++) {
              dist = geometry_default.distPointSegment(
                [1, u[0], u[1]],
                [1, pathX[T[i2] - 1], pathY[T[i2] - 1]],
                [1, pathX[T[i2]], pathY[T[i2]]]
              );
              if (dist < this.config.loop_dist * h) {
                t_v = this.tangent([pathX[T[i2]], pathY[T[i2]]]);
                if (math_default.innerProduct(t_u, t_v, 2) > this.config.loop_dir) {
                  break;
                }
              }
            }
            if (i2 <= m) {
              loop_closed = true;
              break;
            }
            m = 1;
            e = 0;
            for (i2 = 0; i2 < 100; i2++) {
              if ((n + 1) % m !== 0) {
                break;
              }
              m *= 2;
              e++;
            }
            T[e] = n;
          }
        }
        v[0] = u[0] + h * omega * t_u[0];
        v[1] = u[1] + h * omega * t_u[1];
        if (quasi) {
          A = this.updateA(A, u, v);
          v_start = v.slice();
        }
        k = 0;
        do {
          if (quasi) {
            grad = A;
          } else {
            grad = [this.dfx(v[0], v[1]), this.dfy(v[0], v[1])];
          }
          denom = grad[0] * grad[0] + grad[1] * grad[1];
          nrm = this.f(v[0], v[1]) / denom;
          w[0] = v[0] - grad[0] * nrm;
          w[1] = v[1] - grad[1] * nrm;
          if (k === 0) {
            k0 = Math.abs(nrm) * Math.sqrt(denom);
          } else if (k === 1) {
            k1 = Math.abs(nrm) * Math.sqrt(denom);
          }
          v[0] = w[0];
          v[1] = w[1];
          k++;
        } while (k < 20 && Math.abs(this.f(v[0], v[1])) > this.config.tol_newton);
        delta = k0;
        if (k > 1) {
          kappa = k1 / k0;
        } else {
          kappa = 0;
        }
        if (quasi) {
          A = this.updateA(A, v_start, v);
          t_v = this.tangent_A(A);
        } else {
          t_v = this.tangent(v);
        }
        dir = math_default.innerProduct(t_u, t_v, 2);
        dir = Math.max(-1, Math.min(1, dir));
        alpha = Math.acos(dir);
        cusp_or_bifurc = false;
        progress = geometry_default.distance(u, v, 2);
        if (progress < this.config.tol_progress) {
          u = v.slice();
          pathX.push(u[0]);
          pathY.push(u[1]);
          break;
        } else if (dir < 0) {
          if (h > this.config.h_critical) {
          } else {
            cusp_or_bifurc = true;
            if (this.isBifurcation(u, this.config.tol_cusp)) {
              omega *= -1;
              alpha = 0;
            } else {
              u = v.slice();
              pathX.push(u[0]);
              pathY.push(u[1]);
              break;
            }
          }
        }
        if (!cusp_or_bifurc) {
          factor = Math.max(
            Math.sqrt(kappa / kappa_0),
            Math.sqrt(delta / delta_0),
            alpha / alpha_0
          );
          if (isNaN(factor)) {
            factor = 1;
          }
          factor = Math.max(Math.min(factor, 2), 0.5);
          h /= factor;
          h = Math.min(this.config.h_max, h);
          if (factor >= 2) {
            steps++;
            if (steps >= 3 * max_steps) {
              break;
            }
            point_added = false;
            continue;
          }
        }
        u = v.slice();
        pathX.push(u[0]);
        pathY.push(u[1]);
        point_added = true;
        steps++;
      } while (steps < max_steps && u[0] >= this.bbox[0] && u[1] <= this.bbox[1] && u[0] <= this.bbox[2] && u[1] >= this.bbox[3]);
      return [pathX, pathY, loop_closed];
    },
    /**
     * If both eigenvalues of the Hessian are different from zero, the critical point at u
     * is a simple bifurcation point.
     *
     * @param {Array} u Critical point [x, y]
     * @param {Number} tol Tolerance of the eigenvalues to be zero.
     * @returns Boolean True if the point is a simple bifurcation point.
     * @private
     */
    isBifurcation: function(u, tol) {
      var h = math_default.eps * math_default.eps * 100, x, y, a, b, c, d, ad, lbda1, lbda2, dis;
      x = u[0];
      y = u[1];
      a = 0.5 * (this.dfx(x + h, y) - this.dfx(x - h, y)) / h;
      b = 0.5 * (this.dfx(x, y + h) - this.dfx(x, y - h)) / h;
      c = 0.5 * (this.dfy(x + h, y) - this.dfy(x - h, y)) / h;
      d = 0.5 * (this.dfy(x, y + h) - this.dfy(x, y - h)) / h;
      ad = a + d;
      dis = ad * ad - 4 * (a * d - b * c);
      lbda1 = 0.5 * (ad + Math.sqrt(dis));
      lbda2 = 0.5 * (ad - Math.sqrt(dis));
      if (Math.abs(lbda1) > tol && Math.abs(lbda2) > tol) {
        return true;
      }
      return false;
    },
    /**
     * Search in an arc around a critical point for a further point on the curve.
     * Unused for the moment.
     *
     * @param {Array} u Critical point [x, y]
     * @param {Array} t_u Tangent at u
     * @param {Number} r Radius
     * @param {Number} omega angle
     * @returns {Array} Coordinates [x, y] of a new point.
     * @private
     */
    handleCriticalPoint: function(u, t_u, r, omega) {
      var a = Math.atan2(omega * t_u[1], omega * t_u[0]), f_circ = function(t) {
        var x2 = u[0] + r * Math.cos(t), y2 = u[1] + r * Math.sin(t);
        return this.f(x2, y2);
      }, x, y, t0;
      t0 = numerics_default.root(f_circ, a);
      x = u[0] + r * Math.cos(t0);
      y = u[1] + r * Math.sin(t0);
      return [x, y];
    },
    /**
     * Quasi-Newton update of the Moore-Penrose inverse.
     * See (7.2.3) in Allgower, Georg.
     *
     * @param {Array} A
     * @param {Array} u0
     * @param {Array} u1
     * @returns Array
     * @private
     */
    updateA: function(A, u0, u1) {
      var s = [u1[0] - u0[0], u1[1] - u0[1]], y = this.f(u1[0], u1[1]) - this.f(u0[0], u0[1]), nom, denom;
      denom = s[0] * s[0] + s[1] * s[1];
      nom = y - (A[0] * s[0] + A[1] * s[1]);
      nom /= denom;
      A[0] += nom * s[0];
      A[1] += nom * s[1];
      return A;
    },
    /**
     * Approximate tangent (of norm 1) with Quasi-Newton method
     * @param {Array} A
     * @returns Array
     * @private
     */
    tangent_A: function(A) {
      var t = [-A[1], A[0]], nrm = math_default.norm(t, 2);
      if (nrm < math_default.eps) {
      }
      return [t[0] / nrm, t[1] / nrm];
    },
    /**
     * Tangent of norm 1 at point u.
     * @param {Array} u Point [x, y]
     * @returns Array
     * @private
     */
    tangent: function(u) {
      var t = [-this.dfy(u[0], u[1]), this.dfx(u[0], u[1])], nrm = math_default.norm(t, 2);
      if (nrm < math_default.eps * math_default.eps) {
        return false;
      }
      return [t[0] / nrm, t[1] / nrm];
    }
  }
);
var implicitplot_default = math_default.ImplicitPlot;

// node_modules/jsxgraph/src/math/metapost.js
math_default.Metapost = {
  MP_ENDPOINT: 0,
  MP_EXPLICIT: 1,
  MP_GIVEN: 2,
  MP_CURL: 3,
  MP_OPEN: 4,
  MP_END_CYCLE: 5,
  UNITY: 1,
  // two: 2,
  // fraction_half: 0.5,
  FRACTION_ONE: 1,
  FRACTION_THREE: 3,
  ONE_EIGHTY_DEG: Math.PI,
  THREE_SIXTY_DEG: 2 * Math.PI,
  // EPSILON: 1e-5,
  EPS_SQ: 1e-5 * 1e-5,
  /**
   * @private
   */
  make_choices: function(knots) {
    var dely, h, k, delx, n, q, p, s, cosine, t, sine, delta_x, delta_y, delta, psi, endless = true;
    p = knots[0];
    do {
      if (!p) {
        break;
      }
      q = p.next;
      if (p.rtype > this.MP_EXPLICIT && (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y) < this.EPS_SQ) {
        p.rtype = this.MP_EXPLICIT;
        if (p.ltype === this.MP_OPEN) {
          p.ltype = this.MP_CURL;
          p.set_left_curl(this.UNITY);
        }
        q.ltype = this.MP_EXPLICIT;
        if (q.rtype === this.MP_OPEN) {
          q.rtype = this.MP_CURL;
          q.set_right_curl(this.UNITY);
        }
        p.rx = p.x;
        q.lx = p.x;
        p.ry = p.y;
        q.ly = p.y;
      }
      p = q;
    } while (p !== knots[0]);
    h = knots[0];
    while (endless) {
      if (h.ltype !== this.MP_OPEN || h.rtype !== this.MP_OPEN) {
        break;
      }
      h = h.next;
      if (h === knots[0]) {
        h.ltype = this.MP_END_CYCLE;
        break;
      }
    }
    p = h;
    while (endless) {
      if (!p) {
        break;
      }
      q = p.next;
      if (p.rtype >= this.MP_GIVEN) {
        while (q.ltype === this.MP_OPEN && q.rtype === this.MP_OPEN) {
          q = q.next;
        }
        k = 0;
        s = p;
        n = knots.length;
        delta_x = [];
        delta_y = [];
        delta = [];
        psi = [null];
        while (endless) {
          t = s.next;
          delta_x.push(t.x - s.x);
          delta_y.push(t.y - s.y);
          delta.push(this.mp_pyth_add(delta_x[k], delta_y[k]));
          if (k > 0) {
            sine = delta_y[k - 1] / delta[k - 1];
            cosine = delta_x[k - 1] / delta[k - 1];
            psi.push(
              Math.atan2(
                delta_y[k] * cosine - delta_x[k] * sine,
                delta_x[k] * cosine + delta_y[k] * sine
              )
            );
          }
          k++;
          s = t;
          if (s === q) {
            n = k;
          }
          if (k >= n && s.ltype !== this.MP_END_CYCLE) {
            break;
          }
        }
        if (k === n) {
          psi.push(0);
        } else {
          psi.push(psi[1]);
        }
        if (q.ltype === this.MP_OPEN) {
          delx = q.rx - q.x;
          dely = q.ry - q.y;
          if (delx * delx + dely * dely < this.EPS_SQ) {
            q.ltype = this.MP_CURL;
            q.set_left_curl(this.UNITY);
          } else {
            q.ltype = this.MP_GIVEN;
            q.set_left_given(Math.atan2(dely, delx));
          }
        }
        if (p.rtype === this.MP_OPEN && p.ltype === this.MP_EXPLICIT) {
          delx = p.x - p.lx;
          dely = p.y - p.ly;
          if (delx * delx + dely * dely < this.EPS_SQ) {
            p.rtype = this.MP_CURL;
            p.set_right_curl(this.UNITY);
          } else {
            p.rtype = this.MP_GIVEN;
            p.set_right_given(Math.atan2(dely, delx));
          }
        }
        this.mp_solve_choices(p, q, n, delta_x, delta_y, delta, psi);
      } else if (p.rtype === this.MP_ENDPOINT) {
        p.rx = p.x;
        p.ry = p.y;
        q.lx = q.x;
        q.ly = q.y;
      }
      p = q;
      if (p === h) {
        break;
      }
    }
  },
  /**
   * Implements solve_choices form metapost
   * MP 305
   * @private
   */
  mp_solve_choices: function(p, q, n, delta_x, delta_y, delta, psi) {
    var aa, acc, vv, bb, ldelta, ee, k, s, ww, uu, lt, r, t, ff, theta, rt, dd, cc, ct_st, ct, st, cf_sf, cf, sf, i2, k_idx, endless = true;
    ldelta = delta.length + 1;
    uu = new Array(ldelta);
    ww = new Array(ldelta);
    vv = new Array(ldelta);
    theta = new Array(ldelta);
    for (i2 = 0; i2 < ldelta; i2++) {
      theta[i2] = vv[i2] = ww[i2] = uu[i2] = 0;
    }
    k = 0;
    s = p;
    r = 0;
    while (endless) {
      t = s.next;
      if (k === 0) {
        if (s.rtype === this.MP_GIVEN) {
          if (t.ltype === this.MP_GIVEN) {
            aa = Math.atan2(delta_y[0], delta_x[0]);
            ct_st = this.mp_n_sin_cos(p.right_given() - aa);
            ct = ct_st[0];
            st = ct_st[1];
            cf_sf = this.mp_n_sin_cos(q.left_given() - aa);
            cf = cf_sf[0];
            sf = cf_sf[1];
            this.mp_set_controls(p, q, delta_x[0], delta_y[0], st, ct, -sf, cf);
            return;
          }
          vv[0] = s.right_given() - Math.atan2(delta_y[0], delta_x[0]);
          vv[0] = this.reduce_angle(vv[0]);
          uu[0] = 0;
          ww[0] = 0;
        } else if (s.rtype === this.MP_CURL) {
          if (t.ltype === this.MP_CURL) {
            p.rtype = this.MP_EXPLICIT;
            q.ltype = this.MP_EXPLICIT;
            lt = Math.abs(q.left_tension());
            rt = Math.abs(p.right_tension());
            ff = this.UNITY / (3 * rt);
            p.rx = p.x + delta_x[0] * ff;
            p.ry = p.y + delta_y[0] * ff;
            ff = this.UNITY / (3 * lt);
            q.lx = q.x - delta_x[0] * ff;
            q.ly = q.y - delta_y[0] * ff;
            return;
          }
          cc = s.right_curl();
          lt = Math.abs(t.left_tension());
          rt = Math.abs(s.right_tension());
          uu[0] = this.mp_curl_ratio(cc, rt, lt);
          vv[0] = -psi[1] * uu[0];
          ww[0] = 0;
        } else {
          if (s.rtype === this.MP_OPEN) {
            uu[0] = 0;
            vv[0] = 0;
            ww[0] = this.FRACTION_ONE;
          }
        }
      } else {
        if (s.ltype === this.MP_END_CYCLE || s.ltype === this.MP_OPEN) {
          aa = this.UNITY / (3 * Math.abs(r.right_tension()) - this.UNITY);
          dd = delta[k] * (this.FRACTION_THREE - this.UNITY / Math.abs(r.right_tension()));
          bb = this.UNITY / (3 * Math.abs(t.left_tension()) - this.UNITY);
          ee = delta[k - 1] * (this.FRACTION_THREE - this.UNITY / Math.abs(t.left_tension()));
          cc = this.FRACTION_ONE - uu[k - 1] * aa;
          dd = dd * cc;
          lt = Math.abs(s.left_tension());
          rt = Math.abs(s.right_tension());
          if (lt < rt) {
            dd *= Math.pow(lt / rt, 2);
          } else {
            if (lt > rt) {
              ee *= Math.pow(rt / lt, 2);
            }
          }
          ff = ee / (ee + dd);
          uu[k] = ff * bb;
          acc = -psi[k + 1] * uu[k];
          if (r.rtype === this.MP_CURL) {
            ww[k] = 0;
            vv[k] = acc - psi[1] * (this.FRACTION_ONE - ff);
          } else {
            ff = (this.FRACTION_ONE - ff) / cc;
            acc = acc - psi[k] * ff;
            ff = ff * aa;
            vv[k] = acc - vv[k - 1] * ff;
            ww[k] = -ww[k - 1] * ff;
          }
          if (s.ltype === this.MP_END_CYCLE) {
            aa = 0;
            bb = this.FRACTION_ONE;
            while (endless) {
              k -= 1;
              if (k === 0) {
                k = n;
              }
              aa = vv[k] - aa * uu[k];
              bb = ww[k] - bb * uu[k];
              if (k === n) {
                break;
              }
            }
            aa = aa / (this.FRACTION_ONE - bb);
            theta[n] = aa;
            vv[0] = aa;
            for (k_idx = 1; k_idx < n; k_idx++) {
              vv[k_idx] = vv[k_idx] + aa * ww[k_idx];
            }
            break;
          }
        } else {
          if (s.ltype === this.MP_CURL) {
            cc = s.left_curl();
            lt = Math.abs(s.left_tension());
            rt = Math.abs(r.right_tension());
            ff = this.mp_curl_ratio(cc, lt, rt);
            theta[n] = -(vv[n - 1] * ff) / (this.FRACTION_ONE - ff * uu[n - 1]);
            break;
          }
          if (s.ltype === this.MP_GIVEN) {
            theta[n] = s.left_given() - Math.atan2(delta_y[n - 1], delta_x[n - 1]);
            theta[n] = this.reduce_angle(theta[n]);
            break;
          }
        }
      }
      r = s;
      s = t;
      k += 1;
    }
    for (k = n - 1; k > -1; k--) {
      theta[k] = vv[k] - theta[k + 1] * uu[k];
    }
    s = p;
    k = 0;
    while (endless) {
      t = s.next;
      ct_st = this.mp_n_sin_cos(theta[k]);
      ct = ct_st[0];
      st = ct_st[1];
      cf_sf = this.mp_n_sin_cos(-psi[k + 1] - theta[k + 1]);
      cf = cf_sf[0];
      sf = cf_sf[1];
      this.mp_set_controls(s, t, delta_x[k], delta_y[k], st, ct, sf, cf);
      k++;
      s = t;
      if (k === n) {
        break;
      }
    }
  },
  /**
   * @private
   */
  mp_n_sin_cos: function(z) {
    return [Math.cos(z), Math.sin(z)];
  },
  /**
   * @private
   */
  mp_set_controls: function(p, q, delta_x, delta_y, st, ct, sf, cf) {
    var rt, ss, lt, sine, rr;
    lt = Math.abs(q.left_tension());
    rt = Math.abs(p.right_tension());
    rr = this.mp_velocity(st, ct, sf, cf, rt);
    ss = this.mp_velocity(sf, cf, st, ct, lt);
    if (p.right_tension() < 0 || q.left_tension() < 0) {
      if (st >= 0 && sf >= 0 || st <= 0 && sf <= 0) {
        sine = Math.abs(st) * cf + Math.abs(sf) * ct;
        if (sine > 0) {
          sine *= 1.00024414062;
          if (p.right_tension() < 0) {
            if (this.mp_ab_vs_cd(Math.abs(sf), this.FRACTION_ONE, rr, sine) < 0) {
              rr = Math.abs(sf) / sine;
            }
          }
          if (q.left_tension() < 0) {
            if (this.mp_ab_vs_cd(Math.abs(st), this.FRACTION_ONE, ss, sine) < 0) {
              ss = Math.abs(st) / sine;
            }
          }
        }
      }
    }
    p.rx = p.x + (delta_x * ct - delta_y * st) * rr;
    p.ry = p.y + (delta_y * ct + delta_x * st) * rr;
    q.lx = q.x - (delta_x * cf + delta_y * sf) * ss;
    q.ly = q.y - (delta_y * cf - delta_x * sf) * ss;
    p.rtype = this.MP_EXPLICIT;
    q.ltype = this.MP_EXPLICIT;
  },
  /**
   * @private
   */
  mp_pyth_add: function(a, b) {
    return math_default.hypot(a, b);
  },
  /**
   *
   * @private
   */
  mp_curl_ratio: function(gamma, a_tension, b_tension) {
    var alpha = 1 / a_tension, beta = 1 / b_tension;
    return Math.min(
      4,
      ((3 - alpha) * alpha * alpha * gamma + beta * beta * beta) / (alpha * alpha * alpha * gamma + (3 - beta) * beta * beta)
    );
  },
  /**
   * @private
   */
  mp_ab_vs_cd: function(a, b, c, d) {
    if (a * b === c * d) {
      return 0;
    }
    if (a * b > c * d) {
      return 1;
    }
    return -1;
  },
  /**
   * @private
   */
  mp_velocity: function(st, ct, sf, cf, t) {
    return Math.min(
      4,
      (2 + Math.sqrt(2) * (st - sf / 16) * (sf - st / 16) * (ct - cf)) / (1.5 * t * (2 + (Math.sqrt(5) - 1) * ct + (3 - Math.sqrt(5)) * cf))
    );
  },
  /**
   * @private
   * @param {Number} A
   */
  reduce_angle: function(A) {
    if (Math.abs(A) > this.ONE_EIGHTY_DEG) {
      if (A > 0) {
        A -= this.THREE_SIXTY_DEG;
      } else {
        A += this.THREE_SIXTY_DEG;
      }
    }
    return A;
  },
  /**
   *
   * @private
   * @param {Array} p
   * @param {Number} tension
   * @param {Boolean} cycle
   */
  makeknots: function(p, tension) {
    var i2, len, knots = [];
    len = p.length;
    for (i2 = 0; i2 < len; i2++) {
      knots.push({
        x: p[i2][0],
        y: p[i2][1],
        ltype: this.MP_OPEN,
        rtype: this.MP_OPEN,
        lx: false,
        rx: false,
        ly: tension,
        ry: tension,
        left_curl: function() {
          return this.lx || 0;
        },
        right_curl: function() {
          return this.rx || 0;
        },
        left_tension: function() {
          return this.ly || 1;
        },
        right_tension: function() {
          return this.ry || 1;
        },
        set_right_curl: function(v) {
          this.rx = v || 0;
        },
        set_left_curl: function(v) {
          this.lx = v || 0;
        }
      });
    }
    len = knots.length;
    for (i2 = 0; i2 < len; i2++) {
      knots[i2].next = knots[i2 + 1] || knots[i2];
      knots[i2].set_right_given = knots[i2].set_right_curl;
      knots[i2].set_left_given = knots[i2].set_left_curl;
      knots[i2].right_given = knots[i2].right_curl;
      knots[i2].left_given = knots[i2].left_curl;
    }
    knots[len - 1].next = knots[0];
    return knots;
  },
  /**
   *
   * @param {Array} point_list
   * @param {Object} controls
   *
   * @returns {Array}
   */
  curve: function(point_list, controls) {
    var knots, len, i2, ii, val, obj, isClosed = false, x = [], y = [];
    controls = controls || {
      tension: 1,
      direction: {},
      curl: {},
      isClosed: false
    };
    val = 1;
    if (controls.hasOwnProperty("tension")) {
      val = type_default.evaluate(controls.tension);
    }
    knots = this.makeknots(point_list, val);
    len = knots.length;
    if (type_default.exists(controls.isClosed) && type_default.evaluate(controls.isClosed)) {
      isClosed = true;
    }
    if (!isClosed) {
      knots[0].ltype = this.MP_ENDPOINT;
      knots[0].rtype = this.MP_CURL;
      knots[len - 1].rtype = this.MP_ENDPOINT;
      knots[len - 1].ltype = this.MP_CURL;
    }
    for (ii in controls) {
      if (controls.hasOwnProperty(ii)) {
        i2 = parseInt(ii, 10);
        if (isNaN(i2) || i2 < 0 || i2 >= len) {
          continue;
        }
        obj = controls[i2];
        if (type_default.exists(obj.type)) {
          switch (obj.type) {
            case "curl":
              val = type_default.evaluate(obj.curl);
              if (i2 === 0) {
                knots[i2].rtype = this.MP_CURL;
                knots[i2].set_right_curl(val);
              } else if (i2 === len - 1) {
                knots[i2].ltype = this.MP_CURL;
                knots[i2].set_left_curl(val);
              } else {
                knots[i2].ltype = this.MP_CURL;
                knots[i2].rtype = this.MP_CURL;
                knots[i2].lx = val;
                knots[i2].rx = val;
              }
              break;
          }
        }
        if (type_default.exists(obj.direction)) {
          val = type_default.evaluate(obj.direction);
          if (type_default.isArray(val)) {
            if (val[0] !== false) {
              knots[i2].lx = val[0] * Math.PI / 180;
              knots[i2].ltype = this.MP_GIVEN;
            }
            if (val[1] !== false) {
              knots[i2].rx = val[1] * Math.PI / 180;
              knots[i2].rtype = this.MP_GIVEN;
            }
          } else {
            knots[i2].lx = val * Math.PI / 180;
            knots[i2].rx = val * Math.PI / 180;
            knots[i2].ltype = knots[i2].rtype = this.MP_GIVEN;
          }
        }
        if (type_default.exists(obj.tension)) {
          val = type_default.evaluate(obj.tension);
          if (type_default.isArray(val)) {
            if (val[0] !== false) {
              knots[i2].ly = type_default.evaluate(val[0]);
            }
            if (val[1] !== false) {
              knots[i2].ry = type_default.evaluate(val[1]);
            }
          } else {
            knots[i2].ly = val;
            knots[i2].ry = val;
          }
        }
      }
    }
    this.make_choices(knots);
    for (i2 = 0; i2 < len - 1; i2++) {
      x.push(knots[i2].x);
      x.push(knots[i2].rx);
      x.push(knots[i2 + 1].lx);
      y.push(knots[i2].y);
      y.push(knots[i2].ry);
      y.push(knots[i2 + 1].ly);
    }
    x.push(knots[len - 1].x);
    y.push(knots[len - 1].y);
    if (isClosed) {
      x.push(knots[len - 1].rx);
      y.push(knots[len - 1].ry);
      x.push(knots[0].lx);
      y.push(knots[0].ly);
      x.push(knots[0].x);
      y.push(knots[0].y);
    }
    return [x, y];
  }
};
var metapost_default = math_default.Metapost;

// node_modules/jsxgraph/src/utils/zip.js
var bitReverse = [
  0,
  128,
  64,
  192,
  32,
  160,
  96,
  224,
  16,
  144,
  80,
  208,
  48,
  176,
  112,
  240,
  8,
  136,
  72,
  200,
  40,
  168,
  104,
  232,
  24,
  152,
  88,
  216,
  56,
  184,
  120,
  248,
  4,
  132,
  68,
  196,
  36,
  164,
  100,
  228,
  20,
  148,
  84,
  212,
  52,
  180,
  116,
  244,
  12,
  140,
  76,
  204,
  44,
  172,
  108,
  236,
  28,
  156,
  92,
  220,
  60,
  188,
  124,
  252,
  2,
  130,
  66,
  194,
  34,
  162,
  98,
  226,
  18,
  146,
  82,
  210,
  50,
  178,
  114,
  242,
  10,
  138,
  74,
  202,
  42,
  170,
  106,
  234,
  26,
  154,
  90,
  218,
  58,
  186,
  122,
  250,
  6,
  134,
  70,
  198,
  38,
  166,
  102,
  230,
  22,
  150,
  86,
  214,
  54,
  182,
  118,
  246,
  14,
  142,
  78,
  206,
  46,
  174,
  110,
  238,
  30,
  158,
  94,
  222,
  62,
  190,
  126,
  254,
  1,
  129,
  65,
  193,
  33,
  161,
  97,
  225,
  17,
  145,
  81,
  209,
  49,
  177,
  113,
  241,
  9,
  137,
  73,
  201,
  41,
  169,
  105,
  233,
  25,
  153,
  89,
  217,
  57,
  185,
  121,
  249,
  5,
  133,
  69,
  197,
  37,
  165,
  101,
  229,
  21,
  149,
  85,
  213,
  53,
  181,
  117,
  245,
  13,
  141,
  77,
  205,
  45,
  173,
  109,
  237,
  29,
  157,
  93,
  221,
  61,
  189,
  125,
  253,
  3,
  131,
  67,
  195,
  35,
  163,
  99,
  227,
  19,
  147,
  83,
  211,
  51,
  179,
  115,
  243,
  11,
  139,
  75,
  203,
  43,
  171,
  107,
  235,
  27,
  155,
  91,
  219,
  59,
  187,
  123,
  251,
  7,
  135,
  71,
  199,
  39,
  167,
  103,
  231,
  23,
  151,
  87,
  215,
  55,
  183,
  119,
  247,
  15,
  143,
  79,
  207,
  47,
  175,
  111,
  239,
  31,
  159,
  95,
  223,
  63,
  191,
  127,
  255
];
var cplens = [
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var cplext = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  99,
  99
];
var cpdist = [
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577
];
var cpdext = [
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13
];
var border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var NAMEMAX = 256;
jxg_default.Util = jxg_default.Util || {};
jxg_default.Util.Unzip = function(barray) {
  var gpflags, fileout, flens, fmax, outputArr = [], files = 0, unzipped = [], buf32k = new Array(32768), bIdx = 0, modeZIP = false, barraylen = barray.length, bytepos = 0, bb = 1, literalTree = new Array(288), distanceTree = new Array(32), treepos = 0, Places = null, len = 0, fpos = new Array(17), nameBuf = [];
  fpos[0] = 0;
  function readByte() {
    if (bytepos < barraylen) {
      return barray[bytepos++];
    }
    return -1;
  }
  function byteAlign() {
    bb = 1;
  }
  function readBit() {
    var carry;
    try {
      carry = bb & 1;
      bb >>= 1;
      if (bb === 0) {
        bb = readByte();
        carry = bb & 1;
        bb = bb >> 1 | 128;
      }
    } catch (e) {
      console.log("Probably problems on iOS7 with >>");
      throw e;
    }
    return carry;
  }
  function readBits(a) {
    var res = 0, i2 = a;
    try {
      while (i2--) {
        res = res << 1 | readBit();
      }
      if (a) {
        res = bitReverse[res] >> 8 - a;
      }
    } catch (e) {
      console.log("Probably problems on iOS7 with >>");
      throw e;
    }
    return res;
  }
  function flushBuffer() {
    bIdx = 0;
  }
  function addBuffer(a) {
    buf32k[bIdx++] = a;
    outputArr.push(String.fromCharCode(a));
    if (bIdx === 32768) {
      bIdx = 0;
    }
  }
  function HufNode() {
    this.b0 = 0;
    this.b1 = 0;
    this.jump = null;
    this.jumppos = -1;
  }
  function isPat() {
    var endless = true;
    while (endless) {
      if (fpos[len] >= fmax) {
        return -1;
      }
      if (flens[fpos[len]] === len) {
        return fpos[len]++;
      }
      fpos[len]++;
    }
  }
  function rec() {
    var curplace = Places[treepos], tmp;
    if (len === 17) {
      return -1;
    }
    treepos++;
    len++;
    tmp = isPat();
    if (tmp >= 0) {
      curplace.b0 = tmp;
    } else {
      curplace.b0 = 32768;
      if (rec()) {
        return -1;
      }
    }
    tmp = isPat();
    if (tmp >= 0) {
      curplace.b1 = tmp;
      curplace.jump = null;
    } else {
      curplace.b1 = 32768;
      curplace.jump = Places[treepos];
      curplace.jumppos = treepos;
      if (rec()) {
        return -1;
      }
    }
    len--;
    return 0;
  }
  function createTree(currentTree, numval, lengths, show) {
    var i2;
    Places = currentTree;
    treepos = 0;
    flens = lengths;
    fmax = numval;
    for (i2 = 0; i2 < 17; i2++) {
      fpos[i2] = 0;
    }
    len = 0;
    if (rec()) {
      return -1;
    }
    return 0;
  }
  function decodeValue(currentTree) {
    var len2, i2, b, endless = true, xtreepos = 0, X = currentTree[xtreepos];
    while (endless) {
      b = readBit();
      if (b) {
        if (!(X.b1 & 32768)) {
          return X.b1;
        }
        X = X.jump;
        len2 = currentTree.length;
        for (i2 = 0; i2 < len2; i2++) {
          if (currentTree[i2] === X) {
            xtreepos = i2;
            break;
          }
        }
      } else {
        if (!(X.b0 & 32768)) {
          return X.b0;
        }
        xtreepos++;
        X = currentTree[xtreepos];
      }
    }
  }
  function deflateLoop() {
    var last, c, type, i2, j, l, ll, ll2, len2, blockLen, dist, cSum, n, literalCodes, distCodes, lenCodes, endless = true;
    do {
      last = readBit();
      type = readBits(2);
      if (type === 0) {
        byteAlign();
        blockLen = readByte();
        blockLen |= readByte() << 8;
        cSum = readByte();
        cSum |= readByte() << 8;
        if ((blockLen ^ ~cSum) & 65535) {
          jxg_default.debug("BlockLen checksum mismatch\n");
        }
        while (blockLen--) {
          c = readByte();
          addBuffer(c);
        }
      } else if (type === 1) {
        while (endless) {
          j = bitReverse[readBits(7)] >> 1;
          if (j > 23) {
            j = j << 1 | readBit();
            if (j > 199) {
              j -= 128;
              j = j << 1 | readBit();
            } else {
              j -= 48;
              if (j > 143) {
                j = j + 136;
              }
            }
          } else {
            j += 256;
          }
          if (j < 256) {
            addBuffer(j);
          } else if (j === 256) {
            break;
          } else {
            j -= 256 + 1;
            len2 = readBits(cplext[j]) + cplens[j];
            j = bitReverse[readBits(5)] >> 3;
            if (cpdext[j] > 8) {
              dist = readBits(8);
              dist |= readBits(cpdext[j] - 8) << 8;
            } else {
              dist = readBits(cpdext[j]);
            }
            dist += cpdist[j];
            for (j = 0; j < len2; j++) {
              c = buf32k[bIdx - dist & 32767];
              addBuffer(c);
            }
          }
        }
      } else if (type === 2) {
        ll = new Array(288 + 32);
        literalCodes = 257 + readBits(5);
        distCodes = 1 + readBits(5);
        lenCodes = 4 + readBits(4);
        for (j = 0; j < 19; j++) {
          ll[j] = 0;
        }
        for (j = 0; j < lenCodes; j++) {
          ll[border[j]] = readBits(3);
        }
        len2 = distanceTree.length;
        for (i2 = 0; i2 < len2; i2++) {
          distanceTree[i2] = new HufNode();
        }
        if (createTree(distanceTree, 19, ll, 0)) {
          flushBuffer();
          return 1;
        }
        n = literalCodes + distCodes;
        i2 = 0;
        while (i2 < n) {
          j = decodeValue(distanceTree);
          if (j < 16) {
            ll[i2++] = j;
          } else if (j === 16) {
            j = 3 + readBits(2);
            if (i2 + j > n) {
              flushBuffer();
              return 1;
            }
            l = i2 ? ll[i2 - 1] : 0;
            while (j--) {
              ll[i2++] = l;
            }
          } else {
            if (j === 17) {
              j = 3 + readBits(3);
            } else {
              j = 11 + readBits(7);
            }
            if (i2 + j > n) {
              flushBuffer();
              return 1;
            }
            while (j--) {
              ll[i2++] = 0;
            }
          }
        }
        len2 = literalTree.length;
        for (i2 = 0; i2 < len2; i2++) {
          literalTree[i2] = new HufNode();
        }
        if (createTree(literalTree, literalCodes, ll, 0)) {
          flushBuffer();
          return 1;
        }
        len2 = literalTree.length;
        for (i2 = 0; i2 < len2; i2++) {
          distanceTree[i2] = new HufNode();
        }
        ll2 = [];
        for (i2 = literalCodes; i2 < ll.length; i2++) {
          ll2[i2 - literalCodes] = ll[i2];
        }
        if (createTree(distanceTree, distCodes, ll2, 0)) {
          flushBuffer();
          return 1;
        }
        while (endless) {
          j = decodeValue(literalTree);
          if (j >= 256) {
            j -= 256;
            if (j === 0) {
              break;
            }
            j -= 1;
            len2 = readBits(cplext[j]) + cplens[j];
            j = decodeValue(distanceTree);
            if (cpdext[j] > 8) {
              dist = readBits(8);
              dist |= readBits(cpdext[j] - 8) << 8;
            } else {
              dist = readBits(cpdext[j]);
            }
            dist += cpdist[j];
            while (len2--) {
              c = buf32k[bIdx - dist & 32767];
              addBuffer(c);
            }
          } else {
            addBuffer(j);
          }
        }
      }
    } while (!last);
    flushBuffer();
    byteAlign();
    return 0;
  }
  function nextFile() {
    var i2, c, extralen, filelen, size2, compSize, crc, method, tmp = [];
    try {
      outputArr = [];
      modeZIP = false;
      tmp[0] = readByte();
      tmp[1] = readByte();
      if (tmp[0] === 120 && tmp[1] === 218) {
        deflateLoop();
        unzipped[files] = [outputArr.join(""), "geonext.gxt"];
        files++;
      }
      if (tmp[0] === 31 && tmp[1] === 139) {
        skipdir();
        unzipped[files] = [outputArr.join(""), "file"];
        files++;
      }
      if (tmp[0] === 80 && tmp[1] === 75) {
        modeZIP = true;
        tmp[2] = readByte();
        tmp[3] = readByte();
        if (tmp[2] === 3 && tmp[3] === 4) {
          tmp[0] = readByte();
          tmp[1] = readByte();
          gpflags = readByte();
          gpflags |= readByte() << 8;
          method = readByte();
          method |= readByte() << 8;
          readByte();
          readByte();
          readByte();
          readByte();
          crc = readByte();
          crc |= readByte() << 8;
          crc |= readByte() << 16;
          crc |= readByte() << 24;
          compSize = readByte();
          compSize |= readByte() << 8;
          compSize |= readByte() << 16;
          compSize |= readByte() << 24;
          size2 = readByte();
          size2 |= readByte() << 8;
          size2 |= readByte() << 16;
          size2 |= readByte() << 24;
          filelen = readByte();
          filelen |= readByte() << 8;
          extralen = readByte();
          extralen |= readByte() << 8;
          i2 = 0;
          nameBuf = [];
          while (filelen--) {
            c = readByte();
            if (c === "/" | c === ":") {
              i2 = 0;
            } else if (i2 < NAMEMAX - 1) {
              nameBuf[i2++] = String.fromCharCode(c);
            }
          }
          if (!fileout) {
            fileout = nameBuf;
          }
          i2 = 0;
          while (i2 < extralen) {
            c = readByte();
            i2++;
          }
          if (method === 8) {
            deflateLoop();
            unzipped[files] = new Array(2);
            unzipped[files][0] = outputArr.join("");
            unzipped[files][1] = nameBuf.join("");
            files++;
          }
          if (skipdir()) {
            return false;
          }
        }
        return true;
      }
    } catch (e) {
      console.log("Probably problems on iOS7 with >>");
      throw e;
    }
    return false;
  }
  function skipdir() {
    var crc, compSize, size2, os, i2, c, tmp = [];
    if (gpflags & 8) {
      tmp[0] = readByte();
      tmp[1] = readByte();
      tmp[2] = readByte();
      tmp[3] = readByte();
      if (tmp[0] === 80 && tmp[1] === 75 && tmp[2] === 7 && tmp[3] === 8) {
        crc = readByte();
        crc |= readByte() << 8;
        crc |= readByte() << 16;
        crc |= readByte() << 24;
      } else {
        crc = tmp[0] | tmp[1] << 8 | tmp[2] << 16 | tmp[3] << 24;
      }
      compSize = readByte();
      compSize |= readByte() << 8;
      compSize |= readByte() << 16;
      compSize |= readByte() << 24;
      size2 = readByte();
      size2 |= readByte() << 8;
      size2 |= readByte() << 16;
      size2 |= readByte() << 24;
    }
    if (modeZIP) {
      if (nextFile()) {
        return false;
      }
    }
    tmp[0] = readByte();
    if (tmp[0] !== 8) {
      return true;
    }
    gpflags = readByte();
    readByte();
    readByte();
    readByte();
    readByte();
    readByte();
    os = readByte();
    if (gpflags & 4) {
      tmp[0] = readByte();
      tmp[2] = readByte();
      len = tmp[0] + 256 * tmp[1];
      for (i2 = 0; i2 < len; i2++) {
        readByte();
      }
    }
    if (gpflags & 8) {
      i2 = 0;
      nameBuf = [];
      c = readByte();
      while (c) {
        if (c === "7" || c === ":") {
          i2 = 0;
        }
        if (i2 < NAMEMAX - 1) {
          nameBuf[i2++] = c;
        }
        c = readByte();
      }
    }
    if (gpflags & 16) {
      c = readByte();
      while (c) {
        c = readByte();
      }
    }
    if (gpflags & 2) {
      readByte();
      readByte();
    }
    deflateLoop();
    crc = readByte();
    crc |= readByte() << 8;
    crc |= readByte() << 16;
    crc |= readByte() << 24;
    size2 = readByte();
    size2 |= readByte() << 8;
    size2 |= readByte() << 16;
    size2 |= readByte() << 24;
    if (modeZIP) {
      if (nextFile()) {
        return false;
      }
    }
    return false;
  }
  jxg_default.Util.Unzip.prototype.unzipFile = function(name) {
    var i2;
    this.unzip();
    for (i2 = 0; i2 < unzipped.length; i2++) {
      if (unzipped[i2][1] === name) {
        return unzipped[i2][0];
      }
    }
    return "";
  };
  jxg_default.Util.Unzip.prototype.unzip = function() {
    nextFile();
    return unzipped;
  };
};
var zip_default = jxg_default.Util;

// node_modules/jsxgraph/src/utils/encoding.js
var UTF8_ACCEPT = 0;
var UTF8D = [
  // The first part of the table maps bytes to character classes that
  // to reduce the size of the transition table and create bitmasks.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  10,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  4,
  3,
  3,
  11,
  6,
  6,
  6,
  5,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  // The second part is a transition table that maps a combination
  // of a state of the automaton and a character class to a state.
  0,
  12,
  24,
  36,
  60,
  96,
  84,
  12,
  12,
  12,
  48,
  72,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  0,
  12,
  12,
  12,
  12,
  12,
  0,
  12,
  0,
  12,
  12,
  12,
  24,
  12,
  12,
  12,
  12,
  12,
  24,
  12,
  24,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  24,
  12,
  12,
  12,
  12,
  12,
  24,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  24,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  36,
  12,
  36,
  12,
  12,
  12,
  36,
  12,
  12,
  12,
  12,
  12,
  36,
  12,
  36,
  12,
  12,
  12,
  36,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12
];
jxg_default.Util = jxg_default.Util || {};
jxg_default.Util.UTF8 = {
  /**
   * Encode a string to utf-8.
   * @param {String} string
   * @returns {String} utf8 encoded string
   */
  encode: function(string) {
    var n, c, utftext = "", len = string.length;
    string = string.replace(/\r\n/g, "\n");
    if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
      return unescape(encodeURIComponent(string));
    }
    for (n = 0; n < len; n++) {
      c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  },
  /**
   * Decode a string from utf-8.
   * @param {String} utftext to decode
   * @returns {String} utf8 decoded string
   */
  decode: function(utftext) {
    var i2, charCode, type, j = 0, codepoint = 0, state = UTF8_ACCEPT, chars = [], len = utftext.length, results = [];
    for (i2 = 0; i2 < len; i2++) {
      charCode = utftext.charCodeAt(i2);
      type = UTF8D[charCode];
      if (state !== UTF8_ACCEPT) {
        codepoint = charCode & 63 | codepoint << 6;
      } else {
        codepoint = 255 >> type & charCode;
      }
      state = UTF8D[256 + state + type];
      if (state === UTF8_ACCEPT) {
        if (codepoint > 65535) {
          chars.push(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        } else {
          chars.push(codepoint);
        }
        j++;
        if (j % 1e4 === 0) {
          results.push(String.fromCharCode.apply(null, chars));
          chars = [];
        }
      }
    }
    results.push(String.fromCharCode.apply(null, chars));
    return results.join("");
  },
  /**
   * Extends the standard charCodeAt() method of the String class to find the ASCII char code of
   * a character at a given position in a UTF8 encoded string.
   * @param {String} str
   * @param {Number} i position of the character
   * @returns {Number}
   */
  asciiCharCodeAt: function(str2, i2) {
    var c = str2.charCodeAt(i2);
    if (c > 255) {
      switch (c) {
        case 8364:
          c = 128;
          break;
        case 8218:
          c = 130;
          break;
        case 402:
          c = 131;
          break;
        case 8222:
          c = 132;
          break;
        case 8230:
          c = 133;
          break;
        case 8224:
          c = 134;
          break;
        case 8225:
          c = 135;
          break;
        case 710:
          c = 136;
          break;
        case 8240:
          c = 137;
          break;
        case 352:
          c = 138;
          break;
        case 8249:
          c = 139;
          break;
        case 338:
          c = 140;
          break;
        case 381:
          c = 142;
          break;
        case 8216:
          c = 145;
          break;
        case 8217:
          c = 146;
          break;
        case 8220:
          c = 147;
          break;
        case 8221:
          c = 148;
          break;
        case 8226:
          c = 149;
          break;
        case 8211:
          c = 150;
          break;
        case 8212:
          c = 151;
          break;
        case 732:
          c = 152;
          break;
        case 8482:
          c = 153;
          break;
        case 353:
          c = 154;
          break;
        case 8250:
          c = 155;
          break;
        case 339:
          c = 156;
          break;
        case 382:
          c = 158;
          break;
        case 376:
          c = 159;
          break;
        default:
          break;
      }
    }
    return c;
  }
};
var encoding_default = jxg_default.Util.UTF8;

// node_modules/jsxgraph/src/utils/base64.js
var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var pad = "=";
jxg_default.Util = jxg_default.Util || {};
jxg_default.Util.Base64 = {
  // Local helper functions
  /**
   * Extracts one byte from a string and ensures the result is less than or equal to 255.
   * @param {String} s
   * @param {Number} i
   * @returns {Number} <= 255
   * @private
   */
  _getByte: function(s, i2) {
    return s.charCodeAt(i2) & 255;
  },
  /**
   * Determines the index of a base64 character in the base64 alphabet.
   * @param {String} s
   * @param {Number} i
   * @returns {Number}
   * @throws {Error} If the character can not be found in the alphabet.
   * @private
   */
  _getIndex: function(s, i2) {
    return alphabet.indexOf(s.charAt(i2));
  },
  /**
   * Encode the given string.
   * @param {String} input
   * @returns {string} base64 encoded version of the input string.
   */
  encode: function(input) {
    var i2, bin, len, padLen, encInput, buffer = [];
    encInput = encoding_default.encode(input);
    len = encInput.length;
    padLen = len % 3;
    for (i2 = 0; i2 < len - padLen; i2 += 3) {
      bin = this._getByte(encInput, i2) << 16 | this._getByte(encInput, i2 + 1) << 8 | this._getByte(encInput, i2 + 2);
      buffer.push(
        alphabet.charAt(bin >> 18),
        alphabet.charAt(bin >> 12 & 63),
        alphabet.charAt(bin >> 6 & 63),
        alphabet.charAt(bin & 63)
      );
    }
    switch (padLen) {
      case 1:
        bin = this._getByte(encInput, len - 1);
        buffer.push(
          alphabet.charAt(bin >> 2),
          alphabet.charAt(bin << 4 & 63),
          pad,
          pad
        );
        break;
      case 2:
        bin = this._getByte(encInput, len - 2) << 8 | this._getByte(encInput, len - 1);
        buffer.push(
          alphabet.charAt(bin >> 10),
          alphabet.charAt(bin >> 4 & 63),
          alphabet.charAt(bin << 2 & 63),
          pad
        );
        break;
    }
    return buffer.join("");
  },
  /**
   * Decode from Base64
   * @param {String} input Base64 encoded data
   * @param {Boolean} utf8 In case this parameter is true {@link JXG.Util.UTF8.decode} will be applied to
   * the result of the base64 decoder.
   * @throws {Error} If the string has the wrong length.
   * @returns {String}
   */
  decode: function(input, utf8) {
    var encInput, i2, len, padLen, bin, output, result = [], buffer = [];
    encInput = input.replace(/[^A-Za-z0-9+/=]/g, "");
    len = encInput.length;
    if (len % 4 !== 0) {
      throw new Error(
        "JSXGraph/utils/base64: Can't decode string (invalid input length)."
      );
    }
    if (encInput.charAt(len - 1) === pad) {
      padLen = 1;
      if (encInput.charAt(len - 2) === pad) {
        padLen = 2;
      }
      len -= 4;
    }
    for (i2 = 0; i2 < len; i2 += 4) {
      bin = this._getIndex(encInput, i2) << 18 | this._getIndex(encInput, i2 + 1) << 12 | this._getIndex(encInput, i2 + 2) << 6 | this._getIndex(encInput, i2 + 3);
      buffer.push(bin >> 16, bin >> 8 & 255, bin & 255);
      if (i2 % 1e4 === 0) {
        result.push(String.fromCharCode.apply(null, buffer));
        buffer = [];
      }
    }
    switch (padLen) {
      case 1:
        bin = this._getIndex(encInput, len) << 12 | this._getIndex(encInput, len + 1) << 6 | this._getIndex(encInput, len + 2);
        buffer.push(bin >> 10, bin >> 2 & 255);
        break;
      case 2:
        bin = this._getIndex(encInput, i2) << 6 | this._getIndex(encInput, i2 + 1);
        buffer.push(bin >> 4);
        break;
    }
    result.push(String.fromCharCode.apply(null, buffer));
    output = result.join("");
    if (utf8) {
      output = encoding_default.decode(output);
    }
    return output;
  },
  /**
   * Decode the base64 input data as an array
   * @param {string} input
   * @returns {Array}
   */
  decodeAsArray: function(input) {
    var i2, dec = this.decode(input), ar = [], len = dec.length;
    for (i2 = 0; i2 < len; i2++) {
      ar[i2] = dec.charCodeAt(i2);
    }
    return ar;
  }
};
var base64_default = jxg_default.Util.Base64;

// node_modules/jsxgraph/src/server/server.js
jxg_default.Server = {
  /**
   * This is where all of a module's handlers are accessed from. If you're loading a module named JXGModule which
   * provides a handler called ImaHandler, then this handler can be called by invoking JXG.Server.modules.JXGModule.ImaHandler().
   * @namespace
   */
  modules: {},
  /**
   * Stores all asynchronous calls to server which aren't finished yet.
   * @private
   */
  runningCalls: {},
  /**
   * Handles errors, just a default implementation, can be overwritten by you, if you want to handle errors by yourself.
   * @param {object} data An object holding a field of type string named message handling the error described in the message string.
   */
  handleError: function(data) {
    jxg_default.debug("error occured, server says: " + data.message);
  },
  /**
   * The main method of JXG.Server. Actually makes the calls to the server and parses the feedback.
   * @param {String} action Can be 'load' or 'exec'.
   * @param {function} callback Function pointer or anonymous function which takes as it's only argument an
   * object containing the data from the server. The fields of this object depend on the reply of the server
   * module. See the correspondings server module readme.
   * @param {Object} data What is to be sent to the server.
   * @param {Boolean} sync If the call should be synchronous or not.
   */
  callServer: function(action, callback, data, sync) {
    var fileurl, passdata, AJAX, id, dataJSONStr;
    sync = sync || false;
    dataJSONStr = type_default.toJSON(data);
    do {
      id = action + Math.floor(Math.random() * 4096);
    } while (type_default.exists(this.runningCalls[id]));
    this.runningCalls[id] = { action };
    if (type_default.exists(data.module)) {
      this.runningCalls[id].module = data.module;
    }
    fileurl = jxg_default.serverBase + "JXGServer.py";
    passdata = "action=" + escape(action) + "&id=" + id + "&dataJSON=" + escape(base64_default.encode(dataJSONStr));
    this.cbp = function(d) {
      var str2, data2, tmp, inject, paramlist, id2, i2, j;
      str2 = new zip_default.Unzip(base64_default.decodeAsArray(d)).unzip();
      if (type_default.isArray(str2) && str2.length > 0) {
        str2 = str2[0][0];
      }
      if (!type_default.exists(str2)) {
        return;
      }
      data2 = window.JSON && window.JSON.parse ? window.JSON.parse(str2) : new Function("return " + str2)();
      if (data2.type === "error") {
        this.handleError(data2);
      } else if (data2.type === "response") {
        id2 = data2.id;
        for (i2 = 0; i2 < data2.fields.length; i2++) {
          tmp = data2.fields[i2];
          inject = tmp.namespace + (typeof new Function("return " + tmp.namespace)() === "object" ? "." : ".prototype.") + tmp.name + " = " + tmp.value;
          new Function(inject)();
        }
        for (i2 = 0; i2 < data2.handler.length; i2++) {
          tmp = data2.handler[i2];
          paramlist = [];
          for (j = 0; j < tmp.parameters.length; j++) {
            paramlist[j] = '"' + tmp.parameters[j] + '": ' + tmp.parameters[j];
          }
          inject = "if(typeof JXG.Server.modules." + this.runningCalls[id2].module + ' == "undefined")JXG.Server.modules.' + this.runningCalls[id2].module + " = {};";
          inject += "JXG.Server.modules." + this.runningCalls[id2].module + "." + tmp.name + "_cb = " + tmp.callback + ";";
          inject += "JXG.Server.modules." + this.runningCalls[id2].module + "." + tmp.name + " = function (" + tmp.parameters.join(",") + ', __JXGSERVER_CB__, __JXGSERVER_SYNC) {if(typeof __JXGSERVER_CB__ == "undefined") __JXGSERVER_CB__ = JXG.Server.modules.' + this.runningCalls[id2].module + "." + tmp.name + "_cb;var __JXGSERVER_PAR__ = {" + paramlist.join(",") + ', "module": "' + this.runningCalls[id2].module + '", "handler": "' + tmp.name + '" };JXG.Server.callServer("exec", __JXGSERVER_CB__, __JXGSERVER_PAR__, __JXGSERVER_SYNC);};';
          new Function(inject)();
        }
        delete this.runningCalls[id2];
        callback(data2.data);
      }
    };
    this.cb = jxg_default.bind(this.cbp, this);
    if (window.XMLHttpRequest) {
      AJAX = new XMLHttpRequest();
      AJAX.overrideMimeType("text/plain; charset=iso-8859-1");
    } else {
      AJAX = new ActiveXObject("Microsoft.XMLHTTP");
    }
    if (AJAX) {
      AJAX.open("POST", fileurl, !sync);
      AJAX.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
      if (!sync) {
        AJAX.onreadystatechange = function(cb) {
          return function() {
            if (AJAX.readyState === 4 && AJAX.status === 200) {
              cb(AJAX.responseText);
              return true;
            }
            return false;
          };
        }(this.cb);
      }
      AJAX.send(passdata);
      if (sync) {
        this.cb(AJAX.responseText);
        return true;
      }
    }
    return false;
  },
  /**
   * Callback for the default action 'load'.
   */
  loadModule_cb: function(data) {
    var i2;
    for (i2 = 0; i2 < data.length; i2++) {
      jxg_default.debug(data[i2].name + ": " + data[i2].value);
    }
  },
  /**
   * Loads a module from the server.
   * @param {string} module A string containing the module. Has to match the filename of the Python module on the server exactly including
   * lower and upper case letters without the file ending .py.
   */
  loadModule: function(module2) {
    return jxg_default.Server.callServer(
      "load",
      jxg_default.Server.loadModule_cb,
      { module: module2 },
      true
    );
  }
};
jxg_default.Server.load = jxg_default.Server.loadModule;
var server_default = jxg_default.Server;

// node_modules/jsxgraph/src/math/symbolic.js
var undef2;
math_default.Symbolic = {
  /**
   * Generates symbolic coordinates for the part of a construction including all the elements from that
   * a specific element depends of. These coordinates will be stored in GeometryElement.symbolic.
   * @param {JXG.Board} board The board that's element get some symbolic coordinates.
   * @param {JXG.GeometryElement} element All ancestor of this element get symbolic coordinates.
   * @param {String} variable Name for the coordinates, e.g. x or u.
   * @param {String} append Method for how to append the number of the coordinates. Possible values are
   *                        'underscore' (e.g. x_2), 'none' (e.g. x2), 'brace' (e.g. x[2]).
   * @returns {Number} Number of coordinates given.
   * @memberof JXG.Math.Symbolic
   */
  generateSymbolicCoordinatesPartial: function(board, element, variable, append) {
    var t_num, t, k, list2 = element.ancestors, count = 0, makeCoords = function(num) {
      var r;
      if (append === "underscore") {
        r = variable + "_{" + num + "}";
      } else if (append === "brace") {
        r = variable + "[" + num + "]";
      } else {
        r = variable + num;
      }
      return r;
    };
    board.listOfFreePoints = [];
    board.listOfDependantPoints = [];
    for (t in list2) {
      if (list2.hasOwnProperty(t)) {
        t_num = 0;
        if (type_default.isPoint(list2[t])) {
          for (k in list2[t].ancestors) {
            if (list2[t].ancestors.hasOwnProperty(k)) {
              t_num++;
            }
          }
          if (t_num === 0) {
            list2[t].symbolic.x = list2[t].coords.usrCoords[1];
            list2[t].symbolic.y = list2[t].coords.usrCoords[2];
            board.listOfFreePoints.push(list2[t]);
          } else {
            count += 1;
            list2[t].symbolic.x = makeCoords(count);
            count += 1;
            list2[t].symbolic.y = makeCoords(count);
            board.listOfDependantPoints.push(list2[t]);
          }
        }
      }
    }
    if (type_default.isPoint(element)) {
      element.symbolic.x = "x";
      element.symbolic.y = "y";
    }
    return count;
  },
  /**
   * Clears all .symbolic.x and .symbolic.y members on every point of a given board.
   * @param {JXG.Board} board The board that's points get cleared their symbolic coordinates.
   * @memberof JXG.Math.Symbolic
   */
  clearSymbolicCoordinates: function(board) {
    var clear = function(list2) {
      var t, l = list2 && list2.length || 0;
      for (t = 0; t < l; t++) {
        if (type_default.isPoint(list2[t])) {
          list2[t].symbolic.x = "";
          list2[t].symbolic.y = "";
        }
      }
    };
    clear(board.listOfFreePoints);
    clear(board.listOfDependantPoints);
    delete board.listOfFreePoints;
    delete board.listOfDependantPoints;
  },
  /**
   * Generates polynomials for a part of the construction including all the points from that
   * a specific element depends of.
   * @param {JXG.Board} board The board that's points polynomials will be generated.
   * @param {JXG.GeometryElement} element All points in the set of ancestors of this element are used to generate the set of polynomials.
   * @param {Boolean} generateCoords
   * @returns {Array} An array of polynomials as strings.
   * @memberof JXG.Math.Symbolic
   */
  generatePolynomials: function(board, element, generateCoords) {
    var t, k, i2, list2 = element.ancestors, number_of_ancestors, pgs = [], result = [];
    if (generateCoords) {
      this.generateSymbolicCoordinatesPartial(board, element, "u", "brace");
    }
    list2[element.id] = element;
    for (t in list2) {
      if (list2.hasOwnProperty(t)) {
        number_of_ancestors = 0;
        pgs = [];
        if (type_default.isPoint(list2[t])) {
          for (k in list2[t].ancestors) {
            if (list2[t].ancestors.hasOwnProperty(k)) {
              number_of_ancestors++;
            }
          }
          if (number_of_ancestors > 0) {
            pgs = list2[t].generatePolynomial();
            for (i2 = 0; i2 < pgs.length; i2++) {
              result.push(pgs[i2]);
            }
          }
        }
      }
    }
    if (generateCoords) {
      this.clearSymbolicCoordinates(board);
    }
    return result;
  },
  /**
   * Calculate geometric locus of a point given on a board. Invokes python script on server.
   * @param {JXG.Board} board The board on which the point lies.
   * @param {JXG.Point} point The point that will be traced.
   * @returns {Array} An array of points.
   * @memberof JXG.Math.Symbolic
   */
  geometricLocusByGroebnerBase: function(board, point) {
    var poly, polyStr, result, P1, P2, i2, xs, xe, ys, ye, c, s, tx, bol = board.options.locus, oldRadius = {}, numDependent = this.generateSymbolicCoordinatesPartial(board, point, "u", "brace"), xsye = new coords_default(constants_default.COORDS_BY_USR, [0, 0], board), xeys = new coords_default(
      constants_default.COORDS_BY_USR,
      [board.canvasWidth, board.canvasHeight],
      board
    ), sf = 1, transx = 0, transy = 0, rot = 0;
    if (server_default.modules.geoloci === undef2) {
      server_default.loadModule("geoloci");
    }
    if (server_default.modules.geoloci === undef2) {
      throw new Error("JSXGraph: Unable to load JXG.Server module 'geoloci.py'.");
    }
    xs = xsye.usrCoords[1];
    xe = xeys.usrCoords[1];
    ys = xeys.usrCoords[2];
    ye = xsye.usrCoords[2];
    if (bol.translateToOrigin && board.listOfFreePoints.length > 0) {
      if (bol.toOrigin !== undef2 && bol.toOrigin !== null && type_default.isInArray(board.listOfFreePoints, bol.toOrigin.id)) {
        P1 = bol.toOrigin;
      } else {
        P1 = board.listOfFreePoints[0];
      }
      transx = P1.symbolic.x;
      transy = P1.symbolic.y;
      for (i2 = 0; i2 < board.listOfFreePoints.length; i2++) {
        board.listOfFreePoints[i2].symbolic.x -= transx;
        board.listOfFreePoints[i2].symbolic.y -= transy;
      }
      xs -= transx;
      xe -= transx;
      ys -= transy;
      ye -= transy;
      if (bol.translateTo10 && board.listOfFreePoints.length > 1) {
        if (bol.to10 !== undef2 && bol.to10 !== null && bol.to10.id !== bol.toOrigin.id && type_default.isInArray(board.listOfFreePoints, bol.to10.id)) {
          P2 = bol.to10;
        } else {
          if (board.listOfFreePoints[0].id === P1.id) {
            P2 = board.listOfFreePoints[1];
          } else {
            P2 = board.listOfFreePoints[0];
          }
        }
        rot = geometry_default.rad([1, 0], [0, 0], [P2.symbolic.x, P2.symbolic.y]);
        c = Math.cos(-rot);
        s = Math.sin(-rot);
        for (i2 = 0; i2 < board.listOfFreePoints.length; i2++) {
          tx = board.listOfFreePoints[i2].symbolic.x;
          board.listOfFreePoints[i2].symbolic.x = c * board.listOfFreePoints[i2].symbolic.x - s * board.listOfFreePoints[i2].symbolic.y;
          board.listOfFreePoints[i2].symbolic.y = s * tx + c * board.listOfFreePoints[i2].symbolic.y;
        }
        P2.symbolic.y = 0;
        tx = xs;
        xs = c * xs - s * ys;
        ys = s * tx + c * ys;
        tx = xe;
        xe = c * xe - s * ye;
        ye = s * tx + c * ye;
        if (bol.stretch && Math.abs(P2.symbolic.x) > math_default.eps) {
          sf = P2.symbolic.x;
          for (i2 = 0; i2 < board.listOfFreePoints.length; i2++) {
            board.listOfFreePoints[i2].symbolic.x /= sf;
            board.listOfFreePoints[i2].symbolic.y /= sf;
          }
          for (i2 = 0; i2 < board.objectsList.length; i2++) {
            if (board.objectsList[i2].elementClass === constants_default.OBJECT_CLASS_CIRCLE && board.objectsList[i2].method === "pointRadius") {
              oldRadius[i2] = board.objectsList[i2].radius;
              board.objectsList[i2].radius /= sf;
            }
          }
          xs /= sf;
          xe /= sf;
          ys /= sf;
          ye /= sf;
          P2.symbolic.x = 1;
        }
      }
      for (i2 = 0; i2 < board.listOfFreePoints.length; i2++) {
        tx = board.listOfFreePoints[i2].symbolic.x;
        if (Math.abs(tx) < math_default.eps) {
          board.listOfFreePoints[i2].symbolic.x = 0;
        }
        if (Math.abs(tx - Math.round(tx)) < math_default.eps) {
          board.listOfFreePoints[i2].symbolic.x = Math.round(tx);
        }
        tx = board.listOfFreePoints[i2].symbolic.y;
        if (Math.abs(tx) < math_default.eps) {
          board.listOfFreePoints[i2].symbolic.y = 0;
        }
        if (Math.abs(tx - Math.round(tx)) < math_default.eps) {
          board.listOfFreePoints[i2].symbolic.y = Math.round(tx);
        }
      }
    }
    poly = this.generatePolynomials(board, point);
    polyStr = poly.join(",");
    this.cbp = function(data) {
      result = data;
    };
    this.cb = type_default.bind(this.cbp, this);
    server_default.modules.geoloci.lociCoCoA(
      xs,
      xe,
      ys,
      ye,
      numDependent,
      polyStr,
      sf,
      rot,
      transx,
      transy,
      this.cb,
      true
    );
    this.clearSymbolicCoordinates(board);
    for (i2 in oldRadius) {
      if (oldRadius.hasOwnProperty(i2)) {
        board.objects[i2].radius = oldRadius[i2];
      }
    }
    return result;
  }
};
var symbolic_default = math_default.Symbolic;

// node_modules/jsxgraph/src/math/clip.js
math_default.Clip = {
  _isSeparator: function(node2) {
    return isNaN(node2.coords.usrCoords[1]) && isNaN(node2.coords.usrCoords[2]);
  },
  /**
   * Add pointers to an array S such that it is a circular doubly-linked list.
   *
   * @private
   * @param  {Array} S Array
   * @return {Array} return containing the starter indices of each component.
   */
  makeDoublyLinkedList: function(S) {
    var i2, first = null, components = [], le = S.length;
    if (le > 0) {
      for (i2 = 0; i2 < le; i2++) {
        if (this._isSeparator(S[i2])) {
          S[i2]._next = S[(i2 + 1) % le];
          S[i2]._prev = S[(le + i2 - 1) % le];
          continue;
        }
        if (first === null) {
          first = i2;
          components.push(first);
        }
        if (this._isSeparator(S[(i2 + 1) % le]) || i2 === le - 1) {
          S[i2]._next = S[first];
          S[first]._prev = S[i2];
          S[i2]._end = true;
          first = null;
        } else {
          S[i2]._next = S[(i2 + 1) % le];
          S[first]._prev = S[i2];
        }
        if (!this._isSeparator(S[(le + i2 - 1) % le])) {
          S[i2]._prev = S[(le + i2 - 1) % le];
        }
      }
    }
    return components;
  },
  /**
   * JavaScript object containing the intersection of two paths. Every intersection point is on one path, but
   * comes with a neighbour point having the same coordinates and being on the other path.
   *
   * The intersection point is inserted into the doubly linked list of the path.
   *
   * @private
   * @param  {JXG.Coords} coords JSXGraph Coords object containing the coordinates of the intersection
   * @param  {Number} i        Number of the segment of the subject path (first path) containing the intersection.
   * @param  {Number} alpha    The intersection is a p_1 + alpha*(p_2 - p_1), where p_1 and p_2 are the end points
   *      of the i-th segment.
   * @param  {Array} path      Pointer to the path containing the intersection point
   * @param  {String} pathname Name of the path: 'S' or 'C'.
   */
  Vertex: function(coords, i2, alpha, path, pathname, type) {
    this.pos = i2;
    this.intersection = true;
    this.coords = coords;
    this.elementClass = constants_default.OBJECT_CLASS_POINT;
    this.data = {
      alpha,
      path,
      pathname,
      done: false,
      type,
      idx: 0
    };
    this.neighbour = null;
    this.entry_exit = false;
  },
  _addToList: function(list2, coords, pos) {
    var len = list2.length, eps = math_default.eps * math_default.eps;
    if (len > 0 && Math.abs(list2[len - 1].coords.usrCoords[0] - coords.usrCoords[0]) < eps && Math.abs(list2[len - 1].coords.usrCoords[1] - coords.usrCoords[1]) < eps && Math.abs(list2[len - 1].coords.usrCoords[2] - coords.usrCoords[2]) < eps) {
      return;
    }
    list2.push({
      pos,
      intersection: false,
      coords,
      elementClass: constants_default.OBJECT_CLASS_POINT
    });
  },
  /**
   * Sort the intersection points into their path.
   * @private
   * @param  {Array} P_crossings Array of arrays. Each array contains the intersections of the path
   *      with one segment of the other path.
   * @return {Array}  Array of intersection points ordered by first occurrence in the path.
   */
  sortIntersections: function(P_crossings) {
    var i2, j, P, Q, last, next_node, P_intersect = [], P_le = P_crossings.length;
    for (i2 = 0; i2 < P_le; i2++) {
      P_crossings[i2].sort(function(a, b) {
        return a.data.alpha > b.data.alpha ? 1 : -1;
      });
      if (P_crossings[i2].length > 0) {
        last = P_crossings[i2].length - 1;
        P = P_crossings[i2][0];
        Q = P.data.path[P.pos];
        next_node = Q._next;
        if (i2 === P_le - 1) {
          Q._end = false;
        }
        if (P.data.alpha === 0 && P.data.type === "T") {
          Q.intersection = true;
          Q.data = P.data;
          Q.neighbour = P.neighbour;
          Q.neighbour.neighbour = Q;
          Q.entry_exit = false;
          P_crossings[i2][0] = Q;
        } else {
          P._prev = Q;
          P._prev._next = P;
        }
        for (j = 1; j <= last; j++) {
          P = P_crossings[i2][j];
          P._prev = P_crossings[i2][j - 1];
          P._prev._next = P;
        }
        P = P_crossings[i2][last];
        P._next = next_node;
        P._next._prev = P;
        if (i2 === P_le - 1) {
          P._end = true;
        }
        P_intersect = P_intersect.concat(P_crossings[i2]);
      }
    }
    return P_intersect;
  },
  _inbetween: function(q, p1, p2) {
    var alpha, eps = math_default.eps * math_default.eps, px = p2[1] - p1[1], py = p2[2] - p1[2], qx = q[1] - p1[1], qy = q[2] - p1[2];
    if (px === 0 && py === 0 && qx === 0 && qy === 0) {
      return true;
    }
    if (Math.abs(qx) < eps && Math.abs(px) < eps) {
      alpha = qy / py;
    } else {
      alpha = qx / px;
    }
    if (Math.abs(alpha) < eps) {
      alpha = 0;
    }
    return alpha;
  },
  _print_array: function(arr) {
    var i2, end;
    for (i2 = 0; i2 < arr.length; i2++) {
      try {
        end = "";
        if (arr[i2]._end) {
          end = " end";
        }
        console.log(
          i2,
          arr[i2].coords.usrCoords,
          arr[i2].data.type,
          "	",
          "prev",
          arr[i2]._prev.coords.usrCoords,
          "next",
          arr[i2]._next.coords.usrCoords + end
        );
      } catch (e) {
        console.log(i2, arr[i2].coords.usrCoords);
      }
    }
  },
  _print_list: function(P) {
    var cnt = 0, alpha;
    while (cnt < 100) {
      if (P.data) {
        alpha = P.data.alpha;
      } else {
        alpha = "-";
      }
      console.log(
        "	",
        P.coords.usrCoords,
        "\n		is:",
        P.intersection,
        "end:",
        P._end,
        alpha,
        "\n		-:",
        P._prev.coords.usrCoords,
        "\n		+:",
        P._next.coords.usrCoords,
        "\n		n:",
        P.intersection ? P.neighbour.coords.usrCoords : "-"
      );
      if (P._end) {
        break;
      }
      P = P._next;
      cnt++;
    }
  },
  _noOverlap: function(p1, p2, q1, q2) {
    var k, eps = Math.sqrt(math_default.eps), minp, maxp, minq, maxq, no_overlap = false;
    for (k = 0; k < 3; k++) {
      minp = Math.min(p1[k], p2[k]);
      maxp = Math.max(p1[k], p2[k]);
      minq = Math.min(q1[k], q2[k]);
      maxq = Math.max(q1[k], q2[k]);
      if (maxp < minq - eps || minp > maxq + eps) {
        no_overlap = true;
        break;
      }
    }
    return no_overlap;
  },
  /**
   * Find all intersections between two paths.
   * @private
   * @param  {Array} S     Subject path
   * @param  {Array} C     Clip path
   * @param  {JXG.Board} board JSXGraph board object. It is needed to convert between
   * user coordinates and screen coordinates.
   * @return {Array}  Array containing two arrays. The first array contains the intersection vertices
   * of the subject path and the second array contains the intersection vertices of the clip path.
   * @see JXG.Clip#Vertex
   */
  findIntersections: function(S, C, board) {
    var res = [], eps = math_default.eps * 100, i2, j, crds, S_le = S.length, C_le = C.length, Si, Si1, Cj, Cj1, d1, d2, alpha, type, IS, IC, S_intersect = [], C_intersect = [], S_crossings = [], C_crossings = [], hasMultCompsS = false, hasMultCompsC = false, DEBUG = false;
    for (j = 0; j < C_le; j++) {
      C_crossings.push([]);
    }
    for (i2 = 0; i2 < S_le; i2++) {
      S_crossings.push([]);
      if (this._isSeparator(S[i2]) || this._isSeparator(S[(i2 + 1) % S_le])) {
        hasMultCompsS = true;
        continue;
      }
      if (hasMultCompsS && i2 === S_le - 1) {
        break;
      }
      Si = S[i2].coords.usrCoords;
      Si1 = S[(i2 + 1) % S_le].coords.usrCoords;
      for (j = 0; j < C_le; j++) {
        if (this._isSeparator(C[j]) || this._isSeparator(C[(j + 1) % C_le])) {
          hasMultCompsC = true;
          continue;
        }
        if (hasMultCompsC && j === C_le - 1) {
          break;
        }
        Cj = C[j].coords.usrCoords;
        Cj1 = C[(j + 1) % C_le].coords.usrCoords;
        if (this._noOverlap(Si, Si1, Cj, Cj1)) {
          continue;
        }
        res = geometry_default.meetSegmentSegment(Si, Si1, Cj, Cj1);
        d1 = geometry_default.distance(Si, Si1, 3);
        d2 = geometry_default.distance(Cj, Cj1, 3);
        if (
          // "Regular" intersection
          res[1] * d1 > -eps && res[1] < 1 - eps / d1 && res[2] * d2 > -eps && res[2] < 1 - eps / d2 || // Collinear segments
          res[1] === Infinity && res[2] === Infinity && math_default.norm(res[0], 3) < eps
        ) {
          crds = new coords_default(constants_default.COORDS_BY_USER, res[0], board);
          type = "X";
          if (Math.abs(res[1]) * d1 < eps || Math.abs(res[2]) * d2 < eps) {
            type = "T";
            if (Math.abs(res[1]) * d1 < eps) {
              res[1] = 0;
            }
            if (Math.abs(res[2]) * d2 < eps) {
              res[2] = 0;
            }
            if (res[1] === 0) {
              crds = new coords_default(constants_default.COORDS_BY_USER, Si, board);
            } else {
              crds = new coords_default(constants_default.COORDS_BY_USER, Cj, board);
            }
            if (DEBUG) {
              console.log(
                "Degenerate case I",
                res[1],
                res[2],
                crds.usrCoords,
                "type",
                type
              );
            }
          } else if (res[1] === Infinity && res[2] === Infinity && math_default.norm(res[0], 3) < eps) {
            alpha = this._inbetween(Si, Cj, Cj1);
            if (DEBUG) {
            }
            if (alpha >= 0 && alpha < 1) {
              type = "T";
              crds = new coords_default(constants_default.COORDS_BY_USER, Si, board);
              res[1] = 0;
              res[2] = alpha;
              IS = new this.Vertex(crds, i2, res[1], S, "S", type);
              IC = new this.Vertex(crds, j, res[2], C, "C", type);
              IS.neighbour = IC;
              IC.neighbour = IS;
              S_crossings[i2].push(IS);
              C_crossings[j].push(IC);
              if (DEBUG) {
                console.log(
                  "Degenerate case II",
                  res[1],
                  res[2],
                  crds.usrCoords,
                  "type T"
                );
              }
            }
            alpha = this._inbetween(Cj, Si, Si1);
            if (DEBUG) {
            }
            if (geometry_default.distance(Si, Cj, 3) > eps && alpha >= 0 && alpha < 1) {
              type = "T";
              crds = new coords_default(constants_default.COORDS_BY_USER, Cj, board);
              res[1] = alpha;
              res[2] = 0;
              IS = new this.Vertex(crds, i2, res[1], S, "S", type);
              IC = new this.Vertex(crds, j, res[2], C, "C", type);
              IS.neighbour = IC;
              IC.neighbour = IS;
              S_crossings[i2].push(IS);
              C_crossings[j].push(IC);
              if (DEBUG) {
                console.log(
                  "Degenerate case III",
                  res[1],
                  res[2],
                  crds.usrCoords,
                  "type T"
                );
              }
            }
            continue;
          }
          if (DEBUG) {
            console.log("IS", i2, j, crds.usrCoords, type);
          }
          IS = new this.Vertex(crds, i2, res[1], S, "S", type);
          IC = new this.Vertex(crds, j, res[2], C, "C", type);
          IS.neighbour = IC;
          IC.neighbour = IS;
          S_crossings[i2].push(IS);
          C_crossings[j].push(IC);
        }
      }
    }
    S_intersect = this.sortIntersections(S_crossings);
    if (DEBUG) {
      console.log(">>>>>> Intersections ");
      console.log("S_intersect");
      this._print_array(S_intersect);
      console.log("----------");
    }
    for (i2 = 0; i2 < S_intersect.length; i2++) {
      S_intersect[i2].data.idx = i2;
      S_intersect[i2].neighbour.data.idx = i2;
    }
    C_intersect = this.sortIntersections(C_crossings);
    if (DEBUG) {
      console.log("C_intersect");
      this._print_array(C_intersect);
      console.log("<<<<<< Phase 1 done");
    }
    return [S_intersect, C_intersect];
  },
  /**
   * It is testedd if the point q lies to the left or right
   * of the poylgonal chain [p1, p2, p3].
   * @param {Array} q User coords array
   * @param {Array} p1 User coords array
   * @param {Array} p2 User coords array
   * @param {Array} p3 User coords array
   * @returns string 'left' or 'right'
   * @private
   */
  _getPosition: function(q, p1, p2, p3) {
    var s1 = geometry_default.det3p(q, p1, p2), s2 = geometry_default.det3p(q, p2, p3), s3 = geometry_default.det3p(p1, p2, p3);
    if (s3 >= 0) {
      if (s1 >= 0 && s2 >= 0) {
        return "left";
      }
      return "right";
    }
    if (s1 >= 0 || s2 >= 0) {
      return "left";
    }
    return "right";
  },
  /**
   * Determine the delayed status of degenerated intersection points.
   * It is of the form
   *   ['on|left|right', 'on|left|right']
   * <p>
   * If all four determinants are zero, we add random noise to the point.
   *
   * @param {JXG.Math.Clip.Vertex} P Start of path
   * @private
   * @see JXG.Math.Clip#markEntryExit
   * @see JXG.Math.Clip#_handleIntersectionChains
   */
  _classifyDegenerateIntersections: function(P) {
    var Pp, Pm, Qp, Qm, Q, side, cnt, tmp, det, oppositeDir, s1, s2, s3, s4, endless = true, DEBUG = false;
    if (DEBUG) {
      console.log(
        "\n-------------- _classifyDegenerateIntersections()",
        type_default.exists(P.data) ? P.data.pathname : " "
      );
    }
    det = geometry_default.det3p;
    cnt = 0;
    P._tours = 0;
    while (endless) {
      if (DEBUG) {
        console.log("Inspect P:", P.coords.usrCoords, P.data ? P.data.type : " ");
      }
      if (P.intersection && P.data.type === "T") {
        Pp = P._next.coords.usrCoords;
        Pm = P._prev.coords.usrCoords;
        if (geometry_default.distance(P.coords.usrCoords, Pp, 3) < math_default.eps) {
          Pp = P._next._next.coords.usrCoords;
        }
        if (geometry_default.distance(P.coords.usrCoords, Pm, 3) < math_default.eps) {
          Pm = P._prev._prev.coords.usrCoords;
        }
        Q = P.neighbour;
        Qm = Q._prev.coords.usrCoords;
        Qp = Q._next.coords.usrCoords;
        if (geometry_default.distance(Q.coords.usrCoords, Qp, 3) < math_default.eps) {
          Qp = Q._next._next.coords.usrCoords;
        }
        if (geometry_default.distance(Q.coords.usrCoords, Qm, 3) < math_default.eps) {
          Qm = Q._prev._prev.coords.usrCoords;
        }
        if (DEBUG) {
          console.log("P chain:", Pm, P.coords.usrCoords, Pp);
          console.log("Q chain:", Qm, P.neighbour.coords.usrCoords, Qp);
          console.log("Pm", this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp));
          console.log("Pp", this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp));
        }
        s1 = det(P.coords.usrCoords, Pm, Qm);
        s2 = det(P.coords.usrCoords, Pp, Qp);
        s3 = det(P.coords.usrCoords, Pm, Qp);
        s4 = det(P.coords.usrCoords, Pp, Qm);
        if (s1 === 0 && s2 === 0 && s3 === 0 && s4 === 0) {
          P.coords.usrCoords[1] *= 1 + Math.random() * math_default.eps;
          P.coords.usrCoords[2] *= 1 + Math.random() * math_default.eps;
          Q.coords.usrCoords[1] = P.coords.usrCoords[1];
          Q.coords.usrCoords[2] = P.coords.usrCoords[2];
          s1 = det(P.coords.usrCoords, Pm, Qm);
          s2 = det(P.coords.usrCoords, Pp, Qp);
          s3 = det(P.coords.usrCoords, Pm, Qp);
          s4 = det(P.coords.usrCoords, Pp, Qm);
          if (DEBUG) {
            console.log("Random shift", P.coords.usrCoords);
            console.log(s1, s2, s3, s4, s2 === 0);
            console.log(
              this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp),
              this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp)
            );
          }
        }
        oppositeDir = false;
        if (s1 === 0) {
          if (geometry_default.affineRatio(P.coords.usrCoords, Pm, Qm) < 0) {
            oppositeDir = true;
          }
        } else if (s2 === 0) {
          if (geometry_default.affineRatio(P.coords.usrCoords, Pp, Qp) < 0) {
            oppositeDir = true;
          }
        } else if (s3 === 0) {
          if (geometry_default.affineRatio(P.coords.usrCoords, Pm, Qp) > 0) {
            oppositeDir = true;
          }
        } else if (s4 === 0) {
          if (geometry_default.affineRatio(P.coords.usrCoords, Pp, Qm) > 0) {
            oppositeDir = true;
          }
        }
        if (oppositeDir) {
          tmp = Qm;
          Qm = Qp;
          Qp = tmp;
          tmp = s1;
          s1 = s3;
          s3 = tmp;
          tmp = s2;
          s2 = s4;
          s4 = tmp;
        }
        if (DEBUG) {
          console.log(s1, s2, s3, s4, oppositeDir);
        }
        if (!type_default.exists(P.delayedStatus)) {
          P.delayedStatus = [];
        }
        if (s1 === 0 && s2 === 0) {
          P.delayedStatus = ["on", "on"];
        } else if (s1 === 0) {
          side = this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp);
          P.delayedStatus = ["on", side];
        } else if (s2 === 0) {
          side = this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp);
          P.delayedStatus = [side, "on"];
        } else {
          if (P.delayedStatus.length === 0) {
            if (this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp) !== this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp)) {
              P.data.type = "X";
            } else {
              P.data.type = "B";
            }
          }
        }
        if (DEBUG) {
          console.log(
            ">>>> P:",
            P.coords.usrCoords,
            "delayedStatus:",
            P.delayedStatus.toString(),
            P.data ? P.data.type : " ",
            "\n---"
          );
        }
      }
      if (type_default.exists(P._tours)) {
        P._tours++;
      }
      if (P._tours > 3 || P._end || cnt > 1e3) {
        if (cnt > 1e3) {
          console.log("Clipping: _classifyDegenerateIntersections exit");
        }
        if (type_default.exists(P._tours)) {
          delete P._tours;
        }
        break;
      }
      if (P.intersection) {
        cnt++;
      }
      P = P._next;
    }
    if (DEBUG) {
      console.log("------------------------");
    }
  },
  /**
   * At this point the degenerated intersections have been classified.
   * Now we decide if the intersection chains of the given path
   * ultimatively cross the other path or bounce.
   *
   * @param {JXG.Math.Clip.Vertex} P Start of path
   *
   * @see JXG.Math.Clip#markEntryExit
   * @see JXG.Math.Clip#_classifyDegenerateIntersections
   * @private
   */
  _handleIntersectionChains: function(P) {
    var cnt = 0, start_status = "Null", P_start, endless = true, intersection_chain = false, wait_for_exit = false, DEBUG = false;
    if (DEBUG) {
      console.log(
        "\n-------------- _handleIntersectionChains()",
        type_default.exists(P.data) ? P.data.pathname : " "
      );
    }
    while (endless) {
      if (P.intersection === true) {
        if (DEBUG) {
          if (P.data.type === "T") {
            console.log(
              "Degenerate point",
              P.coords.usrCoords,
              P.data.type,
              P.data.type === "T" ? P.delayedStatus : " "
            );
          } else {
            console.log("Intersection point", P.coords.usrCoords, P.data.type);
          }
        }
        if (P.data.type === "T") {
          if (P.delayedStatus[0] !== "on" && P.delayedStatus[1] === "on") {
            intersection_chain = true;
            P_start = P;
            start_status = P.delayedStatus[0];
          } else if (intersection_chain && P.delayedStatus[0] === "on" && P.delayedStatus[1] === "on") {
            P.data.type = "B";
            if (DEBUG) {
              console.log("Interior", P.coords.usrCoords);
            }
          } else if (intersection_chain && P.delayedStatus[0] === "on" && P.delayedStatus[1] !== "on") {
            intersection_chain = false;
            if (start_status === P.delayedStatus[1]) {
              P_start.data.type = "DB";
              P.data.type = "DB";
              if (DEBUG) {
                console.log(
                  "Chain: delayed bouncing",
                  P_start.coords.usrCoords,
                  "...",
                  P.coords.usrCoords
                );
              }
            } else {
              P_start.data.type = "DX";
              P.data.type = "DX";
              if (DEBUG) {
                console.log(
                  "Chain: delayed crossing",
                  P_start.coords.usrCoords,
                  "...",
                  P.coords.usrCoords
                );
              }
            }
          }
        }
        cnt++;
      }
      if (P._end) {
        wait_for_exit = true;
      }
      if (wait_for_exit && !intersection_chain) {
        break;
      }
      if (cnt > 1e3) {
        console.log(
          "Warning: _handleIntersectionChains: intersection chain reached maximum numbers of iterations"
        );
        break;
      }
      P = P._next;
    }
  },
  /**
   * Handle the case that all vertices of one path are contained
   * in the other path. In this case we search for a midpoint of an edge
   * which is not contained in the other path and add it to the path.
   * It will be used as starting point for the entry/exit algorithm.
   *
   * @private
   * @param {Array} S Subject path
   * @param {Array} C Clip path
   * @param {JXG.board} board JSXGraph board object. It is needed to convert between
   * user coordinates and screen coordinates.
   */
  _handleFullyDegenerateCase: function(S, C, board) {
    var P, Q, l, M, crds, q1, q2, node2, i2, j, leP, leQ, is_on_Q, tmp, is_fully_degenerated, arr = [S, C];
    for (l = 0; l < 2; l++) {
      P = arr[l];
      leP = P.length;
      for (i2 = 0, is_fully_degenerated = true; i2 < leP; i2++) {
        if (!P[i2].intersection) {
          is_fully_degenerated = false;
          break;
        }
      }
      if (is_fully_degenerated) {
        Q = arr[(l + 1) % 2];
        leQ = Q.length;
        for (i2 = 0; i2 < leP; i2++) {
          q1 = P[i2].coords.usrCoords;
          q2 = P[i2]._next.coords.usrCoords;
          M = [(q1[0] + q2[0]) * 0.5, (q1[1] + q2[1]) * 0.5, (q1[2] + q2[2]) * 0.5];
          for (j = 0, is_on_Q = false; j < leQ; j++) {
            if (Math.abs(
              geometry_default.det3p(
                Q[j].coords.usrCoords,
                Q[(j + 1) % leQ].coords.usrCoords,
                M
              )
            ) < math_default.eps) {
              is_on_Q = true;
              break;
            }
          }
          if (!is_on_Q) {
            crds = new coords_default(constants_default.COORDS_BY_USER, M, board);
            node2 = {
              pos: i2,
              intersection: false,
              coords: crds,
              elementClass: constants_default.OBJECT_CLASS_POINT
            };
            tmp = P[i2]._next;
            P[i2]._next = node2;
            node2._prev = P[i2];
            node2._next = tmp;
            tmp._prev = node2;
            if (P[i2]._end) {
              P[i2]._end = false;
              node2._end = true;
            }
            break;
          }
        }
      }
    }
  },
  _getStatus: function(P, path) {
    var status;
    while (P.intersection) {
      if (P._end) {
        break;
      }
      P = P._next;
    }
    if (geometry_default.windingNumber(P.coords.usrCoords, path) === 0) {
      status = "entry";
    } else {
      status = "exit";
    }
    return [P, status];
  },
  /**
   * Mark the intersection vertices of path1 as entry points or as exit points
   * in respect to path2.
   * <p>
   * This is the simple algorithm as in
   * Greiner, Günther; Kai Hormann (1998). "Efficient clipping of arbitrary polygons".
   * ACM Transactions on Graphics. 17 (2): 71–83
   * <p>
   * The algorithm handles also "delayed crossings" from
   * Erich, L. Foster, and Kai Hormann, Kai, and Romeo Traaian Popa (2019),
   * "Clipping simple polygons with degenerate intersections", Computers & Graphics:X, 2.
   * and - as an additional improvement -
   * handles self intersections of delayed crossings (A.W. 2021).
   *
   * @private
   * @param  {Array} path1 First path
   * @param  {Array} path2 Second path
   */
  markEntryExit: function(path1, path2, starters) {
    var status, P, cnt, res, i2, len, start, endless = true, chain_start = null, intersection_chain = 0, DEBUG = false;
    len = starters.length;
    for (i2 = 0; i2 < len; i2++) {
      start = starters[i2];
      if (DEBUG) {
        console.log(
          "\n;;;;;;;;;; Labelling phase",
          type_default.exists(path1[start].data) ? path1[start].data.pathname : " ",
          path1[start].coords.usrCoords
        );
      }
      this._classifyDegenerateIntersections(path1[start]);
      this._handleIntersectionChains(path1[start]);
      if (DEBUG) {
        console.log("\n---- back to markEntryExit");
      }
      res = this._getStatus(path1[start], path2);
      P = res[0];
      status = res[1];
      if (DEBUG) {
        console.log("Start node:", P.coords.usrCoords, status);
      }
      P._starter = true;
      cnt = 0;
      chain_start = null;
      intersection_chain = 0;
      while (endless) {
        if (P.intersection === true) {
          if (P.data.type === "X" && intersection_chain === 1) {
            chain_start.entry_exit = status;
            if (status === "exit") {
              chain_start.data.type = "X";
            }
            intersection_chain = 2;
          }
          if (P.data.type === "X" || P.data.type === "DB") {
            P.entry_exit = status;
            status = status === "entry" ? "exit" : "entry";
            if (DEBUG) {
              console.log("mark:", P.coords.usrCoords, P.data.type, P.entry_exit);
            }
          }
          if (P.data.type === "DX") {
            if (intersection_chain === 0) {
              chain_start = P;
              intersection_chain = 1;
              if (DEBUG) {
                console.log(
                  "Start intersection chain:",
                  P.coords.usrCoords,
                  P.data.type,
                  status
                );
              }
            } else if (intersection_chain === 1) {
              P.entry_exit = status;
              chain_start.entry_exit = status;
              if (status === "exit") {
                chain_start.data.type = "X";
              } else {
                P.data.type = "X";
              }
              status = status === "entry" ? "exit" : "entry";
              if (DEBUG) {
                console.log(
                  "mark':",
                  chain_start.coords.usrCoords,
                  chain_start.data.type,
                  chain_start.entry_exit
                );
                console.log(
                  "mark:",
                  P.coords.usrCoords,
                  P.data.type,
                  P.entry_exit
                );
              }
              chain_start = null;
              intersection_chain = 0;
            } else if (intersection_chain === 2) {
              P.entry_exit = status;
              P.data.type = "X";
              status = status === "entry" ? "exit" : "entry";
              chain_start = null;
              intersection_chain = 0;
            }
          }
        }
        P = P._next;
        if (type_default.exists(P._starter) || cnt > 1e4) {
          break;
        }
        cnt++;
      }
    }
  },
  /**
   *
   * @private
   * @param {Array} P
   * @param {Boolean} isBackward
   * @returns {Boolean} True, if the node is an intersection and is of type 'X'
   */
  _stayOnPath: function(P, status) {
    var stay = true;
    if (P.intersection && P.data.type !== "B") {
      stay = status === P.entry_exit;
    }
    return stay;
  },
  /**
   * Add a point to the clipping path and returns if the algorithms
   * arrived at an intersection point which has already been visited.
   * In this case, true is returned.
   *
   * @param {Array} path Resulting path
   * @param {JXG.Math.Clip.Vertex} vertex Point to be added
   * @param {Boolean} DEBUG debug output to console.log
   * @returns {Boolean} true: point has been visited before, false otherwise
   * @private
   */
  _addVertex: function(path, vertex, DEBUG) {
    if (!isNaN(vertex.coords.usrCoords[1]) && !isNaN(vertex.coords.usrCoords[2])) {
      path.push(vertex);
    }
    if (vertex.intersection && vertex.data.done) {
      if (DEBUG) {
        console.log(
          "Add last intersection point",
          vertex.coords.usrCoords,
          "on",
          vertex.data.pathname,
          vertex.entry_exit,
          vertex.data.type
        );
      }
      return true;
    }
    if (vertex.intersection) {
      vertex.data.done = true;
      if (DEBUG) {
        console.log(
          "Add intersection point",
          vertex.coords.usrCoords,
          "on",
          vertex.data.pathname,
          vertex.entry_exit,
          vertex.data.type
        );
      }
    }
    return false;
  },
  /**
   * Tracing phase of the Greiner-Hormann algorithm, see
   * Greiner, Günther; Kai Hormann (1998).
   * "Efficient clipping of arbitrary polygons". ACM Transactions on Graphics. 17 (2): 71–83
   *
   * Boolean operations on polygons are distinguished: 'intersection', 'union', 'difference'.
   *
   * @private
   * @param  {Array} S           Subject path
   * @param  {Array} S_intersect Array containing the intersection vertices of the subject path
   * @param  {String} clip_type  contains the Boolean operation: 'intersection', 'union', or 'difference'
   * @return {Array}             Array consisting of two arrays containing the x-coordinates and the y-coordintaes of
   *      the resulting path.
   */
  tracing: function(S, S_intersect, clip_type) {
    var P, status, current, start, cnt = 0, maxCnt = 1e4, S_idx = 0, path = [], done = false, DEBUG = false;
    if (DEBUG) {
      console.log("\n------ Start Phase 3");
    }
    while (S_idx < S_intersect.length && cnt < maxCnt) {
      current = S_intersect[S_idx];
      if (current.data.done || current.data.type !== "X") {
        S_idx++;
        continue;
      }
      if (DEBUG) {
        console.log(
          "\nStart",
          current.data.pathname,
          current.coords.usrCoords,
          current.data.type,
          current.entry_exit,
          S_idx
        );
      }
      if (path.length > 0) {
        path.push([NaN, NaN]);
      }
      start = current.data.idx;
      P = S;
      done = this._addVertex(path, current, DEBUG);
      status = current.entry_exit;
      do {
        if (done) {
          break;
        }
        if (clip_type === "intersection" && current.entry_exit === "entry" || clip_type === "union" && current.entry_exit === "exit" || clip_type === "difference" && P === S === (current.entry_exit === "exit")) {
          if (DEBUG) {
            console.log("Go forward on", current.data.pathname, current.entry_exit);
          }
          do {
            current = current._next;
            done = this._addVertex(path, current, DEBUG);
            if (done) {
              break;
            }
          } while (this._stayOnPath(current, status));
          cnt++;
        } else {
          if (DEBUG) {
            console.log("Go backward on", current.data.pathname);
          }
          do {
            current = current._prev;
            done = this._addVertex(path, current, DEBUG);
            if (done) {
              break;
            }
          } while (this._stayOnPath(current, status));
          cnt++;
        }
        if (done) {
          break;
        }
        if (!current.neighbour) {
          console.log(
            "Tracing: emergency break - no neighbour!!!!!!!!!!!!!!!!!",
            cnt
          );
          return [[0], [0]];
        }
        if (DEBUG) {
          console.log(
            "Switch from",
            current.coords.usrCoords,
            current.data.pathname,
            "to",
            current.neighbour.coords.usrCoords,
            "on",
            current.neighbour.data.pathname
          );
        }
        current = current.neighbour;
        if (current.data.done) {
          break;
        }
        current.data.done = true;
        status = current.entry_exit;
        P = current.data.path;
      } while (current.data.idx !== start && cnt < maxCnt);
      if (cnt >= maxCnt) {
        console.log("Tracing: stopping an infinite loop!", cnt);
      }
      S_idx++;
    }
    return this._getCoordsArrays(path, false);
  },
  /**
   * Handle path clipping if one of the two paths is empty.
   * @private
   * @param  {Array} S        First path, array of JXG.Coords
   * @param  {Array} C        Second path, array of JXG.Coords
   * @param  {String} clip_type Type of Boolean operation: 'intersection', 'union', 'differrence'.
   * @return {Boolean}        true, if one of the input paths is empty, false otherwise.
   */
  isEmptyCase: function(S, C, clip_type) {
    if (clip_type === "intersection" && (S.length === 0 || C.length === 0)) {
      return true;
    }
    if (clip_type === "union" && S.length === 0 && C.length === 0) {
      return true;
    }
    if (clip_type === "difference" && S.length === 0) {
      return true;
    }
    return false;
  },
  _getCoordsArrays: function(path, doClose) {
    var pathX = [], pathY = [], i2, le = path.length;
    for (i2 = 0; i2 < le; i2++) {
      if (path[i2].coords) {
        pathX.push(path[i2].coords.usrCoords[1]);
        pathY.push(path[i2].coords.usrCoords[2]);
      } else {
        pathX.push(path[i2][0]);
        pathY.push(path[i2][1]);
      }
    }
    if (doClose && le > 0) {
      if (path[0].coords) {
        pathX.push(path[0].coords.usrCoords[1]);
        pathY.push(path[0].coords.usrCoords[2]);
      } else {
        pathX.push(path[0][0]);
        pathY.push(path[0][1]);
      }
    }
    return [pathX, pathY];
  },
  /**
   * Handle cases when there are no intersection points of the two paths. This is the case if the
   * paths are disjoint or one is contained in the other.
   * @private
   * @param  {Array} S        First path, array of JXG.Coords
   * @param  {Array} C        Second path, array of JXG.Coords
   * @param  {String} clip_type Type of Boolean operation: 'intersection', 'union', 'differrence'.
   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of
   *      the resulting path.
   */
  handleEmptyIntersection: function(S, C, clip_type) {
    var P, Q, doClose = false, path = [];
    if (S.length === 0) {
      if (clip_type === "union") {
        path = C;
      } else {
        path = [];
      }
      return this._getCoordsArrays(path, true);
    }
    if (C.length === 0) {
      if (clip_type === "intersection") {
        path = [];
      } else {
        path = S;
      }
      return this._getCoordsArrays(path, true);
    }
    if (S.length > 0) {
      P = S[0];
      while (P.intersection) {
        P = P._next;
        if (P._end) {
          break;
        }
      }
    }
    if (C.length > 0) {
      Q = C[0];
      while (Q.intersection) {
        Q = Q._next;
        if (Q._end) {
          break;
        }
      }
    }
    if (geometry_default.windingNumber(P.coords.usrCoords, C) === 0) {
      if (geometry_default.windingNumber(Q.coords.usrCoords, S) !== 0) {
        if (clip_type === "union") {
          path = path.concat(S);
          path.push(S[0]);
        } else if (clip_type === "difference") {
          path = path.concat(S);
          path.push(S[0]);
          if (geometry_default.signedPolygon(S) * geometry_default.signedPolygon(C) > 0) {
            path.reverse();
          }
          path.push([NaN, NaN]);
        }
        if (clip_type === "difference" || clip_type === "intersection") {
          path = path.concat(C);
          path.push(C[0]);
          doClose = false;
        }
      } else {
        if (clip_type === "difference") {
          path = path.concat(S);
          doClose = true;
        } else if (clip_type === "union") {
          path = path.concat(S);
          path.push(S[0]);
          path.push([NaN, NaN]);
          path = path.concat(C);
          path.push(C[0]);
        }
      }
    } else {
      if (clip_type === "intersection") {
        path = path.concat(S);
        doClose = true;
      } else if (clip_type === "union") {
        path = path.concat(C);
        path.push(C[0]);
      }
    }
    return this._getCoordsArrays(path, doClose);
  },
  /**
   * Count intersection points of type 'X'.
   * @param {JXG.Mat.Clip.Vertex} intersections
   * @returns Number
   * @private
   */
  _countCrossingIntersections: function(intersections) {
    var i2, le = intersections.length, sum = 0;
    for (i2 = 0; i2 < le; i2++) {
      if (intersections[i2].data.type === "X") {
        sum++;
      }
    }
    return sum;
  },
  /**
   * Create path from all sorts of input elements and convert it
   * to a suitable input path for greinerHormann().
   *
   * @private
   * @param {Object} obj Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,
   * array of coordinate pairs.
   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between
   * user coordinates and screen coordinates.
   * @returns {Array} Array of JXG.Coords elements containing a path.
   * @see JXG.Math.Clip#greinerHormann
   */
  _getPath: function(obj, board) {
    var i2, len, r, rad, angle, alpha, steps, S = [];
    if (obj.elementClass === constants_default.OBJECT_CLASS_CURVE && (obj.type === constants_default.OBJECT_TYPE_ARC || obj.type === constants_default.OBJECT_TYPE_SECTOR)) {
      angle = geometry_default.rad(obj.radiuspoint, obj.center, obj.anglepoint);
      steps = Math.floor(angle * 180 / Math.PI);
      r = obj.Radius();
      rad = angle / steps;
      alpha = Math.atan2(
        obj.radiuspoint.coords.usrCoords[2] - obj.center.coords.usrCoords[2],
        obj.radiuspoint.coords.usrCoords[1] - obj.center.coords.usrCoords[1]
      );
      if (obj.type === constants_default.OBJECT_TYPE_SECTOR) {
        this._addToList(S, obj.center.coords, 0);
      }
      for (i2 = 0; i2 <= steps; i2++) {
        this._addToList(
          S,
          new coords_default(
            constants_default.COORDS_BY_USER,
            [
              obj.center.coords.usrCoords[0],
              obj.center.coords.usrCoords[1] + Math.cos(i2 * rad + alpha) * r,
              obj.center.coords.usrCoords[2] + Math.sin(i2 * rad + alpha) * r
            ],
            board
          ),
          i2 + 1
        );
      }
      if (obj.type === constants_default.OBJECT_TYPE_SECTOR) {
        this._addToList(S, obj.center.coords, steps + 2);
      }
    } else if (obj.elementClass === constants_default.OBJECT_CLASS_CURVE && type_default.exists(obj.points)) {
      len = obj.numberPoints;
      for (i2 = 0; i2 < len; i2++) {
        this._addToList(S, obj.points[i2], i2);
      }
    } else if (obj.type === constants_default.OBJECT_TYPE_POLYGON) {
      for (i2 = 0; i2 < obj.vertices.length; i2++) {
        this._addToList(S, obj.vertices[i2].coords, i2);
      }
    } else if (obj.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
      steps = 359;
      r = obj.Radius();
      rad = 2 * Math.PI / steps;
      for (i2 = 0; i2 <= steps; i2++) {
        this._addToList(
          S,
          new coords_default(
            constants_default.COORDS_BY_USER,
            [
              obj.center.coords.usrCoords[0],
              obj.center.coords.usrCoords[1] + Math.cos(i2 * rad) * r,
              obj.center.coords.usrCoords[2] + Math.sin(i2 * rad) * r
            ],
            board
          ),
          i2
        );
      }
    } else if (type_default.isArray(obj)) {
      len = obj.length;
      for (i2 = 0; i2 < len; i2++) {
        if (type_default.exists(obj[i2].coords)) {
          this._addToList(S, obj[i2].coords, i2);
        } else if (type_default.isArray(obj[i2])) {
          this._addToList(S, new coords_default(constants_default.COORDS_BY_USER, obj[i2], board), i2);
        } else if (type_default.exists(obj[i2].usrCoords)) {
          this._addToList(S, obj[i2], i2);
        }
      }
    }
    return S;
  },
  /**
   * Determine the intersection, union or difference of two closed paths.
   * <p>
   * This is an implementation of the Greiner-Hormann algorithm, see
   * Günther Greiner and Kai Hormann (1998).
   * "Efficient clipping of arbitrary polygons". ACM Transactions on Graphics. 17 (2): 71–83.
   * and
   * Erich, L. Foster, and Kai Hormann, Kai, and Romeo Traaian Popa (2019),
   * "Clipping simple polygons with degenerate intersections", Computers & Graphics:X, 2.
   * <p>
   * It is assumed that the pathes are closed, whereby it does not matter if the last point indeed
   * equals the first point. In contrast to the original Greiner-Hormann algorithm,
   * this algorithm can cope with many degenerate cases. A degenerate case is a vertext of one path
   * which is contained in the other path.
   * <p>
   *
   * <p>Problematic are:
   * <ul>
   *   <li>degenerate cases where one path additionally has self-intersections
   *   <li>differences with one path having self-intersections.
   * </ul>
   *
   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path, usually called 'subject'.
   * Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,
   * array of coordinate pairs.
   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path, usually called 'clip'.
   * Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,
   * array of coordinate pairs.
   * @param  {String} clip_type Determines the type of boolean operation on the two paths.
   *  Possible values are 'intersection', 'union', or 'difference'.
   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between
   * user coordinates and screen coordinates.
   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of
   *      the resulting path.
   *
   * @see JXG.Math.Clip#intersection
   * @see JXG.Math.Clip#union
   * @see JXG.Math.Clip#difference
   *
   * @example
   *     var curve1 = board.create('curve', [
   *             [-3, 3, 0, -3],
   *             [3, 3, 0, 3]
   *         ],
   *         {strokeColor: 'black'});
   *
   *     var curve2 = board.create('curve', [
   *             [-4, 4, 0, -4],
   *             [2, 2, 4, 2]
   *         ],
   *         {strokeColor: 'blue'});
   *
   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});
   *     clip_path.updateDataArray = function() {
   *         var a = JXG.Math.Clip.greinerHormann(curve2, curve1, 'intersection', this.board);
   *
   *         this.dataX = a[0];
   *         this.dataY = a[1];
   *     };
   *
   *     board.update();
   *
   * </pre><div id="JXG9d2a6acf-a43b-4035-8f8a-9b1bee580210" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXG9d2a6acf-a43b-4035-8f8a-9b1bee580210',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *
   *         var curve1 = board.create('curve', [
   *                 [-3, 3, 0, -3],
   *                 [3, 3, 0, 3]
   *             ],
   *             {strokeColor: 'black'});
   *
   *         var curve2 = board.create('curve', [
   *                 [-4, 4, 0, -4],
   *                 [2, 2, 4, 2]
   *             ],
   *             {strokeColor: 'blue'});
   *
   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});
   *         clip_path.updateDataArray = function() {
   *             var a = JXG.Math.Clip.greinerHormann(curve2, curve1, 'intersection', this.board);
   *
   *             this.dataX = a[0];
   *             this.dataY = a[1];
   *         };
   *
   *         board.update();
   *
   *     })();
   *
   * <\/script><pre>
   *
   * @example
   *     var curve1 = board.create('curve', [
   *             [-3, 3, 0, -3],
   *             [3, 3, 0, 3]
   *         ],
   *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});
   *
   *     var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],
   *             {strokeColor: 'blue', fillColor: 'none'});
   *
   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});
   *     clip_path.updateDataArray = function() {
   *         var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'union', this.board);
   *         this.dataX = a[0];
   *         this.dataY = a[1];
   *     };
   *
   *     board.update();
   *
   * </pre><div id="JXG6075c918-4d57-4b72-b600-6597a6a4f44e" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXG6075c918-4d57-4b72-b600-6597a6a4f44e',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *         var curve1 = board.create('curve', [
   *                 [-3, 3, 0, -3],
   *                 [3, 3, 0, 3]
   *             ],
   *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});
   *
   *         var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],
   *                 {strokeColor: 'blue', fillColor: 'none'});
   *
   *
   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});
   *         clip_path.updateDataArray = function() {
   *             var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'union', this.board);
   *             this.dataX = a[0];
   *             this.dataY = a[1];
   *         };
   *
   *         board.update();
   *
   *     })();
   *
   * <\/script><pre>
   *
   * @example
   *     var curve1 = board.create('curve', [
   *             [-4, 4, 0, -4],
   *             [4, 4, -2, 4]
   *         ],
   *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});
   *
   *     var curve2 = board.create('circle', [[0, 0], [0, -2]],
   *             {strokeColor: 'blue', strokeWidth: 1, fillColor: 'red', fixed: true, fillOpacity: 0.3,
   *             center: {visible: true, size: 5}, point2: {size: 5}});
   *
   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});
   *     clip_path.updateDataArray = function() {
   *         var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'difference', this.board);
   *
   *         this.dataX = a[0];
   *         this.dataY = a[1];
   *     };
   *
   *     board.update();
   *
   * </pre><div id="JXG46b3316b-5ab9-4928-9473-ccb476ca4185" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXG46b3316b-5ab9-4928-9473-ccb476ca4185',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *         var curve1 = board.create('curve', [
   *                 [-4, 4, 0, -4],
   *                 [4, 4, -2, 4]
   *             ],
   *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});
   *
   *         var curve2 = board.create('circle', [[0, 0], [0, -2]],
   *                 {strokeColor: 'blue', strokeWidth: 1, fillColor: 'red', fixed: true, fillOpacity: 0.3,
   *                 center: {visible: true, size: 5}, point2: {size: 5}});
   *
   *
   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});
   *         clip_path.updateDataArray = function() {
   *             var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'difference', this.board);
   *
   *             this.dataX = a[0];
   *             this.dataY = a[1];
   *         };
   *
   *         board.update();
   *
   *     })();
   *
   * <\/script><pre>
   *
   * @example
   * var clip_path = board.create('curve', [[], []], {strokeWidth: 1, fillColor: 'yellow', fillOpacity: 0.6});
   * clip_path.updateDataArray = function() {
   *     var bbox = this.board.getBoundingBox(),
   *         canvas, triangle;
   *
   *     canvas = [[bbox[0], bbox[1]], // ul
   *          [bbox[0], bbox[3]], // ll
   *          [bbox[2], bbox[3]], // lr
   *          [bbox[2], bbox[1]], // ur
   *          [bbox[0], bbox[1]]] // ul
   *     triangle = [[-1,1], [1,1], [0,-1], [-1,1]];
   *
   *     var a = JXG.Math.Clip.greinerHormann(canvas, triangle, 'difference', this.board);
   *     this.dataX = a[0];
   *     this.dataY = a[1];
   * };
   *
   * </pre><div id="JXGe94da07a-2a01-4498-ad62-f71a327f8e25" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXGe94da07a-2a01-4498-ad62-f71a327f8e25',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 1, fillColor: 'yellow', fillOpacity: 0.6});
   *     clip_path.updateDataArray = function() {
   *         var bbox = this.board.getBoundingBox(),
   *             canvas, triangle;
   *
   *         canvas = [[bbox[0], bbox[1]], // ul
   *              [bbox[0], bbox[3]], // ll
   *              [bbox[2], bbox[3]], // lr
   *              [bbox[2], bbox[1]], // ur
   *              [bbox[0], bbox[1]]] // ul
   *         triangle = [[-1,1], [1,1], [0,-1], [-1,1]];
   *
   *         var a = JXG.Math.Clip.greinerHormann(canvas, triangle, 'difference', this.board);
   *         this.dataX = a[0];
   *         this.dataY = a[1];
   *     };
   *
   *     })();
   *
   * <\/script><pre>
   *
   */
  greinerHormann: function(subject, clip, clip_type, board) {
    var len, S = [], C = [], S_intersect = [], S_starters, C_starters, res = [], DEBUG = false;
    if (DEBUG) {
      console.log("\n------------ GREINER-HORMANN --------------");
    }
    S = this._getPath(subject, board);
    len = S.length;
    if (len > 0 && geometry_default.distance(S[0].coords.usrCoords, S[len - 1].coords.usrCoords, 3) < math_default.eps) {
      S.pop();
    }
    C = this._getPath(clip, board);
    len = C.length;
    if (len > 0 && geometry_default.distance(C[0].coords.usrCoords, C[len - 1].coords.usrCoords, 3) < math_default.eps * math_default.eps) {
      C.pop();
    }
    if (this.isEmptyCase(S, C, clip_type)) {
      return [[], []];
    }
    S_starters = this.makeDoublyLinkedList(S);
    C_starters = this.makeDoublyLinkedList(C);
    if (DEBUG) {
      this._print_array(S);
      console.log("Components:", S_starters);
      this._print_array(C);
      console.log("Components:", C_starters);
    }
    res = this.findIntersections(S, C, board);
    S_intersect = res[0];
    this._handleFullyDegenerateCase(S, C, board);
    this.markEntryExit(S, C, S_starters);
    this.markEntryExit(C, S, C_starters);
    if (this._countCrossingIntersections(S_intersect) === 0) {
      return this.handleEmptyIntersection(S, C, clip_type);
    }
    return this.tracing(S, S_intersect, clip_type);
  },
  /**
   * Union of two closed paths. The paths could be JSXGraph elements circle, curve, or polygon.
   * Computed by the Greiner-Hormann algorithm.
   *
   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.
   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.
   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between
   * user coordinates and screen coordinates.
   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of
   *      the resulting path.
   *
   * @see JXG.Math.Clip#greinerHormann
   * @see JXG.Math.Clip#intersection
   * @see JXG.Math.Clip#difference
   *
   * @example
   *     var curve1 = board.create('curve', [
   *             [-3, 3, 0, -3],
   *             [3, 3, 0, 3]
   *         ],
   *         {strokeColor: 'black'});
   *
   *     var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],
   *             {strokeColor: 'blue', fillColor: 'none'});
   *
   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});
   *     clip_path.updateDataArray = function() {
   *         var a = JXG.Math.Clip.union(curve1, curve2, this.board);
   *         this.dataX = a[0];
   *         this.dataY = a[1];
   *     };
   *
   *     board.update();
   *
   * </pre><div id="JXG7c5204aa-3824-4464-819c-80df7bf1d917" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXG7c5204aa-3824-4464-819c-80df7bf1d917',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *         var curve1 = board.create('curve', [
   *                 [-3, 3, 0, -3],
   *                 [3, 3, 0, 3]
   *             ],
   *             {strokeColor: 'black'});
   *
   *         var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],
   *                 {strokeColor: 'blue', fillColor: 'none'});
   *
   *
   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});
   *         clip_path.updateDataArray = function() {
   *             var a = JXG.Math.Clip.union(curve1, curve2, this.board);
   *             this.dataX = a[0];
   *             this.dataY = a[1];
   *         };
   *
   *         board.update();
   *
   *     })();
   *
   * <\/script><pre>
   *
   */
  union: function(path1, path2, board) {
    return this.greinerHormann(path1, path2, "union", board);
  },
  /**
   * Intersection of two closed paths. The paths could be JSXGraph elements circle, curve, or polygon.
   * Computed by the Greiner-Hormann algorithm.
   *
   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.
   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.
   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between
   * user coordinates and screen coordinates.
   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of
   *      the resulting path.
   *
   * @see JXG.Math.Clip#greinerHormann
   * @see JXG.Math.Clip#union
   * @see JXG.Math.Clip#difference
   *
   * @example
   * var p = [];
   * p.push(board.create('point', [0, -5]));
   * p.push(board.create('point', [-5, 0]));
   * p.push(board.create('point', [-3, 3]));
   *
   * var curve1 = board.create('ellipse', p,
   *                 {strokeColor: 'black'});
   *
   * var curve2 = board.create('curve', [function(phi){return 4 * Math.cos(2*phi); },
   *                                     [0, 0],
   *                                     0, 2 * Math.PI],
   *                       {curveType:'polar', strokeColor: 'blue', strokewidth:1});
   *
   * var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});
   * clip_path.updateDataArray = function() {
   *     var a = JXG.Math.Clip.intersection(curve2, curve1, this.board);
   *
   *     this.dataX = a[0];
   *     this.dataY = a[1];
   * };
   *
   * board.update();
   *
   * </pre><div id="JXG7ad547eb-7b6c-4a1a-a4d4-4ed298fc7998" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXG7ad547eb-7b6c-4a1a-a4d4-4ed298fc7998',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *     var p = [];
   *     p.push(board.create('point', [0, -5]));
   *     p.push(board.create('point', [-5, 0]));
   *     p.push(board.create('point', [-3, 3]));
   *
   *     var curve1 = board.create('ellipse', p,
   *                     {strokeColor: 'black'});
   *
   *     var curve2 = board.create('curve', [function(phi){return 4 * Math.cos(2*phi); },
   *                                         [0, 0],
   *                                         0, 2 * Math.PI],
   *                           {curveType:'polar', strokeColor: 'blue', strokewidth:1});
   *
   *
   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});
   *     clip_path.updateDataArray = function() {
   *         var a = JXG.Math.Clip.intersection(curve2, curve1, this.board);
   *
   *         this.dataX = a[0];
   *         this.dataY = a[1];
   *     };
   *
   *     board.update();
   *
   *     })();
   *
   * <\/script><pre>
   *
   *
   */
  intersection: function(path1, path2, board) {
    return this.greinerHormann(path1, path2, "intersection", board);
  },
  /**
   * Difference of two closed paths, i.e. path1 minus path2.
   * The paths could be JSXGraph elements circle, curve, or polygon.
   * Computed by the Greiner-Hormann algorithm.
   *
   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.
   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.
   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between
   * user coordinates and screen coordinates.
   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of
   *      the resulting path.
   *
   * @see JXG.Math.Clip#greinerHormann
   * @see JXG.Math.Clip#intersection
   * @see JXG.Math.Clip#union
   *
   * @example
   *     var curve1 = board.create('polygon', [[-4, 4], [4, 4], [0, -1]],
   *             {strokeColor: 'blue', fillColor: 'none'});
   *
   *     var curve2 = board.create('curve', [
   *             [-1, 1, 0, -1],
   *             [1, 1, 3, 1]
   *         ],
   *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});
   *
   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});
   *     clip_path.updateDataArray = function() {
   *         var a = JXG.Math.Clip.difference(curve1, curve2, this.board);
   *         this.dataX = a[0];
   *         this.dataY = a[1];
   *     };
   *
   *     board.update();
   *
   * </pre><div id="JXGc5ce6bb3-146c-457f-a48b-6b9081fb68a3" class="jxgbox" style="width: 300px; height: 300px;"></div>
   * <script type="text/javascript">
   *     (function() {
   *         var board = JXG.JSXGraph.initBoard('JXGc5ce6bb3-146c-457f-a48b-6b9081fb68a3',
   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
   *         var curve1 = board.create('polygon', [[-4, 4], [4, 4], [0, -1]],
   *                 {strokeColor: 'blue', fillColor: 'none'});
   *
   *         var curve2 = board.create('curve', [
   *                 [-1, 1, 0, -1],
   *                 [1, 1, 3, 1]
   *             ],
   *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});
   *
   *
   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});
   *         clip_path.updateDataArray = function() {
   *             var a = JXG.Math.Clip.difference(curve1, curve2, this.board);
   *             this.dataX = a[0];
   *             this.dataY = a[1];
   *         };
   *
   *         board.update();
   *
   *     })();
   *
   * <\/script><pre>
   *
   */
  difference: function(path1, path2, board) {
    return this.greinerHormann(path1, path2, "difference", board);
  }
};
var clip_default = math_default.Clip;

// node_modules/jsxgraph/src/math/poly.js
math_default.Poly = {};
math_default.Poly.Ring = function(variables) {
  this.vars = variables;
};
jxg_default.extend(
  math_default.Poly.Ring.prototype,
  /** @lends JXG.Math.Poly.Ring.prototype */
  {
    // nothing yet.
  }
);
math_default.Poly.Monomial = function(ring, coefficient, exponents) {
  var i2;
  if (!type_default.exists(ring)) {
    throw new Error("JSXGraph error: In JXG.Math.Poly.monomial missing parameter 'ring'.");
  }
  if (!type_default.isArray(exponents)) {
    exponents = [];
  }
  exponents = exponents.slice(0, ring.vars.length);
  for (i2 = exponents.length; i2 < ring.vars.length; i2++) {
    exponents.push(0);
  }
  this.ring = ring;
  this.coefficient = coefficient || 0;
  this.exponents = type_default.deepCopy(exponents);
};
jxg_default.extend(
  math_default.Poly.Monomial.prototype,
  /** @lends JXG.Math.Poly.Monomial.prototype */
  {
    /**
     * Creates a deep copy of the monomial.
     *
     * @returns {JXG.Math.Poly.Monomial}
     *
     * @memberof JXG.Math.Poly.Monomial
     */
    copy: function() {
      return new math_default.Poly.Monomial(this.ring, this.coefficient, this.exponents);
    },
    /**
             * Print the monomial.
             * @returns {String} String representation of the monomial
    
             * @memberof JXG.Math.Poly.Monomial
             */
    print: function() {
      var s = [], i2;
      for (i2 = 0; i2 < this.ring.vars.length; i2++) {
        s.push(this.ring.vars[i2] + "^" + this.exponents[i2]);
      }
      return this.coefficient + "*" + s.join("*");
    }
  }
);
math_default.Poly.Polynomial = function(ring, str2) {
  var parse = function() {
  }, mons;
  if (!type_default.exists(ring)) {
    throw new Error(
      "JSXGraph error: In JXG.Math.Poly.polynomial missing parameter 'ring'."
    );
  }
  if (type_default.exists(str2) && type_default.isString(str2)) {
    mons = parse(str2);
  } else {
    mons = [];
  }
  this.ring = ring;
  this.monomials = mons;
};
jxg_default.extend(
  math_default.Poly.Polynomial.prototype,
  /** @lends JXG.Math.Poly.Polynomial.prototype */
  {
    /**
     * Find a monomial with the given signature, i.e. exponent vector.
     * @param {Array} sig An array of numbers
     * @returns {Number} The index of the first monomial with the given signature, or -1
     * if no monomial could be found.
     * @memberof JXG.Math.Poly.Polynomial
     */
    findSignature: function(sig) {
      var i2;
      for (i2 = 0; i2 < this.monomials.length; i2++) {
        if (type_default.cmpArrays(this.monomials[i2].exponents, sig)) {
          return i2;
        }
      }
      return -1;
    },
    /**
     * Adds a monomial to the polynomial. Checks the existing monomials for the added
     * monomial's signature and just adds the coefficient if one is found.
     * @param {JXG.Math.Poly.Monomial} m
     * @param {Number} factor Either <tt>1</tt> or <tt>-1</tt>.
     * @memberof JXG.Math.Poly.Polynomial
     */
    addSubMonomial: function(m, factor) {
      var i2;
      i2 = this.findSignature(m.exponents);
      if (i2 > -1) {
        this.monomials[i2].coefficient += factor * m.coefficient;
      } else {
        m.coefficient *= factor;
        this.monomials.push(m);
      }
    },
    /**
     * Adds another polynomial or monomial to this one and merges them by checking for the
     * signature of each new monomial in the existing monomials.
     * @param {JXG.Math.Poly.Polynomial|JXG.Math.Poly.Monomial} mp
     * @memberof JXG.Math.Poly.Polynomial
     */
    add: function(mp) {
      var i2;
      if (type_default.exists(mp) && mp.ring === this.ring) {
        if (type_default.isArray(mp.exponents)) {
          this.addSubMonomial(mp, 1);
        } else {
          for (i2 = 0; i2 < mp.monomials.length; i2++) {
            this.addSubMonomial(mp.monomials[i2], 1);
          }
        }
      } else {
        throw new Error(
          "JSXGraph error: In JXG.Math.Poly.polynomial.add either summand is undefined or rings don't match."
        );
      }
    },
    /**
     * Subtracts another polynomial or monomial from this one and merges them by checking for the
     * signature of each new monomial in the existing monomials.
     * @param {JXG.Math.Poly.Polynomial|JXG.Math.Poly.Monomial} mp
     * @memberof JXG.Math.Poly.Polynomial
     */
    sub: function(mp) {
      var i2;
      if (type_default.exists(mp) && mp.ring === this.ring) {
        if (type_default.isArray(mp.exponents)) {
          this.addSubMonomial(mp, -1);
        } else {
          for (i2 = 0; i2 < mp.monomials.length; i2++) {
            this.addSubMonomial(mp.monomials[i2], -1);
          }
        }
      } else {
        throw new Error(
          "JSXGraph error: In JXG.Math.Poly.polynomial.sub either summand is undefined or rings don't match."
        );
      }
    },
    /**
     * Creates a deep copy of the polynomial.
     * @returns {JXG.Math.Poly.Polynomial}
     * @memberof JXG.Math.Poly.Polynomial
     */
    copy: function() {
      var i2, p;
      p = new math_default.Poly.Polynomial(this.ring);
      for (i2 = 0; i2 < this.monomials.length; i2++) {
        p.monomials.push(this.monomials[i2].copy());
      }
      return p;
    },
    /**
     * Prints the polynomial.
     * @returns {String} A string representation of the polynomial.
     * @memberof JXG.Math.Poly.Polynomial
     */
    print: function() {
      var s = [], i2;
      for (i2 = 0; i2 < this.monomials.length; i2++) {
        s.push("(" + this.monomials[i2].print() + ")");
      }
      return s.join("+");
    }
  }
);
var poly_default = math_default.Poly;

// node_modules/jsxgraph/src/math/complex.js
jxg_default.Complex = function(x, y) {
  this.isComplex = true;
  if (x && x.isComplex) {
    y = x.imaginary;
    x = x.real;
  }
  this.real = x || 0;
  this.imaginary = y || 0;
  this.absval = 0;
  this.angle = 0;
};
jxg_default.extend(
  jxg_default.Complex.prototype,
  /** @lends JXG.Complex.prototype */
  {
    /**
     * Converts a complex number into a string.
     * @returns {String} Formatted string containing the complex number in human readable form (algebraic form).
     */
    toString: function() {
      return this.real + " + " + this.imaginary + "i";
    },
    /**
     * Add another complex number to this complex number.
     * @param {JXG.Complex|Number} c A JavaScript number or a JXG.Complex object to be added to the current object.
     * @returns {JXG.Complex} Reference to this complex number
     */
    add: function(c) {
      if (type_default.isNumber(c)) {
        this.real += c;
      } else {
        this.real += c.real;
        this.imaginary += c.imaginary;
      }
      return this;
    },
    /**
     * Subtract another complex number from this complex number.
     * @param {JXG.Complex|Number} c A JavaScript number or a JXG.Complex object to subtract from the current object.
     * @returns {JXG.Complex} Reference to this complex number
     */
    sub: function(c) {
      if (type_default.isNumber(c)) {
        this.real -= c;
      } else {
        this.real -= c.real;
        this.imaginary -= c.imaginary;
      }
      return this;
    },
    /**
     * Multiply another complex number to this complex number.
     * @param {JXG.Complex|Number} c A JavaScript number or a JXG.Complex object to
     * multiply with the current object.
     * @returns {JXG.Complex} Reference to this complex number
     */
    mult: function(c) {
      var re, im;
      if (type_default.isNumber(c)) {
        this.real *= c;
        this.imaginary *= c;
      } else {
        re = this.real;
        im = this.imaginary;
        this.real = re * c.real - im * c.imaginary;
        this.imaginary = re * c.imaginary + im * c.real;
      }
      return this;
    },
    /**
     * Divide this complex number by the given complex number.
     * @param {JXG.Complex|Number} c A JavaScript number or a JXG.Complex object to
     * divide the current object by.
     * @returns {JXG.Complex} Reference to this complex number
     */
    div: function(c) {
      var denom, im, re;
      if (type_default.isNumber(c)) {
        if (Math.abs(c) < Math.eps) {
          this.real = Infinity;
          this.imaginary = Infinity;
          return this;
        }
        this.real /= c;
        this.imaginary /= c;
      } else {
        if (Math.abs(c.real) < Math.eps && Math.abs(c.imaginary) < Math.eps) {
          this.real = Infinity;
          this.imaginary = Infinity;
          return this;
        }
        denom = c.real * c.real + c.imaginary * c.imaginary;
        re = this.real;
        im = this.imaginary;
        this.real = (re * c.real + im * c.imaginary) / denom;
        this.imaginary = (im * c.real - re * c.imaginary) / denom;
      }
      return this;
    },
    /**
     * Conjugate a complex number in place.
     * @returns {JXG.Complex} Reference to this complex number
     */
    conj: function() {
      this.imaginary *= -1;
      return this;
    }
  }
);
jxg_default.C = {};
jxg_default.C.add = function(z1, z2) {
  var z = new jxg_default.Complex(z1);
  z.add(z2);
  return z;
};
jxg_default.C.sub = function(z1, z2) {
  var z = new jxg_default.Complex(z1);
  z.sub(z2);
  return z;
};
jxg_default.C.mult = function(z1, z2) {
  var z = new jxg_default.Complex(z1);
  z.mult(z2);
  return z;
};
jxg_default.C.div = function(z1, z2) {
  var z = new jxg_default.Complex(z1);
  z.div(z2);
  return z;
};
jxg_default.C.conj = function(z1) {
  var z = new jxg_default.Complex(z1);
  z.conj();
  return z;
};
jxg_default.C.abs = function(z1) {
  var z = new jxg_default.Complex(z1);
  z.conj();
  z.mult(z1);
  return Math.sqrt(z.real);
};
jxg_default.C.copy = function(z) {
  return new jxg_default.Complex(z);
};
jxg_default.Complex.C = jxg_default.C;
var complex_default = jxg_default.Complex;

// node_modules/jsxgraph/src/utils/color.js
var simpleColors = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dodgerblue: "1e90ff",
  feldspar: "d19275",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgrey: "d3d3d3",
  lightgreen: "90ee90",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslateblue: "8470ff",
  lightslategray: "778899",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "00ff00",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "ff00ff",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370d8",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "d87093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  red: "ff0000",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  violetred: "d02090",
  wheat: "f5deb3",
  white: "ffffff",
  whitesmoke: "f5f5f5",
  yellow: "ffff00",
  yellowgreen: "9acd32"
};
var colorDefs = [
  {
    re: /^\s*rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([\d.]{1,3})\s*\)\s*$/,
    example: ["rgba(123, 234, 45, 0.5)", "rgba(255,234,245,1.0)"],
    process: function(bits) {
      return [parseInt(bits[1], 10), parseInt(bits[2], 10), parseInt(bits[3], 10)];
    }
  },
  {
    re: /^\s*rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)\s*$/,
    example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
    process: function(bits) {
      return [parseInt(bits[1], 10), parseInt(bits[2], 10), parseInt(bits[3], 10)];
    }
  },
  {
    re: /^(\w{2})(\w{2})(\w{2})$/,
    example: ["#00ff00", "336699"],
    process: function(bits) {
      return [parseInt(bits[1], 16), parseInt(bits[2], 16), parseInt(bits[3], 16)];
    }
  },
  {
    re: /^(\w{1})(\w{1})(\w{1})$/,
    example: ["#fb0", "f0f"],
    process: function(bits) {
      return [
        parseInt(bits[1] + bits[1], 16),
        parseInt(bits[2] + bits[2], 16),
        parseInt(bits[3] + bits[3], 16)
      ];
    }
  }
];
jxg_default.rgbParser = function(color2, ag, ab) {
  var color_string, channels, re, processor, bits, i2, r, g, b, values = color2, testFloat;
  if (!type_default.exists(color2)) {
    return [];
  }
  if (type_default.exists(ag) && type_default.exists(ab)) {
    values = [color2, ag, ab];
  }
  color_string = values;
  testFloat = false;
  if (type_default.isArray(color_string)) {
    for (i2 = 0; i2 < 3; i2++) {
      testFloat = testFloat || /\./.test(values[i2].toString());
    }
    for (i2 = 0; i2 < 3; i2++) {
      testFloat = testFloat && values[i2] >= 0 && values[i2] <= 1;
    }
    if (testFloat) {
      return [
        Math.ceil(values[0] * 255),
        Math.ceil(values[1] * 255),
        Math.ceil(values[2] * 255)
      ];
    }
    return values;
  }
  if (typeof values === "string") {
    color_string = values;
  }
  if (color_string.charAt(0) === "#") {
    color_string = color_string.slice(1, 7);
  }
  color_string = color_string.replace(/ /g, "").toLowerCase();
  color_string = simpleColors[color_string] || color_string;
  for (i2 = 0; i2 < colorDefs.length; i2++) {
    re = colorDefs[i2].re;
    processor = colorDefs[i2].process;
    bits = re.exec(color_string);
    if (bits) {
      channels = processor(bits);
      r = channels[0];
      g = channels[1];
      b = channels[2];
    }
  }
  if (isNaN(r) || isNaN(g) || isNaN(b)) {
    return [];
  }
  r = r < 0 || isNaN(r) ? 0 : r > 255 ? 255 : r;
  g = g < 0 || isNaN(g) ? 0 : g > 255 ? 255 : g;
  b = b < 0 || isNaN(b) ? 0 : b > 255 ? 255 : b;
  return [r, g, b];
};
jxg_default.isColor = function(strColor) {
  var s = new Option().style;
  s.color = strColor;
  return s.color !== "";
};
jxg_default.rgb2css = function(color2, ag, ab) {
  var r;
  r = jxg_default.rgbParser(color2, ag, ab);
  return "rgb(" + r[0] + ", " + r[1] + ", " + r[2] + ")";
};
jxg_default.rgb2hex = function(color2, ag, ab) {
  var r, g, b;
  r = jxg_default.rgbParser(color2, ag, ab);
  g = r[1];
  b = r[2];
  r = r[0];
  r = r.toString(16);
  g = g.toString(16);
  b = b.toString(16);
  if (r.length === 1) {
    r = "0" + r;
  }
  if (g.length === 1) {
    g = "0" + g;
  }
  if (b.length === 1) {
    b = "0" + b;
  }
  return "#" + r + g + b;
};
jxg_default.hex2rgb = function(hex) {
  jxg_default.deprecated("JXG.hex2rgb()", "JXG.rgb2css()");
  return jxg_default.rgb2css(hex);
};
jxg_default.hsv2rgb = function(H, S, V) {
  var R, G, B, f, i2, hTemp, p, q, t;
  H = (H % 360 + 360) % 360;
  if (S === 0) {
    if (isNaN(H) || H < math_default.eps) {
      R = V;
      G = V;
      B = V;
    } else {
      return "#ffffff";
    }
  } else {
    if (H >= 360) {
      hTemp = 0;
    } else {
      hTemp = H;
    }
    hTemp = hTemp / 60;
    i2 = Math.floor(hTemp);
    f = hTemp - i2;
    p = V * (1 - S);
    q = V * (1 - S * f);
    t = V * (1 - S * (1 - f));
    switch (i2) {
      case 0:
        R = V;
        G = t;
        B = p;
        break;
      case 1:
        R = q;
        G = V;
        B = p;
        break;
      case 2:
        R = p;
        G = V;
        B = t;
        break;
      case 3:
        R = p;
        G = q;
        B = V;
        break;
      case 4:
        R = t;
        G = p;
        B = V;
        break;
      case 5:
        R = V;
        G = p;
        B = q;
        break;
    }
  }
  R = Math.round(R * 255).toString(16);
  R = R.length === 2 ? R : R.length === 1 ? "0" + R : "00";
  G = Math.round(G * 255).toString(16);
  G = G.length === 2 ? G : G.length === 1 ? "0" + G : "00";
  B = Math.round(B * 255).toString(16);
  B = B.length === 2 ? B : B.length === 1 ? "0" + B : "00";
  return ["#", R, G, B].join("");
};
jxg_default.rgb2hsv = function(color2, ag, ab) {
  var r, g, b, fr, fg, fb, fmax, fmin, h, s, v, max, min;
  r = jxg_default.rgbParser(color2, ag, ab);
  g = r[1];
  b = r[2];
  r = r[0];
  fr = r / 255;
  fg = g / 255;
  fb = b / 255;
  max = Math.max(r, g, b);
  min = Math.min(r, g, b);
  fmax = max / 255;
  fmin = min / 255;
  v = fmax;
  s = 0;
  if (v > 0) {
    s = (v - fmin) / v;
  }
  h = 1 / (fmax - fmin);
  if (s > 0) {
    if (max === r) {
      h = (fg - fb) * h;
    } else if (max === g) {
      h = 2 + (fb - fr) * h;
    } else {
      h = 4 + (fr - fg) * h;
    }
  }
  h *= 60;
  if (h < 0) {
    h += 360;
  }
  if (max === min) {
    h = 0;
  }
  return [h, s, v];
};
jxg_default.rgb2LMS = function(color2, ag, ab) {
  var r, g, b, l, m, s, ret, matrix = [
    [0.05059983, 0.08585369, 95242e-7],
    [0.01893033, 0.08925308, 0.01370054],
    [292202e-8, 975732e-8, 0.07145979]
  ];
  r = jxg_default.rgbParser(color2, ag, ab);
  g = r[1];
  b = r[2];
  r = r[0];
  r = Math.pow(r, 0.476190476);
  g = Math.pow(g, 0.476190476);
  b = Math.pow(b, 0.476190476);
  l = r * matrix[0][0] + g * matrix[0][1] + b * matrix[0][2];
  m = r * matrix[1][0] + g * matrix[1][1] + b * matrix[1][2];
  s = r * matrix[2][0] + g * matrix[2][1] + b * matrix[2][2];
  ret = [l, m, s];
  ret.l = l;
  ret.m = m;
  ret.s = s;
  return ret;
};
jxg_default.LMS2rgb = function(l, m, s) {
  var r, g, b, ret, matrix = [
    [30.830854, -29.832659, 1.610474],
    [-6.481468, 17.715578, -2.532642],
    [-0.37569, -1.199062, 14.273846]
  ], lut_lookup = function(value) {
    var offset = 127, step = 64;
    while (step > 0) {
      if (Math.pow(offset, 0.476190476) > value) {
        offset -= step;
      } else {
        if (Math.pow(offset + 1, 0.476190476) > value) {
          return offset;
        }
        offset += step;
      }
      step /= 2;
    }
    if (offset === 254 && 13.994955247 < value) {
      return 255;
    }
    return offset;
  };
  r = l * matrix[0][0] + m * matrix[0][1] + s * matrix[0][2];
  g = l * matrix[1][0] + m * matrix[1][1] + s * matrix[1][2];
  b = l * matrix[2][0] + m * matrix[2][1] + s * matrix[2][2];
  r = lut_lookup(r);
  g = lut_lookup(g);
  b = lut_lookup(b);
  ret = [r, g, b];
  ret.r = r;
  ret.g = g;
  ret.b = b;
  return ret;
};
jxg_default.rgba2rgbo = function(rgba) {
  var opacity;
  if (rgba.length === 9 && rgba.charAt(0) === "#") {
    opacity = parseInt(rgba.slice(7, 9).toUpperCase(), 16) / 255;
    rgba = rgba.slice(0, 7);
  } else {
    opacity = 1;
  }
  return [rgba, opacity];
};
jxg_default.rgbo2rgba = function(rgb, o) {
  var rgba;
  if (rgb === "none" || rgb === "transparent") {
    return rgb;
  }
  rgba = Math.round(o * 255).toString(16);
  if (rgba.length === 1) {
    rgba = "0" + rgba;
  }
  return jxg_default.rgb2hex(rgb) + rgba;
};
jxg_default.rgb2bw = function(color2) {
  var x, tmp, arr, HexChars = "0123456789ABCDEF";
  if (color2 === "none") {
    return color2;
  }
  arr = jxg_default.rgbParser(color2);
  x = Math.floor(0.3 * arr[0] + 0.59 * arr[1] + 0.11 * arr[2]);
  tmp = HexChars.charAt(x >> 4 & 15) + HexChars.charAt(x & 15);
  color2 = "#" + tmp + tmp + tmp;
  return color2;
};
jxg_default.rgb2cb = function(color2, deficiency) {
  var rgb, l, m, s, lms, tmp, a1, b1, c1, a2, b2, c2, inflection, HexChars = "0123456789ABCDEF";
  if (color2 === "none") {
    return color2;
  }
  lms = jxg_default.rgb2LMS(color2);
  l = lms[0];
  m = lms[1];
  s = lms[2];
  deficiency = deficiency.toLowerCase();
  switch (deficiency) {
    case "protanopia":
      a1 = -0.06150039994295001;
      b1 = 0.08277001656812001;
      c1 = -0.013200141220000003;
      a2 = 0.05858939668799999;
      b2 = -0.07934519995360001;
      c2 = 0.013289415272000003;
      inflection = 0.6903216543277437;
      tmp = s / m;
      if (tmp < inflection) {
        l = -(b1 * m + c1 * s) / a1;
      } else {
        l = -(b2 * m + c2 * s) / a2;
      }
      break;
    case "tritanopia":
      a1 = -58973116217e-14;
      b1 = 0.007690316482;
      c1 = -0.01011703519052;
      a2 = 0.025495080838999994;
      b2 = -0.0422740347;
      c2 = 0.017005316784;
      inflection = 0.8349489908460004;
      tmp = m / l;
      if (tmp < inflection) {
        s = -(a1 * l + b1 * m) / c1;
      } else {
        s = -(a2 * l + b2 * m) / c2;
      }
      break;
    default:
      a1 = -0.06150039994295001;
      b1 = 0.08277001656812001;
      c1 = -0.013200141220000003;
      a2 = 0.05858939668799999;
      b2 = -0.07934519995360001;
      c2 = 0.013289415272000003;
      inflection = 0.5763833686400911;
      tmp = s / l;
      if (tmp < inflection) {
        m = -(a1 * l + c1 * s) / b1;
      } else {
        m = -(a2 * l + c2 * s) / b2;
      }
      break;
  }
  rgb = jxg_default.LMS2rgb(l, m, s);
  tmp = HexChars.charAt(rgb[0] >> 4 & 15) + HexChars.charAt(rgb[0] & 15);
  color2 = "#" + tmp;
  tmp = HexChars.charAt(rgb[1] >> 4 & 15) + HexChars.charAt(rgb[1] & 15);
  color2 += tmp;
  tmp = HexChars.charAt(rgb[2] >> 4 & 15) + HexChars.charAt(rgb[2] & 15);
  color2 += tmp;
  return color2;
};
jxg_default.shadeColor = function(color2, percent) {
  var arr = jxg_default.rgbParser(color2), r = arr[0], g = arr[1], b = arr[2];
  r = parseInt(r + 255 * percent);
  g = parseInt(g + 255 * percent);
  b = parseInt(b + 255 * percent);
  r = r > 0 ? r : 0;
  g = g > 0 ? g : 0;
  b = b > 0 ? b : 0;
  r = r < 255 ? r : 255;
  g = g < 255 ? g : 255;
  b = b < 255 ? b : 255;
  r = Math.round(r);
  g = Math.round(g);
  b = Math.round(b);
  return jxg_default.rgb2hex([r, g, b]);
};
jxg_default.lightenColor = function(color2, percent) {
  return jxg_default.shadeColor(color2, percent);
};
jxg_default.darkenColor = function(color2, percent) {
  return jxg_default.shadeColor(color2, -1 * percent);
};
jxg_default.autoHighlight = function(colstr) {
  var col = jxg_default.rgba2rgbo(colstr), c = col[0], opa = col[1];
  if (colstr.charAt(0) === "#") {
    if (opa < 0.3) {
      opa *= 1.8;
    } else {
      opa *= 0.4;
    }
    return jxg_default.rgbo2rgba(c, opa);
  }
  return colstr;
};
jxg_default.contrast = function(hexColor, darkColor, lightColor, threshold) {
  var rgb, black = "#000000", rgbBlack, l1, l2, contrastRatio;
  darkColor = darkColor || "#000000";
  lightColor = lightColor || "#ffffff";
  threshold = threshold || 7;
  rgb = jxg_default.rgbParser(hexColor);
  rgbBlack = jxg_default.rgbParser(black);
  l1 = 0.2126 * Math.pow(rgb[0] / 255, 2.2) + 0.7152 * Math.pow(rgb[1] / 255, 2.2) + 0.0722 * Math.pow(rgb[2] / 255, 2.2);
  l2 = 0.2126 * Math.pow(rgbBlack[0] / 255, 2.2) + 0.7152 * Math.pow(rgbBlack[1] / 255, 2.2) + 0.0722 * Math.pow(rgbBlack[2] / 255, 2.2);
  if (l1 > l2) {
    contrastRatio = Math.floor((l1 + 0.05) / (l2 + 0.05));
  } else {
    contrastRatio = Math.floor((l2 + 0.05) / (l1 + 0.05));
  }
  contrastRatio = contrastRatio - 1;
  if (contrastRatio > threshold) {
    return darkColor;
  }
  return lightColor;
};
jxg_default.setClassicColors = function() {
  jxg_default.Options.elements.strokeColor = "blue";
  jxg_default.Options.elements.fillColor = "red";
  jxg_default.Options.hatch.strokeColor = "blue";
  jxg_default.Options.angle.fillColor = "#ff7f00";
  jxg_default.Options.angle.highlightFillColor = "#ff7f00";
  jxg_default.Options.angle.strokeColor = "#ff7f00";
  jxg_default.Options.angle.label.strokeColor = "blue";
  jxg_default.Options.arc.strokeColor = "blue";
  jxg_default.Options.circle.center.fillColor = "red";
  jxg_default.Options.circle.center.strokeColor = "blue";
  jxg_default.Options.circumcircle.strokeColor = "blue";
  jxg_default.Options.circumcircle.center.fillColor = "red";
  jxg_default.Options.circumcircle.center.strokeColor = "blue";
  jxg_default.Options.circumcirclearc.strokeColor = "blue";
  jxg_default.Options.circumcirclesector.strokeColor = "blue";
  jxg_default.Options.circumcirclesector.fillColor = "green";
  jxg_default.Options.circumcirclesector.highlightFillColor = "green";
  jxg_default.Options.conic.strokeColor = "blue";
  jxg_default.Options.curve.strokeColor = "blue";
  jxg_default.Options.incircle.strokeColor = "blue";
  jxg_default.Options.incircle.center.fillColor = "red";
  jxg_default.Options.incircle.center.strokeColor = "blue";
  jxg_default.Options.inequality.fillColor = "red";
  jxg_default.Options.integral.fillColor = "red";
  jxg_default.Options.integral.curveLeft.color = "red";
  jxg_default.Options.integral.curveRight.color = "red";
  jxg_default.Options.line.strokeColor = "blue";
  jxg_default.Options.point.fillColor = "red";
  jxg_default.Options.point.strokeColor = "red";
  jxg_default.Options.polygon.fillColor = "green";
  jxg_default.Options.polygon.highlightFillColor = "green";
  jxg_default.Options.polygon.vertices.strokeColor = "red";
  jxg_default.Options.polygon.vertices.fillColor = "red";
  jxg_default.Options.regularpolygon.fillColor = "green";
  jxg_default.Options.regularpolygon.highlightFillColor = "green";
  jxg_default.Options.regularpolygon.vertices.strokeColor = "red";
  jxg_default.Options.regularpolygon.vertices.fillColor = "red";
  jxg_default.Options.riemannsum.fillColor = "yellow";
  jxg_default.Options.sector.fillColor = "green";
  jxg_default.Options.sector.highlightFillColor = "green";
  jxg_default.Options.semicircle.center.fillColor = "red";
  jxg_default.Options.semicircle.center.strokeColor = "blue";
  jxg_default.Options.slopetriangle.fillColor = "red";
  jxg_default.Options.slopetriangle.highlightFillColor = "red";
  jxg_default.Options.turtle.arrow.strokeColor = "blue";
};
jxg_default.extend(
  jxg_default,
  /** @lends JXG */
  {
    /**
     * Bang Wong color palette,
     * optimized for various type
     * of color blindness.
     * It contains values for
     * <ul>
     * <li> 'black'
     * <li> 'orange'
     * <li> 'skyblue'
     * <li> 'bluishgreen'
     * <li> 'yellow'
     * <li> 'darkblue'
     * <li> 'vermillion'
     * <li> 'reddishpurple'
     * </ul>
     *
     * As substitutes for standard colors, it contains the following aliases:
     *
     * <ul>
     * <li> black (= #000000)
     * <li> blue (= darkblue)
     * <li> green (= bluishgreen)
     * <li> purple (= reddishpurple)
     * <li> red (= vermillion)
     * <li> white (= #ffffff)
     * </ul>
     *
     * See <a href="https://www.nature.com/articles/nmeth.1618">Bang Wong: "Points of view: Color blindness"</a>
     * and
     * <a href="https://davidmathlogic.com/colorblind/">https://davidmathlogic.com/colorblind/</a>.
     *
     * @name JXG.paletteWong
     * @type Object
     * @see JXG.palette
     * @example
     * var p = board.create('line', [[-1, 1], [2, -3]], {strokeColor: JXG.paletteWong.yellow});
     */
    paletteWong: {
      black: "#000000",
      orange: "#E69F00",
      skyblue: "#56B4E9",
      bluishgreen: "#009E73",
      yellow: "#F0E442",
      darkblue: "#0072B2",
      vermillion: "#D55E00",
      reddishpurple: "#CC79A7",
      blue: "#0072B2",
      red: "#D55E00",
      // vermillion
      green: "#009E73",
      // bluishgreen
      purple: "#CC79A7",
      // reddishpurple
      white: "#ffffff"
    }
  }
);
jxg_default.palette = jxg_default.paletteWong;
var color_default = jxg_default;

// node_modules/jsxgraph/src/options.js
jxg_default.Options = {
  jc: {
    enabled: true,
    compile: true
  },
  /*
   * Options that are used directly within the board class
   */
  board: {
    /**#@+
     * @visprop
     */
    //updateType: 'hierarchical', // 'all'
    /**
     * Time (in msec) between two animation steps. Used in
     * {@link JXG.CoordsElement#moveAlong}, {@link JXG.CoordsElement#moveTo} and
     * {@link JXG.CoordsElement#visit}.
     *
     * @name JXG.Board#animationDelay
     * @type Number
     * @default 35
     * @see JXG.CoordsElement#moveAlong
     * @see JXG.CoordsElement#moveTo
     * @see JXG.CoordsElement#visit
     */
    animationDelay: 35,
    /**
     * Show default axis.
     * If shown, the horizontal axis can be accessed via JXG.Board.defaultAxes.x, the
     * vertical axis can be accessed via JXG.Board.defaultAxes.y.
     * Both axes have a sub-element "defaultTicks".
     *
     * Value can be Boolean or an object containing axis attributes.
     *
     * @name JXG.Board#axis
     * @type Boolean
     * @default false
     */
    axis: false,
    /**
     * Bounding box of the visible area in user coordinates.
     * It is an array consisting of four values:
     * [x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>]
     *
     * The canvas will be spanned from the upper left corner (<sub>1</sub>, y<sub>1</sub>)
     * to the lower right corner (x<sub>2</sub>, y<sub>2</sub>).
     *
     * @name JXG.Board#boundingBox
     * @type Array
     * @see JXG.Board#maxBoundingBox
     * @see JXG.Board#keepAspectRatio
     *
     * @default [-5, 5, 5, -5]
     * @example
     * var board = JXG.JSXGraph.initBoard('jxgbox', {
     *         boundingbox: [-5, 5, 5, -5],
     *         axis: true
     *     });
     */
    boundingBox: [-5, 5, 5, -5],
    /**
     * Enable browser scrolling on touch interfaces if the user double taps into an empty region
     * of the board.
     *
     * <ul>
     * <li> Implemented for pointer touch devices - not with mouse, pen or old iOS touch.
     * <li> It only works if browserPan:true
     * <li> One finger action by the settings "pan.enabled:true" and "pan.needTwoFingers:false" has priority
     * </ul>
     *
     * @name JXG.Board#browserPan
     * @see JXG.Board#pan
     * @type Boolean
     * @default false
     *
     * @example
     * const board = JXG.JSXGraph.initBoard('jxgbox', {
     *     boundingbox: [-5, 5, 5, -5], axis: true,
     *     pan: {
     *         enabled: true,
     *         needTwoFingers: true,
     *     },
     *     browserPan: true,
     *     zoom: {
     *         enabled: false
     *     }
     * });
     *
     * var p1 = board.create('point', [1, -1]);
     * var p2 = board.create('point', [2.5, -2]);
     * var li1 = board.create('line', [p1, p2]);
     *
     * </pre><div id="JXGcd50c814-be81-4280-9458-d73e50cece8d" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGcd50c814-be81-4280-9458-d73e50cece8d',
     *             {showcopyright: false, shownavigation: false,
     *              axis: true,
     *              pan: {
     *                enabled: true,
     *                needTwoFingers: true,
     *             },
     *             browserPan: true,
     *             zoom: {
     *               enabled: false
     *             }
     *          });
     *
     *     var p1 = board.create('point', [1, -1]);
     *     var p2 = board.create('point', [2.5, -2]);
     *     var li1 = board.create('line', [p1, p2]);
     *
     *     })();
     *
     * <\/script><pre>
     *
     *
     */
    browserPan: false,
    /**
     * Attributes for the default axes in case of the attribute
     * axis:true in {@link JXG.JSXGraph#initBoard}.
     *
     * @name JXG.Board#defaultAxes
     * @type Object
     * @default <tt>{x: {name:'x'}, y: {name: 'y'}}</tt>
     *
     * @example
     * const board = JXG.JSXGraph.initBoard('id', {
     *     boundingbox: [-5, 5, 5, -5], axis:true,
     *     defaultAxes: {
     *         x: {
     *           name: 'Distance (mi)',
     *           withLabel: true,
     *           label: {
     *             position: 'rt',
     *             offset: [-5, 15],
     *             anchorX: 'right'
     *           }
     *         },
     *         y: {
     *           withLabel: true,
     *           name: 'Y',
     *           label: {
     *             position: 'rt',
     *             offset: [-20, -5],
     *             anchorY: 'top'
     *           }
     *         }
     *     }
     * });
     *
     * </pre><div id="JXGc3af5eb8-7401-4476-80b5-379ecbd068c6" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *     var board = JXG.JSXGraph.initBoard('JXGc3af5eb8-7401-4476-80b5-379ecbd068c6', {
     *         showcopyright: false, shownavigation: false,
     *         boundingbox: [-5, 5, 5, -5], axis:true,
     *         defaultAxes: {
     *             x: {
     *               name: 'Distance (mi)',
     *               withLabel: true,
     *               label: {
     *                 position: 'rt',
     *                 offset: [-5, 15],
     *                 anchorX: 'right'
     *               }
     *             },
     *             y: {
     *               withLabel: true,
     *               name: 'Y',
     *               label: {
     *                 position: 'rt',
     *                 offset: [-20, -5],
     *                 anchorY: 'top'
     *               }
     *             }
     *         }
     *     });
     *
     *     })();
     *
     * <\/script><pre>
     *
     * @example
     *  // Display ticks labels as fractions
     *  var board = JXG.JSXGraph.initBoard('jxgbox', {
     *      boundingbox: [-1.2, 2.3, 1.2, -2.3],
     *      axis: true,
     *      defaultAxes: {
     *          x: {
     *              ticks: {
     *                  label: {
     *                      useMathJax: true,
     *                      display: 'html',
     *                      toFraction: true
     *                  }
     *              }
     *          },
     *          y: {
     *              ticks: {
     *                  label: {
     *                      useMathJax: true,
     *                      display: 'html',
     *                      toFraction: true
     *                  }
     *              }
     *          }
     *      }
     *  });
     *
     * </pre><div id="JXG484d2f00-c853-4acb-a8bd-46a9e232d13b" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"><\/script>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG484d2f00-c853-4acb-a8bd-46a9e232d13b',
     *             {boundingbox: [-1.2, 2.3, 1.2, -2.3],
     *              axis: true, showcopyright: false, shownavigation: true,
     *                 defaultAxes: {
     *                     x: {
     *                         ticks: {
     *                             label: {
     *                                 useMathJax: true,
     *                                 display: 'html',
     *                                 toFraction: true
     *                             }
     *                         }
     *                     },
     *                     y: {
     *                         ticks: {
     *                             label: {
     *                                 useMathJax: true,
     *                                 display: 'html',
     *                                 toFraction: true
     *                             }
     *                         }
     *                     }
     *                 }
     *             });
     *     })();
     *
     * <\/script><pre>
     *
     */
    defaultAxes: {
      x: {
        name: "x",
        fixed: true,
        ticks: {
          label: {
            visible: "inherit",
            anchorX: "middle",
            anchorY: "top",
            fontSize: 12,
            offset: [0, -3]
          },
          tickEndings: [0, 1],
          majorTickEndings: [1, 1],
          drawZero: false,
          needsRegularUpdate: false,
          visible: "inherit"
        }
      },
      y: {
        name: "y",
        fixed: true,
        ticks: {
          label: {
            visible: "inherit",
            anchorX: "right",
            anchorY: "middle",
            fontSize: 12,
            offset: [-6, 0]
          },
          tickEndings: [1, 0],
          majorTickEndings: [1, 1],
          drawZero: false,
          needsRegularUpdate: false,
          visible: "inherit"
        }
      }
    },
    /**
     * Description string for the board.
     * Primarily used in an invisible text element which is adressed by
     * the attribute 'aria-describedby' from the JSXGraph container.
     * JSXGraph creates a new div-element with id "{containerid}_ARIAdescription"
     * containing this string.
     *
     * @name JXG.Board#description
     * @see JXG.Board#title
     * @type String
     * @default ''
     *
     */
    description: "",
    /**
     * Supply the document object. Defaults to window.document
     *
     * @name JXG.Board#document
     * @type Object
     * @description DOM object
     * @default false (meaning window.document)
     */
    document: false,
    /**
     * Control the possibilities for dragging objects.
     *
     * Possible sub-attributes with default values are:
     * <pre>
     * drag: {
     *   enabled: true   // Allow dragging
     * }
     * </pre>
     *
     * @name JXG.Board#drag
     * @type Object
     * @default <tt>{enabled: true}</tt>
     */
    drag: {
      enabled: true
    },
    /**
     * Attribute(s) to control the fullscreen icon. The attribute "showFullscreen"
     * controls if the icon is shown.
     * The following attribute(s) can be set:
     * <ul>
     *  <li> symbol (String): Unicode symbol which is shown in the navigation bar.  Default: svg code for '\u26f6', other
     * possibilities are the unicode symbols '\u26f6' and '\u25a1'. However, '\u26f6' is not supported by MacOS and iOS.
     *  <li> scale (number between 0 and 1): Relative size of the larger side of the JSXGraph board in the fullscreen window. 1.0 gives full width or height.
     * Default value is 0.85.
     *  <li> id (String): Id of the HTML element which is brought to full screen or null if the JSXgraph div is taken.
     * It may be an outer div element, e.g. if the old aspect ratio trick is used. Default: null, i.e. use the JSXGraph div.
     * </ul>
     *
     * @example
     * var board = JXG.JSXGraph.initBoard('35bec5a2-fd4d-11e8-ab14-901b0e1b8723',
     *             {boundingbox: [-8, 8, 8,-8], axis: true,
     *             showcopyright: false,
     *             showFullscreen: true,
     *             fullscreen: {
     *                  symbol: '\u22c7',
     *                  scale: 0.95
     *              }
     *             });
     * var pol = board.create('polygon', [[0, 1], [3,4], [1,-4]], {fillColor: 'yellow'});
     *
     * </pre><div id="JXGa35bec5a2-fd4d-11e8-ab14-901b0e1b8723" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGa35bec5a2-fd4d-11e8-ab14-901b0e1b8723',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false,
     *              showFullscreen: true,
     *              fullscreen: {
     *                  symbol: '\u22c7',
     *                  scale: 0.95
     *                  }
     *             });
     *     var pol = board.create('polygon', [[0, 1], [3,4], [1,-4]], {fillColor: 'yellow'});
     *     })();
     *
     * <\/script><pre>
     *
     * @name JXG.Board#fullscreen
     * @default svg code
     * @see JXG.Board#showFullscreen
     * @see JXG.AbstractRenderer#drawNavigationBar
     * @type Object
     */
    fullscreen: {
      symbol: '<svg height="1em" width="1em" version="1.1" viewBox="10 10 18 18"><path fill="#666" d="m 10,16 2,0 0,-4 4,0 0,-2 L 10,10 l 0,6 0,0 z"></path><path fill="#666" d="m 20,10 0,2 4,0 0,4 2,0 L 26,10 l -6,0 0,0 z"></path><path fill="#666" d="m 24,24 -4,0 0,2 L 26,26 l 0,-6 -2,0 0,4 0,0 z"></path><path fill="#666" d="M 12,20 10,20 10,26 l 6,0 0,-2 -4,0 0,-4 0,0 z"></path></svg>',
      // symbol: '\u26f6', // '\u26f6' (not supported by MacOS),
      scale: 0.85,
      id: null
    },
    /**
     * If set true and
     * hasPoint() is true for both an element and it's label,
     * the element (and not the label) is taken as drag element.
     * <p>
     * If set false and hasPoint() is true for both an element and it's label,
     * the label is taken (if it is on a higher layer than the element)
     * <p>
     * Meanwhile, this feature might be irrelevant.
     * @name JXG.Board#ignoreLabels
     * @type Booelan
     * @default true
     */
    ignoreLabels: true,
    /**
     * Support for internationalization of number formatting. This affects
     * <ul>
     *  <li> axis labels
     *  <li> infobox
     *  <li> texts consisting of numbers only
     *  <li> smartlabel elements
     *  <li> slider labels
     *  <li> tapemeasure elements
     *  <li> integral element labels
     * </ul>
     * See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat</a>
     * for an overview on the possibilities and the options.
     * <p>
     * User generated texts consisting of texts AND numbers have to be internationalized by the user, see
     * {@link Text#intl}.
     * Language locale and options can be individually controlled for each element by its intl attribute.
     * If no locale is set, the default language of the browser is used.
     *
     * @name JXG.Board#intl
     * @type Object
     * @default <tt>{enabled: false}</tt>
     * @see Integral#label
     * @see Slider#intl
     * @see Text#intl
     * @see Ticks#intl
     * @see JXG.Board.infobox
     *
     * @example
     * // Set the board-wide locale and use individual
     * // options for a text.
     * const board = JXG.JSXGraph.initBoard(BOARDID, {
     *     axis: true,
     *     intl: {
     *         enabled: true,
     *         locale: 'de-DE'
     *     },
     *     boundingbox:[-0.5, 0.5, 0.5, -0.5]
     * });
     *
     * var t = board.create('text', [0.05, 0.2, -Math.PI*100], {
     *         digits: 2,
     *         intl: {
     *                 enabled: true,
     *                 options: {
     *                     style: 'unit',
     *                     unit: 'celsius'
     *                 }
     *             }
     *     });
     *
     * </pre><div id="JXGcbb0305d-92e2-4628-a58a-d0d515c8fec9" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *     var board = JXG.JSXGraph.initBoard('JXGcbb0305d-92e2-4628-a58a-d0d515c8fec9', {
     *         axis: true, showcopyright: false, shownavigation: false,
     *         intl: {
     *             enabled: true,
     *             locale: 'de-DE'
     *         },
     *     boundingbox:[-0.5, 0.5, 0.5, -0.5]
     *     });
     *     var t = board.create('text', [0.05, 0.2, -Math.PI*100], {
     *         digits: 2,
     *         intl: {
     *                 enabled: true,
     *                 options: {
     *                     style: 'unit',
     *                     unit: 'celsius'
     *                 }
     *             }
     *     });
     *
     *     })();
     *
     * <\/script><pre>
     *
     * @example
     * // Here, locale is disabled in general, but enabled for the horizontal
     * // axis and the infobox.
     * const board = JXG.JSXGraph.initBoard(BOARDID, {
     *     boundingbox: [-0.5, 0.5, 0.5, -0.5],
     *     intl: {
     *         enabled: false,
     *         locale: 'de-DE'
     *     },
     *     keepaspectratio: true,
     *     axis: true,
     *     defaultAxes: {
     *         x: {
     *             ticks: {
     *                 intl: {
     *                         enabled: true,
     *                         options: {
     *                             style: 'unit',
     *                             unit: 'kilometer-per-hour',
     *                             unitDisplay: 'narrow'
     *                         }
     *                 }
     *             }
     *         },
     *         y: {
     *             ticks: {
     *             }
     *         }
     *     },
     *     infobox: {
     *         fontSize: 12,
     *         intl: {
     *             enabled: true,
     *             options: {
     *                 minimumFractionDigits: 4,
     *                 maximumFractionDigits: 5
     *             }
     *         }
     *     }
     * });
     *
     * var p = board.create('point', [0.1, 0.1], {});
     *
     * </pre><div id="JXG07d5d95c-9324-4fc4-aad3-098e433f195f" class="jxgbox" style="width: 600px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *     var board = JXG.JSXGraph.initBoard('JXG07d5d95c-9324-4fc4-aad3-098e433f195f', {
     *         boundingbox: [-0.5, 0.5, 0.5, -0.5], showcopyright: false, shownavigation: false,
     *         intl: {
     *             enabled: false,
     *             locale: 'de-DE'
     *         },
     *         keepaspectratio: true,
     *         axis: true,
     *         defaultAxes: {
     *             x: {
     *                 ticks: {
     *                     intl: {
     *                             enabled: true,
     *                             options: {
     *                                 style: 'unit',
     *                                 unit: 'kilometer-per-hour',
     *                                 unitDisplay: 'narrow'
     *                             }
     *                     }
     *                 }
     *             },
     *             y: {
     *                 ticks: {
     *                 }
     *             }
     *         },
     *         infobox: {
     *             fontSize: 12,
     *             intl: {
     *                 enabled: true,
     *                 options: {
     *                     minimumFractionDigits: 4,
     *                     maximumFractionDigits: 5
     *                 }
     *             }
     *         }
     *     });
     *
     *     var p = board.create('point', [0.1, 0.1], {});
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    intl: {
      enabled: false
    },
    /**
     * If set to true, the ratio between horizontal and vertical unit sizes
     * stays constant - independent of size changes of the hosting HTML div element.
     * <p>
     * If the aspect ration of the hosting div changes, JSXGraphs will change
     * the user supplied bounding box accordingly.
     * This is necessary if circles should look like circles and not
     * like ellipses. It is recommended to set keepAspectRatio = true
     * for geometric applets.
     * <p>
     * For function plotting keepAspectRatio = false
     * might be the better choice.
     *
     * @name JXG.Board#keepAspectRatio
     * @see JXG.Board#boundingBox
     * @see JXG.Board#maxBoundingBox
     * @see JXG.Board#setBoundingBox
     * @type Boolean
     * @default false
     */
    keepAspectRatio: false,
    /**
     * Control using the keyboard to change the construction.
     * <ul>
     * <li> enabled: true / false
     * <li> dx: horizontal shift amount per key press
     * <li> dy: vertical shift amount per key press
     * <li> panShift: zoom if shift key is pressed
     * <li> panCtrl: zoom if ctrl key is pressed
     * </ul>
     *
     * @example
     * var board = JXG.JSXGraph.initBoard("jxgbox", {boundingbox: [-5,5,5,-5],
     *     axis: true,
     *     showCopyright:true,
     *     showNavigation:true,
     *     keyboard: {
     *         enabled: true,
     *         dy: 30,
     *         panShift: true,
     *         panCtrl: false
     *     }
     * });
     *
     * </pre><div id="JXGb1d3aab6-ced2-4fe9-8fa5-b0accc8c7266" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGb1d3aab6-ced2-4fe9-8fa5-b0accc8c7266',
     *             {boundingbox: [-5,5,5,-5],
     *         axis: true,
     *         showCopyright:true,
     *         showNavigation:true,
     *         keyboard: {
     *             enabled: true,
     *             dy: 30,
     *             panShift: true,
     *             panCtrl: false
     *         }
     *     });
     *
     *     })();
     *
     * <\/script><pre>
     *
     *
     * @see JXG.Board#keyDownListener
     * @see JXG.Board#keyFocusInListener
     * @see JXG.Board#keyFocusOutListener
     *
     * @name JXG.Board#keyboard
     * @type Object
     * @default <tt>{enabled: true, dx: 10, dy:10, panShift: true, panCtrl: false}</tt>
     */
    keyboard: {
      enabled: true,
      dx: 10,
      dy: 10,
      panShift: true,
      panCtrl: false
    },
    /**
     * If enabled, user activities are logged in array "board.userLog".
     *
     * @name JXG.Board#logging
     * @type Object
     * @default <tt>{enabled: false}</tt>
     *
     * @example
     * var board = JXG.JSXGraph.initBoard(BOARDID,
     *          {
     *              boundingbox: [-8, 8, 8,-8],
     *              axis: true,
     *              logging: {enabled: true},
     *              showcopyright: false,
     *              shownavigation: false
     *          });
     * var A = board.create('point', [-4, 0], { name: 'A' });
     * var B = board.create('point', [1, 2], { name: 'B' });
     * var showUserLog = function() {
     *     var txt = '';
     *
     *     for (let i = 0; i < board.userLog.length; i++) {
     *         txt += JSON.stringify(board.userLog[i]) + '\n';
     *     }
     *     alert(txt);
     * };
     * var but = board.create('button', [4, 4, 'Show user log', showUserLog]);
     *
     * </pre><div id="JXGe152375c-f478-41aa-a9e6-e104403fc75d" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGe152375c-f478-41aa-a9e6-e104403fc75d',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, logging: {enabled: true},
     *              showcopyright: false, shownavigation: false});
     *     var A = board.create('point', [-4, 0], { name: 'A' });
     *     var B = board.create('point', [1, 2], { name: 'B' });
     *     var showUserLog = function() {
     *         var txt = '';
     *
     *         for (let i = 0; i < board.userLog.length; i++) {
     *             txt += JSON.stringify(board.userLog[i]) + '\n';
     *         }
     *         alert(txt);
     *     };
     *     var but = board.create('button', [4, 4, 'Show user log', showUserLog]);
     *
     *     })();
     *
     * <\/script><pre>
     *
     *
     * @see JXG.Board#userLog
     */
    logging: {
      enabled: false
    },
    /**
     * Change redraw strategy in SVG rendering engine.
     * <p>
     * This optimization seems to be <b>obsolete</b> in newer browsers (from 2021 on, at least)
     * and even slow down the constructions. Therefore, the default is set to 'none' since v1.2.4.
     * <p>
     * If set to 'svg', before every redrawing of the JSXGraph construction
     * the SVG sub-tree of the DOM tree is taken out of the DOM.
     *
     * If set to 'all', before every redrawing of the JSXGraph construction the
     * complete DOM tree is taken out of the DOM.
     * If set to 'none' the redrawing is done in-place.
     *
     * Using 'svg' or 'all' speeds up the update process considerably. The risk
     * is that if there is an exception, only a white div or window is left.
     *
     *
     * @name JXG.Board#minimizeReflow
     * @type String
     * @default 'none'
     */
    minimizeReflow: "none",
    /**
     * Maximal bounding box of the visible area in user coordinates.
     * It is an array consisting of four values:
     * [x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>]
     *
     * The bounding box of the canvas must be inside of this maximal
     * bounding box.
     *
     * @name JXG.Board#maxBoundingBox
     * @type Array
     * @see JXG.Board#boundingBox
     * @default [-Infinity, Infinity, Infinity, -Infinity]
     *
     * @example
     * var board = JXG.JSXGraph.initBoard('jxgbox', {
     *         boundingBox: [-5, 5, 5, -5],
     *         maxBoundingBox: [-8, 8, 8, -8],
     *         pan: {enabled: true},
     *         axis: true
     *     });
     *
     * </pre><div id="JXG065e2750-217c-48ed-a52b-7d7df6de7055" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG065e2750-217c-48ed-a52b-7d7df6de7055', {
     *             showcopyright: false, shownavigation: false,
     *             boundingbox: [-5,5,5,-5],
     *             maxboundingbox: [-8,8,8,-8],
     *             pan: {enabled: true},
     *             axis:true
     *         });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    maxBoundingBox: [-Infinity, Infinity, Infinity, -Infinity],
    /**
     * Maximum frame rate of the board, i.e. maximum number of updates per second
     * triggered by move events.
     *
     * @name JXG.Board#maxFrameRate
     * @type Number
     * @default 40
     */
    maxFrameRate: 40,
    /**
     * Maximum number of digits in automatic label generation.
     * For example, if set to 1 automatic point labels end at "Z".
     * If set to 2, point labels end at "ZZ".
     *
     * @name JXG.Board#maxNameLength
     * @see JXG.Board#generateName
     * @type Number
     * @default 1
     */
    maxNameLength: 1,
    /**
     * Element which listens to move events of the pointing device.
     * This allows to drag elements of a JSXGraph construction outside of the board.
     * Especially, on mobile devices this enhances the user experience.
     * However, it is recommended to allow dragging outside of the JSXGraph board only
     * in certain constructions where users may not "loose" points outside of the board.
     * In such a case, points may become unreachable.
     * <p>
     * A situation where dragging outside of the board is uncritical is for example if
     * only sliders are used to interact with the construction.
     * <p>
     * Possible values for this attributes are:
     * <ul>
     * <li> an element specified by document.getElementById('some id');
     * <li> null: to use the JSXGraph container div element
     * <li> document
     * </ul>
     * <p>
     * Since the introduction of this attribute "moveTarget", the value "document" has become sort of
     * default on touch devices like smartphones. However, it is no longer the case that the document listens to
     * move events, but there is the new feature "setPointerCapture", which is also implicitly enabled on certain devices.
     * In future versions, JSXGraph may adopt this new standard and distinguish only two cases:
     * <ul>
     * <li>null: no pointerCapture
     * <li>document: use pointerCapture
     * </ul>
     * <p>
     * This attribute is immutable.
     * It can be changed as follows:
     *
     * @example
     * board.setAttribute({moveTarget: null});
     * board.removeEventHandlers();
     * board.addEventHandlers();
     *
     * @name JXG.Board#moveTarget
     * @type Object
     * @description HTML node or document
     * @default null
     *
     * @example
     *     var board = JXG.JSXGraph.initBoard('jxgbox', {
     *         boundingbox: [-5,5,5,-5],
     *         axis: true,
     *         moveTarget: document
     *     });
     *
     * </pre><div id="JXG973457e5-c63f-4516-8570-743f2cc560e1" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG973457e5-c63f-4516-8570-743f2cc560e1',
     *             {boundingbox: [-5,5,5,-5],
     *             axis: true,
     *             moveTarget: document
     *         });
     *
     *     })();
     *
     * <\/script><pre>
     *
     *
     */
    moveTarget: null,
    /**
     * A number that will be added to the absolute position of the board used in mouse coordinate
     * calculations in {@link JXG.Board#getCoordsTopLeftCorner}.
     *
     * @name JXG.Board#offsetX
     * @see JXG.Board#offsetY
     * @type Number
     * @default 0
     */
    offsetX: 0,
    /**
     * A number that will be added to the absolute position of the board used in mouse coordinate
     * calculations in {@link JXG.Board#getCoordsTopLeftCorner}.
     *
     * @name JXG.Board#offsetY
     * @see JXG.Board#offsetX
     * @type Number
     * @default 0
     */
    offsetY: 0,
    /**
     * Control the possibilities for panning interaction (i.e. moving the origin).
     *
     * Possible sub-attributes with default values are:
     * <pre>
     * pan: {
     *   enabled: true   // Allow panning
     *   needTwoFingers: false, // panning is done with two fingers on touch devices
     *   needShift: true, // mouse panning needs pressing of the shift key
     * }
     * </pre>
     *
     * @name JXG.Board#pan
     * @see JXG.Board#browserPan
     *
     * @type Object
     */
    pan: {
      enabled: true,
      needShift: true,
      needTwoFingers: false
    },
    /**
     * Allow user interaction by registering pointer events (including mouse and
     * touch events), fullscreen, keyboard, resize, and zoom events.
     * The latter events are essentially mouse wheel events.
     * Decide if JSXGraph listens to these events.
     * <p>
     * Using a Boolean value turns on all events (or not), supplying an object of
     * the form
     * <pre>
     *  {
     *     fullscreen: true / false,
     *     keyboard: true / false,
     *     pointer: true / false,
     *     resize: true / false,
     *     wheel: true / false
     *  }
     * </pre>
     * activates individual event handlers. If an event is NOT given,
     * it will be activated.
     * <p>This attribute is immutable. Please use
     * {@link JXG.Board#addEventHandlers()} and
     * {@link JXG.Board#removeEventHandlers()} directly.
     *
     * @name JXG.Board#registerEvents
     * @see JXG.Board#keyboard
     * @see JXG.Board#registerResizeEvent
     * @see JXG.Board#registerFullscreenEvent
     * @type Boolean
     * @default true
     */
    registerEvents: true,
    // /**
    //  * Listen to fullscreen event.
    //  *
    //  * <p>This attribute is immutable. Please use
    //  * {@link JXG.Board#addFullscreenEventHandlers()} and
    //  * {@link JXG.Board#removeEventHandlers()} directly.
    //  *
    //  * @name JXG.Board#registerFullscreenEvent
    //  * @see JXG.Board#registerEvents
    //  * @see JXG.Board#registerResizeEvent
    //  * @type Boolean
    //  * @default true
    //  */
    // registerFullscreenEvent: true,
    // /**
    //  * Listen to resize events, i.e. start "resizeObserver" or handle the resize event with
    //  * "resizeListener". This is independent from the mouse, touch, pointer events.
    //  *
    //  * <p>This attribute is immutable. Please use
    //  * {@link JXG.Board#addResizeEventHandlers()} and
    //  * {@link JXG.Board#removeEventHandlers()} directly.
    //  * <p>
    //  * This attribute just starts a resizeObserver. If the resizeObserver reacts
    //  * to size changed is controled wuth {@link JXG.Board#resize}.
    //  *
    //  * @name JXG.Board#registerResizeEvent
    //  * @see JXG.Board#resize
    //  * @see JXG.Board#registerEvents
    //  * @see JXG.Board#registerFullscreenEvent
    //  * @type Boolean
    //  * @default true
    //  */
    // registerResizeEvent: true,
    /**
     * Default rendering engine. Possible values are 'svg', 'canvas', 'vml', 'no', or 'auto'.
     * If the rendering engine is not available JSXGraph tries to detect a different engine.
     *
     * <p>
     * In case of 'canvas' it is advisable to call 'board.update()' after all elements have been
     * constructed. This ensures that all elements are drawn with their intended visual appearance.
     *
     * <p>
     * This attribute is immutable.
     *
     * @name JXG.Board#renderer
     * @type String
     * @default 'auto'
     */
    renderer: "auto",
    /**
     * Control if JSXGraph reacts to resizing of the JSXGraph container element
     * by the user / browser.
     * The attribute "throttle" determines the minimal time in msec between to
     * resize calls.
     *
     * @see JXG.Board#startResizeObserver
     * @see JXG.Board#resizeListener
     *
     * @name JXG.Board#resize
     * @type Object
     * @default <tt>{enabled: true, throttle: 10}</tt>
     *
     * @example
     *     var board = JXG.JSXGraph.initBoard('jxgbox', {
     *         boundingbox: [-5,5,5,-5],
     *         keepAspectRatio: true,
     *         axis: true,
     *         resize: {enabled: true, throttle: 200}
     *     });
     *
     * </pre><div id="JXGb55d4608-5d71-4bc3-b332-18c15fbda8c3" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGb55d4608-5d71-4bc3-b332-18c15fbda8c3', {
     *             boundingbox: [-5,5,5,-5],
     *             keepAspectRatio: true,
     *             axis: true,
     *             resize: {enabled: true, throttle: 200}
     *         });
     *
     *     })();
     *
     * <\/script><pre>
     *
     *
     */
    resize: {
      enabled: true,
      throttle: 10
    },
    /**
     * Attributes to control the screenshot function.
     * The following attributes can be set:
     * <ul>
     *  <li>scale: scaling factor (default=1.0)
     *  <li>type: format of the screenshot image. Default: png
     *  <li>symbol: Unicode symbol which is shown in the navigation bar. Default: '\u2318'
     *  <li>css: CSS rules to format the div element containing the screen shot image
     *  <li>cssButton: CSS rules to format the close button of the div element containing the screen shot image
     * </ul>
     * The screenshot will fail if the board contains text elements or foreign objects
     * containing SVG again.
     *
     * @name JXG.Board#screenshot
     * @type Object
     */
    screenshot: {
      scale: 1,
      type: "png",
      symbol: "\u2318",
      //'\u22b9', //'\u26f6',
      css: "background-color:#eeeeee; opacity:1.0; border:2px solid black; border-radius:10px; text-align:center",
      cssButton: "padding: 4px 10px; border: solid #356AA0 1px; border-radius: 5px; position: absolute; right: 2ex; top: 2ex; background-color: rgba(255, 255, 255, 0.3);"
    },
    /**
     * Control the possibilities for a selection rectangle.
     * Starting a selection event triggers the "startselecting" event.
     * When the mouse pointer is released, the "stopselecting" event is fired.
     * The "stopselecting" event is supplied by the user.
     * <p>
     * So far it works in SVG renderer only.
     * <p>
     * Possible sub-attributes with default values are:
     * <pre>
     * selection: {
     *   enabled: false,
     *   name: 'selectionPolygon',
     *   needShift: false,  // mouse selection needs pressing of the shift key
     *   needCtrl: true,    // mouse selection needs pressing of the shift key
     *   fillColor: '#ffff00'
     * }
     * </pre>
     * <p>
     * Board events triggered by selection manipulation:
     * 'startselecting', 'stopselecting', 'mousestartselecting', 'mousestopselecting',
     * 'pointerstartselecting', 'pointerstopselecting', 'touchstartselecting', 'touchstopselecting'.
     *
     * @example
     * board.on('stopselecting', function(){
     *     var box = board.stopSelectionMode(),
     *     // bbox has the coordinates of the selectionr rectangle.
     *     // Attention: box[i].usrCoords have the form [1, x, y], i.e.
     *     // are homogeneous coordinates.
     *     bbox = box[0].usrCoords.slice(1).concat(box[1].usrCoords.slice(1));
     *     // Set a new bounding box
     *     board.setBoundingBox(bbox, false);
     * });
     *
     * @name JXG.Board#selection
     *
     * @see JXG.Board#startSelectionMode
     * @see JXG.Board#stopSelectionMode
     *
     * @type Object
     * @default
     */
    selection: {
      enabled: false,
      name: "selectionPolygon",
      needShift: false,
      needCtrl: true,
      fillColor: "#ffff00",
      // immutable:
      visible: false,
      withLines: false,
      vertices: {
        visible: false
      }
    },
    /**
     * Show a button which allows to clear all traces of a board.
     * This button can be accessed by JavaScript or CSS with
     * the ID <tt>"{board_id}_navigation_button_cleartraces"</tt> or by the CSS classes
     * <tt>JXG_navigation_button"</tt> or
     * <tt>JXG_navigation_button_cleartraces"</tt>.
     *
     * @name JXG.Board#showClearTraces
     * @type Boolean
     * @default false
     * @see JXG.AbstractRenderer#drawNavigationBar
     */
    showClearTraces: false,
    /**
     * Show copyright string in canvas.
     *
     * @name JXG.Board#showCopyright
     * @type Boolean
     * @default true
     */
    showCopyright: true,
    /**
     * Show a button in the navigation bar to start fullscreen mode.
     * This button can be accessed by JavaScript or CSS with
     * the ID <tt>"{board_id}_navigation_button_fullscreen"</tt> or by the CSS classes
     * <tt>JXG_navigation_button"</tt> or
     * <tt>JXG_navigation_button_fullscreen"</tt>.
     *
     * @name JXG.Board#showFullscreen
     * @type Boolean
     * @see JXG.Board#fullscreen
     * @default false
     * @see JXG.AbstractRenderer#drawNavigationBar
     * @see JXG.AbstractRenderer#drawNavigationBar
     */
    showFullscreen: false,
    /**
     * If true, the infobox is shown on mouse/pen over for all points
     * which have set their attribute showInfobox to 'inherit'.
     * If a point has set its attribute showInfobox to false or true,
     * that value will have priority over this value.
     *
     * @name JXG.Board#showInfobox
     * @see Point#showInfobox
     * @type Boolean
     * @default true
     */
    showInfobox: true,
    /**
     * Display of navigation arrows and zoom buttons in the navigation bar.
     * <p>
     * The navigation bar has the
     * the ID <tt>"{board_id}_navigation"</tt> and the CSS class
     * <tt>JXG_navigation"</tt>.
     * The individual buttons can be accessed by JavaScript or CSS with
     * the ID <tt>"{board_id}_navigation_button_{type}"</tt> or by the CSS classes
     * <tt>JXG_navigation_button"</tt> or
     * <tt>JXG_navigation_button_{type}"</tt>, where <tt>{type}</tt>
     * is one of <tt>left</tt>, <tt>right</tt>, or <tt>up</tt>, <tt>down</tt>,
     * <tt>in</tt>, <tt>100</tt>, or <tt>out</tt>,
     * <tt>fullscreen</tt>, <tt>screenshot</tt>, <tt>cleartraces</tt>, <tt>reload</tt>.
     *
     * @name JXG.Board#showNavigation
     * @type Boolean
     * @default true
     * @see JXG.AbstractRenderer#drawNavigationBar
     */
    showNavigation: true,
    /**
     * Show a button in the navigation bar to force reload of a construction.
     * Works only with the JessieCode tag.
     * This button can be accessed by JavaScript or CSS with
     * the ID <tt>"{board_id}_navigation_button_reload"</tt> or by the CSS classes
     * <tt>JXG_navigation_button"</tt> or
     * <tt>JXG_navigation_button_reload"</tt>.
     *
     * @name JXG.Board#showReload
     * @type Boolean
     * @default false
     * @see JXG.AbstractRenderer#drawNavigationBar
     */
    showReload: false,
    /**
     * Show a button in the navigation bar to enable screenshots.
     * This button can be accessed by JavaScript or CSS with
     * the ID <tt>"{board_id}_navigation_button_screenshot"</tt> or by the CSS classes
     * <tt>JXG_navigation_button"</tt> or
     * <tt>JXG_navigation_button_screenshot"</tt>.
     *
     * @name JXG.Board#showScreenshot
     * @type Boolean
     * @default false
     * @see JXG.AbstractRenderer#drawNavigationBar
     */
    showScreenshot: false,
    /**
     * Display of zoom buttons in the navigation bar. To show zoom buttons, additionally
     * showNavigation has to be set to true.
     * <p>
     * The individual buttons can be accessed by JavaScript or CSS with
     * the ID <tt>"{board_id}_navigation_button_{type}"</tt> or by the CSS classes
     * <tt>JXG_navigation_button"</tt> or
     * <tt>JXG_navigation_button_{type}"</tt>, where <tt>{type}</tt>
     * is <tt>in</tt>, <tt>100</tt>, or <tt>out</tt>.
     *
     * @name JXG.Board#showZoom
     * @type Boolean
     * @default true
     * @see JXG.AbstractRenderer#drawNavigationBar
     */
    showZoom: true,
    /**
     * If true the first element of the set JXG.board.objects having hasPoint==true is taken as drag element.
     *
     * @name JXG.Board#takeFirst
     * @type Boolean
     * @default false
     */
    takeFirst: false,
    /**
    * If true, when read from a file or string - the size of the div can be changed by the construction text.
    *
    * @name JXG.Board#takeSizeFromFile
    * @type Boolean
    * @default false
    */
    takeSizeFromFile: false,
    /**
     * Set a visual theme for a board. At the moment this attribute is immutable.
     * Available themes are
     * <ul>
     * <li> 'default'
     * <li> 'mono_thin': a black / white theme using thin strokes. Restricted to 2D.
     * </ul>
     *
     * @name JXG.Board#theme
     * @type String
     * @default 'default'
     * @example
     *  const board = JXG.JSXGraph.initBoard('jxgbox', {
     *      boundingbox: [-5, 5, 5, -5], axis: true,
     *      theme: 'mono_thin'
     *  });
     *
     *  var a = board.create('slider', [[1, 4], [3, 4], [-10, 1, 10]]);
     *  var p1 = board.create('point', [1, 2]);
     *  var ci1 = board.create('circle', [p1, 0.7]);
     *  var cu = board.create('functiongraph', ['x^2']);
     *  var l1 = board.create('line', [2, 3, -1]);
     *  var l2 = board.create('line', [-5, -3, -1], { dash: 2 });
     *  var i1 = board.create('intersection', [l1, l2]);
     *  var pol = board.create('polygon', [[1, 0], [4, 0], [3.5, 1]]);
     *  var an = board.create('angle', [pol.vertices[1], pol.vertices[0], pol.vertices[2]]);
     *  var se = board.create('sector', [pol.vertices[1], pol.vertices[2], pol.vertices[0]]);
     *  var ci1 = board.create('circle', [[-3, -3], 0.7], { center: { visible: true } });
     *
     * </pre><div id="JXG1c5f7a2a-176b-4410-ac06-8593f1a09879" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG1c5f7a2a-176b-4410-ac06-8593f1a09879',
     *             {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright: false, shownavigation: false,
     *              theme: 'mono_thin' });
     *
     *    var a = board.create('slider', [[1, 4], [3, 4], [-10, 1, 10]]);
     *    var p1 = board.create('point', [1, 2]);
     *    var ci1 = board.create('circle', [p1, 0.7]);
     *    var cu = board.create('functiongraph', ['x^2']);
     *    var l1 = board.create('line', [2, 3, -1]);
     *    var l2 = board.create('line', [-5, -3, -1], { dash: 2 });
     *    var i1 = board.create('intersection', [l1, l2]);
     *    var pol = board.create('polygon', [[1, 0], [4, 0], [3.5, 1]]);
     *    var an = board.create('angle', [pol.vertices[1], pol.vertices[0], pol.vertices[2]]);
     *    var se = board.create('sector', [pol.vertices[1], pol.vertices[2], pol.vertices[0]]);
     *    var ci1 = board.create('circle', [[-3, -3], 0.7], { center: { visible: true } });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    theme: "default",
    /**
     * Title string for the board.
     * Primarily used in an invisible text element which is adressed by
     * the attribute 'aria-labelledby' from the JSXGraph container.
     * JSXGraph creates a new div-element with id "{containerid}_ARIAlabel"
     * containing this string.
     *
     * @name JXG.Board#title
     * @see JXG.Board#description
     * @type String
     * @default ''
     *
     */
    title: "",
    /**
     *
     * Set a viewport of the board. viewport is determined by an array of the form '[left, top, right, bottom]'.
     * whose entries determine an inner margin (i.e. a padding) of the board. The entries of the array have to be given
     * as numbers or strings. In the latter case the units 'px' or '%' are supported.
     * The viewport can be individually controlled for each element, too.
     *
     * @type {Array|String}
     * @name JXG.Board#viewport
     * @default [0, 0, 0, 0]
     * @see JXG.GeometryElement#viewport
     */
    viewport: [0, 0, 0, 0],
    /**
     * Control the possibilities for zoom interaction.
     *
     * Possible sub-attributes with default values are:
     * <pre>
     * zoom: {
     *   enabled: true,  // turns off zooming completely, if set to false.
     *   factorX: 1.25,  // horizontal zoom factor (multiplied to {@link JXG.Board#zoomX})
     *   factorY: 1.25,  // vertical zoom factor (multiplied to {@link JXG.Board#zoomY})
     *   wheel: true,    // allow zooming by mouse wheel
     *   needShift: true,  // mouse wheel zooming needs pressing of the shift key
     *   min: 0.001,       // minimal values of {@link JXG.Board#zoomX} and {@link JXG.Board#zoomY}, limits zoomOut
     *   max: 1000.0,      // maximal values of {@link JXG.Board#zoomX} and {@link JXG.Board#zoomY}, limits zoomIn
     *
     *   pinch: true,      // pinch-to-zoom gesture for proportional zoom
     *   pinchHorizontal: true, // Horizontal pinch-to-zoom zooms horizontal axis. Only available if keepaspectratio:false
     *   pinchVertical: true,   // Vertical pinch-to-zoom zooms vertical axis only. Only available if keepaspectratio:false
     *   pinchSensitivity: 7    // Sensitivity (in degrees) for recognizing horizontal or vertical pinch-to-zoom gestures.
     * }
     * </pre>
     *
     * If the zoom buttons are visible, zooming by clicking the buttons is still possible, regardless of zoom.enabled:true/false.
     * If this should be prevented, set showZoom:false.
     *
     * Deprecated: zoom.eps which is superseded by zoom.min
     *
     * @name JXG.Board#zoom
     * @type Object
     * @default See above
     * @see JXG.Board#showZoom
     *
     */
    zoom: {
      enabled: true,
      factorX: 1.25,
      factorY: 1.25,
      wheel: true,
      needShift: true,
      min: 1e-4,
      max: 1e4,
      pinch: true,
      pinchHorizontal: true,
      pinchVertical: true,
      pinchSensitivity: 7
    },
    // /**
    //  * Additional zoom factor multiplied to {@link JXG.Board#zoomX} and {@link JXG.Board#zoomY}.
    //  *
    //  * @name JXG.Board#zoomFactor
    //  * @type Number
    //  * @default 1.0
    //  */
    // zoomFactor: 1,
    /**
     * Zoom factor in horizontal direction.
     *
     * @name JXG.Board#zoomX
     * @see JXG.Board#zoomY
     * @type Number
     * @default 1.0
     */
    zoomX: 1,
    /**
     * Zoom factor in vertical direction.
     *
     * @name JXG.Board#zoomY
     * @see JXG.Board#zoomX
     * @type Number
     * @default 1.0
     */
    zoomY: 1
    /**#@-*/
  },
  /**
   * Options that are used by the navigation bar.
   *
   * Default values are
   * <pre>
   * JXG.Option.navbar: {
   *   strokeColor: '#333333',
   *   fillColor: 'transparent',
   *   highlightFillColor: '#aaaaaa',
   *   padding: '2px',
   *   position: 'absolute',
   *   fontSize: '14px',
   *   cursor: 'pointer',
   *   zIndex: '100',
   *   right: '5px',
   *   bottom: '5px'
   * },
   * </pre>
   * These settings are overruled by the CSS class 'JXG_navigation'.
   * @deprecated
   * @type Object
   * @name JXG.Options#navbar
   *
   */
  navbar: {
    strokeColor: "#333333",
    //'#aaaaaa',
    fillColor: "transparent",
    //#f5f5f5',
    highlightFillColor: "#aaaaaa",
    padding: "2px",
    position: "absolute",
    fontSize: "14px",
    cursor: "pointer",
    zIndex: "100",
    right: "5px",
    bottom: "5px"
    //border: 'none 1px black',
    //borderRadius: '4px'
  },
  /*
   *  Generic options used by {@link JXG.GeometryElement}
   */
  elements: {
    /**#@+
     * @visprop
     */
    // This is a meta tag: http://code.google.com/p/jsdoc-toolkit/wiki/MetaTags
    /**
     * Determines the elements border-style.
     * Possible values are:
     * <ul><li>0 for a solid line</li>
     * <li>1 for a dotted line</li>
     * <li>2 for a line with small dashes</li>
     * <li>3 for a line with medium dashes</li>
     * <li>4 for a line with big dashes</li>
     * <li>5 for a line with alternating medium and big dashes and large gaps</li>
     * <li>6 for a line with alternating medium and big dashes and small gaps</li>
     * <li>7 for a dotted line. Needs {@link JXG.GeometryElement#linecap} set to "round" for round dots.</li>
     * </ul>
     * The dash patterns are defined in {@link JXG.AbstractRenderer#dashArray}.
     *
     * @type Number
     * @name JXG.GeometryElement#dash
     * @default 0
     *
     * @see JXG.GeometryElement#lineCap
     * @see JXG.AbstractRenderer#dashArray
     */
    dash: 0,
    /**
     * If true, the dash pattern is multiplied by strokeWidth / 2.
     * @name JXG.GeometryElement#dashScale
     * @type Boolean
     * @default false
     *
     * @see JXG.GeometryElement#dash
     * @see JXG.AbstractRenderer#dashArray
     */
    dashScale: false,
    /**
     * If draft.draft: true the element will be drawn in grey scale colors (as default)
     * to visualize that it's only a draft.
     *
     * @name JXG.GeometryElement#draft
     * @type Object
     * @default <tt>{@link JXG.Options.elements.draft#draft}</tt>
     */
    draft: {
      draft: false,
      strokeColor: "#565656",
      fillColor: "#565656",
      strokeOpacity: 0.8,
      fillOpacity: 0.8,
      strokeWidth: 1
    },
    /**
     * If the element is dragged it will be moved on mousedown or touchstart to the
     * top of its layer. Works only for SVG renderer and for simple elements
     * consisting of one SVG node.
     * @example
     * var li1 = board.create('line', [1, 1, 1], {strokeWidth: 20, dragToTopOfLayer: true});
     * var li2 = board.create('line', [1, -1, 1], {strokeWidth: 20, strokeColor: 'red'});
     *
     * </pre><div id="JXG38449fee-1ab4-44de-b7d1-43caa1f50f86" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG38449fee-1ab4-44de-b7d1-43caa1f50f86',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var li1 = board.create('line', [1, 1, 1], {strokeWidth: 20, dragToTopOfLayer: true});
     *     var li2 = board.create('line', [1, -1, 1], {strokeWidth: 20, strokeColor: 'red'});
     *
     *     })();
     *
     * <\/script><pre>
     *
     * @type Boolean
     * @default false
     * @name JXG.GeometryElement#dragToTopOfLayer
     */
    dragToTopOfLayer: false,
    /**
     * The fill color of this geometry element.
     * @type String
     * @name JXG.GeometryElement#fillColor
     * @see JXG.GeometryElement#highlightFillColor
     * @see JXG.GeometryElement#fillOpacity
     * @see JXG.GeometryElement#highlightFillOpacity
     * @default JXG.palette.red
     */
    fillColor: color_default.palette.red,
    /**
     * Opacity for fill color.
     * @type Number
     * @name JXG.GeometryElement#fillOpacity
     * @see JXG.GeometryElement#fillColor
     * @see JXG.GeometryElement#highlightFillColor
     * @see JXG.GeometryElement#highlightFillOpacity
     * @default 1
     */
    fillOpacity: 1,
    /**
     * If true the element is fixed and can not be dragged around. The element
     * will be repositioned on zoom and moveOrigin events.
     * @type Boolean
     * @default false
     * @name JXG.GeometryElement#fixed
     */
    fixed: false,
    /**
     * If true the element is fixed and can not be dragged around. The element
     * will even stay at its position on zoom and moveOrigin events.
     * Only free elements like points, texts, images, curves can be frozen.
     * For slider elements, the subobjects point1 and point2 have to be "frozen".
     *
     * @type Boolean
     * @default false
     * @name JXG.GeometryElement#frozen
     *
     * @example
     * var txt = board.create('text', [1, 2, 'Hello'], {frozen: true, fontSize: 24});
     * var sli = board.create('slider', [[-4, 4], [-1.5, 4], [-10, 1, 10]], {
     *     name:'a',
     *     point1: {frozen: true},
     *     point2: {frozen: true}
     * });
     *
     * </pre><div id="JXG02f88c9d-8c0a-4174-9219-f0ea43749159" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG02f88c9d-8c0a-4174-9219-f0ea43749159',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var txt = board.create('text', [1, 2, 'Hello'], {frozen: true, fontSize: 24});
     *     var sli = board.create('slider', [[-4, 4], [-1.5, 4], [-10, 1, 10]], {
     *         name:'a',
     *         point1: {frozen: true},
     *         point2: {frozen: true}
     *     });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    frozen: false,
    /**
     * Gradient type. Possible values are 'linear'. 'radial' or null.
     *
     * @example
     *     var a = board.create('slider', [[0, -0.2], [3.5, -0.2], [0, 0, 2 * Math.PI]], {name: 'angle'});
     *     var b = board.create('slider', [[0, -0.4], [3.5, -0.4], [0, 0, 1]], {name: 'offset1'});
     *     var c = board.create('slider', [[0, -0.6], [3.5, -0.6], [0, 1, 1]], {name: 'offset2'});
     *
     *     var pol = board.create('polygon', [[0, 0], [4, 0], [4,4], [0,4]], {
     *                 fillOpacity: 1,
     *                 fillColor: 'yellow',
     *                 gradient: 'linear',
     *                 gradientSecondColor: 'blue',
     *                 gradientAngle: function() { return a.Value(); },
     *                 gradientStartOffset: function() { return b.Value(); },
     *                 gradientEndOffset: function() { return c.Value(); },
     *                 hasInnerPoints: true
     *         });
     *
     * </pre><div id="JXG3d04b5fd-0cd4-4f49-8c05-4e9686cd7ff0" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG3d04b5fd-0cd4-4f49-8c05-4e9686cd7ff0',
     *             {boundingbox: [-1.5, 4.5, 5, -1.5], axis: true, showcopyright: false, shownavigation: false});
     *         var a = board.create('slider', [[0, -0.2], [3.5, -0.2], [0, 0, 2 * Math.PI]], {name: 'angle'});
     *         var b = board.create('slider', [[0, -0.4], [3.5, -0.4], [0, 0, 1]], {name: 'offset1'});
     *         var c = board.create('slider', [[0, -0.6], [3.5, -0.6], [0, 1, 1]], {name: 'offset2'});
     *
     *         var pol = board.create('polygon', [[0, 0], [4, 0], [4,4], [0,4]], {
     *                     fillOpacity: 1,
     *                     fillColor: 'yellow',
     *                     gradient: 'linear',
     *                     gradientSecondColor: 'blue',
     *                     gradientAngle: function() { return a.Value(); },
     *                     gradientStartOffset: function() { return b.Value(); },
     *                     gradientEndOffset: function() { return c.Value(); },
     *                     hasInnerPoints: true
     *             });
     *
     *     })();
     *
     * <\/script><pre>
     *
     * @example
     *     var cx = board.create('slider', [[0, -.2], [3.5, -.2], [0, 0.5, 1]], {name: 'cx, cy'});
     *     var fx = board.create('slider', [[0, -.4], [3.5, -.4], [0, 0.5, 1]], {name: 'fx, fy'});
     *     var o1 = board.create('slider', [[0, -.6], [3.5, -.6], [0, 0.0, 1]], {name: 'offset1'});
     *     var o2 = board.create('slider', [[0, -.8], [3.5, -.8], [0, 1, 1]], {name: 'offset2'});
     *     var r = board.create('slider', [[0, -1], [3.5, -1], [0, 0.5, 1]], {name: 'r'});
     *     var fr = board.create('slider', [[0, -1.2], [3.5, -1.2], [0, 0, 1]], {name: 'fr'});
     *
     *     var pol = board.create('polygon', [[0, 0], [4, 0], [4,4], [0,4]], {
     *                 fillOpacity: 1,
     *                 fillColor: 'yellow',
     *                 gradient: 'radial',
     *                 gradientSecondColor: 'blue',
     *                 gradientCX: function() { return cx.Value(); },
     *                 gradientCY: function() { return cx.Value(); },
     *                 gradientR: function() { return r.Value(); },
     *                 gradientFX: function() { return fx.Value(); },
     *                 gradientFY: function() { return fx.Value(); },
     *                 gradientFR: function() { return fr.Value(); },
     *                 gradientStartOffset: function() { return o1.Value(); },
     *                 gradientEndOffset: function() { return o2.Value(); },
     *                 hasInnerPoints: true
     *     });
     *
     * </pre><div id="JXG6081ca7f-0d09-4525-87ac-325a02fe2225" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG6081ca7f-0d09-4525-87ac-325a02fe2225',
     *             {boundingbox: [-1.5, 4.5, 5, -1.5], axis: true, showcopyright: false, shownavigation: false});
     *         var cx = board.create('slider', [[0, -.2], [3.5, -.2], [0, 0.5, 1]], {name: 'cx, cy'});
     *         var fx = board.create('slider', [[0, -.4], [3.5, -.4], [0, 0.5, 1]], {name: 'fx, fy'});
     *         var o1 = board.create('slider', [[0, -.6], [3.5, -.6], [0, 0.0, 1]], {name: 'offset1'});
     *         var o2 = board.create('slider', [[0, -.8], [3.5, -.8], [0, 1, 1]], {name: 'offset2'});
     *         var r = board.create('slider', [[0, -1], [3.5, -1], [0, 0.5, 1]], {name: 'r'});
     *         var fr = board.create('slider', [[0, -1.2], [3.5, -1.2], [0, 0, 1]], {name: 'fr'});
     *
     *         var pol = board.create('polygon', [[0, 0], [4, 0], [4,4], [0,4]], {
     *                     fillOpacity: 1,
     *                     fillColor: 'yellow',
     *                     gradient: 'radial',
     *                     gradientSecondColor: 'blue',
     *                     gradientCX: function() { return cx.Value(); },
     *                     gradientCY: function() { return cx.Value(); },
     *                     gradientR: function() { return r.Value(); },
     *                     gradientFX: function() { return fx.Value(); },
     *                     gradientFY: function() { return fx.Value(); },
     *                     gradientFR: function() { return fr.Value(); },
     *                     gradientStartOffset: function() { return o1.Value(); },
     *                     gradientEndOffset: function() { return o2.Value(); },
     *                     hasInnerPoints: true
     *         });
     *
     *     })();
     *
     * <\/script><pre>
     *
     *
     * @type String
     * @name JXG.GeometryElement#gradient
     * @see JXG.GeometryElement#gradientSecondColor
     * @see JXG.GeometryElement#gradientSecondOpacity
     * @default null
     */
    gradient: null,
    /**
     * Angle (in radians) of the gradiant in case the gradient is of type 'linear'.
     * If the angle is 0, the first color is on the left and the second color is on the right.
     * If the angle is &pi;/2 the first color is on top and the second color at the
     * bottom.
     * @type Number
     * @name JXG.GeometryElement#gradientAngle
     * @see JXG.GeometryElement#gradient
     * @default 0
     */
    gradientAngle: 0,
    /**
     * From the SVG specification: ‘cx’, ‘cy’ and ‘r’ define the largest (i.e., outermost) circle for the radial gradient.
     * The gradient will be drawn such that the 100% gradient stop is mapped to the perimeter of this largest (i.e., outermost) circle.
     * For radial gradients in canvas this is the value 'x1'.
     * Takes a value between 0 and 1.
     * @type Number
     * @name JXG.GeometryElement#gradientCX
     * @see JXG.GeometryElement#gradient
     * @see JXG.GeometryElement#gradientCY
     * @see JXG.GeometryElement#gradientR
     * @default 0.5
     */
    gradientCX: 0.5,
    /**
     * From the SVG specification: ‘cx’, ‘cy’ and ‘r’ define the largest (i.e., outermost) circle for the radial gradient.
     * The gradient will be drawn such that the 100% gradient stop is mapped to the perimeter of this largest (i.e., outermost) circle.
     * For radial gradients in canvas this is the value 'y1'.
     * Takes a value between 0 and 1.
     * @type Number
     * @name JXG.GeometryElement#gradientCY
     * @see JXG.GeometryElement#gradient
     * @see JXG.GeometryElement#gradientCX
     * @see JXG.GeometryElement#gradientR
     * @default 0.5
     */
    gradientCY: 0.5,
    /**
     * The gradientEndOffset attribute is a number (ranging from 0 to 1) which indicates where the second gradient stop is placed,
     * see the SVG specification for more information.
     * For linear gradients, this attribute represents a location along the gradient vector.
     * For radial gradients, it represents a percentage distance from (fx,fy) to the edge of the outermost/largest circle.
     * @type Number
     * @name JXG.GeometryElement#gradientEndOffset
     * @see JXG.GeometryElement#gradient
     * @see JXG.GeometryElement#gradientStartOffset
     * @default 1.0
     */
    gradientEndOffset: 1,
    /**
     * ‘fx’ and ‘fy’ define the focal point for the radial gradient.
     * The gradient will be drawn such that the 0% gradient stop is mapped to (fx, fy).
     * For radial gradients in canvas this is the value 'x0'.
     * Takes a value between 0 and 1.
     * @type Number
     * @name JXG.GeometryElement#gradientFX
     * @see JXG.GeometryElement#gradient
     * @see JXG.GeometryElement#gradientFY
     * @see JXG.GeometryElement#gradientFR
     * @default 0.5
     */
    gradientFX: 0.5,
    /**
     * y-coordinate of the circle center for the second color in case of gradient 'radial'. (The attribute fy in SVG)
     * For radial gradients in canvas this is the value 'y0'.
     * Takes a value between 0 and 1.
     * @type Number
     * @name JXG.GeometryElement#gradientFY
     * @see JXG.GeometryElement#gradient
     * @see JXG.GeometryElement#gradientFX
     * @see JXG.GeometryElement#gradientFR
     * @default 0.5
     */
    gradientFY: 0.5,
    /**
     * This attribute defines the radius of the start circle of the radial gradient.
     * The gradient will be drawn such that the 0% &lt;stop&gt; is mapped to the perimeter of the start circle.
     * For radial gradients in canvas this is the value 'r0'.
     * Takes a value between 0 and 1.
     * @type Number
     * @name JXG.GeometryElement#gradientFR
     * @see JXG.GeometryElement#gradient
     * @see JXG.GeometryElement#gradientFX
     * @see JXG.GeometryElement#gradientFY
     * @default 0.0
     */
    gradientFR: 0,
    /**
     * From the SVG specification: ‘cx’, ‘cy’ and ‘r’ define the largest (i.e., outermost) circle for the radial gradient.
     * The gradient will be drawn such that the 100% gradient stop is mapped to the perimeter of this largest (i.e., outermost) circle.
     * For radial gradients in canvas this is the value 'r1'.
     * Takes a value between 0 and 1.
     * @type Number
     * @name JXG.GeometryElement#gradientR
     * @see JXG.GeometryElement#gradient
     * @see JXG.GeometryElement#gradientCX
     * @see JXG.GeometryElement#gradientCY
     * @default 0.5
     */
    gradientR: 0.5,
    /**
     * Second color for gradient.
     * @type String
     * @name JXG.GeometryElement#gradientSecondColor
     * @see JXG.GeometryElement#gradient
     * @see JXG.GeometryElement#gradientSecondOpacity
     * @default '#ffffff'
     */
    gradientSecondColor: "#ffffff",
    /**
     * Opacity of second gradient color. Takes a value between 0 and 1.
     * @type Number
     * @name JXG.GeometryElement#gradientSecondOpacity
     * @see JXG.GeometryElement#gradient
     * @see JXG.GeometryElement#gradientSecondColor
     * @default 1
     */
    gradientSecondOpacity: 1,
    /**
     * The gradientStartOffset attribute is a number (ranging from 0 to 1) which indicates where the first gradient stop is placed,
     * see the SVG specification for more information.
     * For linear gradients, this attribute represents a location along the gradient vector.
     * For radial gradients, it represents a percentage distance from (fx,fy) to the edge of the outermost/largest circle.
     * @type Number
     * @name JXG.GeometryElement#gradientStartOffset
     * @see JXG.GeometryElement#gradient
     * @see JXG.GeometryElement#gradientEndOffset
     * @default 0.0
     */
    gradientStartOffset: 0,
    /**
     * @type Boolean
     * @default true
     * @name JXG.GeometryElement#highlight
     */
    highlight: true,
    /**
     * The fill color of the given geometry element when the mouse is pointed over it.
     * @type String
     * @name JXG.GeometryElement#highlightFillColor
     * @see JXG.GeometryElement#fillColor
     * @see JXG.GeometryElement#fillOpacity
     * @see JXG.GeometryElement#highlightFillOpacity
     * @default 'none'
     */
    highlightFillColor: "none",
    /**
     * Opacity for fill color when the object is highlighted.
     * @type Number
     * @name JXG.GeometryElement#highlightFillOpacity
     * @see JXG.GeometryElement#fillColor
     * @see JXG.GeometryElement#highlightFillColor
     * @see JXG.GeometryElement#fillOpacity
     * @default 1
     */
    highlightFillOpacity: 1,
    /**
     * The stroke color of the given geometry element when the user moves the mouse over it.
     * @type String
     * @name JXG.GeometryElement#highlightStrokeColor
     * @see JXG.GeometryElement#strokeColor
     * @see JXG.GeometryElement#strokeWidth
     * @see JXG.GeometryElement#strokeOpacity
     * @see JXG.GeometryElement#highlightStrokeOpacity
     * @default '#c3d9ff'
     */
    highlightStrokeColor: "#c3d9ff",
    /**
     * Opacity for stroke color when the object is highlighted.
     * @type Number
     * @name JXG.GeometryElement#highlightStrokeOpacity
     * @see JXG.GeometryElement#strokeColor
     * @see JXG.GeometryElement#highlightStrokeColor
     * @see JXG.GeometryElement#strokeWidth
     * @see JXG.GeometryElement#strokeOpacity
     * @default 1
     */
    highlightStrokeOpacity: 1,
    /**
     * Width of the element's stroke when the mouse is pointed over it.
     * @type Number
     * @name JXG.GeometryElement#highlightStrokeWidth
     * @see JXG.GeometryElement#strokeColor
     * @see JXG.GeometryElement#highlightStrokeColor
     * @see JXG.GeometryElement#strokeOpacity
     * @see JXG.GeometryElement#highlightStrokeOpacity
     * @see JXG.GeometryElement#highlightFillColor
     * @default 2
     */
    highlightStrokeWidth: 2,
    /**
     * @name JXG.GeometryElement#isLabel
     * @default false
     * @private
    */
    // By default, an element is not a label. Do not change this.
    isLabel: false,
    /**
     * Display layer which will contain the element.
     * @name JXG.GeometryElement#layer
     * @see JXG.Options#layer
     * @default See {@link JXG.Options#layer}
     */
    layer: 0,
    /**
     * Line endings (linecap) of a stroke element, i.e. line, circle, curve.
     * Possible values are:
     * <ul>
     * <li> 'butt',
     * <li> 'round',
     * <li> 'square'.
     * </ul>
     * Not available for VML renderer.
     *
     * @name JXG.GeometryElement#lineCap
     * @type String
     * @default 'butt'
     */
    lineCap: "butt",
    /**
     * If this is set to true, the element is updated in every update
     * call of the board. If set to false, the element is updated only after
     * zoom events or more generally, when the bounding box has been changed.
     * Examples for the latter behavior should be axes.
     * @type Boolean
     * @default true
     * @see JXG.GeometryElement#needsRegularUpdate
     * @name JXG.GeometryElement#needsRegularUpdate
     */
    needsRegularUpdate: true,
    /**
     * Precision options for JSXGraph elements.
     * This attributes takes either the value 'inherit' or an object of the form:
     * <pre>
     * precision: {
     *      touch: 30,
     *      mouse: 4,
     *      pen: 4
     * }
     * </pre>
     *
     * In the first case, the global, JSXGraph-wide values of JXGraph.Options.precision
     * are taken.
     *
     * @type {String|Object}
     * @name JXG.GeometryElement#precision
     * @see JXG.Options#precision
     * @default 'inherit'
     */
    precision: "inherit",
    /**
     * A private element will be inaccessible in certain environments, e.g. a graphical user interface.
     *
     * @name JXG.GeometryElement#priv
     * @type Boolean
     * @default false
     */
    priv: false,
    /**
     * Determines whether two-finger manipulation may rotate this object.
     * If set to false, the object can only be scaled and translated.
     * <p>
     * In case the element is a polygon or line and it has the attribute "rotatable:false",
     * moving the element with two fingers results in a rotation or translation.
     * <p>
     * If an element is set to be neither scalable nor rotatable, it can only be translated.
     * <p>
     * In case of a polygon, scaling is only possible if <i>no</i> vertex has snapToGrid or snapToPoints
     * enabled and no vertex is fixed by some other constraint. Also, the polygon itself has to have
     * snapToGrid disabled.
     *
     * @type Boolean
     * @default true
     * @name JXG.GeometryElement#rotatable
     * @see JXG.GeometryElement#scalable
     */
    rotatable: true,
    /**
     * Determines whether two-finger manipulation of this object may change its size.
     * If set to false, the object is only rotated and translated.
     * <p>
     * In case the element is a horizontal or vertical line having ticks, "scalable:true"
     * enables zooming of the board by dragging ticks lines. This feature is enabled,
     * for the ticks element of the line element the attribute "fixed" has to be false
     * and the line element's scalable attribute has to be true.
     * <p>
     * In case the element is a polygon or line and it has the attribute "scalable:false",
     * moving the element with two fingers results in a rotation or translation.
     * <p>
     * If an element is set to be neither scalable nor rotatable, it can only be translated.
     * <p>
     * In case of a polygon, scaling is only possible if <i>no</i> vertex has snapToGrid or snapToPoints
     * enabled and no vertex is fixed by some other constraint. Also, the polygon itself has to have
     * snapToGrid disabled.
     *
     * @type Boolean
     * @default true
     * @name JXG.GeometryElement#scalable
     * @see JXG.Ticks#fixed
     * @see JXG.GeometryElement#rotatable
     */
    scalable: true,
    /**
     * If enabled:true the (stroke) element will get a customized shadow.
     * <p>
     * Customize <i>color</i> and <i>opacity</i>:
     * If the object's RGB stroke color is <tt>[r,g,b]</tt> and its opacity is <tt>op</i>, and
     * the shadow parameters <i>color</i> is given as <tt>[r', g', b']</tt> and <i>opacity</i> as <tt>op'</tt>
     * the shadow will receive the RGB color
     * <center>
     * <tt>[blend*r + r', blend*g + g', blend*b + b'] </tt>
     * </center>
     * and its opacity will be equal to <tt>op * op'</tt>.
     * Further, the parameters <i>blur</i> and <i>offset</i> can be adjusted.
     * <p>
     * This attribute is only available with SVG, not with canvas.
     *
     * @type Object
     * @name JXG.GeometryElement#shadow
     * @default shadow: {
     *   enabled: false,
     *   color: [0, 0, 0],
     *   opacity: 1,
     *   blur: 3,
     *   blend: 0.1,
     *   offset: [5, 5]
     * }
     *
     * @example
     * board.options.line.strokeWidth = 2
     * // No shadow
     * var li1 = board.create('line', [[-2, 5], [2, 6]], {strokeColor: 'red', shadow: false});
     *
     * // Default shadow
     * var li2 = board.create('line', [[-2, 3], [2, 4]], {strokeColor: 'red', shadow: true});
     *
     * // No shadow
     * var li3 = board.create('line', [[-2, 1], [2, 2]], {strokeColor: 'blue', shadow: {enabled: false}});
     *
     * // Shadow uses same color as line
     * var li4 = board.create('line', [[-2, -1], [2, 0]], {strokeColor: 'blue',
     *             shadow: {enabled: true, color: '#000000', blend: 1}
     *         });
     *
     * // Shadow color as a mixture between black and the line color, additionally set opacity
     * var li5 = board.create('line', [[-2, -3], [2, -2]], {strokeColor: 'blue',
     *             shadow: {enabled: true, color: '#000000', blend: 0.5, opacity: 0.5}
     *         });
     *
     * // Use different value for blur and offset [dx, dy]
     * var li6 = board.create('line', [[-2, -5], [2, -4]], {strokeColor: 'blue',
     *             shadow: {enabled: true, offset:[0, 25], blur: 6}
     *         });
     *
     * </pre><div id="JXG1185a9fa-0fa5-425f-8c15-55b56e1be958" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG1185a9fa-0fa5-425f-8c15-55b56e1be958',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     board.options.line.strokeWidth = 2
     *     // No shadow
     *     var li1 = board.create('line', [[-2, 5], [2, 6]], {strokeColor: 'red', shadow: false});
     *
     *     // Default shadow
     *     var li2 = board.create('line', [[-2, 3], [2, 4]], {strokeColor: 'red', shadow: true});
     *
     *     // No shadow
     *     var li3 = board.create('line', [[-2, 1], [2, 2]], {strokeColor: 'blue', shadow: {enabled: false}});
     *
     *     // Shadow uses same color as line
     *     var li4 = board.create('line', [[-2, -1], [2, 0]], {strokeColor: 'blue',
     *                 shadow: {enabled: true, color: '#000000', blend: 1}
     *             });
     *
     *     // Shadow color as a mixture between black and the line color, additionally set opacity
     *     var li5 = board.create('line', [[-2, -3], [2, -2]], {strokeColor: 'blue',
     *                 shadow: {enabled: true, color: '#000000', blend: 0.5, opacity: 0.5}
     *             });
     *
     *     // Use different value for blur and offset [dx, dy]
     *     var li6 = board.create('line', [[-2, -5], [2, -4]], {strokeColor: 'blue',
     *                 shadow: {enabled: true, offset:[0, 25], blur: 6}
     *             });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    shadow: {
      enabled: false,
      color: [0, 0, 0],
      opacity: 1,
      blur: 3,
      blend: 0.1,
      offset: [5, 5]
    },
    /**
     * Snaps the element or its parents to the grid. Currently only relevant for points, circles,
     * and lines. Points are snapped to grid directly, on circles and lines it's only the parent
     * points that are snapped
     * @type Boolean
     * @default false
     * @name JXG.GeometryElement#snapToGrid
     */
    snapToGrid: false,
    /**
     * The stroke color of the given geometry element.
     * @type String
     * @name JXG.GeometryElement#strokeColor
     * @see JXG.GeometryElement#highlightStrokeColor
     * @see JXG.GeometryElement#strokeWidth
     * @see JXG.GeometryElement#strokeOpacity
     * @see JXG.GeometryElement#highlightStrokeOpacity
     * @default JXG.palette.blue
     */
    strokeColor: color_default.palette.blue,
    /**
     * Opacity for element's stroke color.
     * @type Number
     * @name JXG.GeometryElement#strokeOpacity
     * @see JXG.GeometryElement#strokeColor
     * @see JXG.GeometryElement#highlightStrokeColor
     * @see JXG.GeometryElement#strokeWidth
     * @see JXG.GeometryElement#highlightStrokeOpacity
     * @default 1
     */
    strokeOpacity: 1,
    /**
     * Width of the element's stroke.
     * @type Number
     * @name JXG.GeometryElement#strokeWidth
     * @see JXG.GeometryElement#strokeColor
     * @see JXG.GeometryElement#highlightStrokeColor
     * @see JXG.GeometryElement#strokeOpacity
     * @see JXG.GeometryElement#highlightStrokeOpacity
     * @default 2
     */
    strokeWidth: 2,
    /**
     * Controls if an element can get the focus with the tab key.
     * tabindex corresponds to the HTML attribute of the same name.
     * See <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex">description at MDN</a>.
     * The additional value "null" completely disables focus of an element.
     * The value will be ignored if keyboard control of the board is not enabled or
     * the element is fixed or not visible.
     *
     * @name JXG.GeometryElement#tabindex
     * @type Number
     * @default 0
     * @see JXG.Board#keyboard
     * @see JXG.GeometryElement#fixed
     * @see JXG.GeometryElement#visible
     */
    tabindex: 0,
    /**
     * If true the element will be traced, i.e. on every movement the element will be copied
     * to the background. Use {@link JXG.GeometryElement#clearTrace} to delete the trace elements.
     *
     * The calling of element.setAttribute({trace:false}) additionally
     * deletes all traces of this element. By calling
     * element.setAttribute({trace:'pause'})
     * the removal of already existing traces can be prevented.
     *
     * The visual appearance of the trace can be influenced by {@link JXG.GeometryElement#traceAttributes}.
     *
     * @see JXG.GeometryElement#clearTrace
     * @see JXG.GeometryElement#traces
     * @see JXG.GeometryElement#numTraces
     * @see JXG.GeometryElement#traceAttributes
     * @type Boolean|String
     * @default false
     * @name JXG.GeometryElement#trace
     */
    trace: false,
    /**
     * Extra visual properties for traces of an element
     * @type Object
     * @see JXG.GeometryElement#trace
     * @name JXG.GeometryElement#traceAttributes
     * @default <tt>{}</tt>
     *
     * @example
     * JXG.Options.elements.traceAttributes = {
     *     size: 2
     * };
     *
     * const board = JXG.JSXGraph.initBoard(BOARDID, {
     *     boundingbox: [-4, 4, 4, -4],
     *     keepaspectratio: true
     * });
     *
     * var p = board.create('point', [0.0, 2.0], {
     *     trace: true,
     *     size: 10,
     *     traceAttributes: {
     *         color: 'black',
     *         face: 'x'
     *     }
     * });
     *
     * </pre><div id="JXG504889cb-bb6f-4b65-85db-3ad555c08bcf" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *     JXG.Options.elements.traceAttributes = {
     *         size: 2
     *     };
     *         var board = JXG.JSXGraph.initBoard('JXG504889cb-bb6f-4b65-85db-3ad555c08bcf',
     *             {boundingbox: [-4, 4, 4, -4], axis: true, showcopyright: false, shownavigation: true, showClearTraces: true});
     *
     *     var p = board.create('point', [0.0, 2.0], {
     *         trace: true,
     *         size: 10,
     *         traceAttributes: {
     *             color: 'black',
     *             face: 'x'
     *         }
     *     });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    traceAttributes: {},
    /**
     * Transition duration (in milliseconds) for certain cahnges of properties like color and opacity.
     * The properties can be set in the attribute transitionProperties
     * Works in SVG renderer, only.
     * @type Number
     * @name JXG.GeometryElement#transitionDuration
     * @see JXG.GeometryElement#transitionProperties
     * @see JXG.GeometryElement#strokeColor
     * @see JXG.GeometryElement#highlightStrokeColor
     * @see JXG.GeometryElement#strokeOpacity
     * @see JXG.GeometryElement#highlightStrokeOpacity
     * @see JXG.GeometryElement#fillColor
     * @see JXG.GeometryElement#highlightFillColor
     * @see JXG.GeometryElement#fillOpacity
     * @see JXG.GeometryElement#highlightFillOpacity
     * @default 100 {@link JXG.Options.elements#transitionDuration}
     */
    transitionDuration: 100,
    /**
     * Properties which change smoothly in the time set in transitionDuration.
     * Possible values are
     * ['fill', 'fill-opacity', 'stroke', 'stroke-opacity', 'stroke-width', 'width', 'height', 'rx', 'ry']
     * (and maybe more) for geometry elements and
     * ['color', 'opacity', 'all'] for HTML texts.
     *
     * @type Array
     * @name JXG.GeometryElement#transitionProperties
     * @see JXG.GeometryElement#transitionDuration
     *
     *
     * @example
     * var p1 = board.create("point", [0, 2], {
     *     name: "A",
     *     highlightStrokeWidth: 10,
     *     transitionDuration: 1000,
     *     transitionProperties: ['width', 'height', 'stroke-width',
     *         'fill', 'fill-opacity', 'rx', 'ry', 'stroke', 'stroke-opacity'] });
     *
     * </pre><div id="JXGdf5230a1-5870-43db-b6ff-4d5b2f5b786b" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGdf5230a1-5870-43db-b6ff-4d5b2f5b786b',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var p1 = board.create("point", [0, 2], {
     *         name: "A",
     *         highlightStrokeWidth: 20,
     *         transitionDuration: 1000,
     *         transitionProperties: ['width', 'height', 'stroke-width',
     *             'fill', 'fill-opacity', 'rx', 'ry', 'stroke', 'stroke-opacity'] });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    transitionProperties: ["fill", "fill-opacity", "stroke", "stroke-opacity", "stroke-width"],
    /**
     * If false the element won't be visible on the board, otherwise it is shown.
     * @type Boolean
     * @name JXG.GeometryElement#visible
     * @see JXG.GeometryElement#hideElement
     * @see JXG.GeometryElement#showElement
     * @default true
     */
    visible: true,
    /**
     * Set individual viewport for an element. If not set to 'inherit', to
     * use the board-wide viewport, an array of the form '[left, top, right, bottom]' has to be given.
     *
     * @type {Array|String}
     * @name JXG.GeometryElement#viewport
     * @default 'inherit'
     * @see JXG.Board#viewport
     */
    viewport: "inherit",
    /**
     * If true a label will display the element's name.
     * Using this to suppress labels is more efficient than visible:false.
     *
     * @name JXG.GeometryElement#withLabel
     * @type Boolean
     * @default false
     */
    withLabel: false
    // close the meta tag
    /**#@-*/
  },
  /*
   *  Generic options used by {@link JXG.Ticks}
   */
  ticks: {
    /**#@+
     * @visprop
     */
    /**
     * A function that expects two {@link JXG.Coords}, the first one representing the coordinates of the
     * tick that is to be labeled, the second one the coordinates of the center (the tick with position 0).
     * The third parameter is a null, number or a string. In the latter two cases, this value is taken.
     * Returns a string.
     *
     * @type function
     * @name Ticks#generateLabelText
     *
     * @example
     * const board = JXG.JSXGraph.initBoard('jxgbox', { boundingBox: [-10, 10, 10, -10], axis: true,
     *     defaultAxes: {
     *         x: {
     *                 margin: -4,
     *                 ticks: {
     *                     minTicksDistance: 0,
     *                     minorTicks:4,
     *                     ticksDistance: 3,
     *                     scale: Math.PI,
     *                     scaleSymbol: 'π',
     *                     insertTicks: true
     *                 }
     *              },
     *         y: {}
     *     }
     * });
     *
     * // Generate a logarithmic labelling of the vertical axis.
     * board.defaultAxes.y.ticks[0].generateLabelText = function (tick, zero) {
     *     var value = Math.pow(10, Math.round(tick.usrCoords[2] - zero.usrCoords[2])),
     *         distance, labelText;
     *     return this.formatLabelText(value);
     * };
     *
     * </pre><div id="JXG3d2203ee-a797-416a-a33c-409581fafdd7" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG3d2203ee-a797-416a-a33c-409581fafdd7',
     *             {boundingbox: [-10, 10, 10, -10], axis: true, showcopyright: false, shownavigation: false,
     *         defaultAxes: {
     *             x: {
     *                     margin: -4,
     *                     ticks: {
     *                         minTicksDistance: 0,
     *                         minorTicks:4,
     *                         ticksDistance: 3,
     *                         scale: Math.PI,
     *                         scaleSymbol: 'π',
     *                         insertTicks: true
     *                     }
     *                  },
     *             y: {}
     *         }
     *     });
     *
     *     // Generate a logarithmic labelling of the vertical axis.
     *     board.defaultAxes.y.ticks[0].generateLabelText = function (tick, zero) {
     *         var value = Math.pow(10, Math.round(tick.usrCoords[2] - zero.usrCoords[2])),
     *             distance, labelText;
     *         return this.formatLabelText(value);
     *     };
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    generateLabelText: null,
    /**
     * A function that expects two {@link JXG.Coords}, the first one representing the coordinates of the
     * tick that is to be labeled, the second one the coordinates of the center (the tick with position 0).
     *
     * @deprecated Use {@link JGX.Options@generateLabelText}
     * @type function
     * @name Ticks#generateLabelValue
     */
    generateLabelValue: null,
    /**
     * Draw labels yes/no
     *
     * @type Boolean
     * @name Ticks#drawLabels
     * @default false
     */
    drawLabels: false,
    /**
     * Attributes for the ticks labels
     *
     * @name Ticks#label
     * @type Object
     * @default <tt>{}</tt>
     *
     */
    label: {},
    /**
    * Format tick labels that were going to have scientific notation
    * like 5.00e+6 to look like 5•10⁶.
    *
    * @example
    * var board = JXG.JSXGraph.initBoard("jxgbox", {
    *     boundingbox: [-500000, 500000, 500000, -500000],
    *     axis: true,
    *     defaultAxes: {
    *         x: {
    *             scalable: true,
    *             ticks: {
    *                 beautifulScientificTickLabels: true
    *           },
    *         },
    *         y: {
    *             scalable: true,
    *             ticks: {
    *                 beautifulScientificTickLabels: true
    *           },
    *         }
    *     },
    * });
    *
    * </pre><div id="JXGc1e46cd1-e025-4002-80aa-b450869fdaa2" class="jxgbox" style="width: 300px; height: 300px;"></div>
    * <script type="text/javascript">
    *     (function() {
    *     var board = JXG.JSXGraph.initBoard('JXGc1e46cd1-e025-4002-80aa-b450869fdaa2', {
    *         boundingbox: [-500000, 500000, 500000, -500000],
    *         showcopyright: false, shownavigation: false,
    *         axis: true,
    *         defaultAxes: {
    *             x: {
    *                 scalable: true,
    *                 ticks: {
    *                     beautifulScientificTickLabels: true
    *               },
    *             },
    *             y: {
    *                 scalable: true,
    *                 ticks: {
    *                     beautifulScientificTickLabels: true
    *               },
    *             }
    *         },
    *     });
    *
    *     })();
    *
    * <\/script><pre>
    *
    * @name Ticks#beautifulScientificTickLabels
    * @type Boolean
    * @default false
    */
    beautifulScientificTickLabels: false,
    /**
     * Use the unicode character 0x2212, i.e. the HTML entity &amp;minus; as minus sign.
     * That is &minus;1 instead of -1.
     *
     * @type Boolean
     * @name Ticks#useUnicodeMinus
     * @default true
     */
    useUnicodeMinus: true,
    /**
     * Determine the position of the tick with value 0. 'left' means point1 of the line, 'right' means point2,
     * and 'middle' is equivalent to the midpoint of the defining points. This attribute is ignored if the parent
     * line is of type axis.
     *
     * @type String
     * @name Ticks#anchor
     * @default 'left'
     *
     * @example
     * var li = board.create('segment', [[-4, -3], [4, 2]]);
     * var t = board.create('ticks', [li], {
     *     // drawZero: true,
     *     anchor: 'left',
     *     drawLabels: true,
     *     minorTicks: 0,
     *     label: {
     *         anchorX: 'middle',
     *         anchorY: 'top',
     *         offset: [0, -5]
     *     }
     * });
     *
     *
     * </pre><div id="JXG3dd23f77-a31d-4649-b0f0-7472722158d8" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG3dd23f77-a31d-4649-b0f0-7472722158d8',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var li = board.create('segment', [[-4, -3], [4, 2]]);
     *     var t = board.create('ticks', [li], {
     *         // drawZero: true,
     *         anchor: 'left',
     *         drawLabels: true,
     *         minorTicks: 0,
     *         label: {
     *             anchorX: 'middle',
     *             anchorY: 'top',
     *             offset: [0, -5]
     *         }
     *     });
     *
     *
     *     })();
     *
     * <\/script><pre>
     *
     * @example
     * var li = board.create('segment', [[-4, -3], [4, 2]]);
     * var t = board.create('ticks', [li], {
     *     drawZero: true,
     *     anchor: 'middle',
     *     drawLabels: true,
     *     minorTicks: 0,
     *     label: {
     *         anchorX: 'middle',
     *         anchorY: 'top',
     *         offset: [0, -5]
     *     }
     * });
     *
     * </pre><div id="JXG430914fd-4e12-44de-b510-e3cc2fd473e0" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG430914fd-4e12-44de-b510-e3cc2fd473e0',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var li = board.create('segment', [[-4, -3], [4, 2]]);
     *     var t = board.create('ticks', [li], {
     *         drawZero: true,
     *         anchor: 'middle',
     *         drawLabels: true,
     *         minorTicks: 0,
     *         label: {
     *             anchorX: 'middle',
     *             anchorY: 'top',
     *             offset: [0, -5]
     *         }
     *     });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    anchor: "left",
    /**
     * Draw the zero tick, that lies at line.point1?
     *
     * @type Boolean
     * @name Ticks#drawZero
     * @default false
     *
     * @example
     * var li = board.create('segment', [[-4, 2], [4, 2]]);
     * var t = board.create('ticks', [li], {
     *     drawZero: false,
     *     anchor: 'middle',
     *     drawLabels: true,
     *     minorTicks: 0,
     *     label: {
     *         anchorX: 'middle',
     *         anchorY: 'top',
     *         offset: [0, -5]
     *     }
     * });
     *
     * var li2 = board.create('segment', [[-4, -2], [4, -2]]);
     * var t2 = board.create('ticks', [li2], {
     *     drawZero: true,
     *     anchor: 'middle',
     *     drawLabels: true,
     *     minorTicks: 0,
     *     label: {
     *         anchorX: 'middle',
     *         anchorY: 'top',
     *         offset: [0, -5]
     *     }
     * });
     *
     * </pre><div id="JXG91584dc4-0ca8-4b3e-841c-c877f2ccdcf1" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG91584dc4-0ca8-4b3e-841c-c877f2ccdcf1',
     *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: false});
     *     var li = board.create('segment', [[-4, 2], [4, 2]]);
     *     var t = board.create('ticks', [li], {
     *         drawZero: false,
     *         anchor: 'middle',
     *         drawLabels: true,
     *         minorTicks: 0,
     *         label: {
     *             anchorX: 'middle',
     *             anchorY: 'top',
     *             offset: [0, -5]
     *         }
     *     });
     *
     *     var li2 = board.create('segment', [[-4, -2], [4, -2]]);
     *     var t2 = board.create('ticks', [li2], {
     *         drawZero: true,
     *         anchor: 'middle',
     *         drawLabels: true,
     *         minorTicks: 0,
     *         label: {
     *             anchorX: 'middle',
     *             anchorY: 'top',
     *             offset: [0, -5]
     *         }
     *     });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    drawZero: false,
    /**
     * Let JSXGraph determine the distance between ticks automatically.
     * If <tt>true</tt>, the attribute <tt>ticksDistance</tt> is ignored.
     * The distance between ticks is affected by the size of the board and
     * the attribute <tt>minTicksDistance</tt> (in pixel).
     *
     * @type Boolean
     * @name Ticks#insertTicks
     * @see Ticks#ticksDistance
     * @see Ticks#minTicksDistance
     * @default false
     * @example
     * // Create an axis providing two coord pairs.
     *   var p1 = board.create('point', [0, 0]);
     *   var p2 = board.create('point', [50, 25]);
     *   var l1 = board.create('line', [p1, p2]);
     *   var t = board.create('ticks', [l1], {
     *      insertTicks: true,
     *      majorHeight: -1,
     *      label: {
     *          offset: [4, -9]
     *      },
     *      drawLabels: true
     *  });
     * </pre><div class="jxgbox" id="JXG2f6fb842-40bd-4223-aa28-3e9369d2097f" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     * (function () {
     *   var board = JXG.JSXGraph.initBoard('JXG2f6fb842-40bd-4223-aa28-3e9369d2097f', {
     *     boundingbox: [-100, 70, 70, -100], axis: true, showcopyright: false, shownavigation: true});
     *   var p1 = board.create('point', [0, 0]);
     *   var p2 = board.create('point', [50, 25]);
     *   var l1 = board.create('line', [p1, p2]);
     *   var t = board.create('ticks', [l1], {insertTicks: true, majorHeight: -1, label: {offset: [4, -9]}, drawLabels: true});
     * })();
     * <\/script><pre>
     */
    insertTicks: false,
    /**
     * Minimum distance in pixel of equidistant ticks in case insertTicks==true.
     * @name Ticks#minTicksDistance
     * @type Number
     * @default 10
     * @see Ticks#insertTicks
     */
    minTicksDistance: 10,
    /**
     * Total height of a minor tick. If negative the full height of the board is taken.
     *
     * @type Number
     * @name Ticks#minorHeight
     * @default 4
     */
    minorHeight: 4,
    /**
     * Total height of a major tick. If negative the full height of the board is taken.
     *
     * @type Number
     * @name Ticks#majorHeight
     * @default 10
     */
    majorHeight: 10,
    /**
     * Decides in which direction minor ticks are visible. Possible values are either the constants
     * 0=false or 1=true or a function returning 0 or 1.
     *
     * In case of [0,1] the tick is only visible to the right of the line. In case of
     * [1,0] the tick is only visible to the left of the line.
     *
     * @type Array
     * @name Ticks#tickEndings
     * @see Ticks#majorTickEndings
     * @default [1, 1]
     */
    tickEndings: [1, 1],
    /**
     * Decides in which direction major ticks are visible. Possible values are either the constants
     * 0=false or 1=true or a function returning 0 or 1.
     *
     * In case of [0,1] the tick is only visible to the right of the line. In case of
     * [1,0] the tick is only visible to the left of the line.
     *
    * @example
    *         var board = JXG.JSXGraph.initBoard("jxgbox", {
    *             boundingbox: [-5, 5, 5, -5],
    *             axis: true,
    *             defaultAxes: {
    *                 x: {
    *                     ticks: {
    *                         majorTickEndings: [1, 0],
    *                         ignoreInfiniteTickEndings: false
    *                     }
    *                 },
    *                 y: {
    *                     ticks: {
    *                         majorTickEndings: [0, 1],
    *                         ignoreInfiniteTickEndings: false
    *                     }
    *                 }
    *             }
    *         });
    *
    *         var p = board.create('point', [1, 1]);
    *         var l = board.create('line', [1, -1, 1]);
    *
    * </pre><div id="JXGf9ccb731-7a73-44d1-852e-f9c9c405a9d1" class="jxgbox" style="width: 300px; height: 300px;"></div>
    * <script type="text/javascript">
    *     (function() {
    *         var board = JXG.JSXGraph.initBoard('JXGf9ccb731-7a73-44d1-852e-f9c9c405a9d1',
    *             {   showcopyright: false, shownavigation: false,
    *                 boundingbox: [-5, 5, 5, -5],
    *                 axis: true,
    *                 defaultAxes: {
    *                     x: {
    *                         ticks: {
    *                             majorTickEndings: [1, 0],
    *                             ignoreInfiniteTickEndings: false
    *                         }
    *                     },
    *                     y: {
    *                         ticks: {
    *                             majorTickEndings: [0, 1],
    *                             ignoreInfiniteTickEndings: false
    *                         }
    *                     }
    *                 }
    *             });
    *
    *             var p = board.create('point', [1, 1]);
    *             var l = board.create('line', [1, -1, 1]);
    *
    *     })();
    *
    * <\/script><pre>
    *
    * @type Array
     * @name Ticks#majorTickEndings
     * @see Ticks#tickEndings
     * @see Ticks#ignoreInfiniteTickEndings
     * @default [1, 1]
     */
    majorTickEndings: [1, 1],
    /**
     * If true, ignore the tick endings attribute for infinite (full height) ticks.
     * This affects major and minor ticks.
     *
     * @type Boolean
     * @name Ticks#ignoreInfiniteTickEndings
     * @see Ticks#tickEndings
     * @see Ticks#majorTickEndings
     * @default true
     */
    ignoreInfiniteTickEndings: true,
    /**
     * The number of minor ticks between two major ticks.
     * @type Number
     * @name Ticks#minorTicks
     * @default 4
     */
    minorTicks: 4,
    /**
     * By default, i.e. if ticksPerLabel==false, labels are generated for major ticks, only.
     * If ticksPerLabel is set to a(n integer) number, this denotes the number of minor ticks
     * between two labels.
     *
     * @type {Number|Boolean}
     * @name Ticks#ticksPerLabel
     * @default false
     *
     * @example
     * const board = JXG.JSXGraph.initBoard('jxgbox', {
     *     boundingbox: [-4, 4, 4, -4],
     *     axis: true,
     *     defaultAxes: {
     *         x: {
     *             ticks: {
     *                 minorTicks: 7,
     *                 ticksPerLabel: 4,
     *                 minorHeight: 20,
     *             }
     *         },
     *         y: {
     *             ticks: {
     *                 minorTicks: 3,
     *                 ticksPerLabel: 2,
     *                 minorHeight: 20
     *             }
     *         }
     *     }
     * });
     *
     * </pre><div id="JXGbc45a421-c867-4b0a-9b8d-2b2576020690" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGbc45a421-c867-4b0a-9b8d-2b2576020690',
     *             {showcopyright: false, shownavigation: false,
     *              boundingbox: [-4, 4, 4, -4],
     *         axis: true,
     *         defaultAxes: {
     *             x: {
     *                 ticks: {
     *                     minorTicks: 7,
     *                     ticksPerLabel: 4,
     *                     minorHeight: 20,
     *                 }
     *             },
     *             y: {
     *                 ticks: {
     *                     minorTicks: 3,
     *                     ticksPerLabel: 2,
     *                     minorHeight: 20
     *                 }
     *             }
     *         }
     *     });
     *     })();
     *
     * <\/script><pre>
     */
    ticksPerLabel: false,
    /**
     * Scale the ticks but not the tick labels.
     * @type Number
     * @default 1
     * @name Ticks#scale
     * @see Ticks#scaleSymbol
     *
     * @example
     * const board = JXG.JSXGraph.initBoard('jxgbox', { boundingBox: [-10, 10, 10, -10], axis: true,
     *     defaultAxes: {
     *         x : {
     *                 margin: -4,
     *                 ticks: {
     *                     minTicksDistance: 0,
     *                     minorTicks:4,
     *                     ticksDistance: 3,
     *                     scale: Math.PI,
     *                     scaleSymbol: 'π',
     *                     insertTicks: true
     *                 }
     *              },
     *         y : {}
     *     }
     * });
     *
     * </pre><div id="JXG23bfda5d-4a85-4469-a552-aa9b4cf62b4a" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG23bfda5d-4a85-4469-a552-aa9b4cf62b4a',
     *             {boundingbox: [-10, 10, 10, -10], axis: true, showcopyright: false, shownavigation: false,
     *         defaultAxes: {
     *             x : {
     *                     margin: -4,
     *                     ticks: {
     *                         minTicksDistance: 0,
     *                         minorTicks:4,
     *                         ticksDistance: 3,
     *                         scale: Math.PI,
     *                         scaleSymbol: 'π',
     *                         insertTicks: true
     *                     }
     *                  },
     *             y : {
     *                  }
     *         }
     *     });
     *
     *     })();
     *
     * <\/script><pre>
     */
    scale: 1,
    /**
     * A string that is appended to every tick, used to represent the scale
     * factor given in {@link Ticks#scale}.
     *
     * @type String
     * @default ''
     * @name Ticks#scaleSymbol
     * @see Ticks#scale
     */
    scaleSymbol: "",
    /**
     * User defined labels for special ticks. Instead of the i-th tick's position, the i-th string stored in this array
     * is shown. If the number of strings in this array is less than the number of special ticks, the tick's position is
     * shown as a fallback.
     *
     * @type Array
     * @name Ticks#labels
     * @default []
     */
    labels: [],
    /**
     * The maximum number of characters a tick label can use.
     *
     * @type Number
     * @name Ticks#maxLabelLength
     * @see Ticks#digits
     * @default 5
     */
    maxLabelLength: 5,
    /**
     * If a label exceeds {@link Ticks#maxLabelLength} this determines the precision used to shorten the tick label.
     * Deprecated! Replaced by the attribute <tt>digits</tt>.
     *
     * @type Number
     * @name Ticks#precision
     * @see Ticks#maxLabelLength
     * @see Ticks#digits
     * @deprecated
     * @default 3
     */
    precision: 3,
    /**
     * If a label exceeds {@link Ticks#maxLabelLength} this determines the number of digits used to shorten the tick label.
     *
     * @type Number
     * @name Ticks#digits
     * @see Ticks#maxLabelLength
     * @deprecated
     * @default 3
     */
    digits: 3,
    /**
     * The default distance (in user coordinates, not  pixels) between two ticks. Please be aware that this value does not have
     * to be used if {@link Ticks#insertTicks} is set to true.
     *
     * @type Number
     * @name Ticks#ticksDistance
     * @see Ticks#insertTicks
     * @default 1
     */
    ticksDistance: 1,
    /**
     * Tick face for major ticks of finite length.  By default (face: '|') this is a straight line.
     * Possible other values are '<' and '>'. These faces are used in
     * {@link JXG.Hatch} for hatch marking parallel lines.
     * @type String
     * @name Ticks#face
     * @see hatch
     * @default '|'
     * @example
     *   var p1 = board.create('point', [0, 3]);
     *   var p2 = board.create('point', [1, 3]);
     *   var l1 = board.create('line', [p1, p2]);
     *   var t = board.create('ticks', [l1], {ticksDistance: 2, face: '>', minorTicks: 0});
     *
     * </pre><div id="JXG950a568a-1264-4e3a-b61d-b6881feecf4b" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG950a568a-1264-4e3a-b61d-b6881feecf4b',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *       var p1 = board.create('point', [0, 3]);
     *       var p2 = board.create('point', [1, 3]);
     *       var l1 = board.create('line', [p1, p2]);
     *       var t = board.create('ticks', [l1], {ticksDistance: 2, face: '>', minorTicks: 0});
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    face: "|",
    strokeOpacity: 1,
    strokeWidth: 1,
    strokeColor: "#000000",
    highlightStrokeColor: "#888888",
    fillColor: "none",
    highlightFillColor: "none",
    visible: "inherit",
    /**
     * Whether line boundaries should be included or not in the lower and upper bounds when
     * creating ticks. In mathematical terms: if a segment considered as interval is open (includeBoundaries:false)
     * or closed (includeBoundaries:true). In case of open interval, the interval is shortened by a small
     * &epsilon;.
     *
     * @type Boolean
     * @name Ticks#includeBoundaries
     * @default false
     *
     * @example
     * var li = board.create('segment', [[-4, 2], [4, 2]]);
     * var t = board.create('ticks', [li], {
     *     includeBoundaries: true,
     *     drawZero: true,
     *     anchor: 'middle',
     *     drawLabels: true,
     *     minorTicks: 0,
     *     label: {
     *         anchorX: 'middle',
     *         anchorY: 'top',
     *         offset: [0, -5]
     *     }
     * });
     *
     * var li2 = board.create('segment', [[-4, -2], [4, -2]]);
     * var t2 = board.create('ticks', [li2], {
     *     includeBoundaries: false,
     *     drawZero: true,
     *     anchor: 'middle',
     *     drawLabels: true,
     *     minorTicks: 0,
     *     label: {
     *         anchorX: 'middle',
     *         anchorY: 'top',
     *         offset: [0, -5]
     *     }
     * });
     *
     * </pre><div id="JXG08e79180-7c9a-4638-bb72-8aa7fd8a8b96" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG08e79180-7c9a-4638-bb72-8aa7fd8a8b96',
     *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: false});
     *     var li = board.create('segment', [[-4, 2], [4, 2]]);
     *     var t = board.create('ticks', [li], {
     *         includeBoundaries: true,
     *         drawZero: true,
     *         anchor: 'middle',
     *         drawLabels: true,
     *         minorTicks: 0,
     *         label: {
     *             anchorX: 'middle',
     *             anchorY: 'top',
     *             offset: [0, -5]
     *         }
     *     });
     *
     *     var li2 = board.create('segment', [[-4, -2], [4, -2]]);
     *     var t2 = board.create('ticks', [li2], {
     *         includeBoundaries: false,
     *         drawZero: true,
     *         anchor: 'middle',
     *         drawLabels: true,
     *         minorTicks: 0,
     *         label: {
     *             anchorX: 'middle',
     *             anchorY: 'top',
     *             offset: [0, -5]
     *         }
     *     });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    includeBoundaries: false,
    /**
     * Set the ticks type.
     * Possible values are 'linear' or 'polar'.
     *
     * @type String
     * @name Ticks#type
     * @default 'linear'
     *
     * @example
     * var ax = board.create('axis', [[0,0], [1,0]], {
     *              needsRegularUpdate: false,
     *              ticks: {
     *                      type: 'linear',
     *                      majorHeight: 0
     *                  }
     *              });
     * var ay = board.create('axis', [[0,0], [0,1]], {
     *              ticks: {
     *                      type: 'polar'
     *                  }
     *              });
     *
     * var p = board.create('point', [3, 2]);
     *
     * </pre><div id="JXG9ab0b50c-b486-4f95-9698-c0dd276155ff" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG9ab0b50c-b486-4f95-9698-c0dd276155ff',
     *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: false});
     *     var ax = board.create('axis', [[0,0], [1,0]], { needsRegularUpdate: false, ticks: { type: 'linear', majorHeight: 0}});
     *     var ay = board.create('axis', [[0,0], [0,1]], { ticks: { type: 'polar'}});
     *
     *     var p = board.create('point', [3, 2]);
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    type: "linear",
    /**
     * Internationalization support for ticks labels.
     * @name intl
     * @memberOf Ticks.prototype
     * @default <pre>{
     *    enabled: 'inherit',
     *    options: {}
     * }</pre>
     * @see JXG.Board#intl
     * @see Text#intl
     *
              * @example
     * // Here, locale is disabled in general, but enabled for the horizontal
     * // axis and the infobox.
     * const board = JXG.JSXGraph.initBoard(BOARDID, {
     *     boundingbox: [-0.5, 0.5, 0.5, -0.5],
     *     intl: {
     *         enabled: false,
     *         locale: 'de-DE'
     *     },
     *     keepaspectratio: true,
     *     axis: true,
     *     defaultAxes: {
     *         x: {
     *             ticks: {
     *                 intl: {
     *                         enabled: true,
     *                         options: {
     *                             style: 'unit',
     *                             unit: 'kilometer-per-hour',
     *                             unitDisplay: 'narrow'
     *                         }
     *                 }
     *             }
     *         },
     *         y: {
     *             ticks: {
     *             }
     *         }
     *     },
     *     infobox: {
     *         fontSize: 12,
     *         intl: {
     *             enabled: true,
     *             options: {
     *                 minimumFractionDigits: 4,
     *                 maximumFractionDigits: 5
     *             }
     *         }
     *     }
     * });
     *
     * var p = board.create('point', [0.1, 0.1], {});
     *
     * </pre><div id="JXG820b60ff-b453-4be9-a9d5-06c0342a9dbe" class="jxgbox" style="width: 600px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *     var board = JXG.JSXGraph.initBoard('JXG820b60ff-b453-4be9-a9d5-06c0342a9dbe', {
     *         boundingbox: [-0.5, 0.5, 0.5, -0.5], showcopyright: false, shownavigation: false,
     *         intl: {
     *             enabled: false,
     *             locale: 'de-DE'
     *         },
     *         keepaspectratio: true,
     *         axis: true,
     *         defaultAxes: {
     *             x: {
     *                 ticks: {
     *                     intl: {
     *                             enabled: true,
     *                             options: {
     *                                 style: 'unit',
     *                                 unit: 'kilometer-per-hour',
     *                                 unitDisplay: 'narrow'
     *                             }
     *                     }
     *                 }
     *             },
     *             y: {
     *                 ticks: {
     *                 }
     *             }
     *         },
     *         infobox: {
     *             fontSize: 12,
     *             intl: {
     *                 enabled: true,
     *                 options: {
     *                     minimumFractionDigits: 4,
     *                     maximumFractionDigits: 5
     *                 }
     *             }
     *         }
     *     });
     *
     *     var p = board.create('point', [0.1, 0.1], {});
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    intl: {
      enabled: "inherit",
      options: {}
    },
    // TODO implementation and documentation
    minorTicksInArrow: false,
    majorTicksInArrow: true,
    labelInArrow: true,
    minorTicksInMargin: false,
    majorTicksInMargin: true,
    labelInMargin: true
    // close the meta tag
    /**#@-*/
  },
  /*
   *  Generic options used by {@link JXG.Hatch}
   */
  hatch: {
    drawLabels: false,
    drawZero: true,
    majorHeight: 20,
    anchor: "middle",
    face: "|",
    strokeWidth: 2,
    strokeColor: color_default.palette.blue,
    /**
     * The default distance (in user coordinates, not  pixels) between two hatch symbols.
     *
     * @type Number
     * @name Hatch#ticksDistance
     * @default 0.2
     */
    ticksDistance: 0.2
  },
  /**
   * Precision options, defining how close a pointer device (mouse, finger, pen) has to be
   * to an object such that the object is highlighted or can be dragged.
   * These values are board-wide and can be overwritten for individual elements by
   * changing their precision attribute.
   *
   * The default values are
   * <pre>
   * JXG.Options.precision: {
   *   touch: 30,
   *   touchMax: 100,
   *   mouse: 4,
   *   pen: 4,
   *   epsilon: 0.0001,
   *   hasPoint: 4
   * }
   * </pre>
   *
   * @type Object
   * @name JXG.Options#precision
   * @see JXG.GeometryElement#precision
   */
  precision: {
    touch: 30,
    touchMax: 100,
    mouse: 4,
    pen: 4,
    epsilon: 1e-4,
    // Unused
    hasPoint: 4
  },
  /**
   * Default ordering of the layers.
   * The numbering starts from 0 and the highest layer number is numlayers-1.
   *
   * The default values are
   * <pre>
   * JXG.Options.layer: {
   *   numlayers: 20, // only important in SVG
   *   text: 9,
   *   point: 9,
   *   glider: 9,
   *   arc: 8,
   *   line: 7,
   *   circle: 6,
   *   curve: 5,
   *   turtle: 5,
   *   polygon: 3,
   *   sector: 3,
   *   angle: 3,
   *   integral: 3,
   *   axis: 2,
   *   ticks: 2,
   *   grid: 1,
   *   image: 0,
   *   trace: 0
   * }
   * </pre>
   * @type Object
   * @name JXG.Options#layer
   */
  layer: {
    numlayers: 20,
    // only important in SVG
    unused9: 19,
    unused8: 18,
    unused7: 17,
    unused6: 16,
    unused5: 15,
    unused4: 14,
    unused3: 13,
    unused2: 12,
    unused1: 11,
    unused0: 10,
    text: 9,
    point: 9,
    glider: 9,
    arc: 8,
    line: 7,
    circle: 6,
    curve: 5,
    turtle: 5,
    polygon: 3,
    sector: 3,
    angle: 3,
    integral: 3,
    axis: 2,
    ticks: 2,
    grid: 1,
    image: 0,
    trace: 0
  },
  /* special angle options */
  angle: {
    /**#@+
     * @visprop
     */
    withLabel: true,
    /**
     * Radius of the sector, displaying the angle.
     * The radius can be given as number (in user coordinates)
     * or as string 'auto'. In the latter case, the angle
     * is set to an value between 20 and 50 px.
     *
     * @type {Number|String}
     * @name Angle#radius
     * @default 'auto'
     * @visprop
     */
    radius: "auto",
    /**
     * Display type of the angle field. Possible values are
     * 'sector' or 'sectordot' or 'square' or 'none'.
     *
     * @type String
     * @default 'sector'
     * @name Angle#type
     * @visprop
     */
    type: "sector",
    /**
     * Display type of the angle field in case of a right angle. Possible values are
     * 'sector' or 'sectordot' or 'square' or 'none'.
     *
     * @type String
     * @default square
     * @name Angle#orthoType
     * @see Angle#orthoSensitivity
     * @visprop
     */
    orthoType: "square",
    /**
     * Sensitivity (in degrees) to declare an angle as right angle.
     * If the angle measure is inside this distance from a rigth angle, the orthoType
     * of the angle is used for display.
     *
     * @type Number
     * @default 1.0
     * @name Angle#orthoSensitivity
     * @see Angle#orthoType
     * @visprop
     */
    orthoSensitivity: 1,
    fillColor: color_default.palette.orange,
    highlightFillColor: color_default.palette.orange,
    strokeColor: color_default.palette.orange,
    // fillColor: '#ff7f00',
    // highlightFillColor: '#ff7f00',
    // strokeColor: '#ff7f00',
    fillOpacity: 0.3,
    highlightFillOpacity: 0.3,
    /**
     * @name Angle#radiuspoint
     * @type Object
     * @deprecated
     */
    radiuspoint: {
      withLabel: false,
      visible: false,
      name: ""
    },
    /**
     * @name Angle#pointsquare
     * @type Object
     * @deprecated
     */
    pointsquare: {
      withLabel: false,
      visible: false,
      name: ""
    },
    /**
     * Attributes of the dot point marking right angles.
     * @name Angle#dot
     * @type Object
     * @default <tt>{face: 'o', size: 2}</tt>
     */
    dot: {
      visible: false,
      strokeColor: "none",
      fillColor: "#000000",
      size: 2,
      face: "o",
      withLabel: false,
      name: ""
    },
    label: {
      position: "top",
      offset: [0, 0],
      strokeColor: color_default.palette.blue
    },
    /**
     * Attributes for sub-element arc. In general, the arc will run through the first point and
     * thus will not have the same radius as the angle sector.
     *
     * @type Arc
     * @name Angle#arc
     * @default '{visible:false}'
     */
    arc: {
      visible: false,
      fillColor: "none"
    }
    /**#@-*/
  },
  /* special arc options */
  arc: {
    /**#@+
     * @visprop
     */
    /**
     * Type of arc. Possible values are 'minor', 'major', and 'auto'.
     *
     * @type String
     * @name Arc#selection
     * @default 'auto'
     */
    selection: "auto",
    /**
     * If <tt>true</tt>, moving the mouse over inner points triggers hasPoint.
     *
     * @see JXG.GeometryElement#hasPoint
     * @name Arc#hasInnerPoints
     * @type Boolean
     * @default false
     */
    hasInnerPoints: false,
    label: {
      anchorX: "auto",
      anchorY: "auto"
    },
    firstArrow: false,
    lastArrow: false,
    fillColor: "none",
    highlightFillColor: "none",
    strokeColor: color_default.palette.blue,
    highlightStrokeColor: "#c3d9ff",
    useDirection: false,
    /**
     * Attributes for center point.
     *
     * @type Point
     * @name Arc#center
     */
    center: {},
    /**
     * Attributes for radius point.
     *
     * @type Point
     * @name Arc#radiusPoint
     */
    radiusPoint: {},
    /**
     * Attributes for angle point.
     *
     * @type Point
     * @name Arc#anglePoint
     */
    anglePoint: {}
    /**#@-*/
  },
  /* special arrow options */
  arrow: {
    /**#@+
     * @visprop
     */
    firstArrow: false,
    lastArrow: {
      type: 1,
      highlightSize: 6,
      size: 6
    }
    /**#@-*/
  },
  /* special arrowparallel options */
  arrowparallel: {
    /**#@+
     * @visprop
     */
    firstArrow: false,
    lastArrow: {
      type: 1,
      highlightSize: 6,
      size: 6
    }
    /**#@-*/
  },
  /* special axis options */
  axis: {
    /**#@+
     * @visprop
     */
    name: "",
    // By default, do not generate names for axes.
    needsRegularUpdate: false,
    // Axes only updated after zooming and moving of the origin.
    strokeWidth: 1,
    lastArrow: {
      type: 1,
      highlightSize: 8,
      size: 8
    },
    strokeColor: "#666666",
    highlightStrokeWidth: 1,
    highlightStrokeColor: "#888888",
    /**
     * Is used to define the behaviour of the axis.
     * Settings in this attribute only have an effect if the axis is exactly horizontal or vertical.
     * Possible values are:
     * <ul>
     *     <li><tt>'static'</tt>: Standard behavior of the axes as know in JSXGraph.
     *     <li><tt>'fixed'</tt>: The axis is placed in a fixed position. Depending on the attribute <tt>anchor</tt>, it is positioned to the right or left of the edge of the board as seen from the axis with a distance defined in <tt>distanceBoarder</tt>. The axis will stay at the given position, when the user navigates through the board.
     *     <li><tt>'sticky'</tt>: This mixes the two settings <tt>static</tt> and <tt>fixed</tt>. When the user navigates in the board, the axis remains in the visible area (taking into account <tt>anchor</tt> and <tt>anchorDist</tt>). If the axis itself is in the visible area, the axis can be moved by navigation.
     * </ul>
     *
     * @type {String}
     * @name Axis#position
     * @default 'static'
     * @see Axis#anchor
     * @see Axis#anchorDist
     *
     * @example // Use navigation to see effect.
     *  var axis1, axis2, circle;
     *
     *  board.create('axis', [[0,0],[1,0]],{
     *      position: 'fixed',
     *      anchor: 'right',
     *      anchorDist: '0.1fr'
     *  });
     *
     *  board.create('axis', [[0,0],[0,1]], {
     *      position: 'fixed',
     *      anchor: 'left',
     *      anchorDist: 1
     *  });
     *
     * </pre><div id="JXG6dff2f81-65ce-46a3-bea0-8ce25cc1cb4a" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *      var board = JXG.JSXGraph.initBoard('JXG6dff2f81-65ce-46a3-bea0-8ce25cc1cb4a',
     *             {boundingbox: [-1, 10, 10,-1], axis: false, showcopyright: false, shownavigation: true});
     *
     *      board.create('axis', [[0,0],[1,0]],{
     *          position: 'fixed',
     *          anchor: 'right',
     *          anchorDist: '0.1fr'
     *      });
     *
     *      board.create('axis', [[0,0],[0,1]], {
     *          position: 'fixed',
     *          anchor: 'left',
     *          anchorDist: 1
     *      });
     *
     *      board.create('circle', [[5,5], 2.5]);
     *     })();
     *
     * <\/script><pre>
     *
     * @example // Use navigation to see effect.
     *      board.create('axis', [[0,0],[1,0]],{
     *          position: 'sticky',
     *          anchor: 'right',
     *          anchorDist: '0.2fr'
     *      });
     *
     *      board.create('axis', [[0,0],[0,1]], {
     *          position: 'sticky',
     *          anchor: 'right left',
     *          anchorDist: '75px'
     *      });
     *
     * </pre><div id="JXG42a90935-80aa-4a6b-8adf-279deef84485" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *          var board = JXG.JSXGraph.initBoard('JXG42a90935-80aa-4a6b-8adf-279deef84485',
     *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: true});
     *          board.create('axis', [[0,0],[1,0]],{
     *              position: 'sticky',
     *              anchor: 'right',
     *              anchorDist: '0.2fr'
     *          });
     *
     *          board.create('axis', [[0,0],[0,1]], {
     *              position: 'sticky',
     *              anchor: 'right left',
     *              anchorDist: '75px'
     *          });
     *
     *          board.create('functiongraph', [function(x){ return 1/(x-5) + 2;}]);
     *     })();
     *
     * <\/script><pre>
     *
     */
    position: "static",
    /**
     * Position is used in cases: <tt>position=='sticky'</tt> or <tt>position=='fixed'</tt>.
     * Possible values are <tt>'right'</tt>, <tt>'left'</tt>, <tt>'right left'</tt>. Left and right indicate the side as seen from the axis.
     * It is used in combination with the attribute position to decide on which side of the board the axis should stick or be fixed.
     *
     * @type {String}
     * @name Axis#anchor
     * @default ''
     * @example
     *  board.create('axis', [[0,0],[0,1]],{
     *      position: 'fixed',
     *      anchor: 'left',
     *      anchorDist: 2,
     *      strokeColor : 'green',
     *      ticks: {
     *          majorHeight: 7,
     *          drawZero: true,
     *      }
     *  });
     *
     *  board.create('axis', [[0,0],[0,1]], {
     *      position: 'fixed',
     *      anchor: 'right',
     *      anchorDist: 2,
     *      strokeColor : 'blue',
     *      ticks: {
     *          majorHeight: 7,
     *          drawZero: true,
     *      }
     *  });
     *
     *  board.create('axis', [[0,0],[0,-1]], {
     *      position: 'fixed',
     *      anchor: 'left',
     *      anchorDist: 4,
     *      strokeColor : 'red',
     *      ticks:{
     *          majorHeight: 7,
     *          drawZero: true,
     *      }
     *  });
     *
     * </pre><div id="JXG11448b49-02b4-48d4-b0e0-8f06a94e909c" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *      var board = JXG.JSXGraph.initBoard('JXG11448b49-02b4-48d4-b0e0-8f06a94e909c',
     *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: true});
     *
     *      board.create('axis', [[0,0],[0,1]],{
     *          position: 'fixed',
     *          anchor: 'left',
     *          anchorDist: 4,
     *          strokeColor : 'green',
     *          ticks: {
     *              majorHeight: 7,
     *              drawZero: true,
     *          }
     *      });
     *
     *      board.create('axis', [[0,0],[0,1]], {
     *          position: 'fixed',
     *          anchor: 'right',
     *          anchorDist: 2,
     *          strokeColor : 'blue',
     *          ticks: {
     *              majorHeight: 7,
     *              drawZero: true,
     *          }
     *      });
     *
     *      board.create('axis', [[0,0],[0,-1]], {
     *          position: 'fixed',
     *          anchor: 'left',
     *          anchorDist: 4,
     *          strokeColor : 'red',
     *          ticks:{
     *              majorHeight: 7,
     *              drawZero: true,
     *          }
     *      });
     *
     *     })();
     *
     * <\/script><pre>
     */
    anchor: "",
    /**
     * Used to define at which distance to the edge of the board the axis should stick or be fixed.
     * This only has an effect if <tt>position=='sticky'</tt> or <tt>position=='fixed'</tt>.
     * There are the following possibilities:
     * <ul>
     *     <li>Numbers or strings which are numbers (e.g. '10') are interpreted as usrCoords.
     *     <li>Strings with the unit 'px' are interpreted as screen pixels.
     *     <li>Strings with the unit '%' or 'fr' are interpreted as a ratio to the width/height of the board. (e.g. 50% = 0.5fr)
     * </ul>
     *
     * @type {Number|String}
     * @name Axis#anchorDist
     * @default '10%'
     */
    anchorDist: "10%",
    /**
     * If set to true, the tick labels of the axis are automatically positioned in the narrower area between the axis and the side of the board.
     * Settings in this attribute only have an effect if the axis is exactly horizontal or vertical.
     * This option overrides <tt>offset</tt>, <tt>anchorX</tt> and <tt>anchorY</tt> of axis tick labels.
     *
     * @type {Boolean}
     * @name Axis#ticksAutoPos
     * @default false
     * @example
     * // Navigate to see an effect.
     * board.create('axis', [[0, 0], [1, 0]], {
     *     position: 'sticky',
     *     anchor: 'left right',
     *     anchorDist: '0.1',
     *     ticksAutoPos: true,
     * });
     *
     * board.create('axis', [[0, 0], [0, 1]], {
     *     position: 'sticky',
     *     anchor: 'left right',
     *     anchorDist: '0.1',
     *     ticksAutoPos: true,
     * });
     *
     * </pre><div id="JXG557c9b5d-e1bd-4d3b-8362-ff7a863255f3" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG557c9b5d-e1bd-4d3b-8362-ff7a863255f3',
     *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: false});
     *
     *     board.create('axis', [[0, 0], [1, 0]], {
     *         position: 'sticky',
     *         anchor: 'left right',
     *         anchorDist: '0.1',
     *         ticksAutoPos: true,
     *     });
     *
     *     board.create('axis', [[0, 0], [0, 1]], {
     *         position: 'sticky',
     *         anchor: 'left right',
     *         anchorDist: '0.1',
     *         ticksAutoPos: true,
     *     });
     *
     *     })();
     *
     * <\/script><pre>
     */
    ticksAutoPos: false,
    /**
     * Defines, when <tt>ticksAutoPos</tt> takes effect.
     * There are the following possibilities:
     * <ul>
     *     <li>Numbers or strings which are numbers (e.g. '10') are interpreted as usrCoords.
     *     <li>Strings with the unit 'px' are interpreted as screen pixels.
     *     <li>Strings with the unit '%' or 'fr' are interpreted as a ratio to the width/height of the board. (e.g. 50% = 0.5fr)
     * </ul>
     *
     * @type {Number|String}
     * @name Axis#ticksAutoPosThreshold
     * @default '5%'
     */
    ticksAutoPosThreshold: "5%",
    /**
     * Show / hide ticks.
     *
     * Deprecated. Suggested alternative is "ticks: {visible: false}"
     *
     * @type Boolean
     * @name Axis#withTicks
     * @default true
     * @deprecated
     */
    withTicks: true,
    straightFirst: true,
    straightLast: true,
    margin: -4,
    withLabel: false,
    scalable: false,
    /**
     * Attributes for ticks of the axis.
     *
     * @type Ticks
     * @name Axis#ticks
     */
    ticks: {
      label: {
        offset: [4, -12 + 3],
        // This seems to be a good offset for 12 point fonts
        parse: false,
        needsRegularUpdate: false,
        display: "internal",
        visible: "inherit",
        layer: 9
      },
      visible: "inherit",
      needsRegularUpdate: false,
      strokeWidth: 1,
      strokeColor: "#666666",
      highlightStrokeColor: "#888888",
      drawLabels: true,
      drawZero: false,
      insertTicks: true,
      minTicksDistance: 5,
      minorHeight: 10,
      // if <0: full width and height
      majorHeight: -1,
      // if <0: full width and height
      tickEndings: [0, 1],
      majorTickEndings: [1, 1],
      minorTicks: 4,
      ticksDistance: 1,
      // TODO doc
      strokeOpacity: 0.25
    },
    /**
     * Attributes for first point the axis.
     *
     * @type Point
     * @name Axis#point1
     */
    point1: {
      // Default values for point1 if created by line
      needsRegularUpdate: false,
      visible: false
    },
    /**
     * Attributes for second point the axis.
     *
     * @type Point
     * @name Axis#point2
     */
    point2: {
      // Default values for point2 if created by line
      needsRegularUpdate: false,
      visible: false
    },
    tabindex: -1,
    /**
     * Attributes for the axis label.
     *
     * @type Label
     * @name Axis#label
     */
    label: {
      position: "lft",
      offset: [10, 10]
    }
    /**#@-*/
  },
  /* special options for angle bisector of 3 points */
  bisector: {
    /**#@+
     * @visprop
     */
    strokeColor: "#000000",
    // Bisector line
    /**
     * Attributes for the helper point of the bisector.
     *
     * @type Point
     * @name Bisector#point
     */
    point: {
      // Bisector point
      visible: false,
      fixed: false,
      withLabel: false,
      name: ""
    }
    /**#@-*/
  },
  /* special options for the 2 bisectors of 2 lines */
  bisectorlines: {
    /**#@+
     * @visprop
     */
    /**
     * Attributes for first line.
     *
     * @type Line
     * @name Bisectorlines#line1
     */
    line1: {
      //
      strokeColor: "#000000"
    },
    /**
     * Attributes for second line.
     *
     * @type Line
     * @name Bisectorlines#line2
     */
    line2: {
      //
      strokeColor: "#000000"
    }
    /**#@-*/
  },
  /* special options for boxplot curves */
  boxplot: {
    /**#@+
     * @visprop
     */
    /**
     *  Direction of the box plot: 'vertical' or 'horizontal'
     *
     * @type String
     * @name Boxplot#dir
     * @default 'vertical'
     */
    dir: "vertical",
    /**
     * Relative width of the maximum and minimum quantile
     *
     * @type Number
     * @name Boxplot#smallWidth
     * @default 0.5
     */
    smallWidth: 0.5,
    strokeWidth: 2,
    strokeColor: color_default.palette.blue,
    fillColor: color_default.palette.blue,
    fillOpacity: 0.2,
    highlightStrokeWidth: 2,
    highlightStrokeColor: color_default.palette.blue,
    highlightFillColor: color_default.palette.blue,
    highlightFillOpacity: 0.1
    /**#@-*/
  },
  /* special button options */
  button: {
    /**#@+
     * @visprop
     */
    /**
     * Control the attribute "disabled" of the HTML button.
     *
     * @name disabled
     * @memberOf Button.prototype
     *
     * @type Boolean
     * @default false
     */
    disabled: false,
    display: "html"
    /**#@-*/
  },
  /* special cardinal spline options */
  cardinalspline: {
    /**#@+
     * @visprop
     */
    /**
     * Controls if the data points of the cardinal spline when given as
     * arrays should be converted into {@link JXG.Points}.
     *
     * @name createPoints
     * @memberOf Cardinalspline.prototype
     *
     * @see Cardinalspline#points
     *
     * @type Boolean
     * @default true
     */
    createPoints: true,
    /**
     * If set to true, the supplied coordinates are interpreted as
     * [[x_0, y_0], [x_1, y_1], p, ...].
     * Otherwise, if the data consists of two arrays of equal length,
     * it is interpreted as
     * [[x_o x_1, ..., x_n], [y_0, y_1, ..., y_n]]
     *
     * @name isArrayOfCoordinates
     * @memberOf Cardinalspline.prototype
     * @type Boolean
     * @default true
     */
    isArrayOfCoordinates: true,
    /**
     * Attributes for the points generated by Cardinalspline in cases
     * {@link createPoints} is set to true
     *
     * @name points
     * @memberOf Cardinalspline.prototype
     *
     * @see Cardinalspline#createPoints
     * @type Object
     */
    points: {
      strokeOpacity: 0.05,
      fillOpacity: 0.05,
      highlightStrokeOpacity: 1,
      highlightFillOpacity: 1,
      withLabel: false,
      name: "",
      fixed: false
    }
    /**#@-*/
  },
  /* special chart options */
  chart: {
    /**#@+
     * @visprop
     */
    chartStyle: "line",
    colors: ["#B02B2C", "#3F4C6B", "#C79810", "#D15600", "#FFFF88", "#c3d9ff", "#4096EE", "#008C00"],
    highlightcolors: null,
    fillcolor: null,
    highlightonsector: false,
    highlightbysize: false,
    fillOpacity: 0.6,
    withLines: false,
    label: {}
    /**#@-*/
  },
  /* special html slider options */
  checkbox: {
    /**#@+
     * @visprop
     */
    /**
     * Control the attribute "disabled" of the HTML checkbox.
     *
     * @name disabled
     * @memberOf Checkbox.prototype
     *
     * @type Boolean
     * @default false
     */
    disabled: false,
    /**
     * Control the attribute "checked" of the HTML checkbox.
     *
     * @name checked
     * @memberOf Checkbox.prototype
     *
     * @type Boolean
     * @default false
     */
    checked: false,
    display: "html"
    /**#@-*/
  },
  /*special circle options */
  circle: {
    /**#@+
     * @visprop
     */
    /**
     * If <tt>true</tt>, moving the mouse over inner points triggers hasPoint.
     *
     * @see JXG.GeometryElement#hasPoint
     * @name Circle#hasInnerPoints
     * @type Boolean
     * @default false
     */
    hasInnerPoints: false,
    fillColor: "none",
    highlightFillColor: "none",
    strokeColor: color_default.palette.blue,
    highlightStrokeColor: "#c3d9ff",
    /**
     * Attributes for center point.
     *
     * @type Point
     * @name Circle#center
     */
    center: {
      visible: false,
      withLabel: false,
      fixed: false,
      fillColor: color_default.palette.red,
      strokeColor: color_default.palette.red,
      highlightFillColor: "#c3d9ff",
      highlightStrokeColor: "#c3d9ff",
      layer: 9,
      name: ""
    },
    /**
     * Attributes for center point.
     *
     * @type Point
     * @name Circle#point2
     */
    point2: {
      fillColor: color_default.palette.red,
      strokeColor: color_default.palette.red,
      highlightFillColor: "#c3d9ff",
      highlightStrokeColor: "#c3d9ff",
      layer: 9,
      visible: false,
      withLabel: false,
      fixed: false,
      name: ""
    },
    /**
     * Attributes for circle label.
     *
     * @type Label
     * @name Circle#label
     */
    label: {
      position: "urt"
    }
    /**#@-*/
  },
  /* special options for circumcircle of 3 points */
  circumcircle: {
    /**#@+
     * @visprop
     */
    fillColor: "none",
    highlightFillColor: "none",
    strokeColor: color_default.palette.blue,
    highlightStrokeColor: "#c3d9ff",
    /**
     * Attributes for center point.
     *
     * @type Point
     * @name Circumcircle#center
     */
    center: {
      // center point
      visible: false,
      fixed: false,
      withLabel: false,
      fillColor: color_default.palette.red,
      strokeColor: color_default.palette.red,
      highlightFillColor: "#c3d9ff",
      highlightStrokeColor: "#c3d9ff",
      name: ""
    }
    /**#@-*/
  },
  circumcirclearc: {
    /**#@+
     * @visprop
     */
    fillColor: "none",
    highlightFillColor: "none",
    strokeColor: color_default.palette.blue,
    highlightStrokeColor: "#c3d9ff",
    /**
     * Attributes for center point.
     *
     * @type Point
     * @name CircumcircleArc#center
     */
    center: {
      visible: false,
      withLabel: false,
      fixed: false,
      name: ""
    }
    /**#@-*/
  },
  /* special options for circumcircle sector of 3 points */
  circumcirclesector: {
    /**#@+
     * @visprop
     */
    useDirection: true,
    fillColor: color_default.palette.yellow,
    highlightFillColor: color_default.palette.yellow,
    fillOpacity: 0.3,
    highlightFillOpacity: 0.3,
    strokeColor: color_default.palette.blue,
    highlightStrokeColor: "#c3d9ff",
    /**
     * Attributes for center point.
     *
     * @type Point
     * @name Circle#point
     */
    point: {
      visible: false,
      fixed: false,
      withLabel: false,
      name: ""
    }
    /**#@-*/
  },
  /* special options for comb */
  comb: {
    /**#@+
     * @visprop
     */
    /**
     * Frequency of comb elements.
     *
     * @type Number
     * @name Comb#frequency
     * @default 0.2
     */
    frequency: 0.2,
    /**
     * Width of the comb.
     *
     * @type Number
     * @name Comb#width
     * @default 0.4
     */
    width: 0.4,
    /**
     * Angle - given in radians - under which comb elements are positioned.
     *
     * @type Number
     * @name Comb#angle
     * @default Math.PI / 3 (i.e. &pi; /3  or 60^° degrees)
     */
    angle: Math.PI / 3,
    /**
     * Should the comb go right to left instead of left to right.
     *
     * @type Boolean
     * @name Comb#reverse
     * @default false
     */
    reverse: false,
    /**
     * Attributes for first defining point of the comb.
     *
     * @type Point
     * @name Comb#point1
     */
    point1: {
      visible: false,
      withLabel: false,
      fixed: false,
      name: ""
    },
    /**
     * Attributes for second defining point of the comb.
     *
     * @type Point
     * @name Comb#point2
     */
    point2: {
      visible: false,
      withLabel: false,
      fixed: false,
      name: ""
    },
    // /**
    //  * Attributes for the curve displaying the comb.
    //  *
    //  * @type Curve
    //  * @name Comb#curve
    //  */
    // curve: {
    //     strokeWidth: 1,
    //     strokeColor: '#0000ff',
    //     fillColor: 'none'
    // },
    strokeWidth: 1,
    strokeColor: "#0000ff",
    fillColor: "none"
  },
  /* special conic options */
  conic: {
    /**#@+
     * @visprop
     */
    fillColor: "none",
    highlightFillColor: "none",
    strokeColor: color_default.palette.blue,
    highlightStrokeColor: "#c3d9ff",
    /**
     * Attributes for foci points.
     *
     * @type Point
     * @name Conic#foci
     */
    foci: {
      // points
      fixed: false,
      visible: false,
      withLabel: false,
      name: ""
    },
    /**
     * Attributes for center point.
     *
     * @type Point
     * @name Conic#center
     */
    center: {
      visible: false,
      withLabel: false,
      name: ""
    },
    /**
     * Attributes for five points defining the conic, if some of them are given as coordinates.
     *
     * @type Point
     * @name Conic#point
     */
    point: {
      withLabel: false,
      name: ""
    },
    /**
     * Attributes for parabola line in case the line is given by two
     * points or coordinate pairs.
     *
     * @type Line
     * @name Conic#line
     */
    line: {
      visible: false
    }
    /**#@-*/
  },
  /* special curve options */
  curve: {
    /**#@+
     * @visprop
     */
    strokeWidth: 1,
    strokeColor: color_default.palette.blue,
    fillColor: "none",
    fixed: true,
    /**
     * The curveType is set in {@link JXG.Curve#generateTerm} and used in {@link JXG.Curve#updateCurve}.
     * Possible values are <ul>
     * <li>'none'</li>
     * <li>'plot': Data plot</li>
     * <li>'parameter': we can not distinguish function graphs and parameter curves</li>
     * <li>'functiongraph': function graph</li>
     * <li>'polar'</li>
     * <li>'implicit' (not yet)</li></ul>
     * Only parameter and plot are set directly. Polar is set with {@link JXG.GeometryElement#setAttribute} only.
     * @name Curve#curveType
     * @type String
     * @default null
     */
    curveType: null,
    /**
     * If true use a recursive bisection algorithm.
     * It is slower, but usually the result is better. It tries to detect jumps
     * and singularities.
     *
     * @name Curve#doAdvancedPlot
     * @type Boolean
     * @default true
     */
    doAdvancedPlot: true,
    /**
     * If true use the algorithm by Gillam and Hohenwarter, which was default until version 0.98.
     *
     * @name Curve#doAdvancedPlotOld
     * @see Curve#doAdvancedPlot
     * @type Boolean
     * @default false
     * @deprecated
     */
    doAdvancedPlotOld: false,
    // v1
    /**
     * Configure arrow head at the start position for curve.
     * Recommended arrow head type is 7.
     *
     * @name Curve#firstArrow
     * @type Boolean | Object
     * @default false
     * @see Line#firstArrow for options
     */
    firstArrow: false,
    /**
     * The data points of the curve are not connected with straight lines but with bezier curves.
     * @name Curve#handDrawing
     * @type Boolean
     * @default false
     */
    handDrawing: false,
    /**
     * Attributes for curve label.
     *
     * @type Label
     * @name Curve#label
     */
    label: {
      position: "lft"
    },
    /**
     * Configure arrow head at the end position for curve.
     * Recommended arrow head type is 7.
     *
     * @name Curve#lastArrow
     * @see Line#lastArrow for options
     * @type Boolean | Object
     * @default false
     */
    lastArrow: false,
    /**
     * Line endings (linecap) of a curve stroke.
     * Possible values are:
     * <ul>
     * <li> 'butt',
     * <li> 'round',
     * <li> 'square'.
     * </ul>
     *
     * @name JXG.Curve#lineCap
     * @type String
     * @default 'round'
     */
    lineCap: "round",
    /**
     * Number of points used for plotting triggered by up events
     * (i.e. high quality plotting) in case
     * {@link Curve#doAdvancedPlot} is false.
     *
     * @name Curve#numberPointsHigh
     * @see Curve#doAdvancedPlot
     * @type Number
     * @default 1600
     */
    numberPointsHigh: 1600,
    // Number of points on curves after mouseUp
    /**
     * Number of points used for plotting triggered by move events
     * (i.e. lower quality plotting but fast) in case
     * {@link Curve#doAdvancedPlot} is false.
     *
     * @name Curve#numberPointsLow
     * @see Curve#doAdvancedPlot
     * @type Number
     * @default 400
     */
    numberPointsLow: 400,
    // Number of points on curves after mousemove
    /**
     * Select the version of the plot algorithm.
     * <ul>
     * <li> Version 1 is very outdated
     * <li> Version 2 is the default version in JSXGraph v0.99.*, v1.0, and v1.1, v1.2.0
     * <li> Version 3 is an internal version that was never published in  a stable version.
     * <li> Version 4 is available since JSXGraph v1.2.0
     * </ul>
     * Version 4 plots correctly logarithms if the function term is supplied as string (i.e. as JessieCode)
     *
     * @example
     *   var c = board.create('functiongraph', ["log(x)"]);
     *
     * @name Curve#plotVersion
     * @type Number
     * @default 2
     */
    plotVersion: 2,
    /**
     * Configure arrow head at the start position for curve.
     * Recommended arrow head type is 7.
     *
     * @name Curve#recursionDepthHigh
     * @see Curve#doAdvancedPlot
     * @type Number
     * @default 17
     */
    recursionDepthHigh: 17,
    /**
     * Number of points used for plotting triggered by move events in case
     * (i.e. lower quality plotting but fast)
     * {@link Curve#doAdvancedPlot} is true.
     *
     * @name Curve#recursionDepthLow
     * @see Curve#doAdvancedPlot
     * @type Number
     * @default 13
     */
    recursionDepthLow: 15
    /**#@-*/
  },
  /* special foreignObject options */
  foreignobject: {
    /**#@+
     * @visprop
     */
    fixed: true,
    visible: true,
    needsRegularUpdate: false,
    /**
     * List of attractor elements. If the distance of the foreignobject is less than
     * attractorDistance the foreignobject is made to glider of this element.
     *
     * @name ForeignObject#attractors
     *
     * @type Array
     * @default empty
     */
    attractors: []
    /**#@-*/
  },
  /* special functiongraph options */
  functiongraph: {
    /**#@+
     * @visprop
     */
    /**#@-*/
  },
  /* special glider options */
  glider: {
    /**#@+
     * @visprop
     */
    label: {}
    /**#@-*/
  },
  /* special grid options */
  grid: {
    /**#@+
     * @visprop
     */
    needsRegularUpdate: false,
    hasGrid: false,
    // Used in standardoptions
    /**
     * Deprecated. Use {@link Grid#majorStep} instead.
     *
     * @deprecated
     * @type {Number|String}
     * @name Grid#gridX
     * @default null
     */
    gridX: null,
    /**
     * Deprecated. Use {@link Grid#majorStep} instead.
     *
     * @deprecated
     * @type {Number|String}
     * @name Grid#gridY
     * @default null
     */
    gridY: null,
    /**
     * Distance of major grid elements. There are three possibilities:
     * <ul>
     *     <li>If it is set to 'auto' the distance of the major grid equals the distance of majorTicks of the corresponding axis.
     *     <li>Numbers or strings which are numbers (e.g. '10') are interpreted as distance in usrCoords.
     *     <li>Strings with the unit 'px' are interpreted as distance in screen pixels.
     *     <li>Strings with the unit '%' or 'fr' are interpreted as a ratio to the width/height of the board. (e.g. 50% = 0.5fr)
     * </ul>
     * Instead of one value you can provide two values as an array <tt>[x, y]</tt> here.
     * These are used as distance in x- and y-direction.
     *
     * @type {Number|String|Array}
     * @name Grid#majorStep
     * @default 'auto'
     * @see JXG.Ticks#getDistanceMajorTicks
     */
    majorStep: "auto",
    /**
     * Number of elements in minor grid between elements of the major grid. There are three possibilities:
     * <ul>
     *     <li>If set to 'auto', the number minor elements is equal to the number of minorTicks of the corresponding axis.
     *     <li>Numbers or strings which are numbers (e.g. '10') are interpreted as quantity.
     * </ul>
     * Instead of one value you can provide two values as an array <tt>[x, y]</tt> here.
     * These are used as number in x- and y-direction.
     *
     * @type {Number|String|Array}
     * @name Grid#minorElements
     * @default 0
     */
    minorElements: 0,
    /**
     * To print a quadratic grid with same distance of major grid elements in x- and y-direction.
     * <tt>'min'</tt> or <tt>true</tt> will set both distances of major grid elements in x- and y-direction to the primarily lesser value,
     * <tt>'max'</tt> to the primarily greater value.
     *
     * @type {Boolean|String}
     * @name Grid#forceSquare
     * @default false
     */
    forceSquare: false,
    /**
     * To decide whether major or minor grid elements on boundaries of the boundingBox shall be shown, half-ones as well.
     *
     * @type {Boolean}
     * @name Grid#includeBoundaries
     * @default false
     */
    includeBoundaries: false,
    /**
     * This object contains the attributes for major grid elements.
     *
     * @see Grid#major_size
     * @see Grid#major_face
     * @see Grid#major_margin
     * @see Grid#major_drawZero
     * @see Grid#major_polygonVertices
     *
     * @name Grid#major
     * @type Object
     */
    major: {
      /**
       * Size of major grid elements. There are the following possibilities:
       * <ul>
       *     <li>Numbers or strings which are numbers (e.g. '10') are interpreted as size in pixels.
       *     <li>Strings with additional '%' (e.g. '95%') are interpreted as the ratio of used space for one element.
       * </ul>
       * Unused for 'line' and 'point', which will use the value of strokeWidth.
       * Instead of one value you can provide two values as an array <tt>[x, y]</tt> here.
       * These are used as size in x- and y-direction.
       *
       * <br><br><b><i>This attribute is a sub-entry of {@link Grid#major}: <tt>major: {size: ...}</tt></i></b><br>
       *
       * @type {Number|String|Array}
       * @name Grid#major_size
       * @default 5
       */
      size: 5,
      /**
       * Appearance of major grid element.
       * There are different styles which differ in appearance.
       * Possible values are (comparing to {@link Point#face})
       * <table>
       * <tr><th>Input</th><th>Output</th><th>Fillable by fillColor,...</th></tr>
       * <tr><td>point, .</td><td>.</td><td>no</td></tr>
       * <tr><td>line</td><td>&minus;</td><td>no</td></tr>
       * <tr><td>cross, x</td><td>x</td><td>no</td></tr>
       * <tr><td>circle, o</td><td>o</td><td>yes</td></tr>
       * <tr><td>square, []</td><td>[]</td><td>yes</td></tr>
       * <tr><td>plus, +</td><td>+</td><td>no</td></tr>
       * <tr><td>minus, -</td><td>-</td><td>no</td></tr>
       * <tr><td>divide, |</td><td>|</td><td>no</td></tr>
       * <tr><td>diamond, &lt;&gt;</td><td>&lt;&gt;</td><td>yes</td></tr>
       * <tr><td>diamond2, &lt;&lt;&gt;&gt;</td><td>&lt;&gt; (bigger)</td><td>yes</td></tr>
       * <tr><td>triangleup, ^, a, A</td><td>^</td><td>no</td></tr>
       * <tr><td>triangledown, v</td><td>v</td><td>no</td></tr>
       * <tr><td>triangleleft, &lt;</td><td> &lt;</td><td>no</td></tr>
       * <tr><td>triangleright, &gt;</td><td>&gt;</td><td>no</td></tr>
       * <tr><td>regularPolygon, regpol</td><td>⬡</td><td>yes</td></tr>
       * </table>
       *
       * <br><b><i>This attribute is a sub-entry of {@link Grid#major}: <tt>major: {face: ...}</tt></i></b><br>
       *
       * @type {String}
       * @name Grid#major_face
       * @default 'line'
       */
      face: "line",
      /**
       * This number (pixel value) controls where infinite lines end at the canvas border. If zero, the line
       * ends exactly at the border, if negative there is a margin to the inside, if positive the line
       * ends outside of the canvas (which is invisible).
       *
       * <br><br><b><i>This attribute is a sub-entry of {@link Grid#major}: <tt>major: {margin: ...}</tt></i></b><br>
       *
       * @name Grid#major_margin
       * @type Number
       * @default 0
       */
      margin: 0,
      /**
       * This attribute determines whether the grid elements located at <tt>x=0</tt>, <tt>y=0</tt>
       * and especially at <tt>(0, 0)</tt> are displayed.
       * <ul>
       *     <li>If <tt>false</tt>, then all these elements are hidden.
       *     <li>If <tt>true</tt>, all these elements are shown.
       *     <li>If an object of the following form is given, the three cases can be distinguished individually:<br>
       *     <tt>{x: true|false, y: true|false, origin: true|false}</tt>
       * </ul>
       *
       * <br><b><i>This attribute is a sub-entry of {@link Grid#major}: <tt>major: {drawZero: ...}</tt></i></b><br>
       *
       * @type {Boolean|Object}
       * @name Grid#major_drawZero
       * @default false
       */
      drawZero: false,
      /**
       * Number of vertices for face 'polygon'.
       *
       * <br><br><b><i>This attribute is a sub-entry of {@link Grid#major}: <tt>major: {polygonVertices: ...}</tt></i></b><br>
       *
       * @type {Number}
       * @name Grid#major_polygonVertices
       * @default 6
       */
      polygonVertices: 6,
      strokeColor: "#c0c0c0",
      // same in old grid
      strokeWidth: 1,
      // same in old grid
      strokeOpacity: 0.5,
      // same in old grid
      highlight: false
    },
    /**
     * This object contains the attributes for minor grid elements.
     *
     * @see Grid#minor_size
     * @see Grid#minor_face
     * @see Grid#minor_margin
     * @see Grid#minor_drawZero
     * @see Grid#minor_polygonVertices
     *
     * @name Grid#minor
     * @type Object
     */
    minor: {
      /**
       * @class
       * @ignore
       */
      visible: "inherit",
      /**
       * Size of minor grid elements. There are the following possibilities:
       * <ul>
       *     <li>Numbers or strings which are numbers (e.g. '10') are interpreted as size in pixels.
       *     <li>Strings with additional '%' (e.g. '95%') are interpreted as the ratio of used space for one element.
       * </ul>
       * Unused for 'line' and 'point', which will use the value of strokeWidth.
       * Instead of one value you can provide two values as an array <tt>[x, y]</tt> here.
       * These are used as size in x- and y-direction.
       *
       * <br><br><b><i>This attribute is a sub-entry of {@link Grid#minor}: <tt>minor: {size: ...}</tt></i></b><br>
       *
       * @type {Number|String|Array}
       * @name Grid#minor_size
       * @default 5
       */
      size: 3,
      /**
       * Appearance of minor grid elements. Same options as for major grid elements.
       *
       * <br><br><b><i>This attribute is a sub-entry of {@link Grid#minor}: <tt>minor: {face: ...}</tt></i></b><br>
       *
       * @type {String}
       * @name Grid#minor_face
       * @default 'point'
       * @see Grid#major_face
       */
      face: "point",
      /**
       * This number (pixel value) controls where infinite lines end at the canvas border. If zero, the line
       * ends exactly at the border, if negative there is a margin to the inside, if positive the line
       * ends outside of the canvas (which is invisible).
       *
       * <br><br><b><i>This attribute is a sub-entry of {@link Grid#minor}: <tt>minor: {margin: ...}</tt></i></b><br>
       *
       * @name Grid#minor_margin
       * @type Number
       * @default 0
       */
      margin: 0,
      /**
       * This attribute determines whether the minor grid elements located at <tt>x=0</tt> and <tt>y=0</tt> are displayed.
       * <ul>
       *     <li>If <tt>false</tt>, then all these elements are hidden.
       *     <li>If <tt>true</tt>, all these elements are shown.
       *     <li>If an object of the following form is given, the three cases can be distinguished individually:<br>
       *     <tt>{x: true|false, y: true|false}</tt>
       * </ul>
       *
       * <br><b><i>This attribute is a sub-entry of {@link Grid#minor}: <tt>minor: {drawZero: ...}</tt></i></b><br>
       *
       * @type {Boolean|Object}
       * @name Grid#minor_drawZero
       * @default false
       */
      drawZero: false,
      /**
       * Number of vertices for face 'polygon'.
       *
       * <br><br><b><i>This attribute is a sub-entry of {@link Grid#minor}: <tt>minor: {polygonVertices: ...}</tt></i></b><br>
       *
       * @type {Number}
       * @name Grid#minor_polygonVertices
       * @default 6
       */
      polygonVertices: 6,
      strokeColor: "#c0c0c0",
      strokeWidth: 1,
      strokeOpacity: 0.25,
      highlight: false
    },
    /**
     * @class
     * @ignore
     * @deprecated
     */
    snapToGrid: false,
    /**
     * Use a predefined theme for grid.
     * Attributes can be overwritten by explicitly set the specific value.
     *
     * @type {Number}
     * @default 0
     * @see Grid#themes
     */
    theme: 0,
    /**
     * Array of theme attributes.
     * The index of the entry is the number of the theme.
     *
     * @type {Array}
     * @name Grid#themes
     * @private
     *
     * @example
     * // Theme 1
     * // quadratic grid appearance with distance of major grid elements set to the primarily greater one
     *
     * const board = JXG.JSXGraph.initBoard('jxgbox', {
     *     boundingbox: [-4, 4, 4, -4], axis: true,
     *     defaultAxes: {
     *         x: { ticks: {majorHeight: 10} },
     *         y: { ticks: {majorHeight: 10} }
     *     },
     *     grid: { theme: 1, color: 'grey' },
     * });
     * </pre> <div id="JXGb8d606c4-7c67-4dc0-9941-3b3bd0932898" class="jxgbox" style="width: 300px; height: 200px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGb8d606c4-7c67-4dc0-9941-3b3bd0932898',
     *             {boundingbox: [-4, 4, 4, -4], axis: true, showcopyright: false, shownavigation: false,
     *                 defaultAxes: {
     *                     x: { ticks: {majorHeight: 10} },
     *                     y: { ticks: {majorHeight: 10} }
     *                 },
     *                grid: { theme: 1, color: 'grey' },
     *             });
     *     })();
     * <\/script> <pre>
     *
     * @example
     * // Theme 2
     * // lines and subtile points in between
     *
     * const board = JXG.JSXGraph.initBoard('jxgbox', {
     *     boundingbox: [-4, 4, 4, -4], axis: false,
     *     grid: { theme: 2, minorElements: 4, color: 'grey' },
     * });
     * </pre> <div id="JXG4e11e6e3-472a-48e0-b7d0-f80d397c769b" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG4e11e6e3-472a-48e0-b7d0-f80d397c769b',
     *             {boundingbox: [-4, 4, 4, -4], axis: false, showcopyright: false, shownavigation: false,
     *                 grid: { theme: 2, minorElements: 4, color: 'grey' },
     *             })
     *     })();
     * <\/script> <pre>
     *
     * @example
     * // Theme 3
     * // lines and thinner lines in between
     *
     * const board = JXG.JSXGraph.initBoard('jxgbox', {
     *     boundingbox: [-4, 4, 4, -4], axis: false,
     *     grid: { theme: 4, minorElements: 4, color: 'grey' },
     * });
     * </pre> <div id="JXG334814a3-03a7-4231-a5a7-a42d3b8dc2de" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG334814a3-03a7-4231-a5a7-a42d3b8dc2de',
     *             {boundingbox: [-4, 4, 4, -4], axis: false, showcopyright: false, shownavigation: false,
     *                 grid: { theme: 4, minorElements: 4, color: 'grey' }
     *         });
     *     })();
     * <\/script> <pre>
     *
     * @example
     * // Theme 4
     * // lines with more subtle grid of '+'s plotted in between
     *
     * const board = JXG.JSXGraph.initBoard('jxgbox', {
     *     boundingbox: [-4, 4, 4, -4], axis: false,
     *     grid: { theme: 5, minorElements: 4, color: 'grey' },
     * });
     * </pre> <div id="JXG9e2bb29c-d998-428c-9432-4a7bf6cd9222" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG9e2bb29c-d998-428c-9432-4a7bf6cd9222',
     *             {boundingbox: [-4, 4, 4, -4], axis: false, showcopyright: false, shownavigation: false,
     *                 grid: { theme: 5, minorElements: 4, color: 'grey' },
     *             });
     *     })();
     * <\/script> <pre>
     *
     * @example
     * // Theme 5
     * // grid of '+'s and more subtile points in between
     *
     * const board = JXG.JSXGraph.initBoard('jxgbox', {
     *     boundingbox: [-4, 4, 4, -4], axis: false,
     *     grid: { theme: 6, minorElements: 4, color: 'grey' },
     * });
     * </pre> <div id="JXG6a967d83-4179-4827-9e97-63fbf1e872c8" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG6a967d83-4179-4827-9e97-63fbf1e872c8',
     *             {boundingbox: [-4, 4, 4, -4], axis: false, showcopyright: false, shownavigation: false,
     *                 grid: { theme: 6, minorElements: 4, color: 'grey' },
     *         });
     *     })();
     * <\/script> <pre>
     *
     * @example
     * // Theme 6
     * // grid of circles with subtile points in between
     *
     * const board = JXG.JSXGraph.initBoard('jxgbox', {
     *     boundingbox: [-4, 4, 4, -4], axis: false,
     *     grid: { theme: 3, minorElements: 4, strokeColor: 'grey' },
     * });
     * </pre> <div id="JXG28bee3da-a7ef-4590-9a18-38d1b99d09ce" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG28bee3da-a7ef-4590-9a18-38d1b99d09ce',
     *             {boundingbox: [-4, 4, 4, -4], axis: false, showcopyright: false, shownavigation: false,
     *                 grid: { theme: 3, minorElements: 4, strokeColor: 'grey' },
     *         });
     *     })();
     * <\/script> <pre>
     *
     * @example
     * // Theme 7
     * // lines and subtile points in between, also plotted on axes
     *
     * const board = JXG.JSXGraph.initBoard('jxgbox', {
     *     boundingbox: [-4, 4, 4, -4], axis: false,
     *     grid: { theme: 7, minorElements: 4, color: 'grey' },
     * });
     * </pre> <div id="JXG7a787274-7f7e-4e10-b59c-f99f1aff35e7" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG7a787274-7f7e-4e10-b59c-f99f1aff35e7',
     *             {boundingbox: [-4, 4, 4, -4], axis: false, showcopyright: false, shownavigation: false,
     *                 grid: { theme: 7, minorElements: 4, color: 'grey' },
     *         });
     *     })();
     * <\/script> <pre>
     */
    themes: [
      {
        // default values
      },
      {
        // Theme 1: quadratic grid appearance with distance of major grid elements in x- and y-direction set to the primarily smaller one
        forceSquare: "min"
      },
      {
        // Theme 2: lines and subtile points in between
        minor: {
          size: 3,
          strokeColor: "#101010"
        },
        minorElements: "auto"
      },
      {
        // Theme 3: lines and thinner lines in between
        minor: {
          face: "line"
        },
        minorElements: "auto"
      },
      {
        // Theme 4: lines with more subtle grid of '+'s plotted in between
        minor: {
          face: "+",
          size: "95%"
        },
        minorElements: "auto"
      },
      {
        // Theme 5: grid of '+'s and more subtile points in between
        major: {
          face: "+",
          size: 10,
          strokeOpacity: 1
        },
        minor: {
          size: 3
        },
        minorElements: "auto"
      },
      {
        // Theme 6: grid of circles with subtile points in between
        major: {
          face: "circle",
          size: 5
        },
        minor: {
          size: 3
        },
        minorElements: "auto"
      },
      {
        // Theme 7: lines and subtile points in between, also plotted on axes
        major: {
          drawZero: true
        },
        minor: {
          size: 3,
          drawZero: true
        },
        minorElements: 4
      }
    ]
    /**#@-*/
  },
  group: {
    needsRegularUpdate: true
  },
  /* special html slider options */
  htmlslider: {
    /**#@+
     * @visprop
     */
    // /**
    //  *
    //  * These affect the DOM element input type="range".
    //  * The other attributes affect the DOM element div containing the range element.
    //  */
    widthRange: 100,
    widthOut: 34,
    step: 0.01,
    frozen: true,
    isLabel: false,
    strokeColor: "#000000",
    display: "html",
    anchorX: "left",
    anchorY: "middle",
    withLabel: false
    /**#@-*/
  },
  /* special image options */
  image: {
    /**#@+
     * @visprop
     */
    imageString: null,
    fillOpacity: 1,
    highlightFillOpacity: 0.6,
    /**
     * Defines the CSS class used by the image. CSS attributes defined in
     * this class will overwrite the corresponding JSXGraph attributes, e.g.
     * opacity.
     * The default CSS class is defined in jsxgraph.css.
     *
     * @name Image#cssClass
     *
     * @see Image#highlightCssClass
     * @type String
     * @default 'JXGimage'
     */
    cssClass: "JXGimage",
    /**
     * Defines the CSS class used by the image when highlighted.
     * CSS attributes defined in this class will overwrite the
     * corresponding JSXGraph attributes, e.g. highlightFillOpacity.
     * The default CSS class is defined in jsxgraph.css.
     *
     * @name Image#highlightCssClass
     *
     * @see Image#cssClass
     * @type String
     * @default 'JXGimageHighlight'
     */
    highlightCssClass: "JXGimageHighlight",
    /**
     * Image rotation in degrees.
     *
     * @name Image#rotate
     * @type Number
     * @default 0
     */
    rotate: 0,
    /**
     * Defines together with {@link Image#snapSizeY} the grid the image snaps on to.
     * The image will only snap on user coordinates which are
     * integer multiples to snapSizeX in x and snapSizeY in y direction.
     * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks
     * of the default ticks of the default x axes of the board.
     *
     * @name Image#snapSizeX
     *
     * @see Point#snapToGrid
     * @see Image#snapSizeY
     * @see JXG.Board#defaultAxes
     * @type Number
     * @default 1
     */
    snapSizeX: 1,
    /**
     * Defines together with {@link Image#snapSizeX} the grid the image snaps on to.
     * The image will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.
     * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks
     * of the default ticks of the default y axes of the board.
     *
     * @name Image#snapSizeY
     *
     * @see Point#snapToGrid
     * @see Image#snapSizeX
     * @see JXG.Board#defaultAxes
     * @type Number
     * @default 1
     */
    snapSizeY: 1,
    /**
     * List of attractor elements. If the distance of the image is less than
     * attractorDistance the image is made to glider of this element.
     *
     * @name Image#attractors
     *
     * @type Array
     * @default empty
     */
    attractors: []
    /**#@-*/
  },
  /* special implicitcurve options */
  implicitcurve: {
    /**#@+
     * @visprop
     */
    /**
     * Defines the margin (in user coordinates) around the JSXGraph board in which the
     * implicit curve is plotted.
     *
     * @name ImplicitCurve#margin
     * @type {Number|Function}
     * @default 1
     */
    margin: 1,
    /**
     * Horizontal resolution: distance (in pixel) between vertical lines to search for components of the implicit curve.
     * A small number increases the running time. For large number components may be missed.
     * Minimum value is 0.01.
     *
     * @name ImplicitCurve#resolution_outer
     * @type {Number|Function}
     * @default 5
     */
    resolution_outer: 5,
    /**
     * Vertical resolution (in pixel) to search for components of the implicit curve.
     * A small number increases the running time. For large number components may be missed.
     * Minimum value is 0.01.
     *
     * @name ImplicitCurve#resolution_inner
     * @type {Number|Function}
     * @default 5
     */
    resolution_inner: 5,
    /**
     * Maximum iterations for one component of the implicit curve.
     *
     * @name ImplicitCurve#max_steps
     * @type {Number|Function}
     * @default 1024
     */
    max_steps: 1024,
    /**
     * Angle &alpha;<sub>0</sub> between two successive tangents: determines the smoothness of
     * the curve.
     *
     * @name ImplicitCurve#alpha_0
     * @type {Number|Function}
     * @default 0.05
     */
    alpha_0: 0.05,
    /**
     * Tolerance to find starting points for the tracing phase of a component.
     *
     * @name ImplicitCurve#tol_0
     * @type {Number|Function}
     * @default JXG.Math.eps
     */
    tol_u0: math_default.eps,
    /**
     * Tolerance for the Newton steps.
     *
     * @name ImplicitCurve#tol_newton
     * @type {Number|Function}
     * @default 1.0e-7
     */
    tol_newton: 1e-7,
    /**
     * Tolerance for cusp / bifurcation detection.
     *
     * @name ImplicitCurve#tol_cusp
     * @type {Number|Function}
     * @default 0.05
     */
    tol_cusp: 0.05,
    /**
     * If two points are closer than this value, we bail out of the tracing phase for that
     * component.
     *
     * @name ImplicitCurve#tol_progress
     * @type {Number|Function}
     * @default 0.0001
     */
    tol_progress: 1e-4,
    /**
     * Half of the box size (in user units) to search for existing line segments in the quadtree.
     *
     * @name ImplicitCurve#qdt_box
     * @type {Number|Function}
     * @default 0.2
     */
    qdt_box: 0.2,
    /**
     * Inverse of desired number of Newton steps.
     *
     * @name ImplicitCurve#kappa_0
     * @type {Number|Function}
     * @default 0.2
     */
    kappa_0: 0.2,
    /**
     * Allowed distance (in user units) of predictor point to curve.
     *
     * @name ImplicitCurve#delta_0
     * @type {Number|Function}
     * @default 0.05
     */
    delta_0: 0.05,
    /**
     * Initial step width (in user units).
     *
     * @name ImplicitCurve#h_initial
     * @type {Number|Function}
     * @default 0.1
     */
    h_initial: 0.1,
    /**
     * If h is below this threshold (in user units), we bail out
     * of the tracing phase of that component.
     *
     * @name ImplicitCurve#h_critical
     * @type {Number|Function}
     * @default 0.001
     */
    h_critical: 1e-3,
    /**
     * Maximum step width (in user units).
     *
     * @name ImplicitCurve#h_max
     * @type {Number|Function}
     * @default 1
     */
    h_max: 1,
    /**
     * Allowed distance (in user units multiplied by actual step width) to detect loop.
     *
     * @name ImplicitCurve#loop_dist
     * @type {Number|Function}
     * @default 0.09
     */
    loop_dist: 0.09,
    /**
     * Minimum acos of angle to detect loop.
     *
     * @name ImplicitCurve#loop_dir
     * @type {Number|Function}
     * @default 0.99
     */
    loop_dir: 0.99,
    /**
     * Use Gosper's loop detector.
     *
     * @name ImplicitCurve#loop_detection
     * @type {Boolean|Function}
     * @default true
     */
    loop_detection: true
    /**#@-*/
  },
  /* special options for incircle of 3 points */
  incircle: {
    /**#@+
     * @visprop
     */
    fillColor: "none",
    highlightFillColor: "none",
    strokeColor: color_default.palette.blue,
    highlightStrokeColor: "#c3d9ff",
    /**
     * Attributes of circle center.
     *
     * @type Point
     * @name Incircle#center
     */
    center: {
      // center point
      visible: false,
      fixed: false,
      withLabel: false,
      fillColor: color_default.palette.red,
      strokeColor: color_default.palette.red,
      highlightFillColor: "#c3d9ff",
      highlightStrokeColor: "#c3d9ff",
      name: ""
    }
    /**#@-*/
  },
  inequality: {
    /**#@+
     * @visprop
     */
    fillColor: color_default.palette.red,
    fillOpacity: 0.2,
    strokeColor: "none",
    /**
     * By default an inequality is less (or equal) than. Set inverse to <tt>true</tt> will consider the inequality
     * greater (or equal) than.
     *
     * @type Boolean
     * @default false
     * @name Inequality#inverse
     * @visprop
     */
    inverse: false
    /**#@-*/
  },
  infobox: {
    /**#@+
     * @visprop
     */
    /**
     * Horizontal offset in pixel of the infobox text from its anchor point.
     *
     * @type Number
     * @default -20
     * @name JXG.Board.infobox#distanceX
     * @visprop
     */
    distanceX: -20,
    /**
     * Vertical offset in pixel of the infobox text from its anchor point.
     *
     * @type Number
     * @default 25
     * @name JXG.Board.infobox#distanceY
     * @visprop
     */
    distanceY: 25,
    /**
     * Internationalization support for infobox text.
     *
     * @name JXG.Board.infobox#intl
     * @type object
     * @default <pre>{
     *    enabled: 'inherit',
     *    options: {}
     * }</pre>
     * @visprop
     * @see JXG.Board#intl
     * @see Text#intl
     */
    intl: {
      enabled: "inherit",
      options: {}
    },
    fontSize: 12,
    isLabel: false,
    strokeColor: "#bbbbbb",
    display: "html",
    // 'html' or 'internal'
    anchorX: "left",
    //  'left', 'middle', or 'right': horizontal alignment
    //  of the text.
    anchorY: "middle",
    //  'top', 'middle', or 'bottom': vertical alignment
    //  of the text.
    cssClass: "JXGinfobox",
    rotate: 0,
    // works for non-zero values only in combination
    // with display=='internal'
    visible: true,
    parse: false,
    transitionDuration: 0,
    needsRegularUpdate: false,
    tabindex: null,
    viewport: [0, 0, 0, 0]
    /**#@-*/
  },
  /* special options for integral */
  integral: {
    /**#@+
     * @visprop
     */
    axis: "x",
    // 'x' or 'y'
    withLabel: true,
    // Show integral value as text
    fixed: true,
    strokeWidth: 0,
    strokeOpacity: 0,
    fillColor: color_default.palette.red,
    fillOpacity: 0.3,
    highlightFillColor: color_default.palette.red,
    highlightFillOpacity: 0.2,
    /**
     * Attributes of the (left) starting point of the integral.
     *
     * @type Point
     * @name Integral#curveLeft
     * @see Integral#baseLeft
     */
    curveLeft: {
      // Start point
      visible: true,
      withLabel: false,
      color: color_default.palette.red,
      fillOpacity: 0.8,
      layer: 9
    },
    /**
     * Attributes of the (left) base point of the integral.
     *
     * @type Point
     * @name Integral#baseLeft
     * @see Integral#curveLeft
     */
    baseLeft: {
      // Start point
      visible: false,
      fixed: false,
      withLabel: false,
      name: ""
    },
    /**
     * Attributes of the (right) end point of the integral.
     *
     * @type Point
     * @name Integral#curveRight
     * @see Integral#baseRight
     */
    curveRight: {
      // End point
      visible: true,
      withLabel: false,
      color: color_default.palette.red,
      fillOpacity: 0.8,
      layer: 9
    },
    /**
     * Attributes of the (right) base point of the integral.
     *
     * @type Point
     * @name Integral#baseRight
     * @see Integral#curveRight
     */
    baseRight: {
      // End point
      visible: false,
      fixed: false,
      withLabel: false,
      name: ""
    },
    /**
     * Attributes for integral label.
     *
     * @type Label
     * @name Integral#label
     * @default <pre>{
     *      fontSize: 20,
     *      digits: 4,
     *      intl: {
     *          enabled: false,
     *          options: {}
     *      }
     *    }</pre>
     */
    label: {
      fontSize: 20,
      digits: 4,
      intl: {
        enabled: false,
        options: {}
      }
    }
    /**#@-*/
  },
  /* special input options */
  input: {
    /**#@+
     * @visprop
     */
    /**
     * Control the attribute "disabled" of the HTML input field.
     *
     * @name disabled
     * @memberOf Input.prototype
     *
     * @type Boolean
     * @default false
     */
    disabled: false,
    /**
     * Control the attribute "maxlength" of the HTML input field.
     *
     * @name maxlength
     * @memberOf Input.prototype
     *
     * @type Number
     * @default 524288 (as in HTML)
     */
    maxlength: 524288,
    display: "html"
    /**#@-*/
  },
  /* special intersection point options */
  intersection: {
    /**#@+
     * @visprop
     */
    /**
     * Used in {@link JXG.Intersection}.
     * This flag sets the behaviour of intersection points of e.g.
     * two segments. If true, the intersection is treated as intersection of lines. If false
     * the intersection point exists if the segments intersect setwise.
     *
     * @name Intersection.alwaysIntersect
     * @type Boolean
     * @default true
     */
    alwaysIntersect: true
    /**#@-*/
  },
  /* special label options */
  label: {
    /**#@+
     * @visprop
     */
    visible: "inherit",
    strokeColor: "#000000",
    strokeOpacity: 1,
    highlightStrokeOpacity: 0.666666,
    highlightStrokeColor: "#000000",
    fixed: true,
    /**
     * Possible string values for the position of a label for
     * label anchor points are:
     * <ul>
     * <li> 'first' (lines only)
     * <li> 'last' (lines only)
     * <li> 'lft'
     * <li> 'rt'
     * <li> 'top'
     * <li> 'bot'
     * <li> 'ulft'
     * <li> 'urt'
     * <li> 'llft'
     * <li> 'lrt'
     * </ul>
     * This is relevant for non-points: line, circle, curve.
     *
     * The names have been borrowed from <a href="https://www.tug.org/metapost.html">MetaPost</a>.
     *
     * @name Label#position
     * @see Label#offset
     * @type String
     * @default 'urt'
     */
    position: "urt",
    /**
     *  Label offset from label anchor.
     *  The label anchor is determined by {@link Label#position}
     *
     * @name Label#offset
     * @see Label#position
     * @type Array
     * @default [10,10]
     */
    offset: [10, 10],
    /**
     * Automatic position of label text. When called first, the positioning algorithm
     * starts at the position defined by offset.
     * The algorithm tries to find a position with the least number of
     * overlappings with other elements, while retaining the distance
     * to the anchor element.
     *
     * @name Label#autoPosition
     * @see Label#offset
     * @type Boolean
     * @default false
     *
     * @example
     * 	var p1 = board.create('point', [-2, 1], {id: 'A'});
     * 	var p2 = board.create('point', [-0.85, 1], {
     *      name: 'B', id: 'B', label:{autoPosition: true, offset:[10, 10]}
     *  });
     * 	var p3 = board.create('point', [-1, 1.2], {
     *      name: 'C', id: 'C', label:{autoPosition: true, offset:[10, 10]}
     *  });
     *  var c = board.create('circle', [p1, p2]);
     * 	var l = board.create('line', [p1, p2]);
     *
     * </pre><div id="JXG7d4dafe7-1a07-4d3f-95cb-bfed9d96dea2" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG7d4dafe7-1a07-4d3f-95cb-bfed9d96dea2',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     	var p1 = board.create('point', [-2, 1], {id: 'A'});
     *     	var p2 = board.create('point', [-0.85, 1], {name: 'B', id: 'B', label:{autoPosition: true, offset:[10, 10]}});
     *     	var p3 = board.create('point', [-1, 1.2], {name: 'C', id: 'C', label:{autoPosition: true, offset:[10, 10]}});
     *      var c = board.create('circle', [p1, p2]);
     *     	var l = board.create('line', [p1, p2]);
     *
     *     })();
     *
     * <\/script><pre>
     *
     *
     */
    autoPosition: false,
    /**
     * The auto position algorithm tries to put a label to a conflict-free
     * position around it's anchor element. For this, the algorithm tests 12 positions
     * around the anchor element starting at a distance from the anchor
     * defined here (in pixel).
     *
     * @name Label#autoPositionMinDistance
     * @see Label#autoPosition
     * @see Label#autoPositionMaxDistance
     * @type Number
     * @default 12
     *
     */
    autoPositionMinDistance: 12,
    /**
     * The auto position algorithm tries to put a label to a conflict-free
     * position around it's anchor element. For this, the algorithm tests 12 positions
     * around the anchor element up to a distance from the anchor
     * defined here (in pixel).
     *
     * @name Label#autoPositionMaxDistance
     * @see Label#autoPosition
     * @see Label#autoPositionMinDistance
     * @type Number
     * @default 28
     *
     */
    autoPositionMaxDistance: 28
    /**#@-*/
  },
  /* special legend options */
  legend: {
    /**
     * @visprop
     */
    /**
     * Default style of a legend element. The only possible value is 'vertical'.
     * @name Legend#style
     * @type String
     * @default 'vertical'
     */
    style: "vertical",
    /**
     * Label names of a legend element.
     * @name Legend#labels
     * @type Array
     * @default "['1', '2', '3', '4', '5', '6', '7', '8']"
     */
    labels: ["1", "2", "3", "4", "5", "6", "7", "8"],
    /**
     * (Circular) array of label colors.
     * @name Legend#colors
     * @type Array
     * @default "['#B02B2C', '#3F4C6B', '#C79810', '#D15600', '#FFFF88', '#c3d9ff', '#4096EE', '#008C00']"
     */
    colors: ["#B02B2C", "#3F4C6B", "#C79810", "#D15600", "#FFFF88", "#c3d9ff", "#4096EE", "#008C00"],
    /**
     * Height (in px) of one legend entry
     * @name Legend#rowHeight
     * @type Number
     * @default 20
     *
     */
    rowHeight: 20,
    strokeWidth: 5
    /**#@-*/
  },
  /* special line options */
  line: {
    /**#@+
     * @visprop
     */
    /**
     * Configure the arrow head at the position of its first point or the corresponding
     * intersection with the canvas border
     *
     * The attribute firstArrow can be a Boolean or an object with the following sub-attributes:
     * <pre>
     * {
     *      type: 1, // possible values are 1, 2, ..., 7. Default value is 1.
     *      size: 6, // size of the arrow head. Default value is 6.
     *               // This value is multiplied with the strokeWidth of the line
     *               // Exception: for type=7 size is ignored
     *      highlightSize: 6, // size of the arrow head in case the element is highlighted. Default value
     * }
     * </pre>
     * type=7 is the default for curves if firstArrow: true
     * <p>
     * An arrow head can be turned off with line.setAttribute({firstArrow: false}).
     *
     * @example
     *     board.options.line.lastArrow = false;
     *     board.options.line.firstArrow = {size: 10, highlightSize: 10};
     *     board.options.line.point1 = {visible: false, withLabel: true, label: {visible: true, anchorX: 'right'}};
     *     board.options.line.strokeWidth = 4;
     *     board.options.line.highlightStrokeWidth = 4;
     *
     *     board.create('segment', [[-5,4], [3,4]], {firstArrow: {type: 1}, point1: {name: 'type:1'}});
     *     board.create('segment', [[-5,3], [3,3]], {firstArrow: {type: 2}, point1: {name: 'type:2'}});
     *     board.create('segment', [[-5,2], [3,2]], {firstArrow: {type: 3}, point1: {name: 'type:3'}});
     *     board.create('segment', [[-5,1], [3,1]], {firstArrow: {type: 4}, point1: {name: 'type:4'}});
     *     board.create('segment', [[-5,0], [3,0]], {firstArrow: {type: 5}, point1: {name: 'type:5'}});
     *     board.create('segment', [[-5,-1], [3,-1]], {firstArrow: {type: 6}, point1: {name: 'type:6'}});
     *     board.create('segment', [[-5,-2], [3,-2]], {firstArrow: {type: 7}, point1: {name: 'type:7'}});
     *
     * </pre><div id="JXGc94a93da-c942-4204-8bb6-b39726cbb09b" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGc94a93da-c942-4204-8bb6-b39726cbb09b',
     *             {boundingbox: [-6, 6, 4,-4], axis: false, showcopyright: false, shownavigation: false});
     *         board.options.line.lastArrow = false;
     *         board.options.line.firstArrow = {size: 10, highlightSize: 10};
     *         board.options.line.point1 = {visible: false, withLabel: true, label: {visible: true, anchorX: 'right'}};
     *         board.options.line.strokeWidth = 4;
     *         board.options.line.highlightStrokeWidth = 4;
     *
     *         board.create('segment', [[-5,4], [3,4]], {firstArrow: {type: 1}, point1: {name: 'type:1'}});
     *         board.create('segment', [[-5,3], [3,3]], {firstArrow: {type: 2}, point1: {name: 'type:2'}});
     *         board.create('segment', [[-5,2], [3,2]], {firstArrow: {type: 3}, point1: {name: 'type:3'}});
     *         board.create('segment', [[-5,1], [3,1]], {firstArrow: {type: 4}, point1: {name: 'type:4'}});
     *         board.create('segment', [[-5,0], [3,0]], {firstArrow: {type: 5}, point1: {name: 'type:5'}});
     *         board.create('segment', [[-5,-1], [3,-1]], {firstArrow: {type: 6}, point1: {name: 'type:6'}});
     *         board.create('segment', [[-5,-2], [3,-2]], {firstArrow: {type: 7}, point1: {name: 'type:7'}});
     *
     *     })();
     *
     * <\/script><pre>
     *
     * @name Line#firstArrow
     * @see Line#lastArrow
     * @see Line#touchFirstPoint
     * @type Boolean | Object
     * @default false
     */
    firstArrow: false,
    /**
     * Configure the arrow head at the position of its second point or the corresponding
     * intersection with the canvas border.
     *
     * The attribute lastArrow can be a Boolean or an object with the following sub-attributes:
     * <pre>
     * {
     *      type: 1, // possible values are 1, 2, ..., 7. Default value is 1.
     *      size: 6, // size of the arrow head. Default value is 6.
     *               // This value is multiplied with the strokeWidth of the line.
     *               // Exception: for type=7 size is ignored
     *      highlightSize: 6, // size of the arrow head in case the element is highlighted. Default value is 6.
     * }
     * </pre>
     * type=7 is the default for curves if lastArrow: true
     * <p>
     * An arrow head can be turned off with line.setAttribute({lastArrow: false}).
     *
     * @example
     *     var p1 = board.create('point', [-5, 2], {size:1});
     *     var p2 = board.create('point', [5, 2], {size:10});
     *     var li = board.create('segment', ['A','B'],
     *         {name:'seg',
     *          strokeColor:'#000000',
     *          strokeWidth:1,
     *          highlightStrokeWidth: 5,
     *          lastArrow: {type: 2, size: 8, highlightSize: 6},
     *          touchLastPoint: true,
     *          firstArrow: {type: 3, size: 8}
     *         });
     *
     * </pre><div id="JXG184e915c-c2ef-11e8-bece-04d3b0c2aad3" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG184e915c-c2ef-11e8-bece-04d3b0c2aad3',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *         var p1 = board.create('point', [-5, 2], {size:1});
     *         var p2 = board.create('point', [5, 2], {size:10});
     *         var li = board.create('segment', ['A','B'],
     *             {name:'seg',
     *              strokeColor:'#000000',
     *              strokeWidth:1,
     *              highlightStrokeWidth: 5,
     *              lastArrow: {type: 2, size: 8, highlightSize: 6},
     *              touchLastPoint: true,
     *              firstArrow: {type: 3, size: 8}
     *             });
     *     })();
     *
     * <\/script>
     *
     * @example
     *     board.options.line.strokeWidth = 4;
     *     board.options.line.highlightStrokeWidth = 4;
     *     board.options.line.firstArrow = false;
     *     board.options.line.lastArrow = {size: 10, highlightSize: 10};
     *     board.options.line.point2 = {visible: false, withLabel: true, label: {visible: true}};
     *
     *     board.create('segment', [[-5,4], [3,4]], {lastArrow: {type: 1}, point2: {name: 'type:1'}});
     *     board.create('segment', [[-5,3], [3,3]], {lastArrow: {type: 2}, point2: {name: 'type:2'}});
     *     board.create('segment', [[-5,2], [3,2]], {lastArrow: {type: 3}, point2: {name: 'type:3'}});
     *     board.create('segment', [[-5,1], [3,1]], {lastArrow: {type: 4}, point2: {name: 'type:4'}});
     *     board.create('segment', [[-5,0], [3,0]], {lastArrow: {type: 5}, point2: {name: 'type:5'}});
     *     board.create('segment', [[-5,-1], [3,-1]], {lastArrow: {type: 6}, point2: {name: 'type:6'}});
     *     board.create('segment', [[-5,-2], [3,-2]], {lastArrow: {type: 7}, point2: {name: 'type:7'}});
     *
     * </pre><div id="JXGca206b1c-e319-4899-8b90-778f53fd926d" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGca206b1c-e319-4899-8b90-778f53fd926d',
     *             {boundingbox: [-6, 6, 6,-4], axis: false, showcopyright: false, shownavigation: false});
     *         board.options.line.strokeWidth = 4;
     *         board.options.line.highlightStrokeWidth = 4;
     *         board.options.line.firstArrow = false;
     *         board.options.line.lastArrow = {size: 10, highlightSize: 10};
     *         board.options.line.point2 = {visible: false, withLabel: true, label: {visible: true}};
     *
     *         board.create('segment', [[-5,4], [3,4]], {lastArrow: {type: 1}, point2: {name: 'type:1'}});
     *         board.create('segment', [[-5,3], [3,3]], {lastArrow: {type: 2}, point2: {name: 'type:2'}});
     *         board.create('segment', [[-5,2], [3,2]], {lastArrow: {type: 3}, point2: {name: 'type:3'}});
     *         board.create('segment', [[-5,1], [3,1]], {lastArrow: {type: 4}, point2: {name: 'type:4'}});
     *         board.create('segment', [[-5,0], [3,0]], {lastArrow: {type: 5}, point2: {name: 'type:5'}});
     *         board.create('segment', [[-5,-1], [3,-1]], {lastArrow: {type: 6}, point2: {name: 'type:6'}});
     *         board.create('segment', [[-5,-2], [3,-2]], {lastArrow: {type: 7}, point2: {name: 'type:7'}});
     *     })();
     *
     * <\/script><pre>
     *
     * @name Line#lastArrow
     * @see Line#firstArrow
     * @see Line#touchLastPoint
     * @type Boolean | Object
     * @default false
     */
    lastArrow: false,
    /**
     * This number (pixel value) controls where infinite lines end at the canvas border. If zero, the line
     * ends exactly at the border, if negative there is a margin to the inside, if positive the line
     * ends outside of the canvas (which is invisible).
     *
     * @name Line#margin
     * @type Number
     * @default 0
     */
    margin: 0,
    /**
     * If true, line stretches infinitely in direction of its first point.
     * Otherwise it ends at point1.
     *
     * @name Line#straightFirst
     * @see Line#straightLast
     * @type Boolean
     * @default true
     */
    straightFirst: true,
    /**
     * If true, line stretches infinitely in direction of its second point.
     * Otherwise it ends at point2.
     *
     * @name Line#straightLast
     * @see Line#straightFirst
     * @type Boolean
     * @default true
     */
    straightLast: true,
    fillColor: "none",
    // Important for VML on IE
    highlightFillColor: "none",
    // Important for VML on IE
    strokeColor: color_default.palette.blue,
    highlightStrokeColor: "#c3d9ff",
    withTicks: false,
    /**
     * Attributes for first defining point of the line.
     *
     * @type Point
     * @name Line#point1
     */
    point1: {
      // Default values for point1 if created by line
      fillColor: color_default.palette.red,
      strokeColor: color_default.palette.red,
      highlightFillColor: "#c3d9ff",
      highlightStrokeColor: "#c3d9ff",
      layer: 9,
      visible: false,
      withLabel: false,
      fixed: false,
      name: ""
    },
    /**
     * Attributes for second defining point of the line.
     *
     * @type Point
     * @name Line#point2
     */
    point2: {
      // Default values for point2 if created by line
      fillColor: color_default.palette.red,
      strokeColor: color_default.palette.red,
      highlightFillColor: "#c3d9ff",
      highlightStrokeColor: "#c3d9ff",
      layer: 9,
      visible: false,
      withLabel: false,
      fixed: false,
      name: ""
    },
    /**
     * Attributes for ticks of the line.
     *
     * @name Line#ticks
     * @type Object
     * @see Ticks
     */
    ticks: {
      drawLabels: true,
      label: {
        offset: [4, -12 + 3]
        // This seems to be a good offset for 12 point fonts
      },
      drawZero: false,
      insertTicks: false,
      ticksDistance: 1,
      minTicksDistance: 50,
      minorHeight: 4,
      // if <0: full width and height
      majorHeight: -1,
      // if <0: full width and height
      minorTicks: 4,
      strokeOpacity: 0.3,
      visible: "inherit"
    },
    /**
     * Attributes for the line label.
     *
     * @type Object
     * @name Line#label
     * @see Label
     */
    label: {
      position: "llft"
    },
    /**
     * If set to true, the point will snap to a grid defined by
     * {@link Point#snapSizeX} and {@link Point#snapSizeY}.
     *
     * @see Point#snapSizeX
     * @see Point#snapSizeY
     * @type Boolean
     * @name Line#snapToGrid
     * @default false
     */
    snapToGrid: false,
    /**
     * Defines together with {@link Point#snapSizeY} the grid the point snaps on to.
     * The point will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.
     * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks
     * of the default ticks of the default x axes of the board.
     *
     * @see Point#snapToGrid
     * @see Point#snapSizeY
     * @see JXG.Board#defaultAxes
     * @type Number
     * @name Line#snapSizeX
     * @default 1
     */
    snapSizeX: 1,
    /**
     * Defines together with {@link Point#snapSizeX} the grid the point snaps on to.
     * The point will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.
     * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks
     * of the default ticks of the default y axes of the board.
     *
     * @see Point#snapToGrid
     * @see Point#snapSizeX
     * @see JXG.Board#defaultAxes
     * @type Number
     * @name Line#snapSizeY
     * @default 1
     */
    snapSizeY: 1,
    /**
     * If set to true, {@link Line#firstArrow} is set to true and the point is visible,
     * the arrow head will just touch the circle line of the start point of the line.
     *
     * @see Line#firstArrow
     * @type Boolean
     * @name Line#touchFirstPoint
     * @default false
     */
    touchFirstPoint: false,
    /**
     * If set to true, {@link Line#lastArrow} is set to true and the point is visible,
     * the arrow head will just touch the circle line of the start point of the line.
     * @see Line#firstArrow
     * @type Boolean
     * @name Line#touchLastPoint
     * @default false
     */
    touchLastPoint: false
    /**#@-*/
  },
  /* special options for locus curves */
  locus: {
    /**#@+
     * @visprop
     */
    translateToOrigin: false,
    translateTo10: false,
    stretch: false,
    toOrigin: null,
    to10: null
    /**#@-*/
  },
  /* special measurement options */
  measurement: {
    /**#@+
     * @visprop
     */
    baseUnit: "",
    units: {},
    dim: null,
    showPrefix: true,
    showSuffix: true,
    prefix: "",
    suffix: "",
    formatPrefix: function(txt) {
      return txt;
    },
    formatSuffix: function(txt) {
      return txt;
    },
    formatCoords: function(x, y, z) {
      return "(" + x + ", " + y + ")";
    },
    formatDirection: function(x, y) {
      return "(" + x + ", " + y + ")";
    }
    /**#@-*/
  },
  /* special metapost spline options */
  metapostspline: {
    /**#@+
     * @visprop
     */
    /**
      * Controls if the data points of the cardinal spline when given as
      * arrays should be converted into {@link JXG.Points}.
      *
      * @name createPoints
      * @memberOf Metapostspline.prototype
      *
      * @see Metapostspline#points
      *
      * @type Boolean
      * @default true
      */
    createPoints: true,
    /**
     * If set to true, the supplied coordinates are interpreted as
     * [[x_0, y_0], [x_1, y_1], p, ...].
     * Otherwise, if the data consists of two arrays of equal length,
     * it is interpreted as
     * [[x_o x_1, ..., x_n], [y_0, y_1, ..., y_n]]
     *
     * @name isArrayOfCoordinates
     * @memberOf Metapostspline.prototype
     * @type Boolean
     * @default true
     */
    isArrayOfCoordinates: true,
    /**
     * Attributes for the points generated by Metapost spline in cases
     * {@link createPoints} is set to true
     *
     * @name points
     * @memberOf Metapostspline.prototype
     *
     * @see Metapostspline#createPoints
     * @type Object
     */
    points: {
      strokeOpacity: 0.5,
      fillOpacity: 0.5,
      highlightStrokeOpacity: 1,
      highlightFillOpacity: 1,
      withLabel: false,
      name: "",
      fixed: false
    }
    /**#@-*/
  },
  /* special mirrorelement options */
  mirrorelement: {
    /**#@+
     * @visprop
     */
    fixed: true,
    /**
     * Attributes of mirror point, i.e. the point along which the element is mirrored.
     *
     * @type Point
     * @name mirrorelement#point
     */
    point: {},
    /**
     * Attributes of circle center, i.e. the center of the circle,
     * if a circle is the mirror element and the transformation type is 'Euclidean'
     *
     * @type Point
     * @name mirrorelement#center
     */
    center: {},
    /**
     * Type of transformation. Possible values are 'Euclidean', 'projective'.
     *
     * If the value is 'Euclidean', the mirror element of a circle is again a circle,
     * otherwise it is a conic section.
     *
     * @type String
     * @name mirrorelement#type
     * @default 'Euclidean'
     */
    type: "Euclidean"
    /**#@-*/
  },
  /* special nonreflexangle options */
  nonreflexangle: {
    /**#@+
     * @visprop
     */
    /**#@-*/
  },
  // /* special options for Msector of 3 points */
  // msector: {
  //     strokeColor: '#000000', // Msector line
  //     point: {               // Msector point
  //         visible: false,
  //         fixed: false,
  //         withLabel: false,
  //         name: ''
  //     }
  // },
  /* special options for normal lines */
  normal: {
    /**#@+
     * @visprop
     */
    strokeColor: "#000000",
    //  normal line
    /**
     * Attributes of helper point of normal.
     *
     * @type Point
     * @name Normal#point
     */
    point: {
      visible: false,
      fixed: false,
      withLabel: false,
      name: ""
    }
    /**#@-*/
  },
  /* special options for orthogonal projection points */
  orthogonalprojection: {
    /**#@+
     * @visprop
     */
    /**#@-*/
  },
  /* special options for parallel lines */
  parallel: {
    /**#@+
     * @visprop
     */
    strokeColor: "#000000",
    // Parallel line
    /**
     * Attributes of helper point of normal.
     *
     * @type Point
     * @name Parallel#point
     */
    point: {
      visible: false,
      fixed: false,
      withLabel: false,
      name: ""
    },
    label: {
      position: "llft"
    }
    /**#@-*/
  },
  /* special parallelogram options */
  parallelogram: {
    parallelpoint: {
      withLabel: false,
      name: ""
    }
  },
  /* special parallelpoint options */
  parallelpoint: {},
  /* special perpendicular options */
  perpendicular: {
    /**#@+
     * @visprop
     */
    strokeColor: "#000000",
    // Perpendicular line
    straightFirst: true,
    straightLast: true
    /**#@-*/
  },
  /* special perpendicular options */
  perpendicularsegment: {
    /**#@+
     * @visprop
     */
    strokeColor: "#000000",
    // Perpendicular segment
    straightFirst: false,
    straightLast: false,
    point: {
      // Perpendicular point
      visible: false,
      fixed: true,
      withLabel: false,
      name: ""
    }
    /**#@-*/
  },
  /* special point options */
  point: {
    /**#@+
     * @visprop
     */
    withLabel: true,
    label: {},
    /**
     * This attribute was used to determined the point layout. It was derived from GEONExT and was
     * replaced by {@link Point#face} and {@link Point#size}.
     *
     * @name Point#style
     *
     * @see Point#face
     * @see Point#size
     * @type Number
     * @default 5
     * @deprecated
     */
    style: 5,
    /**
     * There are different point styles which differ in appearance.
     * Posssible values are
     * <table>
     * <tr><th>Input</th><th>Output</th></tr>
     * <tr><td>cross</td><td>x</td></tr>
     * <tr><td>circle</td><td>o</td></tr>
     * <tr><td>square, []</td><td>[]</td></tr>
     * <tr><td>plus</td><td>+</td></tr>
     * <tr><td>minus</td><td>-</td></tr>
     * <tr><td>divide</td><td>|</td></tr>
     * <tr><td>diamond</td><td>&lt;&gt;</td></tr>
     * <tr><td>diamond2</td><td>&lt;&gt; (bigger)</td></tr>
     * <tr><td>triangleup</td><td>^, a, A</td></tr>
     * <tr><td>triangledown</td><td>v</td></tr>
     * <tr><td>triangleleft</td><td>&lt;</td></tr>
     * <tr><td>triangleright</td><td>&gt;</td></tr>
     * </table>
     *
     * @name Point#face
     *
     * @type String
     * @see JXG.Point#setStyle
     * @default circle
     */
    face: "o",
    /**
     * Size of a point, either in pixel or user coordinates.
     * Means radius resp. half the width of a point (depending on the face).
     *
     * @name Point#size
     *
     * @see Point#face
     * @see JXG.Point#setStyle
     * @see Point#sizeUnit
     * @type Number
     * @default 3
     */
    size: 3,
    /**
     * Unit for size.
     * Possible values are 'screen' and 'user.
     *
     * @name Point#sizeUnit
     *
     * @see Point#size
     * @type String
     * @default 'screen'
     */
    sizeUnit: "screen",
    strokeWidth: 2,
    transitionProperties: ["fill", "fill-opacity", "stroke", "stroke-opacity", "stroke-width", "width", "height", "rx", "ry"],
    fillColor: color_default.palette.red,
    strokeColor: color_default.palette.red,
    highlightFillColor: "#c3d9ff",
    highlightStrokeColor: "#c3d9ff",
    // strokeOpacity: 1.0,
    // fillOpacity: 1.0,
    // highlightFillOpacity: 0.5,
    // highlightStrokeOpacity: 0.5,
    // fillColor: '#ff0000',
    // highlightFillColor: '#eeeeee',
    // strokeWidth: 2,
    // strokeColor: '#ff0000',
    // highlightStrokeColor: '#c3d9ff',
    /**
     * If true, the point size changes on zoom events.
     *
     * @type Boolean
     * @name Point#zoom
     * @default false
     *
     */
    zoom: false,
    // Change the point size on zoom
    /**
     * If true, the infobox is shown on mouse/pen over, if false not.
     * If the value is 'inherit', the value of
     * {@link JXG.Board#showInfobox} is taken.
     *
     * @name Point#showInfobox
     * @see JXG.Board#showInfobox
     * @type Boolean|String
     * @description true | false | 'inherit'
     * @default true
     */
    showInfobox: "inherit",
    /**
     * Truncating rule for the digits in the infobox.
     * <ul>
     * <li>'auto': done automatically by JXG.autoDigits()
     * <li>'none': no truncation
     * <li>number: truncate after "number digits" with JXG.toFixed()
     * </ul>
     *
     * @name Point#infoboxDigits
     *
     * @type String| Number
     * @default 'auto'
     * @see JXG#autoDigits
     * @see JXG#toFixed
     */
    infoboxDigits: "auto",
    draft: false,
    /**
     * List of attractor elements. If the distance of the point is less than
     * attractorDistance the point is made to glider of this element.
     *
     * @name Point#attractors
     *
     * @type Array
     * @default empty
     */
    attractors: [],
    /**
     * Unit for attractorDistance and snatchDistance, used for magnetized points and for snapToPoints.
     * Possible values are 'screen' and 'user'.
     *
     * @name Point#attractorUnit
     *
     * @see Point#attractorDistance
     * @see Point#snatchDistance
     * @see Point#snapToPoints
     * @see Point#attractors
     * @type String
     * @default 'user'
     */
    attractorUnit: "user",
    // 'screen', 'user'
    /**
     * If the distance of the point to one of its attractors is less
     * than this number the point will be a glider on this
     * attracting element.
     * If set to zero nothing happens.
     *
     * @name Point#attractorDistance
     *
     * @type Number
     * @default 0.0
     */
    attractorDistance: 0,
    /**
     * If the distance of the point to one of its attractors is at least
     * this number the point will be released from being a glider on the
     * attracting element.
     * If set to zero nothing happens.
     *
     * @name Point#snatchDistance
     *
     * @type Number
     * @default 0.0
     */
    snatchDistance: 0,
    /**
     * If set to true, the point will snap to a grid of integer multiples of
     * {@link Point#snapSizeX} and {@link Point#snapSizeY} (in user coordinates).
     * <p>
     * The coordinates of the grid points are either integer multiples of snapSizeX and snapSizeY
     * (given in user coordinates, not pixels) or are the intersection points
     * of the major ticks of the boards default axes in case that snapSizeX, snapSizeY are negative.
     *
     * @name Point#snapToGrid
     *
     * @see Point#snapSizeX
     * @see Point#snapSizeY
     * @type Boolean
     * @default false
     */
    snapToGrid: false,
    /**
     * If set to true, the point will only snap to (possibly invisibly) grid points
     * when within {@link Point#attractorDistance} of such a grid point.
     * <p>
     * The coordinates of the grid points are either integer multiples of snapSizeX and snapSizeY
     * (given in user coordinates, not pixels) or are the intersection points
     * of the major ticks of the boards default axes in case that snapSizeX, snapSizeY are negative.
     *
     * @name Point#attractToGrid
     *
     * @see Point#attractorDistance
     * @see Point#attractorUnit
     * @see Point#snapToGrid
     * @see Point#snapSizeX
     * @see Point#snapSizeY
     * @type Boolean
     * @default false
     *
     * @example
     * board.create('point', [3, 3], { attractToGrid: true, attractorDistance: 10, attractorunit: 'screen' });
     *
     * </pre><div id="JXG397ab787-cd40-449c-a7e7-a3f7bab1d4f6" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG397ab787-cd40-449c-a7e7-a3f7bab1d4f6',
     *             {boundingbox: [-1, 4, 7,-4], axis: true, showcopyright: false, shownavigation: false});
     *     board.create('point', [3, 3], { attractToGrid: true, attractorDistance: 10, attractorunit: 'screen' });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    attractToGrid: false,
    /**
     * Defines together with {@link Point#snapSizeY} the grid the point snaps on to.
     * It is given in user coordinates, not in pixels.
     * The point will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.
     * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks
     * of the default ticks of the default x axes of the board.
     *
     * @name Point#snapSizeX
     *
     * @see Point#snapToGrid
     * @see Point#snapSizeY
     * @see JXG.Board#defaultAxes
     * @type Number
     * @default 1
     */
    snapSizeX: 1,
    /**
     * Defines together with {@link Point#snapSizeX} the grid the point snaps on to.
     * It is given in user coordinates, not in pixels.
     * The point will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.
     * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks
     * of the default ticks of the default y axes of the board.
     *
     * @name Point#snapSizeY
     *
     * @see Point#snapToGrid
     * @see Point#snapSizeX
     * @see JXG.Board#defaultAxes
     * @type Number
     * @default 1
     */
    snapSizeY: 1,
    /**
     * If set to true, the point will snap to the nearest point in distance of
     * {@link Point#attractorDistance}.
     *
     * @name Point#snapToPoints
     *
     * @see Point#attractorDistance
     * @type Boolean
     * @default false
     */
    snapToPoints: false,
    /**
     * List of elements which are ignored by snapToPoints.
     * @name Point#ignoredSnapToPoints
     *
     * @type Array
     * @default empty
     */
    ignoredSnapToPoints: []
    /**#@-*/
  },
  /* special polygon options */
  polygon: {
    /**#@+
     * @visprop
     */
    /**
     * If <tt>true</tt>, moving the mouse over inner points triggers hasPoint.
     *
     * @see JXG.GeometryElement#hasPoint
     * @name Polygon#hasInnerPoints
     * @type Boolean
     * @default false
     */
    hasInnerPoints: false,
    fillColor: color_default.palette.yellow,
    highlightFillColor: color_default.palette.yellow,
    // fillColor: '#00ff00',
    // highlightFillColor: '#00ff00',
    fillOpacity: 0.3,
    highlightFillOpacity: 0.2,
    /**
     * Is the polygon bordered by lines?
     *
     * @type Boolean
     * @name Polygon#withLines
     * @default true
     */
    withLines: true,
    /**
     * Attributes for the polygon border lines.
     *
     * @type Line
     * @name Polygon#borders
     */
    borders: {
      withLabel: false,
      strokeWidth: 1,
      highlightStrokeWidth: 1,
      // Polygon layer + 1
      layer: 5,
      label: {
        position: "top"
      },
      visible: "inherit"
    },
    /**
     * By default, the strokewidths of the borders of a polygon are not changed during highlighting (only strokeColor and strokeOpacity are changed
     * to highlightStrokeColor, and highlightStrokeOpacity).
     * However, strokewidth is changed to highlightStrokewidth if an individual border gets the focus.
     * <p>
     * With this attribute set to true, also the borders change strokeWidth if the polygon itself gets the focus.
     *
     * @type Boolean
     * @name Polygon#highlightByStrokeWidth
     * @default false
     */
    highlightByStrokeWidth: false,
    /**
     * Attributes for the polygon vertices.
     *
     * @type Point
     * @name Polygon#vertices
     */
    vertices: {
      layer: 9,
      withLabel: false,
      name: "",
      strokeColor: color_default.palette.red,
      fillColor: color_default.palette.red,
      fixed: false,
      visible: "inherit"
    },
    /**
     * Attributes for the polygon label.
     *
     * @type Label
     * @name Polygon#label
     */
    label: {
      offset: [0, 0]
    }
    /**#@-*/
  },
  /* special polygonal chain options
  */
  polygonalchain: {
    /**#@+
     * @visprop
     */
    fillColor: "none",
    highlightFillColor: "none"
    /**#@-*/
  },
  /* special prescribed angle options
      * Not yet implemented. But angle.setAngle(val) is implemented.
  
      */
  prescribedangle: {
    /**#@+
     * @visprop
     */
    /**
     * Attributes for the helper point of the prescribed angle.
     *
     * @type Point
     * @name Prescribedangle#anglePoint
     * @ignore
     */
    anglePoint: {
      size: 2,
      visible: false,
      withLabel: false
    }
    /**#@-*/
  },
  /* special reflection options */
  reflection: {
    /**#@+
     * @visprop
     */
    fixed: true,
    /**
     * Attributes of circle center, i.e. the center of the circle,
     * if a circle is the mirror element and the transformation type is 'Euclidean'
     *
     * @type center
     * @name Reflection#center
     */
    center: {},
    /**
     * Type of transformation. Possible values are 'Euclidean', 'projective'.
     *
     * If the value is 'Euclidean', the reflected element of a circle is again a circle,
     * otherwise it is a conic section.
     *
     * @type String
     * @name Reflection#type
     * @default 'Euclidean'
     */
    type: "Euclidean"
    /**#@-*/
  },
  /* special reflexangle options */
  reflexangle: {
    /**#@+
     * @visprop
     */
    /**#@-*/
  },
  /* special regular polygon options */
  regularpolygon: {
    /**#@+
     * @visprop
     */
    /**
     * If <tt>true</tt>, moving the mouse over inner points triggers hasPoint.
     * @see JXG.GeometryElement#hasPoint
     *
     * @name RegularPolygon#hasInnerPoints
     * @type Boolean
     * @default false
     */
    hasInnerPoints: false,
    fillColor: color_default.palette.yellow,
    highlightFillColor: color_default.palette.yellow,
    fillOpacity: 0.3,
    highlightFillOpacity: 0.2,
    /**
     * Is the polygon bordered by lines?
     *
     * @type Boolean
     * @name RegularPolygon#withLines
     * @default true
     */
    withLines: true,
    /**
     * Attributes for the polygon border lines.
     *
     * @type Line
     * @name RegularPolygon#borders
     */
    borders: {
      withLabel: false,
      strokeWidth: 1,
      highlightStrokeWidth: 1,
      // Polygon layer + 1
      layer: 5,
      label: {
        position: "top"
      }
    },
    /**
     * Attributes for the polygon vertices.
     *
     * @type Point
     * @name RegularPolygon#vertices
     */
    vertices: {
      layer: 9,
      withLabel: true,
      strokeColor: color_default.palette.red,
      fillColor: color_default.palette.red,
      fixed: false
    },
    /**
     * Attributes for the polygon label.
     *
     * @type Label
     * @name RegularPolygon#label
     */
    label: {
      offset: [0, 0]
    }
    /**#@-*/
  },
  /* special options for riemann sums */
  riemannsum: {
    /**#@+
     * @visprop
     */
    withLabel: false,
    fillOpacity: 0.3,
    fillColor: color_default.palette.yellow
    /**#@-*/
  },
  /* special sector options */
  sector: {
    /**#@+
     * @visprop
     */
    fillColor: color_default.palette.yellow,
    highlightFillColor: color_default.palette.yellow,
    // fillColor: '#00ff00',
    // highlightFillColor: '#00ff00',
    fillOpacity: 0.3,
    highlightFillOpacity: 0.3,
    highlightOnSector: false,
    highlightStrokeWidth: 0,
    /**
     * Type of sector. Possible values are 'minor', 'major', and 'auto'.
     *
     * @type String
     * @name Sector#selection
     * @default 'auto'
     */
    selection: "auto",
    /**
     * Attributes for sub-element arc. It is only available, if the sector is defined by three points.
     *
     * @type Arc
     * @name Sector#arc
     * @default '{visible:false}'
     */
    arc: {
      visible: false,
      fillColor: "none",
      withLabel: false,
      name: "",
      center: {
        visible: false,
        withLabel: false,
        name: ""
      },
      radiusPoint: {
        visible: false,
        withLabel: false,
        name: ""
      },
      anglePoint: {
        visible: false,
        withLabel: false,
        name: ""
      }
    },
    /**
     * Attributes for helper point radiuspoint in case it is provided by coordinates.
     *
     * @type Point
     * @name Sector#radiusPoint
     */
    radiusPoint: {
      visible: false,
      withLabel: false
    },
    /**
     * Attributes for helper point center in case it is provided by coordinates.
     *
     * @type Point
     * @name Sector#center
     */
    center: {
      visible: false,
      withLabel: false
    },
    /**
     * Attributes for helper point anglepoint in case it is provided by coordinates.
     *
     * @type Point
     * @name Sector#anglePoint
     */
    anglePoint: {
      visible: false,
      withLabel: false
    },
    /**
     * Attributes for the sector label.
     *
     * @type Label
     * @name Sector#label
     */
    label: {
      offset: [0, 0],
      anchorX: "auto",
      anchorY: "auto"
    }
    /**#@-*/
  },
  /* special segment options */
  segment: {
    /**#@+
     * @visprop
     */
    label: {
      position: "top"
    }
    /**#@-*/
  },
  semicircle: {
    /**#@+
     * @visprop
     */
    /**
     * Attributes for center point of the semicircle.
     *
     * @type Point
     * @name Semicircle#center
     */
    center: {
      visible: false,
      withLabel: false,
      fixed: false,
      fillColor: color_default.palette.red,
      strokeColor: color_default.palette.red,
      highlightFillColor: "#eeeeee",
      highlightStrokeColor: color_default.palette.red,
      name: ""
    }
    /**#@-*/
  },
  /* special slider options */
  slider: {
    /**#@+
     * @visprop
     */
    /**
     * The slider only returns integer multiples of this value, e.g. for discrete values set this property to <tt>1</tt>. For
     * continuous results set this to <tt>-1</tt>.
     *
     * @memberOf Slider.prototype
     * @name snapWidth
     * @type Number
     */
    snapWidth: -1,
    // -1 = deactivated
    /**
     * List of values to snap to. If the glider is within snapValueDistance
     * (in user coordinate units) of one of these points,
     * then the glider snaps to that point.
     *
     * @memberOf Slider.prototype
     * @name snapValues
     * @type Array
     * @see Slider#snapValueDistance
     * @default empty
     *
     * @example
     *         var n = board.create('slider', [[-2, 3], [4, 3], [1, 5, 100]], {
     *             name: 'n',
     *             snapWidth: 1,
     *             snapValues: [1, 22, 77, 100],
     *             snapValueDistance: 5
     *         });
     *
     *         var k = board.create('slider', [[-2, -1], [4, -1], [-4, 0, 4]], {
     *             name: 'k',
     *             snapWidth: 0.1,
     *             snapValues: [-3, -1, 1, 3],
     *             snapValueDistance: 0.4
     *         });
     *
     * </pre><div id="JXG9be68014-4e14-479a-82b4-e92d9b8f6eef" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG9be68014-4e14-479a-82b4-e92d9b8f6eef',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *             var n = board.create('slider', [[-2, 3], [4, 3], [1, 5, 100]], {
     *                 name: 'n',
     *                 snapWidth: 1,
     *                 snapValues: [1, 22, 77, 100],
     *                 snapValueDistance: 5
     *             });
     *
     *             var k = board.create('slider', [[-2, -1], [4, -1], [-4, 0, 4]], {
     *                 name: 'k',
     *                 snapWidth: 0.1,
     *                 snapValues: [-3, -1, 1, 3],
     *                 snapValueDistance: 0.4
     *             });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    snapValues: [],
    /**
     * If the difference between the slider value and one of the elements of snapValues is less
     * than this number (in user coordinate units), the slider will snap to that value.
     *
     * @memberOf Slider.prototype
     * @name snapValueDistance
     * @type Number
     * @see Slider#snapValues
     * @default 0.0
     */
    snapValueDistance: 0,
    /**
     * The precision of the slider value displayed in the optional text.
     * Replaced by the attribute "digits".
     *
     * @memberOf Slider.prototype
     * @name precision
     * @type Number
     * @deprecated
     * @see Slider#digits
     * @default 2
     */
    precision: 2,
    /**
     * The number of digits of the slider value displayed in the optional text.
     *
     * @memberOf Slider.prototype
     * @name digits
     * @type Number
     * @default 2
     */
    digits: 2,
    /**
     * Internationalization support for slider labels.
     *
     * @name intl
     * @memberOf Slider.prototype
     * @type object
     * @default <pre>{
     *    enabled: 'inherit',
     *    options: {}
     * }</pre>
     * @see JXG.Board#intl
     * @see Text#intl
     *
     * @example
     * var s = board.create('slider', [[-2, 3], [2, 3], [0, 1, 360]], {
     *     name: '&alpha;',
     *     snapWidth: 1,
     *     intl: {
     *         enabled: true,
     *         options: {
     *             style: 'unit',
     *             unit: 'degree',
     *         }
     *     }
     * });
     *
     * </pre><div id="JXGb49a9779-c0c8-419d-9173-c67232cfd65c" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGb49a9779-c0c8-419d-9173-c67232cfd65c',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var s = board.create('slider', [[-2, 3], [2, 3], [0, 1, 360]], {
     *         name: '&alpha;',
     *         snapWidth: 1,
     *         intl: {
     *             enabled: true,
     *             options: {
     *                 style: 'unit',
     *                 unit: 'degree',
     *             }
     *         }
     *     });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    intl: {
      enabled: "inherit",
      options: {}
    },
    firstArrow: false,
    lastArrow: false,
    /**
     * Show slider ticks.
     *
     * @type Boolean
     * @name Slider#withTicks
     * @default true
     */
    withTicks: true,
    /**
     * Show slider label.
     *
     * @type Boolean
     * @name Slider#withLabel
     * @default true
     */
    withLabel: true,
    /**
     * If not null, this replaces the part "name = " in the slider label.
     * Possible types: string, number or function.
     * @type String
     * @name suffixLabel
     * @memberOf Slider.prototype
     * @default null
     * @see JXG.Slider#unitLabel
     * @see JXG.Slider#postLabel
     */
    suffixLabel: null,
    /**
     * If not null, this is appended to the value in the slider label.
     * Possible types: string, number or function.
     * @type String
     * @name unitLabel
     * @memberOf Slider.prototype
     * @default null
     * @see JXG.Slider#suffixLabel
     * @see JXG.Slider#postLabel
     */
    unitLabel: null,
    /**
     * If not null, this is appended to the value and to unitLabel in the slider label.
     * Possible types: string, number or function.
     * @type String
     * @name postLabel
     * @memberOf Slider.prototype
     * @default null
     * @see JXG.Slider#suffixLabel
     * @see JXG.Slider#unitLabel
     */
    postLabel: null,
    layer: 9,
    showInfobox: false,
    name: "",
    visible: true,
    strokeColor: "#000000",
    highlightStrokeColor: "#888888",
    fillColor: "#ffffff",
    highlightFillColor: "none",
    /**
     * Size of slider point.
     *
     * @type Number
     * @name Slider#size
     * @default 6
     * @see Point#size
     */
    size: 6,
    /**
     * Attributes for first (left) helper point defining the slider position.
     *
     * @type Point
     * @name Slider#point1
     */
    point1: {
      needsRegularUpdate: false,
      showInfobox: false,
      withLabel: false,
      visible: false,
      fixed: true,
      name: ""
    },
    /**
     * Attributes for second (right) helper point defining the slider position.
     *
     * @type Point
     * @name Slider#point2
     */
    point2: {
      needsRegularUpdate: false,
      showInfobox: false,
      withLabel: false,
      visible: false,
      fixed: true,
      name: ""
    },
    /**
     * Attributes for the base line of the slider.
     *
     * @type Line
     * @name Slider#baseline
     */
    baseline: {
      needsRegularUpdate: false,
      visible: "inherit",
      fixed: true,
      scalable: false,
      tabindex: null,
      name: "",
      strokeWidth: 1,
      strokeColor: "#000000",
      highlightStrokeColor: "#888888"
    },
    /**
     * Attributes for the ticks of the base line of the slider.
     *
     * @type Ticks
     * @name Slider#ticks
     */
    ticks: {
      needsRegularUpdate: false,
      fixed: true,
      // Label drawing
      drawLabels: false,
      digits: 2,
      includeBoundaries: true,
      drawZero: true,
      label: {
        offset: [-4, -14],
        display: "internal"
      },
      minTicksDistance: 30,
      insertTicks: true,
      ticksDistance: 1,
      // Not necessary, since insertTicks = true
      minorHeight: 4,
      // if <0: full width and height
      majorHeight: 5,
      // if <0: full width and height
      minorTicks: 0,
      strokeOpacity: 1,
      strokeWidth: 1,
      tickEndings: [0, 1],
      majortickEndings: [0, 1],
      strokeColor: "#000000",
      visible: "inherit"
    },
    /**
     * Attributes for the highlighting line of the slider.
     *
     * @type Line
     * @name Slider#highline
     */
    highline: {
      strokeWidth: 3,
      visible: "inherit",
      fixed: true,
      tabindex: null,
      name: "",
      strokeColor: "#000000",
      highlightStrokeColor: "#888888"
    },
    /**
     * Attributes for the slider label.
     *
     * @type Label
     * @name Slider#label
     */
    label: {
      visible: "inherit",
      strokeColor: "#000000"
    },
    /**
     * If true, 'up' events on the baseline will trigger slider moves.
     *
     * @type Boolean
     * @name Slider#moveOnUp
     * @default true
     */
    moveOnUp: true
    /**#@-*/
  },
  /* special vector field options */
  slopefield: {
    /**#@+
     * @visprop
     */
    strokeWidth: 0.5,
    highlightStrokeWidth: 0.5,
    highlightStrokeColor: color_default.palette.blue,
    highlightStrokeOpacity: 0.8,
    /**
     * Set length of the vectors in user coordinates. This in contrast to vector fields, where this attribute just scales the vector.
     * @name scale
     * @memberOf Slopefield.prototype
     * @type {Number|Function}
     * @see Vectorfield.scale
     * @default 1
     */
    scale: 1,
    /**
     * Customize arrow heads of vectors. Be careful! If enabled this will slow down the performance.
     * Fields are:
     * <ul>
     *  <li> enabled: Boolean
     *  <li> size: length of the arrow head legs (in pixel)
     *  <li> angle: angle of the arrow head legs In radians.
     * </ul>
     * @name arrowhead
     * @memberOf Slopefield.prototype
     * @type {Object}
     * @default <tt>{enabled: false, size: 5, angle: Math.PI * 0.125}</tt>
     */
    arrowhead: {
      enabled: false,
      size: 5,
      angle: Math.PI * 0.125
    }
    /**#@-*/
  },
  /* special options for slope triangle */
  slopetriangle: {
    /**#@+
     * @visprop
     */
    fillColor: color_default.palette.red,
    fillOpacity: 0.4,
    highlightFillColor: color_default.palette.red,
    highlightFillOpacity: 0.3,
    borders: {
      lastArrow: {
        type: 1,
        size: 6
      }
    },
    /**
     * Attributes for the gliding helper point.
     *
     * @type Point
     * @name Slopetriangle#glider
     */
    glider: {
      fixed: true,
      visible: false,
      withLabel: false
    },
    /**
     * Attributes for the base line.
     *
     * @type Line
     * @name Slopetriangle#baseline
     */
    baseline: {
      visible: false,
      withLabel: false,
      name: ""
    },
    /**
     * Attributes for the base point.
     *
     * @type Point
     * @name Slopetriangle#basepoint
     */
    basepoint: {
      visible: false,
      withLabel: false,
      name: ""
    },
    /**
     * Attributes for the tangent.
     * The tangent is constructed by slop triangle if the construction
     * is based on a glider, solely.
     *
     * @type Line
     * @name Slopetriangle#tangent
     */
    tangent: {
      visible: false,
      withLabel: false,
      name: ""
    },
    /**
     * Attributes for the top point.
     *
     * @type Point
     * @name Slopetriangle#toppoint
     */
    toppoint: {
      visible: false,
      withLabel: false,
      name: ""
    },
    /**
     * Attributes for the slope triangle label.
     *
     * @type Label
     * @name Slopetriangle#label
     */
    label: {
      visible: true,
      position: "first"
    }
    /**#@-*/
  },
  /* special options for smartlabel of angle */
  smartlabelangle: {
    cssClass: "smart-label-solid smart-label-angle",
    highlightCssClass: "smart-label-solid smart-label-angle",
    anchorX: "left",
    anchorY: "middle",
    unit: "",
    prefix: "",
    suffix: "",
    measure: "deg",
    useMathJax: true
  },
  /* special options for smartlabel of circle */
  smartlabelcircle: {
    /**#@+
     * @visprop
     */
    /**
     * CSS classes for the smart label. Available classes are:
     * <ul>
     * <li> 'smart-label-solid'
     * <li> 'smart-label-outline'
     * <li> 'smart-label-pure'
     * </ul>
     *
     * By default, an additional class is given specific for the element type.
     * Available classes are 'smart-label-angle', 'smart-label-circle',
     * 'smart-label-line', 'smart-label-point', 'smart-label-polygon'.
     *
     * @example
     *  cssClass: 'smart-label-solid smart-label-point'
     *
     * @type String
     * @name Smartlabel#cssClass
     * @see Smartlabel#highlightCssClass
     * @default <ul>
     *  <li> 'smart-label-solid smart-label-circle' for circles</li>
     *  <li> 'smart-label-solid smart-label-point' for points</li>
     *  <li> ...</li>
     * </ul>
     */
    cssClass: "smart-label-solid smart-label-circle",
    /**
     * CSS classes for the smart label when highlighted.
     *
     * @type String
     * @name Smartlabel#highlightCssClass
     * @see Smartlabel#cssClass
     * @default <ul>
     *  <li> 'smart-label-solid smart-label-circle' for circles</li>
     *  <li> 'smart-label-solid smart-label-point' for points</li>
     *  <li> ...</li>
     * </ul>
     */
    highlightCssClass: "smart-label-solid smart-label-circle",
    anchorX: "middle",
    useMathJax: true,
    /**
     * Measurement unit appended to the output text. For areas, the unit is squared automatically.
     * Comes directly after the measurement value.
     *
     * @type {String|Function}
     * @name Smartlabel#unit
     * @default ''
     */
    unit: "",
    /**
     * Prefix text for the smartlabel. Comes before the measurement value.
     *
     * @type {String|Function}
     * @name Smartlabel#prefix
     * @default ''
     */
    prefix: "",
    /**
     * Suffix text for the smartlabel. Comes after unit.
     *
     * @type {String|Function}
     * @name Smartlabel#suffix
     * @default ''
     */
    suffix: "",
    /**
     * Type of measurement.
     * Available values are:
     *  <ul>
     *  <li> 'deg', 'rad' for angles</li>
     *  <li> 'area', 'perimeter', 'radius' for circles</li>
     *  <li> 'length', 'slope' for lines</li>
     *  <li> 'area', 'perimeter' for polygons</li>
     * </ul>
     * Dependent on this value, i.e. the type of measurement, the label is
     * positioned differently on the object.
     *
     * @type String
     * @name Smartlabel#measure
     * @default <ul>
     *   <li> 'radius' for circles</li>
     *   <li> 'length' for lines</li>
     *   <li> 'area' for polygons</li>
     *   <li> 'deg' for angles</li>
     * </ul>
     */
    measure: "radius"
    /**#@-*/
  },
  /* special options for smartlabel of line */
  smartlabelline: {
    cssClass: "smart-label-solid smart-label-line",
    highlightCssClass: "smart-label-solid smart-label-line",
    anchorX: "middle",
    useMathJax: true,
    unit: "",
    measure: "length"
  },
  /* special options for smartlabel of point */
  smartlabelpoint: {
    /**#@+
     * @visprop
     */
    cssClass: "smart-label-solid smart-label-point",
    highlightCssClass: "smart-label-solid smart-label-point",
    anchorX: "middle",
    anchorY: "top",
    useMathJax: true,
    /**
     * Display of point coordinates either as row vector or column vector.
     * Available values are 'row' or 'column'.
     * @type String
     * @name Smartlabel#dir
     * @default 'row'
     */
    dir: "row",
    /**
     * Supply a unit suffix.
     *
     * @type String
     * @name Smartlabel#unit
     * @default ''
     */
    unit: ""
    /**#@-*/
  },
  /* special options for smartlabel of polygon */
  smartlabelpolygon: {
    cssClass: "smart-label-solid smart-label-polygon",
    highlightCssClass: "smart-label-solid smart-label-polygon",
    anchorX: "middle",
    useMathJax: true,
    unit: "",
    measure: "area"
  },
  /* special options for step functions */
  stepfunction: {
    /**#@+
     * @visprop
     */
    /**#@-*/
  },
  /* special tangent options */
  tangent: {},
  /* special tape measure options */
  tapemeasure: {
    /**#@+
     * @visprop
     */
    strokeColor: "#000000",
    strokeWidth: 2,
    highlightStrokeColor: "#000000",
    /**
     * Show tape measure ticks.
     *
     * @type Boolean
     * @name Tapemeasure#withTicks
     * @default true
     */
    withTicks: true,
    /**
     * Show tape measure label.
     *
     * @type Boolean
     * @name Tapemeasure#withLabel
     * @default true
     */
    withLabel: true,
    /**
     * Text rotation in degrees.
     *
     * @name Tapemeasure#rotate
     * @type Number
     * @default 0
     */
    rotate: 0,
    /**
     * The precision of the tape measure value displayed in the optional text.
     * Replaced by the attribute digits
     *
     * @memberOf Tapemeasure.prototype
     * @name precision
     * @type Number
     * @deprecated
     * @see Tapemeasure#digits
     * @default 2
     */
    precision: 2,
    /**
     * The precision of the tape measure value displayed in the optional text.
     * @memberOf Tapemeasure.prototype
     * @name digits
     * @type Number
     * @default 2
     */
    digits: 2,
    /**
     * Attributes for first helper point defining the tape measure position.
     *
     * @type Point
     * @name Tapemeasure#point1
     */
    point1: {
      visible: "inherit",
      strokeColor: "#000000",
      fillColor: "#ffffff",
      fillOpacity: 0,
      highlightFillOpacity: 0.1,
      size: 6,
      snapToPoints: true,
      attractorUnit: "screen",
      attractorDistance: 20,
      showInfobox: false,
      withLabel: false,
      name: ""
    },
    /**
     * Attributes for second helper point defining the tape measure position.
     *
     * @type Point
     * @name Tapemeasure#point2
     */
    point2: {
      visible: "inherit",
      strokeColor: "#000000",
      fillColor: "#ffffff",
      fillOpacity: 0,
      highlightFillOpacity: 0.1,
      size: 6,
      snapToPoints: true,
      attractorUnit: "screen",
      attractorDistance: 20,
      showInfobox: false,
      withLabel: false,
      name: ""
    },
    /**
     * Attributes for the ticks of the tape measure.
     *
     * @type Ticks
     * @name Tapemeasure#ticks
     */
    ticks: {
      drawLabels: false,
      drawZero: true,
      insertTicks: true,
      ticksDistance: 0.1,
      // Ignored, since insertTicks=true
      minorHeight: 8,
      majorHeight: 16,
      minorTicks: 4,
      tickEndings: [0, 1],
      majorTickEndings: [0, 1],
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeColor: "#000000",
      visible: "inherit",
      label: {
        anchorY: "top",
        anchorX: "middle",
        offset: [0, -10]
      }
    },
    /**
     * Attributes for the tape measure label.
     *
     * @type Label
     * @name Tapemeasure#label
     */
    label: {
      position: "top"
    }
    /**#@-*/
  },
  /* special text options */
  text: {
    /**#@+
     * @visprop
     */
    /**
     * The font size in pixels.
     *
     * @name fontSize
     * @memberOf Text.prototype
     * @default 12
     * @type Number
     * @see Text#fontUnit
     */
    fontSize: 12,
    /**
     * CSS unit for the font size of a text element. Usually, this will be the default value 'px' but
     * for responsive application, also 'vw', 'vh', vmax', 'vmin' or 'rem' might be useful.
     *
     * @name fontUnit
     * @memberOf Text.prototype
     * @default 'px'
     * @type String
     * @see Text#fontSize
     *
     * @example
     * var txt = board.create('text', [2, 2, "hello"], {fontSize: 8, fontUnit: 'vmin'});
     *
     * </pre><div id="JXG2da7e972-ac62-416b-a94b-32559c9ec9f9" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG2da7e972-ac62-416b-a94b-32559c9ec9f9',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var txt = board.create('text', [2, 2, "hello"], {fontSize: 8, fontUnit: 'vmin'});
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    fontUnit: "px",
    /**
     * If the text content is solely a number and
     * this attribute is true (default) then the number is formatted
     * according to the number of digits
     * given by the attribute 'digits' and convert into a fraction if 'toFraction'
     * is true.
     * <p>
     * Otherwise, display the raw number.
     *
     * @name formatNumber
     * @memberOf Text.prototype
     * @default true
     * @type Boolean
     *
     */
    formatNumber: true,
    /**
     * Used to round texts given by a number.
     *
     * @name digits
     * @memberOf Text.prototype
     * @default 2
     * @type Number
     */
    digits: 2,
    /**
     * Internationalization support for texts consisting of a number only.
     * <p>
     * Setting the local overwrites the board-wide locale set in the board attributes.
     * The JSXGraph attribute digits is overruled by the
     * Intl attributes "minimumFractionDigits" and "maximumFractionDigits".
     * See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat</a>
     * for more information about possible options.
     * <p>
     * See below for an example where the text is composed from a string and a locale formatted number.
     *
     * @name intl
     * @memberOf Text.prototype
     * @type object
     * @default <pre>{
     *    enabled: 'inherit',
     *    options: {}
     * }</pre>
     * @see JXG.Board#intl
     *
     * @example
     * var t = board.create('text', [1, 2, -Math.PI*100], {
     *         digits: 2,
     *         intl: {
     *                 enabled: true,
     *                 options: {
     *                     style: 'unit',
     *                     unit: 'celsius'
     *                 }
     *             }
     *     });
     *
     * </pre><div id="JXGb7162923-1beb-4e56-8817-19aa66e226d1" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGb7162923-1beb-4e56-8817-19aa66e226d1',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var t = board.create('text', [1, 2, -Math.PI*100], {
     *             digits: 2,
     *             intl: {
     *                     enabled: true,
     *                     options: {
     *                         style: 'unit',
     *                         unit: 'celsius'
     *                     }
     *                 }
     *         });
     *
     *     })();
     *
     * <\/script><pre>
     *
     *
     * @example
     * var t = board.create('text', [0.05, -0.2, ''], {
     *     intl: {
     *         enabled: true,
     *         locale: 'it-IT',
     *         options: {
     *             style: 'unit',
     *             unit: 'kilometer-per-hour',
     *             unitDisplay: 'narrow',
     *             maximumFractionDigits: 2
     *         }
     *     }
     * });
     *
     * // Set dynamic text consisting of text and number.
     * t.setText(function() {
     *     var txt = 'Speed: ',
     *         number = t.X();
     *
     *     // Add formatted number to variable txt
     *     // with fallback if locale is not supported.
     *     if (t.useLocale()) {
     *         txt += t.formatNumberLocale(number);
     *     } else {
     *         txt += JXG.toFixed(number, 2);
     *     }
     *     return txt;
     * });
     *
     * </pre><div id="JXG560aeb1c-55fb-45da-8ad5-d3ad26216056" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG560aeb1c-55fb-45da-8ad5-d3ad26216056',
     *             {boundingbox: [-0.5, 0.5, 0.5, -0.5], axis: true, showcopyright: false, shownavigation: false});
     *     var t = board.create('text', [0.3, -0.3, ''], {
     *         intl: {
     *             enabled: true,
     *             locale: 'it-IT',
     *             options: {
     *                 style: 'unit',
     *                 unit: 'kilometer-per-hour',
     *                 unitDisplay: 'narrow',
     *                 maximumFractionDigits: 2
     *             }
     *         }
     *     });
     *
     *     // Set dynamic text consisting of text and number.
     *     t.setText(function() {
     *         var txt = 'Speed: ',
     *             number = t.X();
     *
     *         // Add formatted number to variable txt
     *         if (t.useLocale()) {
     *             txt += t.formatNumberLocale(number);
     *         } else {
     *             txt += JXG.toFixed(number, 2);
     *         }
     *         return txt;
     *     });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    intl: {
      enabled: "inherit",
      options: {}
    },
    /**
     * If set to true, the text is parsed and evaluated.
     * For labels parse==true results in converting names of the form k_a to subscripts.
     * If the text is given by string and parse==true, the string is parsed as
     * JessieCode expression.
     *
     * @name parse
     * @memberOf Text.prototype
     * @default true
     * @type Boolean
     */
    parse: true,
    /**
     * If set to true and caja's sanitizeHTML function can be found it
     * will be used to sanitize text output.
     *
     * @name useCaja
     * @memberOf Text.prototype
     * @default false
     * @type Boolean
     */
    useCaja: false,
    /**
     * If enabled, the text will be handled as label. Intended for internal use.
     *
     * @name isLabel
     * @memberOf Text.prototype
     * @default false
     * @type Boolean
     */
    isLabel: false,
    strokeColor: "#000000",
    highlightStrokeColor: "#000000",
    highlightStrokeOpacity: 0.666666,
    /**
     * Default CSS properties of the HTML text element.
     * <p>
     * The CSS properties which are set here, are handed over to the style property
     * of the HTML text element. That means, they have higher property than any
     * CSS class.
     * <p>
     * If a property which is set here should be overruled by a CSS class
     * then this property should be removed here.
     * <p>
     * The reason, why this attribute should be kept to its default value at all,
     * is that screen dumps of SVG boards with <tt>board.renderer.dumpToCanvas()</tt>
     * will ignore the font-family if it is set in a CSS class.
     * It has to be set explicitly as style attribute.
     * <p>
     * In summary, the order of priorities from high to low is
     * <ol>
     *  <li> JXG.Options.text.cssStyle
     *  <li> JXG.Options.text.cssDefaultStyle
     *  <li> JXG.Options.text.cssClass
     * </ol>
     * @example
     * If all texts should get its font-family from the default CSS class
     * before initializing the board
     * <pre>
     *   JXG.Options.text.cssDefaultStyle = '';
     *   JXG.Options.text.highlightCssDefaultStyle = '';
     * </pre>
     * should be called.
     *
     * @name cssDefaultStyle
     * @memberOf Text.prototype
     * @default  'font-family: Arial, Helvetica, Geneva, sans-serif;'
     * @type String
     * @see Text#highlightCssDefaultStyle
     * @see Text#cssStyle
     * @see Text#highlightCssStyle
     */
    cssDefaultStyle: "font-family: Arial, Helvetica, Geneva, sans-serif;",
    /**
     * Default CSS properties of the HTML text element in case of highlighting.
     * <p>
     * The CSS properties which are set here, are handed over to the style property
     * of the HTML text element. That means, they have higher property than any
     * CSS class.
     * @example
     * If all texts should get its font-family from the default CSS class
     * before initializing the board
     * <pre>
     *   JXG.Options.text.cssDefaultStyle = '';
     *   JXG.Options.text.highlightCssDefaultStyle = '';
     * </pre>
     * should be called.
     *
     * @name highlightCssDefaultStyle
     * @memberOf Text.prototype
     * @default  'font-family: Arial, Helvetica, Geneva, sans-serif;'
     * @type String
     * @see Text#cssDefaultStyle
     * @see Text#cssStyle
     * @see Text#highlightCssStyle
    */
    highlightCssDefaultStyle: "font-family: Arial, Helvetica, Geneva, sans-serif;",
    /**
     * CSS properties of the HTML text element.
     * <p>
     * The CSS properties which are set here, are handed over to the style property
     * of the HTML text element. That means, they have higher property than any
     * CSS class.
     *
     * @name cssStyle
     * @memberOf Text.prototype
     * @default  ''
     * @type String
     * @see Text#cssDefaultStyle
     * @see Text#highlightCssDefaultStyle
     * @see Text#highlightCssStyle
    */
    cssStyle: "",
    /**
     * CSS properties of the HTML text element in case of highlighting.
     * <p>
     * The CSS properties which are set here, are handed over to the style property
     * of the HTML text element. That means, they have higher property than any
     * CSS class.
     *
     * @name highlightCssStyle
     * @memberOf Text.prototype
     * @default  ''
     * @type String
     * @see Text#cssDefaultStyle
     * @see Text#highlightCssDefaultStyle
     * @see Text#cssStyle
    */
    highlightCssStyle: "",
    transitionProperties: ["color", "opacity"],
    /**
     * If true, the input will be given to ASCIIMathML before rendering.
     *
     * @name useASCIIMathML
     * @memberOf Text.prototype
     * @default false
     * @type Boolean
     */
    useASCIIMathML: false,
    /**
     * If true, MathJax will be used to render the input string.
     * Supports MathJax 2 as well as Mathjax 3.
     * It is recommended to use this option together with the option
     * "parse: false". Otherwise, 4 backslashes (e.g. \\\\alpha) are needed
     * instead of two (e.g. \\alpha).
     *
     * @name useMathJax
     * @memberOf Text.prototype
     * @default false
     * @type Boolean
     * @see Text#parse
     *
     * @example
     *  // Before loading MathJax, it has to be configured something like this:
     * window.MathJax = {
     *   tex: {
     *     inlineMath: [ ['$','$'], ["\\(","\\)"] ],
     *     displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
     *     packages: ['base', 'ams']
     *   },
     *   options: {
     *     ignoreHtmlClass: 'tex2jax_ignore',
     *     processHtmlClass: 'tex2jax_process'
     *   }
     * };
     *
     * // Display style
     * board.create('text',[ 2,2,  function(){return '$$X=\\frac{2}{x}$$'}], {
     *     fontSize: 15, color:'green', useMathJax: true});
     *
     * // Inline style
     * board.create('text',[-2,2,  function(){return '$X_A=\\frac{2}{x}$'}], {
     *     fontSize: 15, color:'green', useMathJax: true});
     *
     * var A = board.create('point', [-2, 0]);
     * var B = board.create('point', [1, 0]);
     * var C = board.create('point', [0, 1]);
     *
     * var graph = board.create('ellipse', [A, B, C], {
     *         fixed: true,
     *         withLabel: true,
     *         strokeColor: 'black',
     *         strokeWidth: 2,
     *         fillColor: '#cccccc',
     *         fillOpacity: 0.3,
     *         highlightStrokeColor: 'red',
     *         highlightStrokeWidth: 3,
     *         name: '$1=\\frac{(x-h)^2}{a^2}+\\frac{(y-k)^2}{b^2}$',
     *         label: {useMathJax: true}
     *     });
     *
     * var nvect1 = board.create('text', [-4, -3, '\\[\\overrightarrow{V}\\]'],
     * {
     *   fontSize: 24, parse: false
     * });
     * var nvect1 = board.create('text', [-2, -4, function() {return '$\\overrightarrow{G}$';}],
     * {
     *   fontSize: 24, useMathJax: true
     * });
     *
     * </pre>
     * <script>
     * window.MathJax = {
     *   tex: {
     *     inlineMath: [ ['$','$'], ["\\(","\\)"] ],
     *     displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
     *     packages: ['base', 'ams']
     *   },
     *   options: {
     *     ignoreHtmlClass: 'tex2jax_ignore',
     *     processHtmlClass: 'tex2jax_process'
     *   }
     * };
     * <\/script>
     * <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"><\/script>
     * <div id="JXGe2a04876-5813-4db0-b7e8-e48bf4e220b9" class="jxgbox" style="width: 400px; height: 400px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGe2a04876-5813-4db0-b7e8-e48bf4e220b9',
     *             {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright: false, shownavigation: false});
     *     // Display style
     *     board.create('text',[ 2,2,  function(){return '$$X=\\frac{2}{x}$$'}], {
     *         fontSize: 15, color:'green', useMathJax: true});
     *
     *     // Inline style
     *     board.create('text',[-2,2,  function(){return '$X_A=\\frac{2}{x}$'}], {
     *         fontSize: 15, color:'green', useMathJax: true});
     *
     *     var A = board.create('point', [-2, 0]);
     *     var B = board.create('point', [1, 0]);
     *     var C = board.create('point', [0, 1]);
     *
     *     var graph = board.create('ellipse', [A, B, C], {
     *             fixed: true,
     *             withLabel: true,
     *             strokeColor: 'black',
     *             strokeWidth: 2,
     *             fillColor: '#cccccc',
     *             fillOpacity: 0.3,
     *             highlightStrokeColor: 'red',
     *             highlightStrokeWidth: 3,
     *             name: '$1=\\frac{(x-h)^2}{a^2}+\\frac{(y-k)^2}{b^2}$',
     *             label: {useMathJax: true}
     *         });
     *
     *     var nvect1 = board.create('text', [-4, -3, '\\[\\overrightarrow{V}\\]'],
     *     {
     *       fontSize: 24, parse: false
     *     });
     *     var nvect1 = board.create('text', [-2, -4, function() {return '$\\overrightarrow{G}$';}],
     *     {
     *       fontSize: 24, useMathJax: true
     *     });
     *     })();
     *
     * <\/script><pre>
     *
     *
     * @example
     * // Load MathJax:
     * // &lt;script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"&lt;&lt;/script&gt;
     *
     * // function and its derivative
     * var f1 = function(x) { return x * x * x; },
     * graph1 = board.create('functiongraph', [f1, -0.1, 1.1]),
     *
     * A = board.create('glider', [0.5, f1(0.5), graph1], {
     *             name: 'f(x)',
     *             color: 'black',
     *             face:'x',
     *             fixed: true,
     *             size: 3,
     *             label: {offset: [-30, 10], fontSize: 15}
     *         }),
     * B = board.create('glider', [0.7, f1(0.7), graph1], {
     *             name: 'f(x+&Delta;x)',
     *             size: 3,
     *             label: {offset: [-60, 10], fontSize: 15}
     *         }),
     *
     * secant_line = board.create('line', [A,B],{dash: 1, color: 'green'}),
     * a_h_segment = board.create('segment', [A, [
     *                     function(){ return B.X() > A.X() ? B.X() : A.X()},
     *                     function(){ return B.X() > A.X() ? A.Y() : B.Y()}
     *                 ]],{ name: '&Delta;x', dash: 1, color: 'black'});
     *
     * b_v_segment = board.create('segment', [B, [
     *                     function(){ return B.X() > A.X() ? B.X() : A.X()},
     *                     function(){ return B.X() > A.X() ? A.Y() : B.Y()}
     *                 ]],{ name: '&Delta;y', dash: 1, color: 'black'}),
     *
     * ma = board.create('midpoint', [a_h_segment.point1, a_h_segment.point2
     *     ], {visible: false});
     *
     * board.create('text', [0, 0, function() {return '\\[\\Delta_x='+(B.X()-A.X()).toFixed(4)+'\\]'}], {
     *     anchor: ma, useMathJax: true, fixed: true, color: 'green', anchorY: 'top'
     * });
     *
     * mb = board.create('midpoint', [b_v_segment.point1, b_v_segment.point2], {visible: false});
     * board.create('text', [0, 0, function() {return '\\[\\Delta_y='+(B.Y()-A.Y()).toFixed(4)+'\\]'}], {
     *     anchor: mb, useMathJax: true, fixed: true, color: 'green'
     * });
     *
     * dval = board.create('text',[0.1, 0.8,
     *     function(){
     *         return '\\[\\frac{\\Delta_y}{\\Delta_x}=\\frac{' + ((B.Y()-A.Y()).toFixed(4)) + '}{' + ((B.X()-A.X()).toFixed(4)) +
     *             '}=' + (((B.Y()-A.Y()).toFixed(4))/((B.X()-A.X()).toFixed(4))).toFixed(4) + '\\]';
     *     }],{fontSize: 15, useMathJax: true});
     *
     * </pre>
     * <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"><\/script>
     * <div id="JXG8c2b65e7-4fc4-43f7-b23c-5076a7fa9621" class="jxgbox" style="width: 400px; height: 400px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG8c2b65e7-4fc4-43f7-b23c-5076a7fa9621',
     *             {boundingbox: [-0.1, 1.1, 1.1, -0.1], axis: true, showcopyright: false, shownavigation: false});
     *     // function and its derivative
     *     var f1 = function(x) { return x * x * x; },
     *     graph1 = board.create('functiongraph', [f1, -0.1, 1.1]),
     *
     *     A = board.create('glider', [0.5, f1(0.5), graph1], {
     *                 name: 'f(x)',
     *                 color: 'black',
     *                 face:'x',
     *                 fixed: true,
     *                 size: 3,
     *                 label: {offset: [-30, 10], fontSize: 15}
     *             }),
     *     B = board.create('glider', [0.7, f1(0.7), graph1], {
     *                 name: 'f(x+&Delta;x)',
     *                 size: 3,
     *                 label: {offset: [-60, 10], fontSize: 15}
     *             }),
     *
     *     secant_line = board.create('line', [A,B],{dash: 1, color: 'green'}),
     *     a_h_segment = board.create('segment', [A, [
     *                         function(){ return B.X() > A.X() ? B.X() : A.X()},
     *                         function(){ return B.X() > A.X() ? A.Y() : B.Y()}
     *                     ]],{ name: '&Delta;x', dash: 1, color: 'black'});
     *
     *     b_v_segment = board.create('segment', [B, [
     *                         function(){ return B.X() > A.X() ? B.X() : A.X()},
     *                         function(){ return B.X() > A.X() ? A.Y() : B.Y()}
     *                     ]],{ name: '&Delta;y', dash: 1, color: 'black'}),
     *
     *     ma = board.create('midpoint', [a_h_segment.point1, a_h_segment.point2
     *         ], {visible: false});
     *
     *     board.create('text', [0, 0, function() {return '\\[\\Delta_x='+(B.X()-A.X()).toFixed(4)+'\\]'}], {
     *         anchor: ma, useMathJax: true, fixed: true, color: 'green', anchorY: 'top'
     *     });
     *
     *     mb = board.create('midpoint', [b_v_segment.point1, b_v_segment.point2], {visible: false});
     *     board.create('text', [0, 0, function() {return '\\[\\Delta_y='+(B.Y()-A.Y()).toFixed(4)+'\\]'}], {
     *         anchor: mb, useMathJax: true, fixed: true, color: 'green'
     *     });
     *
     *     dval = board.create('text',[0.1, 0.8,
     *         function(){
     *             return '\\[\\frac{\\Delta_y}{\\Delta_x}=\\frac{' + ((B.Y()-A.Y()).toFixed(4)) + '}{' + ((B.X()-A.X()).toFixed(4)) +
     *                 '}=' + (((B.Y()-A.Y()).toFixed(4))/((B.X()-A.X()).toFixed(4))).toFixed(4) + '\\]';
     *         }],{fontSize: 15, useMathJax: true});
     *
     *     })();
     *
     * <\/script><pre>
     *
     * @example
     * var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 10, 11, -2], axis: true});
     * board.options.text.useMathjax = true;
     *
     * a = board.create('slider',[[-0.7,1.5],[5,1.5],[0,0.5,1]], {
     *     suffixlabel:'\\(t_1=\\)',
     *     unitLabel: ' \\(\\text{ ms}\\)',
     *     snapWidth:0.01}),
     *
     * func = board.create('functiongraph',[function(x){return (a.Value()*x*x)}], {strokeColor: "red"});
     * text1 = board.create('text', [5, 1, function(){
     *             return '\\(a(t)= { 1 \\over ' + a.Value().toFixed(3) + '}\\)';
     *         }], {fontSize: 15, fixed:true, strokeColor:'red', anchorY: 'top', parse: false});
     *
     * </pre><div id="JXGf8bd01db-fb6a-4a5c-9e7f-8823f7aa5ac6" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGf8bd01db-fb6a-4a5c-9e7f-8823f7aa5ac6',
     *             {boundingbox: [-1, 10, 11, -2], axis: true, showcopyright: false, shownavigation: false});
     *     board.options.text.useMathjax = true;
     *
     *     a = board.create('slider',[[-0.7,1.5],[5,1.5],[0,0.5,1]], {
     *         suffixlabel:'\\(t_1=\\)',
     *         unitLabel: ' \\(\\text{ ms}\\)',
     *         snapWidth:0.01}),
     *
     *     func = board.create('functiongraph',[function(x){return (a.Value()*x*x)}], {strokeColor: "red"});
     *     text1 = board.create('text', [5, 1, function(){
     *                 return '\\(a(t)= { 1 \\over ' + a.Value().toFixed(3) + '}\\)';
     *             }], {fontSize: 15, fixed:true, strokeColor:'red', anchorY: 'top', parse: false});
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    useMathJax: false,
    /**
     *
     * If true, KaTeX will be used to render the input string.
     * For this feature, katex.min.js and katex.min.css have to be included.
     * <p>
     * The example below does not work, because there is a conflict with
     * the MathJax library which is used below.
     * </p>
     *
     * @name useKatex
     * @memberOf Text.prototype
     * @default false
     * @type Boolean
     *
     *
     * @example
     * JXG.Options.text.useKatex = true;
     *
     * const board = JXG.JSXGraph.initBoard('jxgbox', {
     *     boundingbox: [-2, 5, 8, -5], axis:true
     * });
     *
     * var a = board.create('slider',[[-0.7,1.5],[5,1.5],[0,0.5,1]], {
     *     suffixlabel:'t_1=',
     *     unitLabel: ' \\text{ ms}',
     *     snapWidth:0.01});
     *
     * func = board.create('functiongraph',[function(x){return (a.Value()*x*x)}], {strokeColor: "red"});
     * text1 = board.create('text', [5, 1, function(){
     *             return 'a(t)= { 1 \\over ' + a.Value().toFixed(3) + '}';
     *         }], {fontSize: 15, fixed:true, strokeColor:'red', anchorY: 'top'});
     *
     * </pre>
     * <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.css" integrity="sha384-0cCFrwW/0bAk1Z/6IMgIyNU3kfTcNirlObr4WjrUU7+hZeD6ravdYJ3kPWSeC31M" crossorigin="anonymous">
     * <script src="https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.js" integrity="sha384-dtFDxK2tSkECx/6302Z4VN2ZRqt6Gis+b1IwCjJPrn0kMYFQT9rbtyQWg5NFWAF7" crossorigin="anonymous"><\/script>
     * <div id="JXG497f065c-cfc1-44c3-ba21-5fa581668869" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG497f065c-cfc1-44c3-ba21-5fa581668869',
     *             {boundingbox: [-2, 5, 8, -5], axis: true, showcopyright: false, shownavigation: false});
     *     board.options.useKatex = true;
     *     var a = board.create('slider',[[-0.7,1.5],[5,1.5],[0,0.5,1]], {
     *         suffixlabel:'t_1=',
     *         unitLabel: ' \\text{ ms}',
     *         snapWidth:0.01});
     *
     *     func = board.create('functiongraph',[function(x){return (a.Value()*x*x)}], {strokeColor: "red"});
     *     text1 = board.create('text', [5, 1, function(){
     *                 return 'a(t)= { 1 \\over ' + a.Value().toFixed(3) + '}';
     *             }], {fontSize: 15, fixed:true, strokeColor:'red', anchorY: 'top'});
     *
     *     })();
     *
     * <\/script><pre>
     */
    useKatex: false,
    /**
     * Object or function returning an object that contains macros for KaTeX.
     *
     * @name katexMacros
     * @memberOf Text.prototype
     * @default <tt>{}</tt>
     * @type Object
     *
     * @example
     * // to globally apply macros to all text elements use:
     * JXG.Options.text.katexMacros = {'\\jxg': 'JSXGraph is awesome'};
     *
     * const board = JXG.JSXGraph.initBoard('jxgbox', {
     *     boundingbox: [-2, 5, 8, -5], axis:true
     * });
     *
     * // This macro only get applied to the p ('text') element
     * var p = board.create('text', [1, 0, '\\jsg \\sR '], { katexMacros: {'\\sR':'\\mathbb{R}'} });
     */
    katexMacros: {},
    /**
     * Display number as integer + nominator / denominator. Works together
     * with MathJax, KaTex or as plain text.
     * @name toFraction
     * @memberOf Text.prototype
     * @type Boolean
     * @default false
     * @see JXG#toFraction
     *
     * @example
     *  board.create('text', [2, 2, 2 / 7], { anchorY: 'top', toFraction: true, useMathjax: true });
     *  board.create('text', [2, -2, 2 / 19], { toFraction: true, useMathjax: false });
     *
     * </pre><div id="JXGc10fe0b6-15ac-42b6-890f-2593b427d493" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"><\/script>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGc10fe0b6-15ac-42b6-890f-2593b427d493',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *             board.create('text', [2, 2, 2 / 7], { anchorY: 'top', toFraction: true, useMathjax: true });
     *             board.create('text', [2, -2, 2 / 19], { toFraction: true, useMathjax: false });
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    toFraction: false,
    /**
     * Determines the rendering method of the text. Possible values
     * include <tt>'html'</tt> and <tt>'internal</tt>.
     *
     * @name display
     * @memberOf Text.prototype
     * @default 'html'
     * @type String
     */
    display: "html",
    /**
     * Anchor element {@link Point}, {@link Text} or {@link Image} of the text.
     * If it exists, the coordinates of the text are relative
     * to this anchor element. In this case, only numbers are possible coordinates,
     * functions are not supported.
     *
     * @name anchor
     * @memberOf Text.prototype
     * @default null
     * @type Object
     */
    anchor: null,
    /**
     * The horizontal alignment of the text. Possible values include <tt>'auto'</tt>, <tt>'left'</tt>,
     * <tt>'middle'</tt>, and <tt>'right'</tt>.
     *
     * @name anchorX
     * @memberOf Text.prototype
     * @default 'left'
     * @type String
     */
    anchorX: "left",
    /**
     * The vertical alignment of the text. Possible values include <tt>'auto</tt>, <tt>'top'</tt>, <tt>'middle'</tt>, and
     * <tt>'bottom'</tt>.
     * For MathJax or KaTeX, 'top' is recommended.
     *
     * @name anchorY
     * @memberOf Text.prototype
     * @default 'middle'
     * @type String
     */
    anchorY: "middle",
    /**
     * CSS class of the text in non-highlighted view.
     *
     * @name cssClass
     * @memberOf Text.prototype
     * @type String
     * @default 'JXGtext'
     */
    cssClass: "JXGtext",
    /**
     * CSS class of the text in highlighted view.
     *
     * @name highlightCssClass
     * @memberOf Text.prototype
     * @type String
     * @default 'JXGtext'
     */
    highlightCssClass: "JXGtext",
    /**
     * Sensitive area for dragging the text.
     * Possible values are 'all', or something else.
     * If set to 'small', a sensitivity margin at the right and left border is taken.
     * This may be extended to left, right, ... in the future.
     *
     * @name Text#dragArea
     * @type String
     * @default 'all'
     */
    dragArea: "all",
    withLabel: false,
    /**
     * Text rotation in degrees.
     * Works for non-zero values only in combination with display=='internal'.
     *
     * @name Text#rotate
     * @type Number
     * @default 0
     */
    rotate: 0,
    /**
     * @name Text#visible
     * @type Boolean
     * @default true
     */
    visible: true,
    /**
     * Defines together with {@link Text#snapSizeY} the grid the text snaps on to.
     * The text will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.
     * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks
     * of the default ticks of the default x axes of the board.
     *
     * @name snapSizeX
     * @memberOf Text.prototype
     *
     * @see Point#snapToGrid
     * @see Text#snapSizeY
     * @see JXG.Board#defaultAxes
     * @type Number
     * @default 1
     */
    snapSizeX: 1,
    /**
     * Defines together with {@link Text#snapSizeX} the grid the text snaps on to.
     * The text will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.
     * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks
     * of the default ticks of the default y axes of the board.
     *
     * @name snapSizeY
     * @memberOf Text.prototype
     *
     * @see Point#snapToGrid
     * @see Text#snapSizeX
     * @see JXG.Board#defaultAxes
     * @type Number
     * @default 1
     */
    snapSizeY: 1,
    /**
     * List of attractor elements. If the distance of the text is less than
     * attractorDistance the text is made to glider of this element.
     *
     * @name attractors
     * @memberOf Text.prototype
     * @type Array
     * @default empty
     */
    attractors: []
    /**#@-*/
  },
  /* special options for trace curves */
  tracecurve: {
    /**#@+
     * @visprop
     */
    strokeColor: "#000000",
    fillColor: "none",
    /**
     * The number of evaluated data points.
     * @memberOf Tracecurve.prototype
     * @default 100
     * @name numberPoints
     * @type Number
     */
    numberPoints: 100
    /**#@-*/
  },
  /* special turtle options */
  turtle: {
    /**#@+
     * @visprop
     */
    strokeWidth: 1,
    fillColor: "none",
    strokeColor: "#000000",
    /**
     * Attributes for the turtle arrow.
     *
     * @type Curve
     * @name Turtle#arrow
     */
    arrow: {
      strokeWidth: 2,
      withLabel: false,
      strokeColor: color_default.palette.red,
      lastArrow: true
    }
    /**#@-*/
  },
  /* special vector field options */
  vectorfield: {
    /**#@+
     * @visprop
     */
    strokeWidth: 0.5,
    highlightStrokeWidth: 0.5,
    highlightStrokeColor: color_default.palette.blue,
    highlightStrokeOpacity: 0.8,
    /**
     * Scaling factor of the vectors. This in contrast to slope fields, where this attribute sets the vector to the given length.
     * @name scale
     * @memberOf Vectorfield.prototype
     * @type {Number|Function}
     * @see Slopefield.scale
     * @default 1
     */
    scale: 1,
    /**
     * Customize arrow heads of vectors. Be careful! If enabled this will slow down the performance.
     * Fields are:
     * <ul>
     *  <li> enabled: Boolean
     *  <li> size: length of the arrow head legs (in pixel)
     *  <li> angle: angle of the arrow head legs In radians.
     * </ul>
     * @name arrowhead
     * @memberOf Vectorfield.prototype
     * @type {Object}
     * @default <tt>{enabled: true, size: 5, angle: Math.PI * 0.125}</tt>
     */
    arrowhead: {
      enabled: true,
      size: 5,
      angle: Math.PI * 0.125
    }
    /**#@-*/
  },
  /**
   * Abbreviations of attributes. Setting the shortcut means setting abbreviated properties
   * to the same value.
   * It is used in {@link JXG.GeometryElement#setAttribute} and in
   * the constructor {@link JXG.GeometryElement}.
   * Attention: In Options.js abbreviations are not allowed.
   * @type Object
   * @name JXG.Options#shortcuts
   *
   */
  shortcuts: {
    color: ["strokeColor", "fillColor"],
    opacity: ["strokeOpacity", "fillOpacity"],
    highlightColor: ["highlightStrokeColor", "highlightFillColor"],
    highlightOpacity: ["highlightStrokeOpacity", "highlightFillOpacity"],
    strokeWidth: ["strokeWidth", "highlightStrokeWidth"]
  }
};
jxg_default.Validator = function() {
  var i2, validatePixel = function(v2) {
    return /^[0-9]+px$/.test(v2);
  }, validateDisplay = function(v2) {
    return v2 === "html" || v2 === "internal";
  }, validateColor = function(v2) {
    return type_default.isString(v2);
  }, validatePointFace = function(v2) {
    return type_default.exists(jxg_default.normalizePointFace(v2));
  }, validateInteger = function(v2) {
    return Math.abs(v2 - Math.round(v2)) < math_default.eps;
  }, validateNotNegativeInteger = function(v2) {
    return validateInteger(v2) && v2 >= 0;
  }, validatePositiveInteger = function(v2) {
    return validateInteger(v2) && v2 > 0;
  }, validateScreenCoords = function(v2) {
    return v2.length >= 2 && validateInteger(v2[0]) && validateInteger(v2[1]);
  }, validateRenderer = function(v2) {
    return v2 === "vml" || v2 === "svg" || v2 === "canvas" || v2 === "no";
  }, validatePositive = function(v2) {
    return v2 > 0;
  }, validateNotNegative = function(v2) {
    return v2 >= 0;
  }, v = {}, validators = {
    attractorDistance: validateNotNegative,
    color: validateColor,
    // defaultDistance: Type.isNumber,
    display: validateDisplay,
    doAdvancedPlot: false,
    draft: false,
    drawLabels: false,
    drawZero: false,
    face: validatePointFace,
    factor: type_default.isNumber,
    fillColor: validateColor,
    fillOpacity: type_default.isNumber,
    firstArrow: false,
    fontSize: validateInteger,
    dash: validateInteger,
    gridX: type_default.isNumber,
    gridY: type_default.isNumber,
    // POI: Do we have to add something here?
    hasGrid: false,
    highlightFillColor: validateColor,
    highlightFillOpacity: type_default.isNumber,
    highlightStrokeColor: validateColor,
    highlightStrokeOpacity: type_default.isNumber,
    insertTicks: false,
    //: validateScreenCoords,
    lastArrow: false,
    layer: validateNotNegativeInteger,
    majorHeight: validateInteger,
    minorHeight: validateInteger,
    minorTicks: validateNotNegative,
    minTicksDistance: validatePositiveInteger,
    numberPointsHigh: validatePositiveInteger,
    numberPointsLow: validatePositiveInteger,
    opacity: type_default.isNumber,
    radius: type_default.isNumber,
    RDPsmoothing: false,
    renderer: validateRenderer,
    right: validatePixel,
    showCopyright: false,
    showInfobox: false,
    showNavigation: false,
    size: validateNotNegative,
    //validateInteger,
    snapSizeX: validatePositive,
    snapSizeY: validatePositive,
    snapWidth: type_default.isNumber,
    snapToGrid: false,
    snatchDistance: validateNotNegative,
    straightFirst: false,
    straightLast: false,
    stretch: false,
    strokeColor: validateColor,
    strokeOpacity: type_default.isNumber,
    strokeWidth: validateNotNegative,
    //validateInteger,
    takeFirst: false,
    takeSizeFromFile: false,
    to10: false,
    toOrigin: false,
    translateTo10: false,
    translateToOrigin: false,
    useASCIIMathML: false,
    useDirection: false,
    useMathJax: false,
    withLabel: false,
    withTicks: false,
    zoom: false
  };
  for (i2 in validators) {
    if (validators.hasOwnProperty(i2)) {
      v[i2.toLowerCase()] = validators[i2];
    }
  }
  return v;
}();
jxg_default.normalizePointFace = function(s) {
  var map = {
    cross: "x",
    x: "x",
    circle: "o",
    o: "o",
    square: "[]",
    "[]": "[]",
    plus: "+",
    "+": "+",
    divide: "|",
    "|": "|",
    minus: "-",
    "-": "-",
    diamond: "<>",
    "<>": "<>",
    diamond2: "<<>>",
    "<<>>": "<<>>",
    triangleup: "^",
    A: "^",
    a: "^",
    "^": "^",
    triangledown: "v",
    v: "v",
    triangleleft: "<",
    "<": "<",
    triangleright: ">",
    ">": ">"
  };
  return map[s];
};
jxg_default.useStandardOptions = function(board) {
  var el, t, p, copyProps, o = jxg_default.Options, boardHadGrid = board.hasGrid;
  board.options.grid.hasGrid = o.grid.hasGrid;
  board.options.grid.gridX = o.grid.gridX;
  board.options.grid.gridY = o.grid.gridY;
  board.options.grid.gridColor = o.grid.gridColor;
  board.options.grid.gridOpacity = o.grid.gridOpacity;
  board.options.grid.gridDash = o.grid.gridDash;
  board.options.grid.snapToGrid = o.grid.snapToGrid;
  board.options.grid.snapSizeX = o.grid.SnapSizeX;
  board.options.grid.snapSizeY = o.grid.SnapSizeY;
  board.takeSizeFromFile = o.takeSizeFromFile;
  copyProps = function(p2, o2) {
    p2.visProp.fillcolor = o2.fillColor;
    p2.visProp.highlightfillcolor = o2.highlightFillColor;
    p2.visProp.strokecolor = o2.strokeColor;
    p2.visProp.highlightstrokecolor = o2.highlightStrokeColor;
  };
  for (el in board.objects) {
    if (board.objects.hasOwnProperty(el)) {
      p = board.objects[el];
      if (p.elementClass === constants_default.OBJECT_CLASS_POINT) {
        copyProps(p, o.point);
      } else if (p.elementClass === constants_default.OBJECT_CLASS_LINE) {
        copyProps(p, o.line);
        for (t = 0; t < p.ticks.length; t++) {
          p.ticks[t].majorTicks = o.line.ticks.majorTicks;
          p.ticks[t].minTicksDistance = o.line.ticks.minTicksDistance;
          p.ticks[t].visProp.minorheight = o.line.ticks.minorHeight;
          p.ticks[t].visProp.majorheight = o.line.ticks.majorHeight;
        }
      } else if (p.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
        copyProps(p, o.circle);
      } else if (p.type === constants_default.OBJECT_TYPE_ANGLE) {
        copyProps(p, o.angle);
      } else if (p.type === constants_default.OBJECT_TYPE_ARC) {
        copyProps(p, o.arc);
      } else if (p.type === constants_default.OBJECT_TYPE_POLYGON) {
        copyProps(p, o.polygon);
      } else if (p.type === constants_default.OBJECT_TYPE_CONIC) {
        copyProps(p, o.conic);
      } else if (p.type === constants_default.OBJECT_TYPE_CURVE) {
        copyProps(p, o.curve);
      } else if (p.type === constants_default.OBJECT_TYPE_SECTOR) {
        p.arc.visProp.fillcolor = o.sector.fillColor;
        p.arc.visProp.highlightfillcolor = o.sector.highlightFillColor;
        p.arc.visProp.fillopacity = o.sector.fillOpacity;
        p.arc.visProp.highlightfillopacity = o.sector.highlightFillOpacity;
      }
    }
  }
  board.fullUpdate();
  if (boardHadGrid && !board.hasGrid) {
    board.removeGrids(board);
  } else if (!boardHadGrid && board.hasGrid) {
    board.create("grid", []);
  }
};
jxg_default.useBlackWhiteOptions = function(board) {
  var o = jxg_default.Options;
  o.point.fillColor = color_default.rgb2bw(o.point.fillColor);
  o.point.highlightFillColor = color_default.rgb2bw(o.point.highlightFillColor);
  o.point.strokeColor = color_default.rgb2bw(o.point.strokeColor);
  o.point.highlightStrokeColor = color_default.rgb2bw(o.point.highlightStrokeColor);
  o.line.fillColor = color_default.rgb2bw(o.line.fillColor);
  o.line.highlightFillColor = color_default.rgb2bw(o.line.highlightFillColor);
  o.line.strokeColor = color_default.rgb2bw(o.line.strokeColor);
  o.line.highlightStrokeColor = color_default.rgb2bw(o.line.highlightStrokeColor);
  o.circle.fillColor = color_default.rgb2bw(o.circle.fillColor);
  o.circle.highlightFillColor = color_default.rgb2bw(o.circle.highlightFillColor);
  o.circle.strokeColor = color_default.rgb2bw(o.circle.strokeColor);
  o.circle.highlightStrokeColor = color_default.rgb2bw(o.circle.highlightStrokeColor);
  o.arc.fillColor = color_default.rgb2bw(o.arc.fillColor);
  o.arc.highlightFillColor = color_default.rgb2bw(o.arc.highlightFillColor);
  o.arc.strokeColor = color_default.rgb2bw(o.arc.strokeColor);
  o.arc.highlightStrokeColor = color_default.rgb2bw(o.arc.highlightStrokeColor);
  o.polygon.fillColor = color_default.rgb2bw(o.polygon.fillColor);
  o.polygon.highlightFillColor = color_default.rgb2bw(o.polygon.highlightFillColor);
  o.sector.fillColor = color_default.rgb2bw(o.sector.fillColor);
  o.sector.highlightFillColor = color_default.rgb2bw(o.sector.highlightFillColor);
  o.curve.strokeColor = color_default.rgb2bw(o.curve.strokeColor);
  o.grid.gridColor = color_default.rgb2bw(o.grid.gridColor);
  jxg_default.useStandardOptions(board);
};
jxg_default.Options.normalizePointFace = jxg_default.normalizePointFace;
var options_default = jxg_default.Options;

// node_modules/jsxgraph/src/renderer/abstract.js
jxg_default.AbstractRenderer = function() {
  this.vOffsetText = 0;
  this.enhancedRendering = true;
  this.container = null;
  this.type = "";
  this.supportsForeignObject = false;
  this.dashArray = [
    [2, 2],
    [5, 5],
    [10, 10],
    [20, 20],
    [20, 10, 10, 10],
    [20, 5, 10, 5],
    [0, 5]
  ];
};
jxg_default.extend(
  jxg_default.AbstractRenderer.prototype,
  /** @lends JXG.AbstractRenderer.prototype */
  {
    /* ******************************** *
     *    private methods               *
     *    should not be called from     *
     *    outside AbstractRenderer      *
     * ******************************** */
    /**
     * Update visual properties, but only if {@link JXG.AbstractRenderer#enhancedRendering} or <tt>enhanced</tt> is set to true.
     * @param {JXG.GeometryElement} el The element to update
     * @param {Object} [not={}] Select properties you don't want to be updated: <tt>{fill: true, dash: true}</tt> updates
     * everything except for fill and dash. Possible values are <tt>stroke, fill, dash, shadow, gradient</tt>.
     * @param {Boolean} [enhanced=false] If true, {@link JXG.AbstractRenderer#enhancedRendering} is assumed to be true.
     * @private
     */
    _updateVisual: function(el, not, enhanced) {
      if (enhanced || this.enhancedRendering) {
        not = not || {};
        this.setObjectViewport(el);
        this.setObjectTransition(el);
        if (!type_default.evaluate(el.visProp.draft)) {
          if (!not.stroke) {
            if (el.highlighted) {
              this.setObjectStrokeColor(
                el,
                el.visProp.highlightstrokecolor,
                el.visProp.highlightstrokeopacity
              );
              this.setObjectStrokeWidth(el, el.visProp.highlightstrokewidth);
            } else {
              this.setObjectStrokeColor(
                el,
                el.visProp.strokecolor,
                el.visProp.strokeopacity
              );
              this.setObjectStrokeWidth(el, el.visProp.strokewidth);
            }
          }
          if (!not.fill) {
            if (el.highlighted) {
              this.setObjectFillColor(
                el,
                el.visProp.highlightfillcolor,
                el.visProp.highlightfillopacity
              );
            } else {
              this.setObjectFillColor(
                el,
                el.visProp.fillcolor,
                el.visProp.fillopacity
              );
            }
          }
          if (!not.dash) {
            this.setDashStyle(el, el.visProp);
          }
          if (!not.shadow) {
            this.setShadow(el);
          }
          if (!not.tabindex) {
            this.setTabindex(el);
          }
        } else {
          this.setDraft(el);
        }
      }
    },
    /**
     * Get information if element is highlighted.
     * @param {JXG.GeometryElement} el The element which is tested for being highlighted.
     * @returns {String} 'highlight' if highlighted, otherwise the ampty string '' is returned.
     * @private
     */
    _getHighlighted: function(el) {
      var isTrace = false, hl;
      if (!type_default.exists(el.board) || !type_default.exists(el.board.highlightedObjects)) {
        isTrace = true;
      }
      if (!isTrace && type_default.exists(el.board.highlightedObjects[el.id])) {
        hl = "highlight";
      } else {
        hl = "";
      }
      return hl;
    },
    /* ******************************** *
     *    Point drawing and updating    *
     * ******************************** */
    /**
     * Draws a point on the {@link JXG.Board}.
     * @param {JXG.Point} el Reference to a {@link JXG.Point} object that has to be drawn.
     * @see Point
     * @see JXG.Point
     * @see JXG.AbstractRenderer#updatePoint
     * @see JXG.AbstractRenderer#changePointStyle
     */
    drawPoint: function(el) {
      var prim, face = options_default.normalizePointFace(type_default.evaluate(el.visProp.face));
      if (face === "o") {
        prim = "ellipse";
      } else if (face === "[]") {
        prim = "rect";
      } else {
        prim = "path";
      }
      el.rendNode = this.appendChildPrim(
        this.createPrim(prim, el.id),
        type_default.evaluate(el.visProp.layer)
      );
      this.appendNodesToElement(el, prim);
      this._updateVisual(el, { dash: true, shadow: true }, true);
      this.updatePoint(el);
    },
    /**
     * Updates visual appearance of the renderer element assigned to the given {@link JXG.Point}.
     * @param {JXG.Point} el Reference to a {@link JXG.Point} object, that has to be updated.
     * @see Point
     * @see JXG.Point
     * @see JXG.AbstractRenderer#drawPoint
     * @see JXG.AbstractRenderer#changePointStyle
     */
    updatePoint: function(el) {
      var size2 = type_default.evaluate(el.visProp.size), face = options_default.normalizePointFace(type_default.evaluate(el.visProp.face)), unit = type_default.evaluate(el.visProp.sizeunit), zoom = type_default.evaluate(el.visProp.zoom), s1;
      if (!isNaN(el.coords.scrCoords[2] + el.coords.scrCoords[1])) {
        if (unit === "user") {
          size2 *= Math.sqrt(Math.abs(el.board.unitX * el.board.unitY));
        }
        size2 *= !el.board || !zoom ? 1 : Math.sqrt(el.board.zoomX * el.board.zoomY);
        s1 = size2 === 0 ? 0 : size2 + 1;
        if (face === "o") {
          this.updateEllipsePrim(
            el.rendNode,
            el.coords.scrCoords[1],
            el.coords.scrCoords[2],
            s1,
            s1
          );
        } else if (face === "[]") {
          this.updateRectPrim(
            el.rendNode,
            el.coords.scrCoords[1] - size2,
            el.coords.scrCoords[2] - size2,
            size2 * 2,
            size2 * 2
          );
        } else {
          this.updatePathPrim(
            el.rendNode,
            this.updatePathStringPoint(el, size2, face),
            el.board
          );
        }
        this._updateVisual(el, { dash: false, shadow: false });
        this.setShadow(el);
      }
    },
    /**
     * Changes the style of a {@link JXG.Point}. This is required because the point styles differ in what
     * elements have to be drawn, e.g. if the point is marked by a "x" or a "+" two lines are drawn, if
     * it's marked by spot a circle is drawn. This method removes the old renderer element(s) and creates
     * the new one(s).
     * @param {JXG.Point} el Reference to a {@link JXG.Point} object, that's style is changed.
     * @see Point
     * @see JXG.Point
     * @see JXG.AbstractRenderer#updatePoint
     * @see JXG.AbstractRenderer#drawPoint
     */
    changePointStyle: function(el) {
      var node2 = this.getElementById(el.id);
      if (type_default.exists(node2)) {
        this.remove(node2);
      }
      this.drawPoint(el);
      type_default.clearVisPropOld(el);
      if (!el.visPropCalc.visible) {
        this.display(el, false);
      }
      if (type_default.evaluate(el.visProp.draft)) {
        this.setDraft(el);
      }
    },
    /* ******************************** *
     *           Lines                  *
     * ******************************** */
    /**
     * Draws a line on the {@link JXG.Board}.
     * @param {JXG.Line} el Reference to a line object, that has to be drawn.
     * @see Line
     * @see JXG.Line
     * @see JXG.AbstractRenderer#updateLine
     */
    drawLine: function(el) {
      el.rendNode = this.appendChildPrim(
        this.createPrim("line", el.id),
        type_default.evaluate(el.visProp.layer)
      );
      this.appendNodesToElement(el, "lines");
      this.updateLine(el);
    },
    /**
     * Updates visual appearance of the renderer element assigned to the given {@link JXG.Line}.
     * @param {JXG.Line} el Reference to the {@link JXG.Line} object that has to be updated.
     * @see Line
     * @see JXG.Line
     * @see JXG.AbstractRenderer#drawLine
     */
    updateLine: function(el) {
      this._updateVisual(el);
      this.updatePathWithArrowHeads(el);
      this.setLineCap(el);
    },
    /* **************************
     *    Curves
     * **************************/
    /**
     * Draws a {@link JXG.Curve} on the {@link JXG.Board}.
     * @param {JXG.Curve} el Reference to a graph object, that has to be plotted.
     * @see Curve
     * @see JXG.Curve
     * @see JXG.AbstractRenderer#updateCurve
     */
    drawCurve: function(el) {
      el.rendNode = this.appendChildPrim(
        this.createPrim("path", el.id),
        type_default.evaluate(el.visProp.layer)
      );
      this.appendNodesToElement(el, "path");
      this.updateCurve(el);
    },
    /**
     * Updates visual appearance of the renderer element assigned to the given {@link JXG.Curve}.
     * @param {JXG.Curve} el Reference to a {@link JXG.Curve} object, that has to be updated.
     * @see Curve
     * @see JXG.Curve
     * @see JXG.AbstractRenderer#drawCurve
     */
    updateCurve: function(el) {
      this._updateVisual(el);
      this.updatePathWithArrowHeads(el);
      this.setLineCap(el);
    },
    /* **************************
     *    Arrow heads and related stuff
     * **************************/
    /**
     * Handles arrow heads of a line or curve element and calls the renderer primitive.
     *
     * @param {JXG.GeometryElement} el Reference to a line or curve object that has to be drawn.
     * @param {Boolean} doHighlight
     *
     * @private
     * @see Line
     * @see JXG.Line
     * @see Curve
     * @see JXG.Curve
     * @see JXG.AbstractRenderer#updateLine
     * @see JXG.AbstractRenderer#updateCurve
     * @see JXG.AbstractRenderer#makeArrows
     * @see JXG.AbstractRenderer#getArrowHeadData
     */
    updatePathWithArrowHeads: function(el, doHighlight) {
      var ev = el.visProp, hl = doHighlight ? "highlight" : "", w, arrowData;
      if (doHighlight && ev.highlightstrokewidth) {
        w = Math.max(
          type_default.evaluate(ev.highlightstrokewidth),
          type_default.evaluate(ev.strokewidth)
        );
      } else {
        w = type_default.evaluate(ev.strokewidth);
      }
      arrowData = this.getArrowHeadData(el, w, hl);
      this.makeArrows(el, arrowData);
      if (el.elementClass === constants_default.OBJECT_CLASS_LINE) {
        this.updateLineWithEndings(el, arrowData);
      } else if (el.elementClass === constants_default.OBJECT_CLASS_CURVE) {
        this.updatePath(el);
      }
      this.setArrowSize(el, arrowData);
    },
    /**
     * This method determines some data about the line endings of this element.
     * If there are arrow heads, the offset is determined so that no parts of the line stroke
     * lap over the arrow head.
     * <p>
     * The returned object also contains the types of the arrow heads.
     *
     * @param {JXG.GeometryElement} el JSXGraph line or curve element
     * @param {Number} strokewidth strokewidth of the element
     * @param {String} hl Ither 'highlight' or empty string
     * @returns {Object} object containing the data
     *
     * @private
     */
    getArrowHeadData: function(el, strokewidth, hl) {
      var minlen = math_default.eps, typeFirst, typeLast, offFirst = 0, offLast = 0, sizeFirst = 0, sizeLast = 0, ev_fa = type_default.evaluate(el.visProp.firstarrow), ev_la = type_default.evaluate(el.visProp.lastarrow), off, size2;
      if (ev_fa || ev_la) {
        if (type_default.exists(ev_fa.type)) {
          typeFirst = type_default.evaluate(ev_fa.type);
        } else {
          if (el.elementClass === constants_default.OBJECT_CLASS_LINE) {
            typeFirst = 1;
          } else {
            typeFirst = 7;
          }
        }
        if (type_default.exists(ev_la.type)) {
          typeLast = type_default.evaluate(ev_la.type);
        } else {
          if (el.elementClass === constants_default.OBJECT_CLASS_LINE) {
            typeLast = 1;
          } else {
            typeLast = 7;
          }
        }
        if (ev_fa) {
          size2 = 6;
          if (type_default.exists(ev_fa.size)) {
            size2 = type_default.evaluate(ev_fa.size);
          }
          if (hl !== "" && type_default.exists(ev_fa[hl + "size"])) {
            size2 = type_default.evaluate(ev_fa[hl + "size"]);
          }
          off = strokewidth * size2;
          if (typeFirst === 2) {
            off *= 0.5;
            minlen += strokewidth * size2;
          } else if (typeFirst === 3) {
            off = strokewidth * size2 / 3;
            minlen += strokewidth;
          } else if (typeFirst === 4 || typeFirst === 5 || typeFirst === 6) {
            off = strokewidth * size2 / 1.5;
            minlen += strokewidth * size2;
          } else if (typeFirst === 7) {
            off = 0;
            size2 = 10;
            minlen += strokewidth;
          } else {
            minlen += strokewidth * size2;
          }
          offFirst += off;
          sizeFirst = size2;
        }
        if (ev_la) {
          size2 = 6;
          if (type_default.exists(ev_la.size)) {
            size2 = type_default.evaluate(ev_la.size);
          }
          if (hl !== "" && type_default.exists(ev_la[hl + "size"])) {
            size2 = type_default.evaluate(ev_la[hl + "size"]);
          }
          off = strokewidth * size2;
          if (typeLast === 2) {
            off *= 0.5;
            minlen += strokewidth * size2;
          } else if (typeLast === 3) {
            off = strokewidth * size2 / 3;
            minlen += strokewidth;
          } else if (typeLast === 4 || typeLast === 5 || typeLast === 6) {
            off = strokewidth * size2 / 1.5;
            minlen += strokewidth * size2;
          } else if (typeLast === 7) {
            off = 0;
            size2 = 10;
            minlen += strokewidth;
          } else {
            minlen += strokewidth * size2;
          }
          offLast += off;
          sizeLast = size2;
        }
      }
      el.visPropCalc.typeFirst = typeFirst;
      el.visPropCalc.typeLast = typeLast;
      return {
        evFirst: ev_fa,
        evLast: ev_la,
        typeFirst,
        typeLast,
        offFirst,
        offLast,
        sizeFirst,
        sizeLast,
        showFirst: 1,
        // Show arrow head. 0 if the distance is too small
        showLast: 1,
        // Show arrow head. 0 if the distance is too small
        minLen: minlen,
        strokeWidth: strokewidth
      };
    },
    /**
     * Corrects the line length if there are arrow heads, such that
     * the arrow ends exactly at the intended position.
     * Calls the renderer method to draw the line.
     *
     * @param {JXG.Line} el Reference to a line object, that has to be drawn
     * @param {Object} arrowData Data concerning possible arrow heads
     *
     * @returns {JXG.AbstractRenderer} Reference to the renderer
     *
     * @private
     * @see Line
     * @see JXG.Line
     * @see JXG.AbstractRenderer#updateLine
     * @see JXG.AbstractRenderer#getPositionArrowHead
     *
     */
    updateLineWithEndings: function(el, arrowData) {
      var c1, c2, margin = null;
      c1 = new coords_default(constants_default.COORDS_BY_USER, el.point1.coords.usrCoords, el.board);
      c2 = new coords_default(constants_default.COORDS_BY_USER, el.point2.coords.usrCoords, el.board);
      margin = type_default.evaluate(el.visProp.margin);
      geometry_default.calcStraight(el, c1, c2, margin);
      this.handleTouchpoints(el, c1, c2, arrowData);
      this.getPositionArrowHead(el, c1, c2, arrowData);
      this.updateLinePrim(
        el.rendNode,
        c1.scrCoords[1],
        c1.scrCoords[2],
        c2.scrCoords[1],
        c2.scrCoords[2],
        el.board
      );
      return this;
    },
    /**
     *
     * Calls the renderer method to draw a curve.
     *
     * @param {JXG.GeometryElement} el Reference to a line object, that has to be drawn.
     * @returns {JXG.AbstractRenderer} Reference to the renderer
     *
     * @private
     * @see Curve
     * @see JXG.Curve
     * @see JXG.AbstractRenderer#updateCurve
     *
     */
    updatePath: function(el) {
      if (type_default.evaluate(el.visProp.handdrawing)) {
        this.updatePathPrim(el.rendNode, this.updatePathStringBezierPrim(el), el.board);
      } else {
        this.updatePathPrim(el.rendNode, this.updatePathStringPrim(el), el.board);
      }
      return this;
    },
    /**
     * Shorten the length of a line element such that the arrow head touches
     * the start or end point and such that the arrow head ends exactly
     * at the start / end position of the line.
     * <p>
     * The Coords objects c1 and c2 are changed in place. In object a, the Boolean properties
     * 'showFirst' and 'showLast' are set.
     *
     * @param  {JXG.Line} el Reference to the line object that gets arrow heads.
     * @param  {JXG.Coords} c1  Coords of the first point of the line (after {@link JXG.Math.Geometry#calcStraight}).
     * @param  {JXG.Coords} c2  Coords of the second point of the line (after {@link JXG.Math.Geometry#calcStraight}).
     * @param  {Object}  a Object { evFirst: Boolean, evLast: Boolean} containing information about arrow heads.
     * @see JXG.AbstractRenderer#getArrowHeadData
     *
     */
    getPositionArrowHead: function(el, c1, c2, a) {
      var d, d1x, d1y, d2x, d2y;
      if (a.evFirst || a.evLast) {
        d1x = d1y = d2x = d2y = 0;
        d = c1.distance(constants_default.COORDS_BY_SCREEN, c2);
        if (a.evFirst && el.board.renderer.type !== "vml") {
          if (d >= a.minLen) {
            d1x = (c2.scrCoords[1] - c1.scrCoords[1]) * a.offFirst / d;
            d1y = (c2.scrCoords[2] - c1.scrCoords[2]) * a.offFirst / d;
          } else {
            a.showFirst = 0;
          }
        }
        if (a.evLast && el.board.renderer.type !== "vml") {
          if (d >= a.minLen) {
            d2x = (c2.scrCoords[1] - c1.scrCoords[1]) * a.offLast / d;
            d2y = (c2.scrCoords[2] - c1.scrCoords[2]) * a.offLast / d;
          } else {
            a.showLast = 0;
          }
        }
        c1.setCoordinates(
          constants_default.COORDS_BY_SCREEN,
          [c1.scrCoords[1] + d1x, c1.scrCoords[2] + d1y],
          false,
          true
        );
        c2.setCoordinates(
          constants_default.COORDS_BY_SCREEN,
          [c2.scrCoords[1] - d2x, c2.scrCoords[2] - d2y],
          false,
          true
        );
      }
      return this;
    },
    /**
     * Handle touchlastpoint / touchfirstpoint
     *
     * @param {JXG.GeometryElement} el
     * @param {JXG.Coords} c1 Coordinates of the start of the line. The coordinates are changed in place.
     * @param {JXG.Coords} c2 Coordinates of the end of the line. The coordinates are changed in place.
     * @param {Object} a
     * @see JXG.AbstractRenderer#getArrowHeadData
     */
    handleTouchpoints: function(el, c1, c2, a) {
      var s1, s2, d, d1x, d1y, d2x, d2y;
      if (a.evFirst || a.evLast) {
        d = d1x = d1y = d2x = d2y = 0;
        s1 = type_default.evaluate(el.point1.visProp.size) + type_default.evaluate(el.point1.visProp.strokewidth);
        s2 = type_default.evaluate(el.point2.visProp.size) + type_default.evaluate(el.point2.visProp.strokewidth);
        if (a.evFirst && type_default.evaluate(el.visProp.touchfirstpoint) && type_default.evaluate(el.point1.visProp.visible)) {
          d = c1.distance(constants_default.COORDS_BY_SCREEN, c2);
          d1x = (c2.scrCoords[1] - c1.scrCoords[1]) * s1 / d;
          d1y = (c2.scrCoords[2] - c1.scrCoords[2]) * s1 / d;
        }
        if (a.evLast && type_default.evaluate(el.visProp.touchlastpoint) && type_default.evaluate(el.point2.visProp.visible)) {
          d = c1.distance(constants_default.COORDS_BY_SCREEN, c2);
          d2x = (c2.scrCoords[1] - c1.scrCoords[1]) * s2 / d;
          d2y = (c2.scrCoords[2] - c1.scrCoords[2]) * s2 / d;
        }
        c1.setCoordinates(
          constants_default.COORDS_BY_SCREEN,
          [c1.scrCoords[1] + d1x, c1.scrCoords[2] + d1y],
          false,
          true
        );
        c2.setCoordinates(
          constants_default.COORDS_BY_SCREEN,
          [c2.scrCoords[1] - d2x, c2.scrCoords[2] - d2y],
          false,
          true
        );
      }
      return this;
    },
    /**
     * Set the arrow head size.
     *
     * @param {JXG.GeometryElement} el Reference to a line or curve object that has to be drawn.
     * @param {Object} arrowData Data concerning possible arrow heads
     * @returns {JXG.AbstractRenderer} Reference to the renderer
     *
     * @private
     * @see Line
     * @see JXG.Line
     * @see Curve
     * @see JXG.Curve
     * @see JXG.AbstractRenderer#updatePathWithArrowHeads
     * @see JXG.AbstractRenderer#getArrowHeadData
     */
    setArrowSize: function(el, a) {
      if (a.evFirst) {
        this._setArrowWidth(
          el.rendNodeTriangleStart,
          a.showFirst * a.strokeWidth,
          el.rendNode,
          a.sizeFirst
        );
      }
      if (a.evLast) {
        this._setArrowWidth(
          el.rendNodeTriangleEnd,
          a.showLast * a.strokeWidth,
          el.rendNode,
          a.sizeLast
        );
      }
      return this;
    },
    /**
     * Update the line endings (linecap) of a straight line from its attribute
     * 'linecap'.
     * Possible values for the attribute 'linecap' are: 'butt', 'round', 'square'.
     * The default value is 'butt'. Not available for VML renderer.
     *
     * @param {JXG.Line} element A arbitrary line.
     * @see Line
     * @see JXG.Line
     * @see JXG.AbstractRenderer#updateLine
     */
    setLineCap: function(el) {
    },
    /* **************************
     *    Ticks related stuff
     * **************************/
    /**
     * Creates a rendering node for ticks added to a line.
     * @param {JXG.Line} el A arbitrary line.
     * @see Line
     * @see Ticks
     * @see JXG.Line
     * @see JXG.Ticks
     * @see JXG.AbstractRenderer#updateTicks
     */
    drawTicks: function(el) {
      el.rendNode = this.appendChildPrim(
        this.createPrim("path", el.id),
        type_default.evaluate(el.visProp.layer)
      );
      this.appendNodesToElement(el, "path");
    },
    /**
     * Update {@link Ticks} on a {@link JXG.Line}. This method is only a stub and has to be implemented
     * in any descendant renderer class.
     * @param {JXG.Ticks} element Reference of a ticks object that has to be updated.
     * @see Line
     * @see Ticks
     * @see JXG.Line
     * @see JXG.Ticks
     * @see JXG.AbstractRenderer#drawTicks
     */
    updateTicks: function(element) {
    },
    /* **************************
     *    Circle related stuff
     * **************************/
    /**
     * Draws a {@link JXG.Circle}
     * @param {JXG.Circle} el Reference to a {@link JXG.Circle} object that has to be drawn.
     * @see Circle
     * @see JXG.Circle
     * @see JXG.AbstractRenderer#updateEllipse
     */
    drawEllipse: function(el) {
      el.rendNode = this.appendChildPrim(
        this.createPrim("ellipse", el.id),
        type_default.evaluate(el.visProp.layer)
      );
      this.appendNodesToElement(el, "ellipse");
      this.updateEllipse(el);
    },
    /**
     * Updates visual appearance of a given {@link JXG.Circle} on the {@link JXG.Board}.
     * @param {JXG.Circle} el Reference to a {@link JXG.Circle} object, that has to be updated.
     * @see Circle
     * @see JXG.Circle
     * @see JXG.AbstractRenderer#drawEllipse
     */
    updateEllipse: function(el) {
      this._updateVisual(el);
      var radius = el.Radius();
      if (
        /*radius > 0.0 &&*/
        Math.abs(el.center.coords.usrCoords[0]) > math_default.eps && !isNaN(radius + el.center.coords.scrCoords[1] + el.center.coords.scrCoords[2]) && radius * el.board.unitX < 2e6
      ) {
        this.updateEllipsePrim(
          el.rendNode,
          el.center.coords.scrCoords[1],
          el.center.coords.scrCoords[2],
          radius * el.board.unitX,
          radius * el.board.unitY
        );
      }
      this.setLineCap(el);
    },
    /* **************************
     *   Polygon related stuff
     * **************************/
    /**
     * Draws a {@link JXG.Polygon} on the {@link JXG.Board}.
     * @param {JXG.Polygon} el Reference to a Polygon object, that is to be drawn.
     * @see Polygon
     * @see JXG.Polygon
     * @see JXG.AbstractRenderer#updatePolygon
     */
    drawPolygon: function(el) {
      el.rendNode = this.appendChildPrim(
        this.createPrim("polygon", el.id),
        type_default.evaluate(el.visProp.layer)
      );
      this.appendNodesToElement(el, "polygon");
      this.updatePolygon(el);
    },
    /**
     * Updates properties of a {@link JXG.Polygon}'s rendering node.
     * @param {JXG.Polygon} el Reference to a {@link JXG.Polygon} object, that has to be updated.
     * @see Polygon
     * @see JXG.Polygon
     * @see JXG.AbstractRenderer#drawPolygon
     */
    updatePolygon: function(el) {
      this._updateVisual(el, { stroke: true, dash: true });
      this.updatePolygonPrim(el.rendNode, el);
    },
    /* **************************
     *    Text related stuff
     * **************************/
    /**
     * Shows a small copyright notice in the top left corner of the board.
     * @param {String} str The copyright notice itself
     * @param {Number} fontsize Size of the font the copyright notice is written in
     */
    displayCopyright: function(str2, fontsize) {
    },
    /**
     * An internal text is a {@link JXG.Text} element which is drawn using only
     * the given renderer but no HTML. This method is only a stub, the drawing
     * is done in the special renderers.
     * @param {JXG.Text} element Reference to a {@link JXG.Text} object
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#updateInternalText
     * @see JXG.AbstractRenderer#drawText
     * @see JXG.AbstractRenderer#updateText
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    drawInternalText: function(element) {
    },
    /**
     * Updates visual properties of an already existing {@link JXG.Text} element.
     * @param {JXG.Text} element Reference to an {@link JXG.Text} object, that has to be updated.
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#drawInternalText
     * @see JXG.AbstractRenderer#drawText
     * @see JXG.AbstractRenderer#updateText
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    updateInternalText: function(element) {
    },
    /**
     * Displays a {@link JXG.Text} on the {@link JXG.Board} by putting a HTML div over it.
     * @param {JXG.Text} el Reference to an {@link JXG.Text} object, that has to be displayed
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#drawInternalText
     * @see JXG.AbstractRenderer#updateText
     * @see JXG.AbstractRenderer#updateInternalText
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    drawText: function(el) {
      var node2, z, level, ev_visible;
      if (type_default.evaluate(el.visProp.display) === "html" && env_default.isBrowser && this.type !== "no") {
        node2 = this.container.ownerDocument.createElement("div");
        node2.style.position = "absolute";
        node2.className = type_default.evaluate(el.visProp.cssclass);
        level = type_default.evaluate(el.visProp.layer);
        if (!type_default.exists(level)) {
          level = 0;
        }
        if (this.container.style.zIndex === "") {
          z = 0;
        } else {
          z = parseInt(this.container.style.zIndex, 10);
        }
        node2.style.zIndex = z + level;
        this.container.appendChild(node2);
        node2.setAttribute("id", this.container.id + "_" + el.id);
      } else {
        node2 = this.drawInternalText(el);
      }
      el.rendNode = node2;
      el.htmlStr = "";
      if (el.visProp.islabel && type_default.exists(el.visProp.anchor)) {
        ev_visible = type_default.evaluate(el.visProp.anchor.visProp.visible);
        el.prepareUpdate().updateVisibility(ev_visible);
      } else {
        el.prepareUpdate().updateVisibility();
      }
      this.updateText(el);
    },
    /**
     * Updates visual properties of an already existing {@link JXG.Text} element.
     * @param {JXG.Text} el Reference to an {@link JXG.Text} object, that has to be updated.
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#drawText
     * @see JXG.AbstractRenderer#drawInternalText
     * @see JXG.AbstractRenderer#updateInternalText
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    updateText: function(el) {
      var content = el.plaintext, v, c, parentNode, node2, ax, ay, angle, co, si, to_h, to_v;
      if (el.visPropCalc.visible) {
        this.updateTextStyle(el, false);
        if (type_default.evaluate(el.visProp.display) === "html" && this.type !== "no") {
          if (!isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])) {
            c = el.coords.scrCoords[1];
            c = Math.abs(c) < 1e6 ? c : 1e6;
            ax = el.getAnchorX();
            if (ax === "right") {
              v = el.board.canvasWidth - c;
              to_h = "right";
            } else if (ax === "middle") {
              v = c - 0.5 * el.size[0];
              to_h = "center";
            } else {
              v = c;
              to_h = "left";
            }
            if (el.visPropOld.left !== ax + v) {
              if (ax === "right") {
                el.rendNode.style.right = v + "px";
                el.rendNode.style.left = "auto";
              } else {
                el.rendNode.style.left = v + "px";
                el.rendNode.style.right = "auto";
              }
              el.visPropOld.left = ax + v;
            }
            c = el.coords.scrCoords[2] + this.vOffsetText;
            c = Math.abs(c) < 1e6 ? c : 1e6;
            ay = el.getAnchorY();
            if (ay === "bottom") {
              v = el.board.canvasHeight - c;
              to_v = "bottom";
            } else if (ay === "middle") {
              v = c - 0.5 * el.size[1];
              to_v = "center";
            } else {
              v = c;
              to_v = "top";
            }
            if (el.visPropOld.top !== ay + v) {
              if (ay === "bottom") {
                el.rendNode.style.top = "auto";
                el.rendNode.style.bottom = v + "px";
              } else {
                el.rendNode.style.bottom = "auto";
                el.rendNode.style.top = v + "px";
              }
              el.visPropOld.top = ay + v;
            }
          }
          if (el.htmlStr !== content) {
            try {
              if (el.type === type_default.OBJECT_TYPE_BUTTON) {
                el.rendNodeButton.innerHTML = content;
              } else if (el.type === type_default.OBJECT_TYPE_CHECKBOX || el.type === type_default.OBJECT_TYPE_INPUT) {
                el.rendNodeLabel.innerHTML = content;
              } else {
                el.rendNode.innerHTML = content;
              }
            } catch (e) {
              parentNode = el.rendNode.parentNode;
              el.rendNode.parentNode.removeChild(el.rendNode);
              el.rendNode.innerHTML = content;
              parentNode.appendChild(el.rendNode);
            }
            el.htmlStr = content;
            if (type_default.evaluate(el.visProp.usemathjax)) {
              try {
                if (MathJax.typeset) {
                  MathJax.typeset([el.rendNode]);
                } else {
                  MathJax.Hub.Queue(["Typeset", MathJax.Hub, el.rendNode]);
                }
              } catch (e) {
                jxg_default.debug("MathJax (not yet) loaded");
              }
            } else if (type_default.evaluate(el.visProp.usekatex)) {
              try {
                if (el.rendNode.innerHTML.indexOf("<span") === 0 && el.rendNode.innerHTML.indexOf("<label") > 0 && (el.rendNode.innerHTML.indexOf("<checkbox") > 0 || el.rendNode.innerHTML.indexOf("<input") > 0)) {
                  node2 = el.rendNodeLabel;
                } else if (el.rendNode.innerHTML.indexOf("<button") === 0) {
                  node2 = el.rendNodeButton;
                } else {
                  node2 = el.rendNode;
                }
                if (node2) {
                  katex.render(content, node2, {
                    macros: type_default.evaluate(el.visProp.katexmacros),
                    throwOnError: false
                  });
                }
              } catch (e) {
                jxg_default.debug("KaTeX not loaded (yet)");
              }
            } else if (type_default.evaluate(el.visProp.useasciimathml)) {
              try {
                AMprocessNode(el.rendNode, false);
              } catch (e) {
                jxg_default.debug("AsciiMathML not loaded (yet)");
              }
            }
          }
          angle = type_default.evaluate(el.visProp.rotate);
          if (angle !== 0) {
            angle *= Math.PI / 180;
            co = Math.cos(angle);
            si = Math.sin(angle);
            el.rendNode.style["transform"] = "matrix(" + [co, -1 * si, si, co, 0, 0].join(",") + ")";
            el.rendNode.style["transform-origin"] = to_h + " " + to_v;
          }
          this.transformImage(el, el.transformations);
        } else {
          this.updateInternalText(el);
        }
      }
    },
    /**
     * Converts string containing CSS properties into
     * array with key-value pair objects.
     *
     * @example
     * "color:blue; background-color:yellow" is converted to
     * [{'color': 'blue'}, {'backgroundColor': 'yellow'}]
     *
     * @param  {String} cssString String containing CSS properties
     * @return {Array}           Array of CSS key-value pairs
     */
    _css2js: function(cssString) {
      var pairs = [], i2, len, key, val, s, list2 = type_default.trim(cssString).replace(/;$/, "").split(";");
      len = list2.length;
      for (i2 = 0; i2 < len; ++i2) {
        if (type_default.trim(list2[i2]) !== "") {
          s = list2[i2].split(":");
          key = type_default.trim(
            s[0].replace(/-([a-z])/gi, function(match, char) {
              return char.toUpperCase();
            })
          );
          val = type_default.trim(s[1]);
          pairs.push({ key, val });
        }
      }
      return pairs;
    },
    /**
     * Updates font-size, color and opacity propertiey and CSS style properties of a {@link JXG.Text} node.
     * This function is also called by highlight() and nohighlight().
     * @param {JXG.Text} el Reference to the {@link JXG.Text} object, that has to be updated.
     * @param {Boolean} doHighlight
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#drawText
     * @see JXG.AbstractRenderer#drawInternalText
     * @see JXG.AbstractRenderer#updateText
     * @see JXG.AbstractRenderer#updateInternalText
     * @see JXG.AbstractRenderer#updateInternalTextStyle
     */
    updateTextStyle: function(el, doHighlight) {
      var fs, so, sc, css, node2, ev = el.visProp, display = env_default.isBrowser ? ev.display : "internal", nodeList = ["rendNode", "rendNodeTag", "rendNodeLabel"], lenN = nodeList.length, fontUnit = type_default.evaluate(ev.fontunit), cssList, prop, style, cssString, styleList = ["cssdefaultstyle", "cssstyle"], lenS = styleList.length;
      if (doHighlight) {
        sc = ev.highlightstrokecolor;
        so = ev.highlightstrokeopacity;
        css = ev.highlightcssclass;
      } else {
        sc = ev.strokecolor;
        so = ev.strokeopacity;
        css = ev.cssclass;
      }
      if (this.type !== "no" && (display === "html" || this.type !== "canvas")) {
        for (style = 0; style < lenS; style++) {
          cssString = type_default.evaluate(
            ev[(doHighlight ? "highlight" : "") + styleList[style]]
          );
          if (cssString !== "" && el.visPropOld[styleList[style]] !== cssString) {
            cssList = this._css2js(cssString);
            for (node2 = 0; node2 < lenN; node2++) {
              if (type_default.exists(el[nodeList[node2]])) {
                for (prop in cssList) {
                  if (cssList.hasOwnProperty(prop)) {
                    el[nodeList[node2]].style[cssList[prop].key] = cssList[prop].val;
                  }
                }
              }
            }
            el.visPropOld[styleList[style]] = cssString;
          }
        }
        fs = type_default.evaluate(ev.fontsize);
        if (el.visPropOld.fontsize !== fs) {
          el.needsSizeUpdate = true;
          try {
            for (node2 = 0; node2 < lenN; node2++) {
              if (type_default.exists(el[nodeList[node2]])) {
                el[nodeList[node2]].style.fontSize = fs + fontUnit;
              }
            }
          } catch (e) {
            for (node2 = 0; node2 < lenN; node2++) {
              if (type_default.exists(el[nodeList[node2]])) {
                el[nodeList[node2]].style.fontSize = fs;
              }
            }
          }
          el.visPropOld.fontsize = fs;
        }
      }
      this.setTabindex(el);
      this.setObjectTransition(el);
      if (display === "html" && this.type !== "no") {
        this.setObjectViewport(el, true);
        if (el.visPropOld.cssclass !== css) {
          el.rendNode.className = css;
          el.visPropOld.cssclass = css;
          el.needsSizeUpdate = true;
        }
        this.setObjectStrokeColor(el, sc, so);
      } else {
        this.updateInternalTextStyle(el, sc, so);
      }
      return this;
    },
    /**
     * Set color and opacity of internal texts.
     * This method is used for Canvas and VML.
     * SVG needs its own version.
     * @private
     * @see JXG.AbstractRenderer#updateTextStyle
     * @see JXG.SVGRenderer#updateInternalTextStyle
     */
    updateInternalTextStyle: function(el, strokeColor, strokeOpacity) {
      this.setObjectStrokeColor(el, strokeColor, strokeOpacity);
    },
    /* **************************
     *    Image related stuff
     * **************************/
    /**
     * Draws an {@link JXG.Image} on a board; This is just a template that has to be implemented by special
     * renderers.
     * @param {JXG.Image} element Reference to the image object that is to be drawn
     * @see Image
     * @see JXG.Image
     * @see JXG.AbstractRenderer#updateImage
     */
    drawImage: function(element) {
    },
    /**
     * Updates the properties of an {@link JXG.Image} element.
     * @param {JXG.Image} el Reference to an {@link JXG.Image} object, that has to be updated.
     * @see Image
     * @see JXG.Image
     * @see JXG.AbstractRenderer#drawImage
     */
    updateImage: function(el) {
      this.updateRectPrim(
        el.rendNode,
        el.coords.scrCoords[1],
        el.coords.scrCoords[2] - el.size[1],
        el.size[0],
        el.size[1]
      );
      this.updateImageURL(el);
      this.transformImage(el, el.transformations);
      this._updateVisual(el, { stroke: true, dash: true }, true);
    },
    /**
     * Multiplication of transformations without updating. That means, at that point it is expected that the
     * matrices contain numbers only. First, the origin in user coords is translated to <tt>(0,0)</tt> in screen
     * coords. Then, the stretch factors are divided out. After the transformations in user coords, the stretch
     * factors are multiplied in again, and the origin in user coords is translated back to its position. This
     * method does not have to be implemented in a new renderer.
     * @param {JXG.GeometryElement} el A JSXGraph element. We only need its board property.
     * @param {Array} transformations An array of JXG.Transformations.
     * @returns {Array} A matrix represented by a two dimensional array of numbers.
     * @see JXG.AbstractRenderer#transformImage
     */
    joinTransforms: function(el, transformations) {
      var i2, ox = el.board.origin.scrCoords[1], oy = el.board.origin.scrCoords[2], ux = el.board.unitX, uy = el.board.unitY, len = transformations.length, m = [
        [1, 0, 0],
        [-ox / ux, 1 / ux, 0],
        [oy / uy, 0, -1 / uy]
      ];
      for (i2 = 0; i2 < len; i2++) {
        m = math_default.matMatMult(transformations[i2].matrix, m);
      }
      m = math_default.matMatMult(
        [
          [1, 0, 0],
          [ox, ux, 0],
          [oy, 0, -uy]
        ],
        m
      );
      return m;
    },
    /**
     * Applies transformations on images and text elements. This method has to implemented in
     * all descendant classes where text and image transformations are to be supported.
     * <p>
     * Only affine transformation are supported, no proper projective transformations. This means, the
     * respective entries of the transformation matrix are simply ignored.
     *
     * @param {JXG.Image|JXG.Text} element A {@link JXG.Image} or {@link JXG.Text} object.
     * @param {Array} transformations An array of {@link JXG.Transformation} objects. This is usually the
     * transformations property of the given element <tt>el</tt>.
     */
    transformImage: function(element, transformations) {
    },
    /**
     * If the URL of the image is provided by a function the URL has to be updated during updateImage()
     * @param {JXG.Image} element Reference to an image object.
     * @see JXG.AbstractRenderer#updateImage
     */
    updateImageURL: function(element) {
    },
    /**
     * Updates CSS style properties of a {@link JXG.Image} node.
     * In SVGRenderer opacity is the only available style element.
     * This function is called by highlight() and nohighlight().
     * This function works for VML.
     * It does not work for Canvas.
     * SVGRenderer overwrites this method.
     * @param {JXG.Text} el Reference to the {@link JXG.Image} object, that has to be updated.
     * @param {Boolean} doHighlight
     * @see Image
     * @see JXG.Image
     * @see JXG.AbstractRenderer#highlight
     * @see JXG.AbstractRenderer#noHighlight
     */
    updateImageStyle: function(el, doHighlight) {
      el.rendNode.className = type_default.evaluate(
        doHighlight ? el.visProp.highlightcssclass : el.visProp.cssclass
      );
    },
    drawForeignObject: function(el) {
    },
    updateForeignObject: function(el) {
    },
    /* **************************
     * Render primitive objects
     * **************************/
    /**
     * Appends a node to a specific layer level. This is just an abstract method and has to be implemented
     * in all renderers that want to use the <tt>createPrim</tt> model to draw.
     * @param {Node} node A DOM tree node.
     * @param {Number} level The layer the node is attached to. This is the index of the layer in
     * {@link JXG.SVGRenderer#layer} or the <tt>z-index</tt> style property of the node in VMLRenderer.
     */
    appendChildPrim: function(node2, level) {
    },
    /**
     * Stores the rendering nodes. This is an abstract method which has to be implemented in all renderers that use
     * the <tt>createPrim</tt> method.
     * @param {JXG.GeometryElement} element A JSXGraph element.
     * @param {String} type The XML node name. Only used in VMLRenderer.
     */
    appendNodesToElement: function(element, type) {
    },
    /**
     * Creates a node of a given type with a given id.
     * @param {String} type The type of the node to create.
     * @param {String} id Set the id attribute to this.
     * @returns {Node} Reference to the created node.
     */
    createPrim: function(type, id) {
      return null;
    },
    /**
     * Removes an element node. Just a stub.
     * @param {Node} node The node to remove.
     */
    remove: function(node2) {
    },
    /**
     * Can be used to create the nodes to display arrows. This is an abstract method which has to be implemented
     * in any descendant renderer.
     * @param {JXG.GeometryElement} element The element the arrows are to be attached to.
     * @param {Object} arrowData Data concerning possible arrow heads
     *
     */
    makeArrows: function(element, arrowData) {
    },
    /**
     * Updates width of an arrow DOM node. Used in
     * @param {Node} node The arrow node.
     * @param {Number} width
     * @param {Node} parentNode Used in IE only
     */
    _setArrowWidth: function(node2, width, parentNode) {
    },
    /**
     * Updates an ellipse node primitive. This is an abstract method which has to be implemented in all renderers
     * that use the <tt>createPrim</tt> method.
     * @param {Node} node Reference to the node.
     * @param {Number} x Centre X coordinate
     * @param {Number} y Centre Y coordinate
     * @param {Number} rx The x-axis radius.
     * @param {Number} ry The y-axis radius.
     */
    updateEllipsePrim: function(node2, x, y, rx, ry) {
    },
    /**
     * Refreshes a line node. This is an abstract method which has to be implemented in all renderers that use
     * the <tt>createPrim</tt> method.
     * @param {Node} node The node to be refreshed.
     * @param {Number} p1x The first point's x coordinate.
     * @param {Number} p1y The first point's y coordinate.
     * @param {Number} p2x The second point's x coordinate.
     * @param {Number} p2y The second point's y coordinate.
     * @param {JXG.Board} board
     */
    updateLinePrim: function(node2, p1x, p1y, p2x, p2y, board) {
    },
    /**
     * Updates a path element. This is an abstract method which has to be implemented in all renderers that use
     * the <tt>createPrim</tt> method.
     * @param {Node} node The path node.
     * @param {String} pathString A string formatted like e.g. <em>'M 1,2 L 3,1 L5,5'</em>. The format of the string
     * depends on the rendering engine.
     * @param {JXG.Board} board Reference to the element's board.
     */
    updatePathPrim: function(node2, pathString, board) {
    },
    /**
     * Builds a path data string to draw a point with a face other than <em>rect</em> and <em>circle</em>. Since
     * the format of such a string usually depends on the renderer this method
     * is only an abstract method. Therefore, it has to be implemented in the descendant renderer itself unless
     * the renderer does not use the createPrim interface but the draw* interfaces to paint.
     * @param {JXG.Point} element The point element
     * @param {Number} size A positive number describing the size. Usually the half of the width and height of
     * the drawn point.
     * @param {String} type A string describing the point's face. This method only accepts the shortcut version of
     * each possible face: <tt>x, +, |, -, [], <>, <<>>,^, v, >, < </tt>
     */
    updatePathStringPoint: function(element, size2, type) {
    },
    /**
     * Builds a path data string from a {@link JXG.Curve} element. Since the path data strings heavily depend on the
     * underlying rendering technique this method is just a stub. Although such a path string is of no use for the
     * CanvasRenderer, this method is used there to draw a path directly.
     * @param element
     */
    updatePathStringPrim: function(element) {
    },
    /**
     * Builds a path data string from a {@link JXG.Curve} element such that the curve looks like hand drawn. Since
     * the path data strings heavily depend on the underlying rendering technique this method is just a stub.
     * Although such a path string is of no use for the CanvasRenderer, this method is used there to draw a path
     * directly.
     * @param element
     */
    updatePathStringBezierPrim: function(element) {
    },
    /**
     * Update a polygon primitive.
     * @param {Node} node
     * @param {JXG.Polygon} element A JSXGraph element of type {@link JXG.Polygon}
     */
    updatePolygonPrim: function(node2, element) {
    },
    /**
     * Update a rectangle primitive. This is used only for points with face of type 'rect'.
     * @param {Node} node The node yearning to be updated.
     * @param {Number} x x coordinate of the top left vertex.
     * @param {Number} y y coordinate of the top left vertex.
     * @param {Number} w Width of the rectangle.
     * @param {Number} h The rectangle's height.
     */
    updateRectPrim: function(node2, x, y, w, h) {
    },
    /* **************************
     *  Set Attributes
     * **************************/
    /**
     * Sets a node's attribute.
     * @param {Node} node The node that is to be updated.
     * @param {String} key Name of the attribute.
     * @param {String} val New value for the attribute.
     */
    setPropertyPrim: function(node2, key, val) {
    },
    setTabindex: function(element) {
      var val;
      if (element.board.attr.keyboard.enabled && type_default.exists(element.rendNode)) {
        val = type_default.evaluate(element.visProp.tabindex);
        if (!element.visPropCalc.visible || type_default.evaluate(element.visProp.fixed)) {
          val = null;
        }
        if (val !== element.visPropOld.tabindex) {
          element.rendNode.setAttribute("tabindex", val);
          element.visPropOld.tabindex = val;
        }
      }
    },
    /**
     * Shows or hides an element on the canvas; Only a stub, requires implementation in the derived renderer.
     * @param {JXG.GeometryElement} element Reference to the object that has to appear.
     * @param {Boolean} value true to show the element, false to hide the element.
     */
    display: function(element, value) {
      if (element) {
        element.visPropOld.visible = value;
      }
    },
    /**
     * Shows a hidden element on the canvas; Only a stub, requires implementation in the derived renderer.
     *
     * Please use JXG.AbstractRenderer#display instead
     * @param {JXG.GeometryElement} element Reference to the object that has to appear.
     * @see JXG.AbstractRenderer#hide
     * @deprecated
     */
    show: function(element) {
    },
    /**
     * Hides an element on the canvas; Only a stub, requires implementation in the derived renderer.
     *
     * Please use JXG.AbstractRenderer#display instead
     * @param {JXG.GeometryElement} element Reference to the geometry element that has to disappear.
     * @see JXG.AbstractRenderer#show
     * @deprecated
     */
    hide: function(element) {
    },
    /**
     * Sets the buffering as recommended by SVGWG. Until now only Opera supports this and will be ignored by other
     * browsers. Although this feature is only supported by SVG we have this method in {@link JXG.AbstractRenderer}
     * because it is called from outside the renderer.
     * @param {Node} node The SVG DOM Node which buffering type to update.
     * @param {String} type Either 'auto', 'dynamic', or 'static'. For an explanation see
     *   {@link https://www.w3.org/TR/SVGTiny12/painting.html#BufferedRenderingProperty}.
     */
    setBuffering: function(node2, type) {
    },
    /**
     * Sets an element's dash style.
     * @param {JXG.GeometryElement} element An JSXGraph element.
     */
    setDashStyle: function(element) {
    },
    /**
     * Puts an object into draft mode, i.e. it's visual appearance will be changed. For GEONE<sub>x</sub>T backwards
     * compatibility.
     * @param {JXG.GeometryElement} el Reference of the object that is in draft mode.
     */
    setDraft: function(el) {
      if (!type_default.evaluate(el.visProp.draft)) {
        return;
      }
      var draftColor = el.board.options.elements.draft.color, draftOpacity = el.board.options.elements.draft.opacity;
      this.setObjectViewport(el);
      this.setObjectTransition(el);
      if (el.type === constants_default.OBJECT_TYPE_POLYGON) {
        this.setObjectFillColor(el, draftColor, draftOpacity);
      } else {
        if (el.elementClass === constants_default.OBJECT_CLASS_POINT) {
          this.setObjectFillColor(el, draftColor, draftOpacity);
        } else {
          this.setObjectFillColor(el, "none", 0);
        }
        this.setObjectStrokeColor(el, draftColor, draftOpacity);
        this.setObjectStrokeWidth(el, el.board.options.elements.draft.strokeWidth);
      }
    },
    /**
     * Puts an object from draft mode back into normal mode.
     * @param {JXG.GeometryElement} el Reference of the object that no longer is in draft mode.
     */
    removeDraft: function(el) {
      this.setObjectViewport(el);
      this.setObjectTransition(el);
      if (el.type === constants_default.OBJECT_TYPE_POLYGON) {
        this.setObjectFillColor(el, el.visProp.fillcolor, el.visProp.fillopacity);
      } else {
        if (el.type === constants_default.OBJECT_CLASS_POINT) {
          this.setObjectFillColor(el, el.visProp.fillcolor, el.visProp.fillopacity);
        }
        this.setObjectStrokeColor(el, el.visProp.strokecolor, el.visProp.strokeopacity);
        this.setObjectStrokeWidth(el, el.visProp.strokewidth);
      }
    },
    /**
     * Sets up nodes for rendering a gradient fill.
     * @param element
     */
    setGradient: function(element) {
    },
    /**
     * Updates the gradient fill.
     * @param {JXG.GeometryElement} element An JSXGraph element with an area that can be filled.
     */
    updateGradient: function(element) {
    },
    /**
     * Sets the transition duration (in milliseconds) for fill color and stroke
     * color and opacity.
     * @param {JXG.GeometryElement} element Reference of the object that wants a
     *         new transition duration.
     * @param {Number} duration (Optional) duration in milliseconds. If not given,
     *        element.visProp.transitionDuration is taken. This is the default.
     */
    setObjectTransition: function(element, duration) {
    },
    /**
     *
     * @param {*} element
     * @param {*} isHTML
     */
    setObjectViewport: function(element, isHTML) {
    },
    /**
     * Sets an objects fill color.
     * @param {JXG.GeometryElement} element Reference of the object that wants a new fill color.
     * @param {String} color Color in a HTML/CSS compatible format. If you don't want any fill color at all, choose
     * 'none'.
     * @param {Number} opacity Opacity of the fill color. Must be between 0 and 1.
     */
    setObjectFillColor: function(element, color2, opacity) {
    },
    /**
     * Changes an objects stroke color to the given color.
     * @param {JXG.GeometryElement} element Reference of the {@link JXG.GeometryElement} that gets a new stroke
     * color.
     * @param {String} color Color value in a HTML compatible format, e.g. <strong>#00ff00</strong> or
     * <strong>green</strong> for green.
     * @param {Number} opacity Opacity of the fill color. Must be between 0 and 1.
     */
    setObjectStrokeColor: function(element, color2, opacity) {
    },
    /**
     * Sets an element's stroke width.
     * @param {JXG.GeometryElement} element Reference to the geometry element.
     * @param {Number} width The new stroke width to be assigned to the element.
     */
    setObjectStrokeWidth: function(element, width) {
    },
    /**
     * Sets the shadow properties to a geometry element. This method is only a stub, it is implemented in the actual
     * renderers.
     * @param {JXG.GeometryElement} element Reference to a geometry object, that should get a shadow
     */
    setShadow: function(element) {
    },
    /**
     * Highlights an object, i.e. changes the current colors of the object to its highlighting colors
     * and highlighting strokewidth.
     * @param {JXG.GeometryElement} el Reference of the object that will be highlighted.
     * @param {Boolean} [suppressHighlightStrokeWidth=undefined] If undefined or false, highlighting also changes strokeWidth. This might not be
     * the cases for polygon borders. Thus, if a polygon is highlighted, its polygon borders change strokeWidth only if the polygon attribute
     * highlightByStrokeWidth == true.
     * @returns {JXG.AbstractRenderer} Reference to the renderer
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    highlight: function(el, suppressHighlightStrokeWidth) {
      var i2, do_hl, ev = el.visProp, sw;
      this.setObjectViewport(el);
      this.setObjectTransition(el);
      if (!ev.draft) {
        if (el.type === constants_default.OBJECT_TYPE_POLYGON) {
          this.setObjectFillColor(el, ev.highlightfillcolor, ev.highlightfillopacity);
          do_hl = type_default.evaluate(ev.highlightbystrokewidth);
          for (i2 = 0; i2 < el.borders.length; i2++) {
            this.highlight(el.borders[i2], !do_hl);
          }
        } else {
          if (el.elementClass === constants_default.OBJECT_CLASS_TEXT) {
            this.updateTextStyle(el, true);
          } else if (el.type === constants_default.OBJECT_TYPE_IMAGE) {
            this.updateImageStyle(el, true);
            this.setObjectFillColor(
              el,
              ev.highlightfillcolor,
              ev.highlightfillopacity
            );
          } else {
            this.setObjectStrokeColor(
              el,
              ev.highlightstrokecolor,
              ev.highlightstrokeopacity
            );
            this.setObjectFillColor(
              el,
              ev.highlightfillcolor,
              ev.highlightfillopacity
            );
          }
        }
        if (ev.highlightstrokewidth && !suppressHighlightStrokeWidth) {
          sw = Math.max(
            type_default.evaluate(ev.highlightstrokewidth),
            type_default.evaluate(ev.strokewidth)
          );
          this.setObjectStrokeWidth(el, sw);
          if (el.elementClass === constants_default.OBJECT_CLASS_LINE || el.elementClass === constants_default.OBJECT_CLASS_CURVE) {
            this.updatePathWithArrowHeads(el, true);
          }
        }
      }
      return this;
    },
    /**
     * Uses the normal colors of an object, i.e. the opposite of {@link JXG.AbstractRenderer#highlight}.
     * @param {JXG.GeometryElement} el Reference of the object that will get its normal colors.
     * @returns {JXG.AbstractRenderer} Reference to the renderer
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    noHighlight: function(el) {
      var i2, ev = el.visProp, sw;
      this.setObjectViewport(el);
      this.setObjectTransition(el);
      if (!type_default.evaluate(el.visProp.draft)) {
        if (el.type === constants_default.OBJECT_TYPE_POLYGON) {
          this.setObjectFillColor(el, ev.fillcolor, ev.fillopacity);
          for (i2 = 0; i2 < el.borders.length; i2++) {
            this.noHighlight(el.borders[i2]);
          }
        } else {
          if (el.elementClass === constants_default.OBJECT_CLASS_TEXT) {
            this.updateTextStyle(el, false);
          } else if (el.type === constants_default.OBJECT_TYPE_IMAGE) {
            this.updateImageStyle(el, false);
            this.setObjectFillColor(el, ev.fillcolor, ev.fillopacity);
          } else {
            this.setObjectStrokeColor(el, ev.strokecolor, ev.strokeopacity);
            this.setObjectFillColor(el, ev.fillcolor, ev.fillopacity);
          }
        }
        sw = type_default.evaluate(ev.strokewidth);
        this.setObjectStrokeWidth(el, sw);
        if (el.elementClass === constants_default.OBJECT_CLASS_LINE || el.elementClass === constants_default.OBJECT_CLASS_CURVE) {
          this.updatePathWithArrowHeads(el, false);
        }
      }
      return this;
    },
    /* **************************
     * renderer control
     * **************************/
    /**
     * Stop redraw. This method is called before every update, so a non-vector-graphics based renderer can use this
     * method to delete the contents of the drawing panel. This is an abstract method every descendant renderer
     * should implement, if appropriate.
     * @see JXG.AbstractRenderer#unsuspendRedraw
     */
    suspendRedraw: function() {
    },
    /**
     * Restart redraw. This method is called after updating all the rendering node attributes.
     * @see JXG.AbstractRenderer#suspendRedraw
     */
    unsuspendRedraw: function() {
    },
    /**
     * The tiny zoom bar shown on the bottom of a board (if board attribute "showNavigation" is true).
     * It is a div element and gets the CSS class "JXG_navigation" and the id {board id}_navigationbar.
     * <p>
     * The buttons get the CSS class "JXG_navigation_button" and the id {board_id}_name where name is
     * one of [top, down, left, right, out, 100, in, fullscreen, screenshot, reload, cleartraces].
     * <p>
     * The symbols for zoom, navigation and reload are hard-coded.
     *
     * @param {JXG.Board} board Reference to a JSXGraph board.
     * @param {Object} attr Attributes of the navigation bar
     * @private
     */
    drawNavigationBar: function(board, attr) {
      var doc, node2, cancelbubble = function(e) {
        if (!e) {
          e = window.event;
        }
        if (e.stopPropagation) {
          e.stopPropagation();
        } else {
          e.cancelBubble = true;
        }
      }, createButton = function(label, handler, board_id, type) {
        var button;
        board_id = board_id || "";
        button = doc.createElement("span");
        button.innerHTML = label;
        button.style.paddingLeft = "7px";
        button.style.paddingRight = "7px";
        if (button.classList !== void 0) {
          button.classList.add("JXG_navigation_button");
          button.classList.add("JXG_navigation_button_" + type);
        }
        button.setAttribute("id", board_id + "_navigation_" + type);
        node2.appendChild(button);
        env_default.addEvent(
          button,
          "click",
          function(e) {
            type_default.bind(handler, board)();
            return false;
          },
          board
        );
        env_default.addEvent(button, "pointerup", cancelbubble, board);
        env_default.addEvent(button, "pointerdown", cancelbubble, board);
        env_default.addEvent(button, "pointerleave", cancelbubble, board);
        env_default.addEvent(button, "mouseup", cancelbubble, board);
        env_default.addEvent(button, "mousedown", cancelbubble, board);
        env_default.addEvent(button, "touchend", cancelbubble, board);
        env_default.addEvent(button, "touchstart", cancelbubble, board);
      };
      if (env_default.isBrowser && this.type !== "no") {
        doc = board.containerObj.ownerDocument;
        node2 = doc.createElement("div");
        node2.setAttribute("id", board.container + "_navigationbar");
        node2.style.color = attr.strokecolor;
        node2.style.backgroundColor = attr.fillcolor;
        node2.style.padding = attr.padding;
        node2.style.position = attr.position;
        node2.style.fontSize = attr.fontsize;
        node2.style.cursor = attr.cursor;
        node2.style.zIndex = attr.zindex;
        board.containerObj.appendChild(node2);
        node2.style.right = attr.right;
        node2.style.bottom = attr.bottom;
        if (node2.classList !== void 0) {
          node2.classList.add("JXG_navigation");
        }
        if (board.attr.showfullscreen) {
          createButton(
            board.attr.fullscreen.symbol,
            function() {
              board.toFullscreen(board.attr.fullscreen.id);
            },
            board.container,
            "fullscreen"
          );
        }
        if (board.attr.showscreenshot) {
          createButton(
            board.attr.screenshot.symbol,
            function() {
              window.setTimeout(function() {
                board.renderer.screenshot(board, "", false);
              }, 330);
            },
            board.container,
            "screenshot"
          );
        }
        if (board.attr.showreload) {
          createButton(
            "\u21BB",
            function() {
              board.reload();
            },
            board.container,
            "reload"
          );
        }
        if (board.attr.showcleartraces) {
          createButton(
            "\u2297",
            function() {
              board.clearTraces();
            },
            board.container,
            "cleartraces"
          );
        }
        if (board.attr.shownavigation) {
          if (board.attr.showzoom) {
            createButton("\u2013", board.zoomOut, board.container, "out");
            createButton("o", board.zoom100, board.container, "100");
            createButton("+", board.zoomIn, board.container, "in");
          }
          createButton("\u2190", board.clickLeftArrow, board.container, "left");
          createButton("\u2193", board.clickUpArrow, board.container, "down");
          createButton("\u2191", board.clickDownArrow, board.container, "up");
          createButton("\u2192", board.clickRightArrow, board.container, "right");
        }
      }
    },
    /**
     * Wrapper for getElementById for maybe other renderers which elements are not directly accessible by DOM
     * methods like document.getElementById().
     * @param {String} id Unique identifier for element.
     * @returns {Object} Reference to a JavaScript object. In case of SVG/VMLRenderer it's a reference to a SVG/VML node.
     */
    getElementById: function(id) {
      var str2;
      if (type_default.exists(this.container)) {
        str2 = this.container.id + "_" + id;
        if (type_default.exists(CSS) && type_default.exists(CSS.escape)) {
          str2 = CSS.escape(str2);
        }
        return this.container.querySelector("#" + str2);
      }
      return "";
    },
    /**
     * Remove an element and provide a function that inserts it into its original position. This method
     * is taken from this article {@link https://developers.google.com/speed/articles/javascript-dom}.
     * @author KeeKim Heng, Google Web Developer
     * @param {Element} el The element to be temporarily removed
     * @returns {Function} A function that inserts the element into its original position
     */
    removeToInsertLater: function(el) {
      var parentNode = el.parentNode, nextSibling = el.nextSibling;
      if (parentNode === null) {
        return;
      }
      parentNode.removeChild(el);
      return function() {
        if (nextSibling) {
          parentNode.insertBefore(el, nextSibling);
        } else {
          parentNode.appendChild(el);
        }
      };
    },
    /**
     * Resizes the rendering element
     * @param {Number} w New width
     * @param {Number} h New height
     */
    resize: function(w, h) {
    },
    /**
     * Create crosshair elements (Fadenkreuz) for presentations.
     * @param {Number} n Number of crosshairs.
     */
    createTouchpoints: function(n) {
    },
    /**
     * Show a specific crosshair.
     * @param {Number} i Number of the crosshair to show
     */
    showTouchpoint: function(i2) {
    },
    /**
     * Hide a specific crosshair.
     * @param {Number} i Number of the crosshair to show
     */
    hideTouchpoint: function(i2) {
    },
    /**
     * Move a specific crosshair.
     * @param {Number} i Number of the crosshair to show
     * @param {Array} pos New positon in screen coordinates
     */
    updateTouchpoint: function(i2, pos) {
    },
    /**
     * Convert SVG construction to base64 encoded SVG data URL.
     * Only available on SVGRenderer.
     *
     * @see JXG.SVGRenderer#dumpToDataURI
     */
    dumpToDataURI: function(_ignoreTexts) {
    },
    /**
     * Convert SVG construction to canvas.
     * Only available on SVGRenderer.
     *
     * @see JXG.SVGRenderer#dumpToCanvas
     */
    dumpToCanvas: function(canvasId, w, h, _ignoreTexts) {
    },
    /**
     * Display SVG image in html img-tag which enables
     * easy download for the user.
     *
     * See JXG.SVGRenderer#screenshot
     */
    screenshot: function(board) {
    },
    /**
     * Move element into new layer. This is trivial for canvas, but needs more effort in SVG.
     * Does not work dynamically, i.e. if level is a function.
     *
     * @param {JXG.GeometryElement} el Element which is put into different layer
     * @param {Number} value Layer number
     * @private
     */
    setLayer: function(el, level) {
    }
  }
);
var abstract_default = jxg_default.AbstractRenderer;

// node_modules/jsxgraph/src/reader/file.js
jxg_default.FileReader = {
  /**
   *
   * @param {String} url
   * @param {JXG.Board} board
   * @param {String} format
   * @param {Boolean} async
   * @param {Function} callback
   *
   * @private
   */
  handleRemoteFile: function(url, board, format, async, encoding, callback) {
    var request = false;
    try {
      request = new XMLHttpRequest();
      if (format.toLowerCase() === "raw") {
        request.overrideMimeType("text/plain; charset=" + encoding);
      } else {
        request.overrideMimeType("text/xml; charset=" + encoding);
      }
    } catch (e) {
      try {
        request = new ActiveXObject("Msxml2.XMLHTTP");
      } catch (ex) {
        try {
          request = new ActiveXObject("Microsoft.XMLHTTP");
        } catch (exc) {
          request = false;
        }
      }
    }
    if (!request) {
      jxg_default.debug("AJAX not activated!");
      return;
    }
    request.open("GET", url, async);
    if (format.toLowerCase() === "raw") {
      this.cbp = function() {
        var req = request;
        if (req.readyState === 4) {
          board(req.responseText);
        }
      };
    } else {
      this.cbp = function() {
        var req = request, text = "";
        if (req.readyState === 4) {
          if (type_default.exists(req.responseStream) && // PK: zip, geogebra
          // 31: gzip, cinderella
          (req.responseText.slice(0, 2) === "PK" || encoding_default.asciiCharCodeAt(req.responseText.slice(0, 1), 0) === 31)) {
            text = base64_default.decode(jxgBinFileReader(req));
          } else {
            text = req.responseText;
          }
          this.parseString(text, board, format, callback);
        }
      };
    }
    this.cb = type_default.bind(this.cbp, this);
    request.onreadystatechange = this.cb;
    try {
      request.send(null);
    } catch (ex2) {
      throw new Error(
        "JSXGraph: A problem occurred while trying to read remote file '" + url + "'."
      );
    }
  },
  /**
   *
   * @param {Blob} url The Blob or File from which to read
   * @param {JXG.Board} board
   * @param {String} format
   * @param {Boolean} async
   * @param {Function} callback
   *
   * @private
   */
  handleLocalFile: function(url, board, format, async, encoding, callback) {
    if (!type_default.exists(async)) {
      async = true;
    }
    if (format.toLowerCase() === "raw") {
      this.cbp = function(e) {
        board(e.target.result);
      };
    } else {
      this.cbp = function(e) {
        var text = e.target.result;
        this.parseString(text, board, format, callback);
      };
    }
    this.cb = type_default.bind(this.cbp, this);
    var reader = new FileReader();
    reader.onload = this.cb;
    if (format.toLowerCase() === "raw") {
      reader.readAsText(url);
    } else {
      reader.readAsText(url, encoding);
    }
  },
  /**
   * Opens a file using the given URL and passes the contents to {@link JXG.FileReader#parseString}
   * @param {String} url
   * @param {JXG.Board|function} board Either a board or in case <tt>format</tt> equals 'raw' this has to be a callback function.
   * @param {String} format The expected file format. Possible values are <dl>
   * <dt>raw</dt><dd>Raw text file. In this case <tt>board</tt> has to be a callback function.</dd>
   * <dt>geonext</dt><dd>Geonext File <a href="https://www.geonext.de">https://www.geonext.de</a></dd>
   * <dt>intergeo</dt><dd>Intergeo file format <a href="https://www.i2geo.net">https://www.i2geo.net</a></dd>
   * <dt>tracenpoche</dt><dd>Tracenpoche construction <a href="https://tracenpoche.sesamath.net/">https://tracenpoche.sesamath.net/</a></dd>
   * <dt>graph</dt><dd>Graph file</dd>
   * <dt>digraph</dt><dd>DiGraph file</dd>
   * <dt>geogebra</dt><dd>Geogebra File <a href="https://www.geogebra.org">https://www.geogebra.org</a></dd>
   * <dl><dt>cdy or cinderella</dt><dd>Cinderella (<a href="https://www.cinderella.de/">https://www.cinderella.de</a></dd>
   * </dl>
   * @param {Boolean} async Call ajax asynchonously.
   * @param {function} callback A function that is run when the board is ready.
   */
  parseFileContent: function(url, board, format, async, encoding, callback) {
    if (type_default.isString(url) || FileReader === void 0) {
      this.handleRemoteFile(url, board, format, async, encoding, callback);
    } else {
      this.handleLocalFile(url, board, format, async, encoding, callback);
    }
  },
  /**
   * Parses a given string according to the file format given in format.
   * @param {String} str Contents of the file.
   * @param {JXG.Board} board The board the construction in the file should be loaded in.
   * @param {String} format Possible values are <dl>
   * <dt>raw</dt><dd>Raw text file. In this case <tt>board</tt> has to be a callback function.</dd>
   * <dt>geonext</dt><dd>Geonext File <a href="https://www.geonext.de">https://www.geonext.de</a></dd>
   * <dt>intergeo</dt><dd>Intergeo file format <a href="https://www.i2geo.net">https://www.i2geo.net</a></dd>
   * <dt>tracenpoche</dt><dd>Tracenpoche construction <a href="https://tracenpoche.sesamath.net/">https://tracenpoche.sesamath.net/</a></dd>
   * <dt>graph</dt><dd>Graph file</dd>
   * <dt>digraph</dt><dd>DiGraph file</dd>
   * <dt>geogebra</dt><dd>Geogebra File <a href="https://www.geogebra.org">https://www.geogebra.org</a></dd>
   * <dl><dt>cdy or cinderella</dt><dd>Cinderella (<a href="https://www.cinderella.de/">https://www.cinderella.de</a></dd>
   * </dl>
   * @param {function} callback
   */
  parseString: function(str2, board, format, callback) {
    var Reader, read;
    format = format.toLowerCase();
    Reader = jxg_default.readers[format];
    if (type_default.exists(Reader)) {
      read = new Reader(board, str2);
      read.read();
    } else if (format === "jessiecode") {
    } else {
      throw new Error("JSXGraph: There is no reader available for '" + format + "'.");
    }
    if (type_default.isFunction(callback)) {
      callback(board);
    }
  }
};
if (!env_default.isMetroApp() && env_default.isBrowser && typeof navigator === "object" && /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) && document && document.write) {
  document.write(
    `<script type="text/vbscript">
Function Base64Encode(inData)
  Const Base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  Dim cOut, sOut, I
  For I = 1 To LenB(inData) Step 3
    Dim nGroup, pOut, sGroup
    nGroup = &H10000 * AscB(MidB(inData, I, 1)) + _
      &H100 * MyASC(MidB(inData, I + 1, 1)) + MyASC(MidB(inData, I + 2, 1))
    nGroup = Oct(nGroup)
    nGroup = String(8 - Len(nGroup), "0") & nGroup
    pOut = Mid(Base64, CLng("&o" & Mid(nGroup, 1, 2)) + 1, 1) + _
      Mid(Base64, CLng("&o" & Mid(nGroup, 3, 2)) + 1, 1) + _
      Mid(Base64, CLng("&o" & Mid(nGroup, 5, 2)) + 1, 1) + _
      Mid(Base64, CLng("&o" & Mid(nGroup, 7, 2)) + 1, 1)
    sOut = sOut + pOut
  Next
  Select Case LenB(inData) Mod 3
    Case 1: '8 bit final
      sOut = Left(sOut, Len(sOut) - 2) + "=="
    Case 2: '16 bit final
      sOut = Left(sOut, Len(sOut) - 1) + "="
  End Select
  Base64Encode = sOut
End Function

Function MyASC(OneChar)
  If OneChar = "" Then MyASC = 0 Else MyASC = AscB(OneChar)
End Function

Function jxgBinFileReader(xhr)
    Dim byteString
    Dim b64String
    Dim i
    byteString = xhr.responseBody
    ReDim byteArray(LenB(byteString))
    For i = 1 To LenB(byteString)
        byteArray(i-1) = AscB(MidB(byteString, i, 1))
    Next
    b64String = Base64Encode(byteString)
    jxgBinFileReader = b64String
End Function
<\/script>
`
  );
}
var file_default = jxg_default.FileReader;

// node_modules/jsxgraph/src/parser/geonext.js
jxg_default.GeonextParser = {
  /**
   * Converts expression of the form <i>leftop^rightop</i> into <i>Math.pow(leftop,rightop)</i>.
   * @param {String} te Expression of the form <i>leftop^rightop</i>
   * @returns {String} Converted expression.
   */
  replacePow: function(te) {
    var count, pos, c, previousIndex, leftop, rightop, pre, p, left, i2, right, expr;
    te = te.replace(/(\s*)\^(\s*)/g, "^");
    i2 = te.indexOf("^");
    previousIndex = -1;
    while (i2 >= 0 && i2 < te.length - 1) {
      if (previousIndex === i2) {
        throw new Error("JSXGraph: Error while parsing expression '" + te + "'");
      }
      previousIndex = i2;
      left = te.slice(0, i2);
      right = te.slice(i2 + 1);
      if (left.charAt(left.length - 1) === ")") {
        count = 1;
        pos = left.length - 2;
        while (pos >= 0 && count > 0) {
          c = left.charAt(pos);
          if (c === ")") {
            count++;
          } else if (c === "(") {
            count -= 1;
          }
          pos -= 1;
        }
        if (count === 0) {
          leftop = "";
          pre = left.substring(0, pos + 1);
          p = pos;
          while (p >= 0 && pre.slice(p, p + 1).match(/([\w.]+)/)) {
            leftop = RegExp.$1 + leftop;
            p -= 1;
          }
          leftop += left.substring(pos + 1, left.length);
          leftop = leftop.replace(/([()+*%^\-/\][])/g, "\\$1");
        } else {
          throw new Error("JSXGraph: Missing '(' in expression");
        }
      } else {
        leftop = "[\\w\\.]+";
      }
      if (right.match(/^([\w.]*\()/)) {
        count = 1;
        pos = RegExp.$1.length;
        while (pos < right.length && count > 0) {
          c = right.charAt(pos);
          if (c === ")") {
            count -= 1;
          } else if (c === "(") {
            count += 1;
          }
          pos += 1;
        }
        if (count === 0) {
          rightop = right.substring(0, pos);
          rightop = rightop.replace(/([()+*%^\-/[\]])/g, "\\$1");
        } else {
          throw new Error("JSXGraph: Missing ')' in expression");
        }
      } else {
        rightop = "[\\w\\.]+";
      }
      expr = new RegExp("(" + leftop + ")\\^(" + rightop + ")");
      te = te.replace(expr, "pow($1,$2)");
      i2 = te.indexOf("^");
    }
    return te;
  },
  /**
   * Converts expression of the form <i>If(a,b,c)</i> into <i>(a)?(b):(c)/i>.
   * @param {String} te Expression of the form <i>If(a,b,c)</i>
   * @returns {String} Converted expression.
   */
  replaceIf: function(te) {
    var left, right, i2, pos, count, k1, k2, c, meat, s = "", first = null, second = null, third = null;
    i2 = te.indexOf("If(");
    if (i2 < 0) {
      return te;
    }
    te = te.replace(/""/g, "0");
    while (i2 >= 0) {
      left = te.slice(0, i2);
      right = te.slice(i2 + 3);
      count = 1;
      pos = 0;
      k1 = -1;
      k2 = -1;
      while (pos < right.length && count > 0) {
        c = right.charAt(pos);
        if (c === ")") {
          count -= 1;
        } else if (c === "(") {
          count += 1;
        } else if (c === "," && count === 1) {
          if (k1 < 0) {
            k1 = pos;
          } else {
            k2 = pos;
          }
        }
        pos += 1;
      }
      meat = right.slice(0, pos - 1);
      right = right.slice(pos);
      if (k1 < 0) {
        return "";
      }
      if (k2 < 0) {
        return "";
      }
      first = meat.slice(0, k1);
      second = meat.slice(k1 + 1, k2);
      third = meat.slice(k2 + 1);
      first = this.replaceIf(first);
      second = this.replaceIf(second);
      third = this.replaceIf(third);
      s += left + "((" + first + ")?(" + second + "):(" + third + "))";
      te = right;
      first = null;
      second = null;
      i2 = te.indexOf("If(");
    }
    s += right;
    return s;
  },
  /**
   * Replace an element's name in terms by an element's id.
   * @param {String} term Term containing names of elements.
   * @param {JXG.Board} board Reference to the board the elements are on.
   * @param {Boolean} [jc=false] If true, all id's will be surrounded by <tt>$('</tt> and <tt>')</tt>.
   * @returns {String} The same string with names replaced by ids.
   **/
  replaceNameById: function(term, board, jc2) {
    var end, elName, el, i2, pos = 0, funcs = ["X", "Y", "L", "V"], printId = function(id) {
      if (jc2) {
        return "$('" + id + "')";
      }
      return id;
    };
    for (i2 = 0; i2 < funcs.length; i2++) {
      pos = term.indexOf(funcs[i2] + "(");
      while (pos >= 0) {
        if (pos >= 0) {
          end = term.indexOf(")", pos + 2);
          if (end >= 0) {
            elName = term.slice(pos + 2, end);
            elName = elName.replace(/\\(['"])?/g, "$1");
            el = board.elementsByName[elName];
            if (el) {
              term = term.slice(0, pos + 2) + (jc2 ? "$('" : "") + printId(el.id) + term.slice(end);
            }
          }
        }
        end = term.indexOf(")", pos + 2);
        pos = term.indexOf(funcs[i2] + "(", end);
      }
    }
    pos = term.indexOf("Dist(");
    while (pos >= 0) {
      if (pos >= 0) {
        end = term.indexOf(",", pos + 5);
        if (end >= 0) {
          elName = term.slice(pos + 5, end);
          elName = elName.replace(/\\(['"])?/g, "$1");
          el = board.elementsByName[elName];
          if (el) {
            term = term.slice(0, pos + 5) + printId(el.id) + term.slice(end);
          }
        }
      }
      end = term.indexOf(",", pos + 5);
      pos = term.indexOf(",", end);
      end = term.indexOf(")", pos + 1);
      if (end >= 0) {
        elName = term.slice(pos + 1, end);
        elName = elName.replace(/\\(['"])?/g, "$1");
        el = board.elementsByName[elName];
        if (el) {
          term = term.slice(0, pos + 1) + printId(el.id) + term.slice(end);
        }
      }
      end = term.indexOf(")", pos + 1);
      pos = term.indexOf("Dist(", end);
    }
    funcs = ["Deg", "Rad"];
    for (i2 = 0; i2 < funcs.length; i2++) {
      pos = term.indexOf(funcs[i2] + "(");
      while (pos >= 0) {
        if (pos >= 0) {
          end = term.indexOf(",", pos + 4);
          if (end >= 0) {
            elName = term.slice(pos + 4, end);
            elName = elName.replace(/\\(['"])?/g, "$1");
            el = board.elementsByName[elName];
            if (el) {
              term = term.slice(0, pos + 4) + printId(el.id) + term.slice(end);
            }
          }
        }
        end = term.indexOf(",", pos + 4);
        pos = term.indexOf(",", end);
        end = term.indexOf(",", pos + 1);
        if (end >= 0) {
          elName = term.slice(pos + 1, end);
          elName = elName.replace(/\\(['"])?/g, "$1");
          el = board.elementsByName[elName];
          if (el) {
            term = term.slice(0, pos + 1) + printId(el.id) + term.slice(end);
          }
        }
        end = term.indexOf(",", pos + 1);
        pos = term.indexOf(",", end);
        end = term.indexOf(")", pos + 1);
        if (end >= 0) {
          elName = term.slice(pos + 1, end);
          elName = elName.replace(/\\(['"])?/g, "$1");
          el = board.elementsByName[elName];
          if (el) {
            term = term.slice(0, pos + 1) + printId(el.id) + term.slice(end);
          }
        }
        end = term.indexOf(")", pos + 1);
        pos = term.indexOf(funcs[i2] + "(", end);
      }
    }
    return term;
  },
  /**
   * Replaces element ids in terms by element this.board.objects['id'].
   * @param {String} term A GEONE<sub>x</sub>T function string with JSXGraph ids in it.
   * @returns {String} The input string with element ids replaced by this.board.objects["id"].
   **/
  replaceIdByObj: function(term) {
    var expr = /(X|Y|L)\(([\w_]+)\)/g;
    term = term.replace(expr, "$('$2').$1()");
    expr = /(V)\(([\w_]+)\)/g;
    term = term.replace(expr, "$('$2').Value()");
    expr = /(Dist)\(([\w_]+),([\w_]+)\)/g;
    term = term.replace(expr, "dist($('$2'), $('$3'))");
    expr = /(Deg)\(([\w_]+),([ \w[\w_]+),([\w_]+)\)/g;
    term = term.replace(expr, "deg($('$2'),$('$3'),$('$4'))");
    expr = /Rad\(([\w_]+),([\w_]+),([\w_]+)\)/g;
    term = term.replace(expr, "rad($('$1'),$('$2'),$('$3'))");
    expr = /N\((.+)\)/g;
    term = term.replace(expr, "($1)");
    return term;
  },
  /**
   * Converts the given algebraic expression in GEONE<sub>x</sub>T syntax into an equivalent expression in JavaScript syntax.
   * @param {String} term Expression in GEONExT syntax
   * @param {JXG.Board} board
   * @returns {String} Given expression translated to JavaScript.
   */
  geonext2JS: function(term, board) {
    var expr, newterm, i2, from = [
      "Abs",
      "ACos",
      "ASin",
      "ATan",
      "Ceil",
      "Cos",
      "Exp",
      "Factorial",
      "Floor",
      "Log",
      "Max",
      "Min",
      "Random",
      "Round",
      "Sin",
      "Sqrt",
      "Tan",
      "Trunc"
    ], to = [
      "abs",
      "acos",
      "asin",
      "atan",
      "ceil",
      "cos",
      "exp",
      "factorial",
      "floor",
      "log",
      "max",
      "min",
      "random",
      "round",
      "sin",
      "sqrt",
      "tan",
      "ceil"
    ];
    term = term.replace(/&lt;/g, "<");
    term = term.replace(/&gt;/g, ">");
    term = term.replace(/&amp;/g, "&");
    newterm = term;
    newterm = this.replaceNameById(newterm, board);
    newterm = this.replaceIf(newterm);
    newterm = this.replacePow(newterm);
    newterm = this.replaceIdByObj(newterm);
    for (i2 = 0; i2 < from.length; i2++) {
      expr = new RegExp(["(\\W|^)(", from[i2], ")"].join(""), "ig");
      newterm = newterm.replace(expr, ["$1", to[i2]].join(""));
    }
    newterm = newterm.replace(/True/g, "true");
    newterm = newterm.replace(/False/g, "false");
    newterm = newterm.replace(/fasle/g, "false");
    newterm = newterm.replace(/Pi/g, "PI");
    newterm = newterm.replace(/"/g, "'");
    return newterm;
  },
  /**
   * Finds dependencies in a given term and resolves them by adding the
   * dependent object to the found objects child elements.
   * @param {JXG.GeometryElement} me Object depending on objects in given term.
   * @param {String} term String containing dependencies for the given object.
   * @param {JXG.Board} [board=me.board] Reference to a board
   */
  findDependencies: function(me, term, board) {
    var elements2, el, expr, elmask;
    if (!type_default.exists(board)) {
      board = me.board;
    }
    elements2 = board.elementsByName;
    for (el in elements2) {
      if (elements2.hasOwnProperty(el)) {
        if (el !== me.name) {
          if (elements2[el].elementClass === constants_default.OBJECT_CLASS_TEXT) {
            if (!type_default.evaluate(elements2[el].visProp.islabel)) {
              elmask = el.replace(/\[/g, "\\[");
              elmask = elmask.replace(/\]/g, "\\]");
              expr = new RegExp(
                "\\(([\\w\\[\\]'_ ]+,)*(" + elmask + ")(,[\\w\\[\\]'_ ]+)*\\)",
                "g"
              );
              if (term.search(expr) >= 0) {
                elements2[el].addChild(me);
              }
            }
          } else {
            elmask = el.replace(/\[/g, "\\[");
            elmask = elmask.replace(/\]/g, "\\]");
            expr = new RegExp(
              "\\(([\\w\\[\\]'_ ]+,)*(" + elmask + ")(,[\\w\\[\\]'_ ]+)*\\)",
              "g"
            );
            if (term.search(expr) >= 0) {
              elements2[el].addChild(me);
            }
          }
        }
      }
    }
  },
  /**
   * Converts the given algebraic expression in GEONE<sub>x</sub>T syntax into an equivalent expression in JessieCode syntax.
   * @param {String} term Expression in GEONExT syntax
   * @param {JXG.Board} board
   * @returns {String} Given expression translated to JavaScript.
   */
  gxt2jc: function(term, board) {
    var newterm;
    term = term.replace(/&lt;/g, "<");
    term = term.replace(/&gt;/g, ">");
    term = term.replace(/&amp;/g, "&");
    newterm = term;
    newterm = this.replaceNameById(newterm, board, true);
    newterm = newterm.replace(/True/g, "true");
    newterm = newterm.replace(/False/g, "false");
    newterm = newterm.replace(/fasle/g, "false");
    return newterm;
  }
};
var geonext_default = jxg_default.GeonextParser;

// node_modules/jsxgraph/src/base/element.js
jxg_default.GeometryElement = function(board, attributes, type, oclass) {
  var name, key, attr;
  this.needsUpdate = true;
  this.isDraggable = false;
  this.isReal = true;
  this.childElements = {};
  this.hasLabel = false;
  this.highlighted = false;
  this.notExistingParents = {};
  this.traces = {};
  this.numTraces = 0;
  this.transformations = [];
  this.baseElement = null;
  this.descendants = {};
  this.ancestors = {};
  this.parents = [];
  this.symbolic = {};
  this.rendNode = null;
  this.elType = "";
  this.dump = true;
  this.subs = {};
  this.inherits = [];
  this._pos = -1;
  this.stdform = [1, 0, 0, 0, 1, 1, 0, 0];
  this.methodMap = {
    setLabel: "setLabel",
    label: "label",
    setName: "setName",
    getName: "getName",
    Name: "getName",
    addTransform: "addTransform",
    setProperty: "setAttribute",
    setAttribute: "setAttribute",
    addChild: "addChild",
    animate: "animate",
    on: "on",
    off: "off",
    trigger: "trigger",
    addTicks: "addTicks",
    removeTicks: "removeTicks",
    removeAllTicks: "removeAllTicks",
    Bounds: "bounds"
  };
  this.quadraticform = [
    [1, 0, 0],
    [0, 1, 0],
    [0, 0, 1]
  ];
  this.visProp = {};
  this.visPropCalc = {
    visible: false
  };
  event_default.eventify(this);
  this.mouseover = false;
  this.lastDragTime = new Date();
  if (arguments.length > 0) {
    this.board = board;
    this.type = type;
    this._org_type = type;
    this.elementClass = oclass || constants_default.OBJECT_CLASS_OTHER;
    this.id = attributes.id;
    name = attributes.name;
    if (!type_default.exists(name)) {
      name = this.board.generateName(this);
    }
    if (name !== "") {
      this.board.elementsByName[name] = this;
    }
    this.name = name;
    this.needsRegularUpdate = attributes.needsregularupdate;
    type_default.clearVisPropOld(this);
    attr = this.resolveShortcuts(attributes);
    for (key in attr) {
      if (attr.hasOwnProperty(key)) {
        this._set(key, attr[key]);
      }
    }
    this.visProp.draft = attr.draft && attr.draft.draft;
  }
};
jxg_default.extend(
  jxg_default.GeometryElement.prototype,
  /** @lends JXG.GeometryElement.prototype */
  {
    /**
     * Add an element as a child to the current element. Can be used to model dependencies between geometry elements.
     * @param {JXG.GeometryElement} obj The dependent object.
     */
    addChild: function(obj) {
      var el, el2;
      this.childElements[obj.id] = obj;
      this.addDescendants(obj);
      obj.ancestors[this.id] = this;
      for (el in this.descendants) {
        if (this.descendants.hasOwnProperty(el)) {
          this.descendants[el].ancestors[this.id] = this;
          for (el2 in this.ancestors) {
            if (this.ancestors.hasOwnProperty(el2)) {
              this.descendants[el].ancestors[this.ancestors[el2].id] = this.ancestors[el2];
            }
          }
        }
      }
      for (el in this.ancestors) {
        if (this.ancestors.hasOwnProperty(el)) {
          for (el2 in this.descendants) {
            if (this.descendants.hasOwnProperty(el2)) {
              this.ancestors[el].descendants[this.descendants[el2].id] = this.descendants[el2];
            }
          }
        }
      }
      return this;
    },
    /**
     * @param {JXG.GeometryElement} obj The element that is to be added to the descendants list.
     * @private
     * @return this
    */
    // Adds the given object to the descendants list of this object and all its child objects.
    addDescendants: function(obj) {
      var el;
      this.descendants[obj.id] = obj;
      for (el in obj.childElements) {
        if (obj.childElements.hasOwnProperty(el)) {
          this.addDescendants(obj.childElements[el]);
        }
      }
      return this;
    },
    /**
     * Adds ids of elements to the array this.parents. This method needs to be called if some dependencies
     * can not be detected automatically by JSXGraph. For example if a function graph is given by a function
     * which refers to coordinates of a point, calling addParents() is necessary.
     *
     * @param {Array} parents Array of elements or ids of elements.
     * Alternatively, one can give a list of objects as parameters.
     * @returns {JXG.Object} reference to the object itself.
     *
     * @example
     * // Movable function graph
     * var A = board.create('point', [1, 0], {name:'A'}),
     *     B = board.create('point', [3, 1], {name:'B'}),
     *     f = board.create('functiongraph', function(x) {
     *          var ax = A.X(),
     *              ay = A.Y(),
     *              bx = B.X(),
     *              by = B.Y(),
     *              a = (by - ay) / ( (bx - ax) * (bx - ax) );
     *           return a * (x - ax) * (x - ax) + ay;
     *      }, {fixed: false});
     * f.addParents([A, B]);
     * </pre><div class="jxgbox" id="JXG7c91d4d2-986c-4378-8135-24505027f251" style="width: 400px; height: 400px;"></div>
     * <script type="text/javascript">
     * (function() {
     *   var board = JXG.JSXGraph.initBoard('JXG7c91d4d2-986c-4378-8135-24505027f251', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var A = board.create('point', [1, 0], {name:'A'}),
     *       B = board.create('point', [3, 1], {name:'B'}),
     *       f = board.create('functiongraph', function(x) {
     *            var ax = A.X(),
     *                ay = A.Y(),
     *                bx = B.X(),
     *                by = B.Y(),
     *                a = (by - ay) / ( (bx - ax) * (bx - ax) );
     *             return a * (x - ax) * (x - ax) + ay;
     *        }, {fixed: false});
     *   f.addParents([A, B]);
     * })();
     * <\/script><pre>
     *
     **/
    addParents: function(parents) {
      var i2, len, par;
      if (type_default.isArray(parents)) {
        par = parents;
      } else {
        par = arguments;
      }
      len = par.length;
      for (i2 = 0; i2 < len; ++i2) {
        if (!type_default.exists(par[i2])) {
          continue;
        }
        if (type_default.isId(this.board, par[i2])) {
          this.parents.push(par[i2]);
        } else if (type_default.exists(par[i2].id)) {
          this.parents.push(par[i2].id);
        }
      }
      this.parents = type_default.uniqueArray(this.parents);
    },
    /**
     * Sets ids of elements to the array this.parents.
     * First, this.parents is cleared. See {@link JXG.GeometryElement#addParents}.
     * @param {Array} parents Array of elements or ids of elements.
     * Alternatively, one can give a list of objects as parameters.
     * @returns {JXG.Object} reference to the object itself.
     **/
    setParents: function(parents) {
      this.parents = [];
      this.addParents(parents);
    },
    /**
     * Add dependence on elements in JessieCode functions.
     * @param {Array} function_array Array of functions containing potential properties "deps" with
     * elements the function depends on.
     * @returns {JXG.Object} reference to the object itself
     * @private
     */
    addParentsFromJCFunctions: function(function_array) {
      var i2, e, obj;
      for (i2 = 0; i2 < function_array.length; i2++) {
        for (e in function_array[i2].deps) {
          obj = function_array[i2].deps[e];
          this.addParents(obj);
          obj.addChild(this);
        }
      }
      return this;
    },
    /**
     * Remove an element as a child from the current element.
     * @param {JXG.GeometryElement} obj The dependent object.
     * @returns {JXG.Object} reference to the object itself
     */
    removeChild: function(obj) {
      delete this.childElements[obj.id];
      this.removeDescendants(obj);
      delete obj.ancestors[this.id];
      return this;
    },
    /**
     * Removes the given object from the descendants list of this object and all its child objects.
     * @param {JXG.GeometryElement} obj The element that is to be removed from the descendants list.
     * @private
     * @returns {JXG.Object} reference to the object itself
     */
    removeDescendants: function(obj) {
      var el;
      delete this.descendants[obj.id];
      for (el in obj.childElements) {
        if (obj.childElements.hasOwnProperty(el)) {
          this.removeDescendants(obj.childElements[el]);
        }
      }
      return this;
    },
    /**
     * Counts the direct children of an object without counting labels.
     * @private
     * @returns {number} Number of children
     */
    countChildren: function() {
      var prop, d, s = 0;
      d = this.childElements;
      for (prop in d) {
        if (d.hasOwnProperty(prop) && prop.indexOf("Label") < 0) {
          s++;
        }
      }
      return s;
    },
    /**
     * Returns the elements name. Used in JessieCode.
     * @returns {String}
     */
    getName: function() {
      return this.name;
    },
    /**
     * Add transformations to this element.
     * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation}
     * or an array of {@link JXG.Transformation}s.
     * @returns {JXG.GeometryElement} Reference to the element.
     */
    addTransform: function(transform) {
      return this;
    },
    /**
     * Decides whether an element can be dragged. This is used in
     * {@link JXG.GeometryElement#setPositionDirectly} methods
     * where all parent elements are checked if they may be dragged, too.
     * @private
     * @returns {boolean}
     */
    draggable: function() {
      return this.isDraggable && !type_default.evaluate(this.visProp.fixed) && // !this.visProp.frozen &&
      this.type !== constants_default.OBJECT_TYPE_GLIDER;
    },
    /**
     * Translates the object by <tt>(x, y)</tt>. In case the element is defined by points, the defining points are
     * translated, e.g. a circle constructed by a center point and a point on the circle line.
     * @param {Number} method The type of coordinates used here.
     * Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.
     * @param {Array} coords array of translation vector.
     * @returns {JXG.GeometryElement} Reference to the element object.
     */
    setPosition: function(method, coords) {
      var parents = [], el, i2, len, t;
      if (!type_default.exists(this.parents)) {
        return this;
      }
      len = this.parents.length;
      for (i2 = 0; i2 < len; ++i2) {
        el = this.board.select(this.parents[i2]);
        if (type_default.isPoint(el)) {
          if (!el.draggable()) {
            return this;
          }
          parents.push(el);
        }
      }
      if (coords.length === 3) {
        coords = coords.slice(1);
      }
      t = this.board.create("transform", coords, { type: "translate" });
      len = parents.length;
      if (len > 0) {
        t.applyOnce(parents);
      } else {
        if (this.transformations.length > 0 && this.transformations[this.transformations.length - 1].isNumericMatrix) {
          this.transformations[this.transformations.length - 1].melt(t);
        } else {
          this.addTransform(t);
        }
      }
      for (i2 = 0; i2 < len; ++i2) {
        if (parents[i2].type === constants_default.OBJECT_TYPE_GLIDER) {
          parents[i2].updateGlider();
        }
      }
      return this;
    },
    /**
     * Moves an element by the difference of two coordinates.
     * @param {Number} method The type of coordinates used here.
     * Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.
     * @param {Array} coords coordinates in screen/user units
     * @param {Array} oldcoords previous coordinates in screen/user units
     * @returns {JXG.GeometryElement} this element
     */
    setPositionDirectly: function(method, coords, oldcoords) {
      var c = new coords_default(method, coords, this.board, false), oldc = new coords_default(method, oldcoords, this.board, false), dc = statistics_default.subtract(c.usrCoords, oldc.usrCoords);
      this.setPosition(constants_default.COORDS_BY_USER, dc);
      return this;
    },
    /**
     * Array of strings containing the polynomials defining the element.
     * Used for determining geometric loci the groebner way.
     * @returns {Array} An array containing polynomials describing the locus of the current object.
     * @public
     */
    generatePolynomial: function() {
      return [];
    },
    /**
     * Animates properties for that object like stroke or fill color, opacity and maybe
     * even more later.
     * @param {Object} hash Object containing properties with target values for the animation.
     * @param {number} time Number of milliseconds to complete the animation.
     * @param {Object} [options] Optional settings for the animation:<ul><li>callback: A function that is called as soon as the animation is finished.</li></ul>
     * @returns {JXG.GeometryElement} A reference to the object
     */
    animate: function(hash, time, options) {
      options = options || {};
      var r, p, i2, delay = this.board.attr.animationdelay, steps = Math.ceil(time / delay), self2 = this, animateColor = function(startRGB, endRGB, property) {
        var hsv1, hsv2, sh, ss, sv;
        hsv1 = color_default.rgb2hsv(startRGB);
        hsv2 = color_default.rgb2hsv(endRGB);
        sh = (hsv2[0] - hsv1[0]) / steps;
        ss = (hsv2[1] - hsv1[1]) / steps;
        sv = (hsv2[2] - hsv1[2]) / steps;
        self2.animationData[property] = [];
        for (i2 = 0; i2 < steps; i2++) {
          self2.animationData[property][steps - i2 - 1] = color_default.hsv2rgb(
            hsv1[0] + (i2 + 1) * sh,
            hsv1[1] + (i2 + 1) * ss,
            hsv1[2] + (i2 + 1) * sv
          );
        }
      }, animateFloat = function(start, end, property, round) {
        var tmp, s;
        start = parseFloat(start);
        end = parseFloat(end);
        if (isNaN(start) || isNaN(end)) {
          return;
        }
        s = (end - start) / steps;
        self2.animationData[property] = [];
        for (i2 = 0; i2 < steps; i2++) {
          tmp = start + (i2 + 1) * s;
          self2.animationData[property][steps - i2 - 1] = round ? Math.floor(tmp) : tmp;
        }
      };
      this.animationData = {};
      for (r in hash) {
        if (hash.hasOwnProperty(r)) {
          p = r.toLowerCase();
          switch (p) {
            case "strokecolor":
            case "fillcolor":
              animateColor(this.visProp[p], hash[r], p);
              break;
            case "size":
              if (!type_default.isPoint(this)) {
                break;
              }
              animateFloat(this.visProp[p], hash[r], p, true);
              break;
            case "strokeopacity":
            case "strokewidth":
            case "fillopacity":
              animateFloat(this.visProp[p], hash[r], p, false);
              break;
          }
        }
      }
      this.animationCallback = options.callback;
      this.board.addAnimation(this);
      return this;
    },
    /**
     * General update method. Should be overwritten by the element itself.
     * Can be used sometimes to commit changes to the object.
     * @return {JXG.GeometryElement} Reference to the element
     */
    update: function() {
      if (type_default.evaluate(this.visProp.trace)) {
        this.cloneToBackground();
      }
      return this;
    },
    /**
     * Provide updateRenderer method.
     * @return {JXG.GeometryElement} Reference to the element
     * @private
     */
    updateRenderer: function() {
      return this;
    },
    /**
     * Run through the full update chain of an element.
     * @param  {Boolean} visible Set visibility in case the elements attribute value is 'inherit'. null is allowed.
     * @return {JXG.GeometryElement} Reference to the element
     * @private
     */
    fullUpdate: function(visible) {
      return this.prepareUpdate().update().updateVisibility(visible).updateRenderer();
    },
    /**
     * Show the element or hide it. If hidden, it will still exist but not be
     * visible on the board.
     * <p>
     * Sets also the display of the inherits elements. These can be
     * JSXGraph elements or arrays of JSXGraph elements.
     * However, deeper nesting than this is not supported.
     *
     * @param  {Boolean} val true: show the element, false: hide the element
     * @return {JXG.GeometryElement} Reference to the element
     * @private
     */
    setDisplayRendNode: function(val) {
      var i2, len, s, len_s, obj;
      if (val === void 0) {
        val = this.visPropCalc.visible;
      }
      if (val === this.visPropOld.visible) {
        return this;
      }
      this.board.renderer.display(this, val);
      len = this.inherits.length;
      for (s = 0; s < len; s++) {
        obj = this.inherits[s];
        if (type_default.isArray(obj)) {
          len_s = obj.length;
          for (i2 = 0; i2 < len_s; i2++) {
            if (type_default.exists(obj[i2]) && type_default.exists(obj[i2].rendNode) && type_default.evaluate(obj[i2].visProp.visible) === "inherit") {
              obj[i2].setDisplayRendNode(val);
            }
          }
        } else {
          if (type_default.exists(obj) && type_default.exists(obj.rendNode) && type_default.evaluate(obj.visProp.visible) === "inherit") {
            obj.setDisplayRendNode(val);
          }
        }
      }
      if (this.hasLabel && type_default.exists(this.label) && type_default.exists(this.label.rendNode)) {
        if (type_default.evaluate(this.label.visProp.visible) === "inherit") {
          this.label.setDisplayRendNode(val);
        }
      }
      return this;
    },
    /**
     * Hide the element. It will still exist but not be visible on the board.
     * Alias for "element.setAttribute({visible: false});"
     * @return {JXG.GeometryElement} Reference to the element
     */
    hide: function() {
      this.setAttribute({ visible: false });
      return this;
    },
    /**
     * Hide the element. It will still exist but not be visible on the board.
     * Alias for {@link JXG.GeometryElement#hide}
     * @returns {JXG.GeometryElement} Reference to the element
     */
    hideElement: function() {
      this.hide();
      return this;
    },
    /**
     * Make the element visible.
     * Alias for "element.setAttribute({visible: true});"
     * @return {JXG.GeometryElement} Reference to the element
     */
    show: function() {
      this.setAttribute({ visible: true });
      return this;
    },
    /**
     * Make the element visible.
     * Alias for {@link JXG.GeometryElement#show}
     * @returns {JXG.GeometryElement} Reference to the element
     */
    showElement: function() {
      this.show();
      return this;
    },
    /**
     * Set the visibility of an element. The visibility is influenced by
     * (listed in ascending priority):
     * <ol>
     * <li> The value of the element's attribute 'visible'
     * <li> The visibility of a parent element. (Example: label)
     * This overrules the value of the element's attribute value only if
     * this attribute value of the element is 'inherit'.
     * <li> being inside of the canvas
     * </ol>
     * <p>
     * This method is called three times for most elements:
     * <ol>
     * <li> between {@link JXG.GeometryElement#update}
     * and {@link JXG.GeometryElement#updateRenderer}. In case the value is 'inherit', nothing is done.
     * <li> Recursively, called by itself for child elements. Here, 'inherit' is overruled by the parent's value.
     * <li> In {@link JXG.GeometryElement#updateRenderer}, if the element is outside of the canvas.
     * </ol>
     *
     * @param  {Boolean} parent_val Visibility of the parent element.
     * @return {JXG.GeometryElement} Reference to the element.
     * @private
     */
    updateVisibility: function(parent_val) {
      var i2, len, s, len_s, obj, val;
      if (this.needsUpdate) {
        if (parent_val !== void 0) {
          this.visPropCalc.visible = parent_val;
        } else {
          val = type_default.evaluate(this.visProp.visible);
          if (type_default.exists(this.hiddenByParent) && this.hiddenByParent) {
            val = false;
          }
          if (val !== "inherit") {
            this.visPropCalc.visible = val;
          }
        }
        len = this.inherits.length;
        for (s = 0; s < len; s++) {
          obj = this.inherits[s];
          if (type_default.isArray(obj)) {
            len_s = obj.length;
            for (i2 = 0; i2 < len_s; i2++) {
              if (type_default.exists(obj[i2]) && type_default.evaluate(obj[i2].visProp.visible) === "inherit") {
                obj[i2].prepareUpdate().updateVisibility(this.visPropCalc.visible);
              }
            }
          } else {
            if (type_default.exists(obj) && type_default.evaluate(obj.visProp.visible) === "inherit") {
              obj.prepareUpdate().updateVisibility(this.visPropCalc.visible);
            }
          }
        }
        if (type_default.exists(this.label) && type_default.exists(this.label.visProp) && type_default.evaluate(this.label.visProp.visible)) {
          this.label.prepareUpdate().updateVisibility(this.visPropCalc.visible);
        }
      }
      return this;
    },
    /**
     * Sets the value of attribute <tt>key</tt> to <tt>value</tt>.
     * @param {String} key The attribute's name.
     * @param value The new value
     * @private
     */
    _set: function(key, value) {
      var el;
      key = key.toLocaleLowerCase();
      if (this.visProp.hasOwnProperty(key) && key.indexOf("color") >= 0 && type_default.isString(value) && value.length === 9 && value.charAt(0) === "#") {
        value = color_default.rgba2rgbo(value);
        this.visProp[key] = value[0];
        this.visProp[key.replace("color", "opacity")] = value[1];
      } else {
        if (value !== null && type_default.isObject(value) && !type_default.exists(value.id) && !type_default.exists(value.name)) {
          this.visProp[key] = {};
          for (el in value) {
            if (value.hasOwnProperty(el)) {
              this.visProp[key][el.toLocaleLowerCase()] = value[el];
            }
          }
        } else {
          this.visProp[key] = value;
        }
      }
    },
    /**
     * Resolves attribute shortcuts like <tt>color</tt> and expands them, e.g. <tt>strokeColor</tt> and <tt>fillColor</tt>.
     * Writes the expanded attributes back to the given <tt>attributes</tt>.
     * @param {Object} attributes object
     * @returns {Object} The given attributes object with shortcuts expanded.
     * @private
     */
    resolveShortcuts: function(attributes) {
      var key, i2, j, subattr = ["traceattributes", "traceAttributes"];
      for (key in options_default.shortcuts) {
        if (options_default.shortcuts.hasOwnProperty(key)) {
          if (type_default.exists(attributes[key])) {
            for (i2 = 0; i2 < options_default.shortcuts[key].length; i2++) {
              if (!type_default.exists(attributes[options_default.shortcuts[key][i2]])) {
                attributes[options_default.shortcuts[key][i2]] = attributes[key];
              }
            }
          }
          for (j = 0; j < subattr.length; j++) {
            if (type_default.isObject(attributes[subattr[j]])) {
              attributes[subattr[j]] = this.resolveShortcuts(
                attributes[subattr[j]]
              );
            }
          }
        }
      }
      return attributes;
    },
    /**
     * Sets a label and its text
     * If label doesn't exist, it creates one
     * @param {String} str
     */
    setLabel: function(str2) {
      if (!this.hasLabel) {
        this.setAttribute({ withlabel: true });
      }
      this.setLabelText(str2);
    },
    /**
     * Updates the element's label text, strips all html.
     * @param {String} str
     */
    setLabelText: function(str2) {
      if (type_default.exists(this.label)) {
        str2 = str2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        this.label.setText(str2);
      }
      return this;
    },
    /**
     * Updates the element's label text and the element's attribute "name", strips all html.
     * @param {String} str
     */
    setName: function(str2) {
      str2 = str2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      if (this.elType !== "slider") {
        this.setLabelText(str2);
      }
      this.setAttribute({ name: str2 });
    },
    /**
     * Deprecated alias for {@link JXG.GeometryElement#setAttribute}.
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}.
     */
    setProperty: function() {
      jxg_default.deprecated("setProperty()", "setAttribute()");
      this.setAttribute.apply(this, arguments);
    },
    /**
     * Sets an arbitrary number of attributes. This method has one or more
     * parameters of the following types:
     * <ul>
     * <li> object: {key1:value1,key2:value2,...}
     * <li> string: 'key:value'
     * <li> array: ['key', value]
     * </ul>
     * @param {Object} attributes An object with attributes.
     * @returns {JXG.GeometryElement} A reference to the element.
     *
     * @function
     * @example
     * // Set attribute directly on creation of an element using the attributes object parameter
     * var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 5, 5, 1]};
     * var p = board.create('point', [2, 2], {visible: false});
     *
     * // Now make this point visible and fixed:
     * p.setAttribute({
     *     fixed: true,
     *     visible: true
     * });
     */
    setAttribute: function(attr) {
      var i2, j, le, key, value, arg, opacity, pair, oldvalue, attributes = {};
      for (i2 = 0; i2 < arguments.length; i2++) {
        arg = arguments[i2];
        if (type_default.isString(arg)) {
          pair = arg.split(":");
          attributes[type_default.trim(pair[0])] = type_default.trim(pair[1]);
        } else if (!type_default.isArray(arg)) {
          jxg_default.extend(attributes, arg);
        } else {
          attributes[arg[0]] = arg[1];
        }
      }
      attributes = this.resolveShortcuts(attributes);
      for (i2 in attributes) {
        if (attributes.hasOwnProperty(i2)) {
          key = i2.replace(/\s+/g, "").toLowerCase();
          value = attributes[i2];
          if (type_default.isObject(value) && type_default.exists(this.visProp[key])) {
            this.visProp[key] = type_default.merge(this.visProp[key], value);
            if (this.type === constants_default.OBJECT_TYPE_TICKS && type_default.exists(this.labels)) {
              le = this.labels.length;
              for (j = 0; j < le; j++) {
                this.labels[j].setAttribute(value);
              }
            } else if (type_default.exists(this[key])) {
              if (type_default.isArray(this[key])) {
                for (j = 0; j < this[key].length; j++) {
                  this[key][j].setAttribute(value);
                }
              } else {
                this[key].setAttribute(value);
              }
            }
            continue;
          }
          oldvalue = this.visProp[key];
          switch (key) {
            case "checked":
              if (type_default.exists(this.rendNodeTag)) {
                this.rendNodeCheckbox.checked = !!value;
              }
              break;
            case "disabled":
              if (type_default.exists(this.rendNodeTag)) {
                this.rendNodeTag.disabled = !!value;
              }
              break;
            case "face":
              if (type_default.isPoint(this)) {
                this.visProp.face = value;
                this.board.renderer.changePointStyle(this);
              }
              break;
            case "generatelabelvalue":
              if (this.type === constants_default.OBJECT_TYPE_TICKS && type_default.isFunction(value)) {
                this.generateLabelValue = value;
              }
              break;
            case "gradient":
              this.visProp.gradient = value;
              this.board.renderer.setGradient(this);
              break;
            case "gradientsecondcolor":
              value = color_default.rgba2rgbo(value);
              this.visProp.gradientsecondcolor = value[0];
              this.visProp.gradientsecondopacity = value[1];
              this.board.renderer.updateGradient(this);
              break;
            case "gradientsecondopacity":
              this.visProp.gradientsecondopacity = value;
              this.board.renderer.updateGradient(this);
              break;
            case "infoboxtext":
              if (type_default.isString(value)) {
                this.infoboxText = value;
              } else {
                this.infoboxText = false;
              }
              break;
            case "labelcolor":
              value = color_default.rgba2rgbo(value);
              opacity = value[1];
              value = value[0];
              if (opacity === 0) {
                if (type_default.exists(this.label) && this.hasLabel) {
                  this.label.hideElement();
                }
              }
              if (type_default.exists(this.label) && this.hasLabel) {
                this.label.visProp.strokecolor = value;
                this.board.renderer.setObjectStrokeColor(
                  this.label,
                  value,
                  opacity
                );
              }
              if (this.elementClass === constants_default.OBJECT_CLASS_TEXT) {
                this.visProp.strokecolor = value;
                this.visProp.strokeopacity = opacity;
                this.board.renderer.setObjectStrokeColor(this, value, opacity);
              }
              break;
            case "layer":
              this.board.renderer.setLayer(this, type_default.evaluate(value));
              this._set(key, value);
              break;
            case "maxlength":
              if (type_default.exists(this.rendNodeTag)) {
                this.rendNodeTag.maxlength = !!value;
              }
              break;
            case "name":
              oldvalue = this.name;
              delete this.board.elementsByName[this.name];
              this.name = value;
              this.board.elementsByName[this.name] = this;
              break;
            case "needsregularupdate":
              this.needsRegularUpdate = !(value === "false" || value === false);
              this.board.renderer.setBuffering(
                this,
                this.needsRegularUpdate ? "auto" : "static"
              );
              break;
            case "onpolygon":
              if (this.type === constants_default.OBJECT_TYPE_GLIDER) {
                this.onPolygon = !!value;
              }
              break;
            case "radius":
              if (this.type === constants_default.OBJECT_TYPE_ANGLE || this.type === constants_default.OBJECT_TYPE_SECTOR) {
                this.setRadius(value);
              }
              break;
            case "rotate":
              if (this.elementClass === constants_default.OBJECT_CLASS_TEXT && type_default.evaluate(this.visProp.display) === "internal" || this.type === constants_default.OBJECT_TYPE_IMAGE) {
                this.addRotation(value);
              }
              break;
            case "tabindex":
              if (type_default.exists(this.rendNode)) {
                this.rendNode.setAttribute("tabindex", value);
                this._set(key, value);
              }
              break;
            case "trace":
              if (value === "false" || value === false) {
                this.clearTrace();
                this.visProp.trace = false;
              } else if (value === "pause") {
                this.visProp.trace = false;
              } else {
                this.visProp.trace = true;
              }
              break;
            case "visible":
              if (value === "false") {
                this.visProp.visible = false;
              } else if (value === "true") {
                this.visProp.visible = true;
              } else {
                this.visProp.visible = value;
              }
              this.setDisplayRendNode(type_default.evaluate(this.visProp.visible));
              if (type_default.evaluate(this.visProp.visible) && type_default.exists(this.updateSize)) {
                this.updateSize();
              }
              break;
            case "withlabel":
              this.visProp.withlabel = value;
              if (!type_default.evaluate(value)) {
                if (this.label && this.hasLabel) {
                  this.label.setAttribute({ visible: false });
                }
              } else {
                if (!this.label) {
                  this.createLabel();
                }
                this.label.setAttribute({ visible: "inherit" });
              }
              this.hasLabel = value;
              break;
            default:
              if (type_default.exists(this.visProp[key]) && (!jxg_default.Validator[key] || jxg_default.Validator[key] && jxg_default.Validator[key](value) || jxg_default.Validator[key] && type_default.isFunction(value) && jxg_default.Validator[key](value()))) {
                value = value.toLowerCase && value.toLowerCase() === "false" ? false : value;
                this._set(key, value);
              }
              break;
          }
          this.triggerEventHandlers(["attribute:" + key], [oldvalue, value, this]);
        }
      }
      this.triggerEventHandlers(["attribute"], [attributes, this]);
      if (!type_default.evaluate(this.visProp.needsregularupdate)) {
        this.board.fullUpdate();
      } else {
        this.board.update(this);
      }
      if (this.elementClass === constants_default.OBJECT_CLASS_TEXT) {
        this.updateSize();
      }
      return this;
    },
    /**
     * Deprecated alias for {@link JXG.GeometryElement#getAttribute}.
     * @deprecated Use {@link JXG.GeometryElement#getAttribute}.
     */
    getProperty: function() {
      jxg_default.deprecated("getProperty()", "getAttribute()");
      this.getProperty.apply(this, arguments);
    },
    /**
     * Get the value of the property <tt>key</tt>.
     * @param {String} key The name of the property you are looking for
     * @returns The value of the property
     */
    getAttribute: function(key) {
      var result;
      key = key.toLowerCase();
      switch (key) {
        case "needsregularupdate":
          result = this.needsRegularUpdate;
          break;
        case "labelcolor":
          result = this.label.visProp.strokecolor;
          break;
        case "infoboxtext":
          result = this.infoboxText;
          break;
        case "withlabel":
          result = this.hasLabel;
          break;
        default:
          result = this.visProp[key];
          break;
      }
      return result;
    },
    /**
     * Set the dash style of an object. See {@link JXG.GeometryElement#dash}
     * for a list of available dash styles.
     * You should use {@link JXG.GeometryElement#setAttribute} instead of this method.
     *
     * @param {number} dash Indicates the new dash style
     * @private
     */
    setDash: function(dash) {
      this.setAttribute({ dash });
      return this;
    },
    /**
     * Notify all child elements for updates.
     * @private
     */
    prepareUpdate: function() {
      this.needsUpdate = true;
      return this;
    },
    /**
     * Removes the element from the construction.  This only removes the SVG or VML node of the element and its label (if available) from
     * the renderer, to remove the element completely you should use {@link JXG.Board#removeObject}.
     */
    remove: function() {
      this.board.renderer.remove(this.rendNode);
      if (this.hasLabel) {
        this.board.renderer.remove(this.board.renderer.getElementById(this.label.id));
      }
      return this;
    },
    /**
     * Returns the coords object where a text that is bound to the element shall be drawn.
     * Differs in some cases from the values that getLabelAnchor returns.
     * @returns {JXG.Coords} JXG.Coords Place where the text shall be drawn.
     * @see JXG.GeometryElement#getLabelAnchor
     */
    getTextAnchor: function() {
      return new coords_default(constants_default.COORDS_BY_USER, [0, 0], this.board);
    },
    /**
     * Returns the coords object where the label of the element shall be drawn.
     * Differs in some cases from the values that getTextAnchor returns.
     * @returns {JXG.Coords} JXG.Coords Place where the text shall be drawn.
     * @see JXG.GeometryElement#getTextAnchor
     */
    getLabelAnchor: function() {
      return new coords_default(constants_default.COORDS_BY_USER, [0, 0], this.board);
    },
    /**
     * Determines whether the element has arrows at start or end of the arc.
     * If it is set to be a "typical" vector, ie lastArrow == true,
     * then the element.type is set to VECTOR.
     * @param {Boolean} firstArrow True if there is an arrow at the start of the arc, false otherwise.
     * @param {Boolean} lastArrow True if there is an arrow at the end of the arc, false otherwise.
     */
    setArrow: function(firstArrow, lastArrow) {
      this.visProp.firstarrow = firstArrow;
      this.visProp.lastarrow = lastArrow;
      if (lastArrow) {
        this.type = constants_default.OBJECT_TYPE_VECTOR;
        this.elType = "arrow";
      }
      this.prepareUpdate().update().updateVisibility().updateRenderer();
      return this;
    },
    /**
     * Creates a gradient nodes in the renderer.
     * @see JXG.SVGRenderer#setGradient
     * @private
     */
    createGradient: function() {
      var ev_g = type_default.evaluate(this.visProp.gradient);
      if (ev_g === "linear" || ev_g === "radial") {
        this.board.renderer.setGradient(this);
      }
    },
    /**
     * Creates a label element for this geometry element.
     * @see #addLabelToElement
     */
    createLabel: function() {
      var attr, that2 = this;
      if (jxg_default.elements.text) {
        attr = type_default.deepCopy(this.visProp.label, null);
        attr.id = this.id + "Label";
        attr.isLabel = true;
        attr.anchor = this;
        attr.priv = this.visProp.priv;
        if (this.visProp.withlabel) {
          this.label = jxg_default.elements.text(
            this.board,
            [
              0,
              0,
              function() {
                if (type_default.isFunction(that2.name)) {
                  return that2.name();
                }
                return that2.name;
              }
            ],
            attr
          );
          this.label.needsUpdate = true;
          this.label.dump = false;
          this.label.fullUpdate();
          this.hasLabel = true;
        }
      } else {
        jxg_default.debug(
          "JSXGraph: Can't create label: text element is not available. Make sure you include base/text"
        );
      }
      return this;
    },
    /**
     * Highlights the element.
     * @private
     * @param {Boolean} [force=false] Force the highlighting
     * @returns {JXG.Board}
     */
    highlight: function(force) {
      force = type_default.def(force, false);
      if (type_default.evaluate(this.visProp.highlight) && (!this.highlighted || force)) {
        this.highlighted = true;
        this.board.highlightedObjects[this.id] = this;
        this.board.renderer.highlight(this);
      }
      return this;
    },
    /**
     * Uses the "normal" properties of the element.
     * @returns {JXG.Board}
     */
    noHighlight: function() {
      if (this.highlighted) {
        this.highlighted = false;
        delete this.board.highlightedObjects[this.id];
        this.board.renderer.noHighlight(this);
      }
      return this;
    },
    /**
     * Removes all objects generated by the trace function.
     */
    clearTrace: function() {
      var obj;
      for (obj in this.traces) {
        if (this.traces.hasOwnProperty(obj)) {
          this.board.renderer.remove(this.traces[obj]);
        }
      }
      this.numTraces = 0;
      return this;
    },
    /**
     * Copy the element to background. This is used for tracing elements.
     * @returns {JXG.GeometryElement} A reference to the element
     */
    cloneToBackground: function() {
      return this;
    },
    /**
     * Dimensions of the smallest rectangle enclosing the element.
     * @returns {Array} The coordinates of the enclosing rectangle in a format
     * like the bounding box in {@link JXG.Board#setBoundingBox}.
     *
     * @returns {Array} similar to {@link JXG.Board#setBoundingBox}.
     */
    bounds: function() {
      return [0, 0, 0, 0];
    },
    /**
     * Normalize the element's standard form.
     * @private
     */
    normalize: function() {
      this.stdform = math_default.normalize(this.stdform);
      return this;
    },
    /**
     * EXPERIMENTAL. Generate JSON object code of visProp and other properties.
     * @type String
     * @private
     * @ignore
     * @returns JSON string containing element's properties.
     */
    toJSON: function() {
      var vis, key, json = ['{"name":', this.name];
      json.push(', "id":' + this.id);
      vis = [];
      for (key in this.visProp) {
        if (this.visProp.hasOwnProperty(key)) {
          if (type_default.exists(this.visProp[key])) {
            vis.push('"' + key + '":' + this.visProp[key]);
          }
        }
      }
      json.push(', "visProp":{' + vis.toString() + "}");
      json.push("}");
      return json.join("");
    },
    /**
     * Rotate texts or images by a given degree.
     * @param {number} angle The degree of the rotation (90 means vertical text).
     * @see JXG.GeometryElement#rotate
     */
    addRotation: function(angle) {
      var tOffInv, tOff, tS, tSInv, tRot, that2 = this;
      if ((this.elementClass === constants_default.OBJECT_CLASS_TEXT || this.type === constants_default.OBJECT_TYPE_IMAGE) && angle !== 0) {
        tOffInv = this.board.create(
          "transform",
          [
            function() {
              return -that2.X();
            },
            function() {
              return -that2.Y();
            }
          ],
          { type: "translate" }
        );
        tOff = this.board.create(
          "transform",
          [
            function() {
              return that2.X();
            },
            function() {
              return that2.Y();
            }
          ],
          { type: "translate" }
        );
        tS = this.board.create(
          "transform",
          [
            function() {
              return that2.board.unitX / that2.board.unitY;
            },
            function() {
              return 1;
            }
          ],
          { type: "scale" }
        );
        tSInv = this.board.create(
          "transform",
          [
            function() {
              return that2.board.unitY / that2.board.unitX;
            },
            function() {
              return 1;
            }
          ],
          { type: "scale" }
        );
        tRot = this.board.create(
          "transform",
          [
            function() {
              return type_default.evaluate(angle) * Math.PI / 180;
            }
          ],
          { type: "rotate" }
        );
        tOffInv.bindTo(this);
        tS.bindTo(this);
        tRot.bindTo(this);
        tSInv.bindTo(this);
        tOff.bindTo(this);
      }
      return this;
    },
    /**
     * Set the highlightStrokeColor of an element
     * @ignore
     * @name JXG.GeometryElement#highlightStrokeColorMethod
     * @param {String} sColor String which determines the stroke color of an object when its highlighted.
     * @see JXG.GeometryElement#highlightStrokeColor
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    highlightStrokeColor: function(sColor) {
      jxg_default.deprecated("highlightStrokeColor()", "setAttribute()");
      this.setAttribute({ highlightStrokeColor: sColor });
      return this;
    },
    /**
     * Set the strokeColor of an element
     * @ignore
     * @name JXG.GeometryElement#strokeColorMethod
     * @param {String} sColor String which determines the stroke color of an object.
     * @see JXG.GeometryElement#strokeColor
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    strokeColor: function(sColor) {
      jxg_default.deprecated("strokeColor()", "setAttribute()");
      this.setAttribute({ strokeColor: sColor });
      return this;
    },
    /**
     * Set the strokeWidth of an element
     * @ignore
     * @name JXG.GeometryElement#strokeWidthMethod
     * @param {Number} width Integer which determines the stroke width of an outline.
     * @see JXG.GeometryElement#strokeWidth
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    strokeWidth: function(width) {
      jxg_default.deprecated("strokeWidth()", "setAttribute()");
      this.setAttribute({ strokeWidth: width });
      return this;
    },
    /**
     * Set the fillColor of an element
     * @ignore
     * @name JXG.GeometryElement#fillColorMethod
     * @param {String} fColor String which determines the fill color of an object.
     * @see JXG.GeometryElement#fillColor
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    fillColor: function(fColor) {
      jxg_default.deprecated("fillColor()", "setAttribute()");
      this.setAttribute({ fillColor: fColor });
      return this;
    },
    /**
     * Set the highlightFillColor of an element
     * @ignore
     * @name JXG.GeometryElement#highlightFillColorMethod
     * @param {String} fColor String which determines the fill color of an object when its highlighted.
     * @see JXG.GeometryElement#highlightFillColor
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    highlightFillColor: function(fColor) {
      jxg_default.deprecated("highlightFillColor()", "setAttribute()");
      this.setAttribute({ highlightFillColor: fColor });
      return this;
    },
    /**
     * Set the labelColor of an element
     * @ignore
     * @param {String} lColor String which determines the text color of an object's label.
     * @see JXG.GeometryElement#labelColor
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    labelColor: function(lColor) {
      jxg_default.deprecated("labelColor()", "setAttribute()");
      this.setAttribute({ labelColor: lColor });
      return this;
    },
    /**
     * Set the dash type of an element
     * @ignore
     * @name JXG.GeometryElement#dashMethod
     * @param {Number} d Integer which determines the way of dashing an element's outline.
     * @see JXG.GeometryElement#dash
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    dash: function(d) {
      jxg_default.deprecated("dash()", "setAttribute()");
      this.setAttribute({ dash: d });
      return this;
    },
    /**
     * Set the visibility of an element
     * @ignore
     * @name JXG.GeometryElement#visibleMethod
     * @param {Boolean} v Boolean which determines whether the element is drawn.
     * @see JXG.GeometryElement#visible
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    visible: function(v) {
      jxg_default.deprecated("visible()", "setAttribute()");
      this.setAttribute({ visible: v });
      return this;
    },
    /**
     * Set the shadow of an element
     * @ignore
     * @name JXG.GeometryElement#shadowMethod
     * @param {Boolean} s Boolean which determines whether the element has a shadow or not.
     * @see JXG.GeometryElement#shadow
     * @deprecated Use {@link JXG.GeometryElement#setAttribute}
     */
    shadow: function(s) {
      jxg_default.deprecated("shadow()", "setAttribute()");
      this.setAttribute({ shadow: s });
      return this;
    },
    /**
     * The type of the element as used in {@link JXG.Board#create}.
     * @returns {String}
     */
    getType: function() {
      return this.elType;
    },
    /**
     * List of the element ids resp. values used as parents in {@link JXG.Board#create}.
     * @returns {Array}
     */
    getParents: function() {
      return type_default.isArray(this.parents) ? this.parents : [];
    },
    /**
     * @ignore
     * @private
     * Snaps the element to the grid. Only works for points, lines and circles. Points will snap to the grid
     * as defined in their properties {@link JXG.Point#snapSizeX} and {@link JXG.Point#snapSizeY}. Lines and circles
     * will snap their parent points to the grid, if they have {@link JXG.Point#snapToGrid} set to true.
     * @returns {JXG.GeometryElement} Reference to the element.
     */
    snapToGrid: function() {
      return this;
    },
    /**
     * Snaps the element to points. Only works for points. Points will snap to the next point
     * as defined in their properties {@link JXG.Point#attractorDistance} and {@link JXG.Point#attractorUnit}.
     * Lines and circles
     * will snap their parent points to points.
     * @private
     * @returns {JXG.GeometryElement} Reference to the element.
     */
    snapToPoints: function() {
      return this;
    },
    /**
     * Retrieve a copy of the current visProp.
     * @returns {Object}
     */
    getAttributes: function() {
      var attributes = type_default.deepCopy(this.visProp), cleanThis = [], i2, len = cleanThis.length;
      attributes.id = this.id;
      attributes.name = this.name;
      for (i2 = 0; i2 < len; i2++) {
        delete attributes[cleanThis[i2]];
      }
      return attributes;
    },
    /**
     * Checks whether (x,y) is near the element.
     * @param {Number} x Coordinate in x direction, screen coordinates.
     * @param {Number} y Coordinate in y direction, screen coordinates.
     * @returns {Boolean} True if (x,y) is near the element, False otherwise.
     */
    hasPoint: function(x, y) {
      return false;
    },
    /**
     * Adds ticks to this line or curve. Ticks can be added to a curve or any kind of line: line, arrow, and axis.
     * @param {JXG.Ticks} ticks Reference to a ticks object which is describing the ticks (color, distance, how many, etc.).
     * @returns {String} Id of the ticks object.
     */
    addTicks: function(ticks) {
      if (ticks.id === "" || !type_default.exists(ticks.id)) {
        ticks.id = this.id + "_ticks_" + (this.ticks.length + 1);
      }
      this.board.renderer.drawTicks(ticks);
      this.ticks.push(ticks);
      return ticks.id;
    },
    /**
     * Removes all ticks from a line or curve.
     */
    removeAllTicks: function() {
      var t;
      if (type_default.exists(this.ticks)) {
        for (t = this.ticks.length - 1; t >= 0; t--) {
          this.removeTicks(this.ticks[t]);
        }
        this.ticks = [];
        this.board.update();
      }
    },
    /**
     * Removes ticks identified by parameter named tick from this line or curve.
     * @param {JXG.Ticks} tick Reference to tick object to remove.
     */
    removeTicks: function(tick) {
      var t, j;
      if (type_default.exists(this.defaultTicks) && this.defaultTicks === tick) {
        this.defaultTicks = null;
      }
      if (type_default.exists(this.ticks)) {
        for (t = this.ticks.length - 1; t >= 0; t--) {
          if (this.ticks[t] === tick) {
            this.board.removeObject(this.ticks[t]);
            if (this.ticks[t].ticks) {
              for (j = 0; j < this.ticks[t].ticks.length; j++) {
                if (type_default.exists(this.ticks[t].labels[j])) {
                  this.board.removeObject(this.ticks[t].labels[j]);
                }
              }
            }
            delete this.ticks[t];
            break;
          }
        }
      }
    },
    /**
     * Determine values of snapSizeX and snapSizeY. If the attributes
     * snapSizex and snapSizeY are greater than zero, these values are taken.
     * Otherwise, determine the distance between major ticks of the
     * default axes.
     * @returns {Array} containing the snap sizes for x and y direction.
     * @private
     */
    getSnapSizes: function() {
      var sX, sY, ticks;
      sX = type_default.evaluate(this.visProp.snapsizex);
      sY = type_default.evaluate(this.visProp.snapsizey);
      if (sX <= 0 && this.board.defaultAxes && this.board.defaultAxes.x.defaultTicks) {
        ticks = this.board.defaultAxes.x.defaultTicks;
        sX = ticks.ticksDelta * (type_default.evaluate(ticks.visProp.minorticks) + 1);
      }
      if (sY <= 0 && this.board.defaultAxes && this.board.defaultAxes.y.defaultTicks) {
        ticks = this.board.defaultAxes.y.defaultTicks;
        sY = ticks.ticksDelta * (type_default.evaluate(ticks.visProp.minorticks) + 1);
      }
      return [sX, sY];
    },
    /**
     * Move an element to its nearest grid point.
     * The function uses the coords object of the element as
     * its actual position. If there is no coords object or if the object is fixed, nothing is done.
     * @param {Boolean} force force snapping independent from what the snaptogrid attribute says
     * @param {Boolean} fromParent True if the drag comes from a child element. This is the case if a line
     *    through two points is dragged. In this case we do not try to force the points to stay inside of
     *    the visible board, but the distance between the two points stays constant.
     * @returns {JXG.GeometryElement} Reference to this element
     */
    handleSnapToGrid: function(force, fromParent) {
      var x, y, rx, ry, rcoords, mi, ma, boardBB, res, sX, sY, needsSnapToGrid = false, attractToGrid = type_default.evaluate(this.visProp.attracttogrid), ev_au = type_default.evaluate(this.visProp.attractorunit), ev_ad = type_default.evaluate(this.visProp.attractordistance);
      if (!type_default.exists(this.coords) || type_default.evaluate(this.visProp.fixed)) {
        return this;
      }
      needsSnapToGrid = type_default.evaluate(this.visProp.snaptogrid) || attractToGrid || force === true;
      if (needsSnapToGrid) {
        x = this.coords.usrCoords[1];
        y = this.coords.usrCoords[2];
        res = this.getSnapSizes();
        sX = res[0];
        sY = res[1];
        if (sX > 0 && sY > 0) {
          boardBB = this.board.getBoundingBox();
          rx = Math.round(x / sX) * sX;
          ry = Math.round(y / sY) * sY;
          rcoords = new jxg_default.Coords(constants_default.COORDS_BY_USER, [rx, ry], this.board);
          if (!attractToGrid || rcoords.distance(
            ev_au === "screen" ? constants_default.COORDS_BY_SCREEN : constants_default.COORDS_BY_USER,
            this.coords
          ) < ev_ad) {
            x = rx;
            y = ry;
            if (!fromParent) {
              mi = Math.min(boardBB[0], boardBB[2]);
              ma = Math.max(boardBB[0], boardBB[2]);
              if (x < mi && x > mi - sX) {
                x += sX;
              } else if (x > ma && x < ma + sX) {
                x -= sX;
              }
              mi = Math.min(boardBB[1], boardBB[3]);
              ma = Math.max(boardBB[1], boardBB[3]);
              if (y < mi && y > mi - sY) {
                y += sY;
              } else if (y > ma && y < ma + sY) {
                y -= sY;
              }
            }
            this.coords.setCoordinates(constants_default.COORDS_BY_USER, [x, y]);
          }
        }
      }
      return this;
    },
    getBoundingBox: function() {
      var i2, le, v, x, y, bb = [Infinity, Infinity, -Infinity, -Infinity];
      if (this.type === constants_default.OBJECT_TYPE_POLYGON) {
        le = this.vertices.length - 1;
        if (le <= 0) {
          return bb;
        }
        for (i2 = 0; i2 < le; i2++) {
          v = this.vertices[i2].X();
          bb[0] = v < bb[0] ? v : bb[0];
          bb[2] = v > bb[2] ? v : bb[2];
          v = this.vertices[i2].Y();
          bb[1] = v < bb[1] ? v : bb[1];
          bb[3] = v > bb[3] ? v : bb[3];
        }
      } else if (this.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
        x = this.center.X();
        y = this.center.Y();
        bb = [x - this.radius, y + this.radius, x + this.radius, y - this.radius];
      } else if (this.elementClass === constants_default.OBJECT_CLASS_CURVE) {
        le = this.vertices.length;
        if (le === 0) {
          return bb;
        }
        for (i2 = 0; i2 < le; i2++) {
          v = this.points[i2].coords.usrCoords[1];
          bb[0] = v < bb[0] ? v : bb[0];
          bb[2] = v > bb[2] ? v : bb[2];
          v = this.points[i2].coords.usrCoords[1];
          bb[1] = v < bb[1] ? v : bb[1];
          bb[3] = v > bb[3] ? v : bb[3];
        }
      }
      return bb;
    },
    /**
     * Alias of {@link JXG.EventEmitter.on}.
     *
     * @name addEvent
     * @memberof JXG.GeometryElement
     * @function
     */
    addEvent: jxg_default.shortcut(jxg_default.GeometryElement.prototype, "on"),
    /**
     * Alias of {@link JXG.EventEmitter.off}.
     *
     * @name removeEvent
     * @memberof JXG.GeometryElement
     * @function
     */
    removeEvent: jxg_default.shortcut(jxg_default.GeometryElement.prototype, "off"),
    /**
     * Format a number according to the locale set in the attribute "intl".
     * If in the options of the intl-attribute "maximumFractionDigits" is not set,
     * the optional parameter digits is used instead.
     * See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat</a>
     * for more  information about internationalization.
     *
     * @param {Number} value Number to be formatted
     * @param {Number} [digits=undefined] Optional number of digits
     * @returns {String|Number} string containing the formatted number according to the locale
     * or the number itself of the formatting is not possible.
     */
    formatNumberLocale: function(value, digits) {
      var loc, opt, key, optCalc = {}, translate = {
        maximumfractiondigits: "maximumFractionDigits",
        minimumfractiondigits: "minimumFractionDigits",
        compactdisplay: "compactDisplay",
        currencydisplay: "currencyDisplay",
        currencysign: "currencySign",
        localematcher: "localeMatcher",
        numberingsystem: "numberingSystem",
        signdisplay: "signDisplay",
        unitdisplay: "unitDisplay",
        usegrouping: "useGrouping",
        roundingmode: "roundingMode",
        roundingpriority: "roundingPriority",
        roundingincrement: "roundingIncrement",
        trailingzerodisplay: "trailingZeroDisplay",
        minimumintegerdigits: "minimumIntegerDigits",
        minimumsignificantdigits: "minimumSignificantDigits",
        maximumsignificantdigits: "maximumSignificantDigits"
      };
      if (type_default.exists(Intl) && this.useLocale()) {
        loc = type_default.evaluate(this.visProp.intl.locale) || type_default.evaluate(this.board.attr.intl.locale);
        opt = type_default.evaluate(this.visProp.intl.options) || {};
        for (key in opt) {
          if (opt.hasOwnProperty(key)) {
            if (translate.hasOwnProperty(key)) {
              optCalc[translate[key]] = type_default.evaluate(opt[key]);
            } else {
              optCalc[key] = type_default.evaluate(opt[key]);
            }
          }
        }
        key = "maximumfractiondigits";
        if (!type_default.exists(opt[key])) {
          optCalc[translate[key]] = digits;
        }
        return Intl.NumberFormat(loc, optCalc).format(value);
      }
      return value;
    },
    /**
     * Checks if locale is enabled in the attribute. This may be in the attributes of the board,
     * or in the attributes of the text. The latter has higher priority. The board attribute is taken if
     * attribute "intl.enabled" of the text element is set to 'inherit'.
     *
     * @returns {Boolean} if locale can be used for number formatting.
     */
    useLocale: function() {
      var val;
      if (!type_default.exists(this.visProp.intl) || !type_default.exists(this.visProp.intl.enabled)) {
        return false;
      }
      val = type_default.evaluate(this.visProp.intl.enabled);
      if (val === true) {
        return true;
      }
      if (val === "inherit") {
        if (type_default.evaluate(this.board.attr.intl.enabled) === true) {
          return true;
        }
      }
      return false;
    },
    /* **************************
     *     EVENT DEFINITION
     * for documentation purposes
     * ************************** */
    //region Event handler documentation
    /**
     * @event
     * @description This event is fired whenever the user is hovering over an element.
     * @name JXG.GeometryElement#over
     * @param {Event} e The browser's event object.
     */
    __evt__over: function(e) {
    },
    /**
     * @event
     * @description This event is fired whenever the user puts the mouse over an element.
     * @name JXG.GeometryElement#mouseover
     * @param {Event} e The browser's event object.
     */
    __evt__mouseover: function(e) {
    },
    /**
     * @event
     * @description This event is fired whenever the user is leaving an element.
     * @name JXG.GeometryElement#out
     * @param {Event} e The browser's event object.
     */
    __evt__out: function(e) {
    },
    /**
     * @event
     * @description This event is fired whenever the user puts the mouse away from an element.
     * @name JXG.GeometryElement#mouseout
     * @param {Event} e The browser's event object.
     */
    __evt__mouseout: function(e) {
    },
    /**
     * @event
     * @description This event is fired whenever the user is moving over an element.
     * @name JXG.GeometryElement#move
     * @param {Event} e The browser's event object.
     */
    __evt__move: function(e) {
    },
    /**
     * @event
     * @description This event is fired whenever the user is moving the mouse over an element.
     * @name JXG.GeometryElement#mousemove
     * @param {Event} e The browser's event object.
     */
    __evt__mousemove: function(e) {
    },
    /**
     * @event
     * @description This event is fired whenever the user drags an element.
     * @name JXG.GeometryElement#drag
     * @param {Event} e The browser's event object.
     */
    __evt__drag: function(e) {
    },
    /**
     * @event
     * @description This event is fired whenever the user drags the element with a mouse.
     * @name JXG.GeometryElement#mousedrag
     * @param {Event} e The browser's event object.
     */
    __evt__mousedrag: function(e) {
    },
    /**
     * @event
     * @description This event is fired whenever the user drags the element with a pen.
     * @name JXG.GeometryElement#pendrag
     * @param {Event} e The browser's event object.
     */
    __evt__pendrag: function(e) {
    },
    /**
     * @event
     * @description This event is fired whenever the user drags the element on a touch device.
     * @name JXG.GeometryElement#touchdrag
     * @param {Event} e The browser's event object.
     */
    __evt__touchdrag: function(e) {
    },
    /**
     * @event
     * @description This event is fired whenever the user drags the element by pressing arrow keys
     * on the keyboard.
     * @name JXG.GeometryElement#keydrag
     * @param {Event} e The browser's event object.
     */
    __evt__keydrag: function(e) {
    },
    /**
     * @event
     * @description Whenever the user starts to touch or click an element.
     * @name JXG.GeometryElement#down
     * @param {Event} e The browser's event object.
     */
    __evt__down: function(e) {
    },
    /**
     * @event
     * @description Whenever the user starts to click an element.
     * @name JXG.GeometryElement#mousedown
     * @param {Event} e The browser's event object.
     */
    __evt__mousedown: function(e) {
    },
    /**
     * @event
     * @description Whenever the user taps an element with the pen.
     * @name JXG.GeometryElement#pendown
     * @param {Event} e The browser's event object.
     */
    __evt__pendown: function(e) {
    },
    /**
     * @event
     * @description Whenever the user starts to touch an element.
     * @name JXG.GeometryElement#touchdown
     * @param {Event} e The browser's event object.
     */
    __evt__touchdown: function(e) {
    },
    /**
     * @event
     * @description Whenever the user clicks on an element.
     * @name JXG.Board#click
     * @param {Event} e The browser's event object.
     */
    __evt__click: function(e) {
    },
    /**
     * @event
     * @description Whenever the user double clicks on an element.
     * This event works on desktop browser, but is undefined
     * on mobile browsers.
     * @name JXG.Board#dblclick
     * @param {Event} e The browser's event object.
     */
    __evt__dblclick: function(e) {
    },
    /**
     * @event
     * @description Whenever the user clicks on an element with a mouse device.
     * @name JXG.Board#mouseclick
     * @param {Event} e The browser's event object.
     */
    __evt__mouseclick: function(e) {
    },
    /**
     * @event
     * @description Whenever the user double clicks on an element with a mouse device.
     * @name JXG.Board#mousedblclick
     * @param {Event} e The browser's event object.
     */
    __evt__mousedblclick: function(e) {
    },
    /**
     * @event
     * @description Whenever the user clicks on an element with a pointer device.
     * @name JXG.Board#pointerclick
     * @param {Event} e The browser's event object.
     */
    __evt__pointerclick: function(e) {
    },
    /**
     * @event
     * @description Whenever the user double clicks on an element with a pointer device.
     * This event works on desktop browser, but is undefined
     * on mobile browsers.
     * @name JXG.Board#pointerdblclick
     * @param {Event} e The browser's event object.
     */
    __evt__pointerdblclick: function(e) {
    },
    /**
     * @event
     * @description Whenever the user stops to touch or click an element.
     * @name JXG.GeometryElement#up
     * @param {Event} e The browser's event object.
     */
    __evt__up: function(e) {
    },
    /**
     * @event
     * @description Whenever the user releases the mousebutton over an element.
     * @name JXG.GeometryElement#mouseup
     * @param {Event} e The browser's event object.
     */
    __evt__mouseup: function(e) {
    },
    /**
     * @event
     * @description Whenever the user lifts the pen over an element.
     * @name JXG.GeometryElement#penup
     * @param {Event} e The browser's event object.
     */
    __evt__penup: function(e) {
    },
    /**
     * @event
     * @description Whenever the user stops touching an element.
     * @name JXG.GeometryElement#touchup
     * @param {Event} e The browser's event object.
     */
    __evt__touchup: function(e) {
    },
    /**
     * @event
     * @description Notify every time an attribute is changed.
     * @name JXG.GeometryElement#attribute
     * @param {Object} o A list of changed attributes and their new value.
     * @param {Object} el Reference to the element
     */
    __evt__attribute: function(o, el) {
    },
    /**
     * @event
     * @description This is a generic event handler. It exists for every possible attribute that can be set for
     * any element, e.g. if you want to be notified everytime an element's strokecolor is changed, is the event
     * <tt>attribute:strokecolor</tt>.
     * @name JXG.GeometryElement#attribute:key
     * @param val The old value.
     * @param nval The new value
     * @param {Object} el Reference to the element
     */
    __evt__attribute_: function(val, nval, el) {
    },
    /**
     * @ignore
     */
    __evt: function() {
    }
    //endregion
  }
);
var element_default = jxg_default.GeometryElement;

// node_modules/jsxgraph/src/base/coordselement.js
jxg_default.CoordsElement = function(coordinates, isLabel) {
  var i2;
  if (!type_default.exists(coordinates)) {
    coordinates = [1, 0, 0];
  }
  for (i2 = 0; i2 < coordinates.length; ++i2) {
    coordinates[i2] = parseFloat(coordinates[i2]);
  }
  this.coords = new coords_default(constants_default.COORDS_BY_USER, coordinates, this.board);
  this.initialCoords = new coords_default(constants_default.COORDS_BY_USER, coordinates, this.board);
  this.position = null;
  this.isConstrained = false;
  this.onPolygon = false;
  this.slideObject = null;
  this.slideObjects = [];
  this.needsUpdateFromParent = true;
  this.groups = [];
  this.Xjc = null;
  this.Yjc = null;
  this.methodMap = type_default.deepCopy(this.methodMap, {
    move: "moveTo",
    moveTo: "moveTo",
    moveAlong: "moveAlong",
    visit: "visit",
    glide: "makeGlider",
    makeGlider: "makeGlider",
    intersect: "makeIntersection",
    makeIntersection: "makeIntersection",
    X: "X",
    Y: "Y",
    Coords: "Coords",
    free: "free",
    setPosition: "setGliderPosition",
    setGliderPosition: "setGliderPosition",
    addConstraint: "addConstraint",
    dist: "Dist",
    Dist: "Dist",
    onPolygon: "onPolygon",
    startAnimation: "startAnimation",
    stopAnimation: "stopAnimation"
  });
  if (type_default.exists(this.element)) {
    this.addAnchor(coordinates, isLabel);
  }
  this.isDraggable = true;
};
jxg_default.extend(
  jxg_default.CoordsElement.prototype,
  /** @lends JXG.CoordsElement.prototype */
  {
    /**
     * Dummy function for unconstrained points or gliders.
     * @private
     */
    updateConstraint: function() {
      return this;
    },
    /**
     * Updates the coordinates of the element.
     * @private
     */
    updateCoords: function(fromParent) {
      if (!this.needsUpdate) {
        return this;
      }
      if (!type_default.exists(fromParent)) {
        fromParent = false;
      }
      if (!type_default.evaluate(this.visProp.frozen)) {
        this.updateConstraint();
      }
      if (this.type === constants_default.OBJECT_TYPE_GLIDER) {
        if (this.isConstrained) {
          fromParent = false;
        }
        if (fromParent) {
          this.updateGliderFromParent();
        } else {
          this.updateGlider();
        }
      }
      this.updateTransform(fromParent);
      return this;
    },
    /**
     * Update of glider in case of dragging the glider or setting the postion of the glider.
     * The relative position of the glider has to be updated.
     *
     * In case of a glider on a line:
     * If the second point is an ideal point, then -1 < this.position < 1,
     * this.position==+/-1 equals point2, this.position==0 equals point1
     *
     * If the first point is an ideal point, then 0 < this.position < 2
     * this.position==0  or 2 equals point1, this.position==1 equals point2
     *
     * @private
     */
    updateGlider: function() {
      var i2, d, v, p1c, p2c, poly, cc, pos, angle, sgn, alpha, beta, delta = 2 * Math.PI, cp, c, invMat, newCoords, newPos, doRound = false, ev_sw, snappedTo, snapValues, slide = this.slideObject, res, cu, slides = [], isTransformed;
      this.needsUpdateFromParent = false;
      if (slide.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
        if (type_default.evaluate(this.visProp.isgeonext)) {
          delta = 1;
        }
        newCoords = geometry_default.projectPointToCircle(this, slide, this.board);
        newPos = geometry_default.rad(
          [slide.center.X() + 1, slide.center.Y()],
          slide.center,
          this
        ) / delta;
      } else if (slide.elementClass === constants_default.OBJECT_CLASS_LINE) {
        if (this.onPolygon) {
          p1c = slide.point1.coords.usrCoords;
          p2c = slide.point2.coords.usrCoords;
          i2 = 1;
          d = p2c[i2] - p1c[i2];
          if (Math.abs(d) < math_default.eps) {
            i2 = 2;
            d = p2c[i2] - p1c[i2];
          }
          cc = geometry_default.projectPointToLine(this, slide, this.board);
          pos = (cc.usrCoords[i2] - p1c[i2]) / d;
          poly = slide.parentPolygon;
          if (pos < 0) {
            for (i2 = 0; i2 < poly.borders.length; i2++) {
              if (slide === poly.borders[i2]) {
                slide = poly.borders[(i2 - 1 + poly.borders.length) % poly.borders.length];
                break;
              }
            }
          } else if (pos > 1) {
            for (i2 = 0; i2 < poly.borders.length; i2++) {
              if (slide === poly.borders[i2]) {
                slide = poly.borders[(i2 + 1 + poly.borders.length) % poly.borders.length];
                break;
              }
            }
          }
          if (slide.id !== this.slideObject.id) {
            this.slideObject = slide;
          }
        }
        p1c = slide.point1.coords;
        p2c = slide.point2.coords;
        d = p1c.distance(constants_default.COORDS_BY_USER, p2c);
        if (d < math_default.eps) {
          newCoords = p1c;
          doRound = true;
          newPos = 0;
        } else {
          newCoords = geometry_default.projectPointToLine(this, slide, this.board);
          p1c = p1c.usrCoords.slice(0);
          p2c = p2c.usrCoords.slice(0);
          if (Math.abs(p2c[0]) < math_default.eps) {
            i2 = 1;
            d = p2c[i2];
            if (Math.abs(d) < math_default.eps) {
              i2 = 2;
              d = p2c[i2];
            }
            d = (newCoords.usrCoords[i2] - p1c[i2]) / d;
            sgn = d >= 0 ? 1 : -1;
            d = Math.abs(d);
            newPos = sgn * d / (d + 1);
          } else if (Math.abs(p1c[0]) < math_default.eps) {
            i2 = 1;
            d = p1c[i2];
            if (Math.abs(d) < math_default.eps) {
              i2 = 2;
              d = p1c[i2];
            }
            d = (newCoords.usrCoords[i2] - p2c[i2]) / d;
            if (d < 0) {
              newPos = (1 - 2 * d) / (1 - d);
            } else {
              newPos = 1 / (d + 1);
            }
          } else {
            i2 = 1;
            d = p2c[i2] - p1c[i2];
            if (Math.abs(d) < math_default.eps) {
              i2 = 2;
              d = p2c[i2] - p1c[i2];
            }
            newPos = (newCoords.usrCoords[i2] - p1c[i2]) / d;
          }
        }
        snappedTo = this.findClosestSnapValue(newPos);
        if (snappedTo !== null) {
          snapValues = type_default.evaluate(this.visProp.snapvalues);
          newPos = (snapValues[snappedTo] - this._smin) / (this._smax - this._smin);
          this.update(true);
        } else {
          ev_sw = type_default.evaluate(this.visProp.snapwidth);
          if (type_default.evaluate(ev_sw) > 0 && Math.abs(this._smax - this._smin) >= math_default.eps) {
            newPos = Math.max(Math.min(newPos, 1), 0);
            v = newPos * (this._smax - this._smin) + this._smin;
            v = Math.round(v / ev_sw) * ev_sw;
            newPos = (v - this._smin) / (this._smax - this._smin);
            this.update(true);
          }
        }
        p1c = slide.point1.coords;
        if (!type_default.evaluate(slide.visProp.straightfirst) && Math.abs(p1c.usrCoords[0]) > math_default.eps && newPos < 0) {
          newCoords = p1c;
          doRound = true;
          newPos = 0;
        }
        p2c = slide.point2.coords;
        if (!type_default.evaluate(slide.visProp.straightlast) && Math.abs(p2c.usrCoords[0]) > math_default.eps && newPos > 1) {
          newCoords = p2c;
          doRound = true;
          newPos = 1;
        }
      } else if (slide.type === constants_default.OBJECT_TYPE_TURTLE) {
        this.updateConstraint();
        res = geometry_default.projectPointToTurtle(this, slide, this.board);
        newCoords = res[0];
        newPos = res[1];
      } else if (slide.elementClass === constants_default.OBJECT_CLASS_CURVE) {
        if (slide.type === constants_default.OBJECT_TYPE_ARC || slide.type === constants_default.OBJECT_TYPE_SECTOR) {
          newCoords = geometry_default.projectPointToCircle(this, slide, this.board);
          angle = geometry_default.rad(slide.radiuspoint, slide.center, this);
          alpha = 0;
          beta = geometry_default.rad(slide.radiuspoint, slide.center, slide.anglepoint);
          newPos = angle;
          ev_sw = type_default.evaluate(slide.visProp.selection);
          if (ev_sw === "minor" && beta > Math.PI || ev_sw === "major" && beta < Math.PI) {
            alpha = beta;
            beta = 2 * Math.PI;
          }
          if (angle < alpha || angle > beta) {
            newPos = beta;
            if (angle < alpha && angle > alpha * 0.5 || angle > beta && angle > beta * 0.5 + Math.PI) {
              newPos = alpha;
            }
            this.needsUpdateFromParent = true;
            this.updateGliderFromParent();
          }
          delta = beta - alpha;
          if (this.visProp.isgeonext) {
            delta = 1;
          }
          if (Math.abs(delta) > math_default.eps) {
            newPos /= delta;
          }
        } else {
          this.updateConstraint();
          if (slide.transformations.length > 0) {
            isTransformed = false;
            res = slide.getTransformationSource();
            if (res[0]) {
              isTransformed = res[0];
              slides.push(slide);
              slides.push(res[1]);
            }
            while (res[0] && type_default.exists(res[1]._transformationSource)) {
              res = res[1].getTransformationSource();
              slides.push(res[1]);
            }
            cu = this.coords.usrCoords;
            if (isTransformed) {
              for (i2 = 0; i2 < slides.length; i2++) {
                slides[i2].updateTransformMatrix();
                invMat = math_default.inverse(slides[i2].transformMat);
                cu = math_default.matVecMult(invMat, cu);
              }
              cp = new coords_default(constants_default.COORDS_BY_USER, cu, this.board).usrCoords;
              c = geometry_default.projectCoordsToCurve(
                cp[1],
                cp[2],
                this.position || 0,
                slides[slides.length - 1],
                this.board
              );
              cu = c[0].usrCoords;
              for (i2 = slides.length - 2; i2 >= 0; i2--) {
                cu = math_default.matVecMult(slides[i2].transformMat, cu);
              }
              c[0] = new coords_default(constants_default.COORDS_BY_USER, cu, this.board);
            } else {
              slide.updateTransformMatrix();
              invMat = math_default.inverse(slide.transformMat);
              cu = math_default.matVecMult(invMat, cu);
              cp = new coords_default(constants_default.COORDS_BY_USER, cu, this.board).usrCoords;
              c = geometry_default.projectCoordsToCurve(
                cp[1],
                cp[2],
                this.position || 0,
                slide,
                this.board
              );
            }
            newCoords = c[0];
            newPos = c[1];
          } else {
            res = geometry_default.projectPointToCurve(this, slide, this.board);
            newCoords = res[0];
            newPos = res[1];
          }
        }
      } else if (type_default.isPoint(slide)) {
        newCoords = geometry_default.projectPointToPoint(this, slide, this.board);
        newPos = this.position;
      }
      this.coords.setCoordinates(constants_default.COORDS_BY_USER, newCoords.usrCoords, doRound);
      this.position = newPos;
    },
    /**
     * Find the closest entry in snapValues that is within snapValueDistance of pos.
     *
     * @param {Number} pos Value for which snapping is calculated.
     * @returns {Number} Index of the value to snap to, or null.
     * @private
     */
    findClosestSnapValue: function(pos) {
      var i2, d, snapValues, snapValueDistance, snappedTo = null;
      snapValues = type_default.evaluate(this.visProp.snapvalues);
      snapValueDistance = type_default.evaluate(this.visProp.snapvaluedistance);
      if (type_default.isArray(snapValues) && Math.abs(this._smax - this._smin) >= math_default.eps && snapValueDistance > 0) {
        for (i2 = 0; i2 < snapValues.length; i2++) {
          d = Math.abs(pos * (this._smax - this._smin) + this._smin - snapValues[i2]);
          if (d < snapValueDistance) {
            snapValueDistance = d;
            snappedTo = i2;
          }
        }
      }
      return snappedTo;
    },
    /**
     * Update of a glider in case a parent element has been updated. That means the
     * relative position of the glider stays the same.
     * @private
     */
    updateGliderFromParent: function() {
      var p1c, p2c, r, lbda, c, slide = this.slideObject, slides = [], res, i2, isTransformed, baseangle, alpha, angle, beta, delta = 2 * Math.PI;
      if (!this.needsUpdateFromParent) {
        this.needsUpdateFromParent = true;
        return;
      }
      if (slide.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
        r = slide.Radius();
        if (type_default.evaluate(this.visProp.isgeonext)) {
          delta = 1;
        }
        c = [
          slide.center.X() + r * Math.cos(this.position * delta),
          slide.center.Y() + r * Math.sin(this.position * delta)
        ];
      } else if (slide.elementClass === constants_default.OBJECT_CLASS_LINE) {
        p1c = slide.point1.coords.usrCoords;
        p2c = slide.point2.coords.usrCoords;
        if (p1c[0] === 0 && p1c[1] === 0 && p1c[2] === 0 || p2c[0] === 0 && p2c[1] === 0 && p2c[2] === 0) {
          c = [0, 0, 0];
        } else if (Math.abs(p2c[0]) < math_default.eps) {
          lbda = Math.min(Math.abs(this.position), 1 - math_default.eps);
          lbda /= 1 - lbda;
          if (this.position < 0) {
            lbda = -lbda;
          }
          c = [
            p1c[0] + lbda * p2c[0],
            p1c[1] + lbda * p2c[1],
            p1c[2] + lbda * p2c[2]
          ];
        } else if (Math.abs(p1c[0]) < math_default.eps) {
          lbda = Math.max(this.position, math_default.eps);
          lbda = Math.min(lbda, 2 - math_default.eps);
          if (lbda > 1) {
            lbda = (lbda - 1) / (lbda - 2);
          } else {
            lbda = (1 - lbda) / lbda;
          }
          c = [
            p2c[0] + lbda * p1c[0],
            p2c[1] + lbda * p1c[1],
            p2c[2] + lbda * p1c[2]
          ];
        } else {
          lbda = this.position;
          c = [
            p1c[0] + lbda * (p2c[0] - p1c[0]),
            p1c[1] + lbda * (p2c[1] - p1c[1]),
            p1c[2] + lbda * (p2c[2] - p1c[2])
          ];
        }
      } else if (slide.type === constants_default.OBJECT_TYPE_TURTLE) {
        this.coords.setCoordinates(constants_default.COORDS_BY_USER, [
          slide.Z(this.position),
          slide.X(this.position),
          slide.Y(this.position)
        ]);
        this.updateConstraint();
        c = geometry_default.projectPointToTurtle(this, slide, this.board)[0].usrCoords;
      } else if (slide.elementClass === constants_default.OBJECT_CLASS_CURVE) {
        isTransformed = false;
        res = slide.getTransformationSource();
        if (res[0]) {
          isTransformed = res[0];
          slides.push(slide);
          slides.push(res[1]);
        }
        while (res[0] && type_default.exists(res[1]._transformationSource)) {
          res = res[1].getTransformationSource();
          slides.push(res[1]);
        }
        if (isTransformed) {
          this.coords.setCoordinates(constants_default.COORDS_BY_USER, [
            slides[slides.length - 1].Z(this.position),
            slides[slides.length - 1].X(this.position),
            slides[slides.length - 1].Y(this.position)
          ]);
        } else {
          this.coords.setCoordinates(constants_default.COORDS_BY_USER, [
            slide.Z(this.position),
            slide.X(this.position),
            slide.Y(this.position)
          ]);
        }
        if (slide.type === constants_default.OBJECT_TYPE_ARC || slide.type === constants_default.OBJECT_TYPE_SECTOR) {
          baseangle = geometry_default.rad(
            [slide.center.X() + 1, slide.center.Y()],
            slide.center,
            slide.radiuspoint
          );
          alpha = 0;
          beta = geometry_default.rad(slide.radiuspoint, slide.center, slide.anglepoint);
          if (slide.visProp.selection === "minor" && beta > Math.PI || slide.visProp.selection === "major" && beta < Math.PI) {
            alpha = beta;
            beta = 2 * Math.PI;
          }
          delta = beta - alpha;
          if (type_default.evaluate(this.visProp.isgeonext)) {
            delta = 1;
          }
          angle = this.position * delta;
          if (angle < alpha || angle > beta) {
            angle = beta;
            if (angle < alpha && angle > alpha * 0.5 || angle > beta && angle > beta * 0.5 + Math.PI) {
              angle = alpha;
            }
            this.position = angle;
            if (Math.abs(delta) > math_default.eps) {
              this.position /= delta;
            }
          }
          r = slide.Radius();
          c = [
            slide.center.X() + r * Math.cos(this.position * delta + baseangle),
            slide.center.Y() + r * Math.sin(this.position * delta + baseangle)
          ];
        } else {
          this.updateConstraint();
          if (isTransformed) {
            c = geometry_default.projectPointToCurve(
              this,
              slides[slides.length - 1],
              this.board
            )[0].usrCoords;
            for (i2 = slides.length - 2; i2 >= 0; i2--) {
              c = new coords_default(
                constants_default.COORDS_BY_USER,
                math_default.matVecMult(slides[i2].transformMat, c),
                this.board
              ).usrCoords;
            }
          } else {
            c = geometry_default.projectPointToCurve(this, slide, this.board)[0].usrCoords;
          }
        }
      } else if (type_default.isPoint(slide)) {
        c = geometry_default.projectPointToPoint(this, slide, this.board).usrCoords;
      }
      this.coords.setCoordinates(constants_default.COORDS_BY_USER, c, false);
    },
    updateRendererGeneric: function(rendererMethod) {
      if (!this.needsUpdate || !this.board.renderer) {
        return this;
      }
      if (this.visPropCalc.visible) {
        this.isReal = !isNaN(this.coords.usrCoords[1] + this.coords.usrCoords[2]);
        this.isReal = Math.abs(this.coords.usrCoords[0]) > math_default.eps ? this.isReal : false;
        if (
          // wasReal &&
          !this.isReal
        ) {
          this.updateVisibility(false);
        }
      }
      if (this.visPropCalc.visible) {
        this.board.renderer[rendererMethod](this);
      }
      if (this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal) {
        this.label.update();
        this.board.renderer.updateText(this.label);
      }
      this.setDisplayRendNode();
      this.needsUpdate = false;
      return this;
    },
    /**
     * Getter method for x, this is used by for CAS-points to access point coordinates.
     * @returns {Number} User coordinate of point in x direction.
     */
    X: function() {
      return this.coords.usrCoords[1];
    },
    /**
     * Getter method for y, this is used by CAS-points to access point coordinates.
     * @returns {Number} User coordinate of point in y direction.
     */
    Y: function() {
      return this.coords.usrCoords[2];
    },
    /**
     * Getter method for z, this is used by CAS-points to access point coordinates.
     * @returns {Number} User coordinate of point in z direction.
     */
    Z: function() {
      return this.coords.usrCoords[0];
    },
    /**
     * Getter method for coordinates x, y and (optional) z.
     * @param {Number|String} [digits='auto'] Truncating rule for the digits in the infobox.
     * <ul>
     * <li>'auto': done automatically by JXG.autoDigits()
     * <li>'none': no truncation
     * <li>number: truncate after "number digits" with JXG.toFixed()
     * </ul>
     * @param {Boolean} [withZ=false] If set to true the return value will be <tt>(x | y | z)</tt> instead of <tt>(x, y)</tt>.
     * @returns {String} User coordinates of point.
     */
    Coords: function(withZ) {
      if (withZ) {
        return this.coords.usrCoords.slice();
      }
      return this.coords.usrCoords.slice(1);
    },
    // Coords: function (digits, withZ) {
    //     var arr, sep;
    //     digits = digits || 'auto';
    //     if (withZ) {
    //         sep = ' | ';
    //     } else {
    //         sep = ', ';
    //     }
    //     if (digits === 'none') {
    //         arr = [this.X(), sep, this.Y()];
    //         if (withZ) {
    //             arr.push(sep, this.Z());
    //         }
    //     } else if (digits === 'auto') {
    //         if (this.useLocale()) {
    //             arr = [this.formatNumberLocale(this.X()), sep, this.formatNumberLocale(this.Y())];
    //             if (withZ) {
    //                 arr.push(sep, this.formatNumberLocale(this.Z()));
    //             }
    //         } else {
    //             arr = [Type.autoDigits(this.X()), sep, Type.autoDigits(this.Y())];
    //             if (withZ) {
    //                 arr.push(sep, Type.autoDigits(this.Z()));
    //             }
    //         }
    //     } else {
    //         if (this.useLocale()) {
    //             arr = [this.formatNumberLocale(this.X(), digits), sep, this.formatNumberLocale(this.Y(), digits)];
    //             if (withZ) {
    //                 arr.push(sep, this.formatNumberLocale(this.Z(), digits));
    //             }
    //         } else {
    //             arr = [Type.toFixed(this.X(), digits), sep, Type.toFixed(this.Y(), digits)];
    //             if (withZ) {
    //                 arr.push(sep, Type.toFixed(this.Z(), digits));
    //             }
    //         }
    //     }
    //     return '(' + arr.join('') + ')';
    // },
    /**
     * New evaluation of the function term.
     * This is required for CAS-points: Their XTerm() method is
     * overwritten in {@link JXG.CoordsElement#addConstraint}.
     *
     * @returns {Number} User coordinate of point in x direction.
     * @private
     */
    XEval: function() {
      return this.coords.usrCoords[1];
    },
    /**
     * New evaluation of the function term.
     * This is required for CAS-points: Their YTerm() method is overwritten
     * in {@link JXG.CoordsElement#addConstraint}.
     *
     * @returns {Number} User coordinate of point in y direction.
     * @private
     */
    YEval: function() {
      return this.coords.usrCoords[2];
    },
    /**
     * New evaluation of the function term.
     * This is required for CAS-points: Their ZTerm() method is overwritten in
     * {@link JXG.CoordsElement#addConstraint}.
     *
     * @returns {Number} User coordinate of point in z direction.
     * @private
     */
    ZEval: function() {
      return this.coords.usrCoords[0];
    },
    /**
     * Getter method for the distance to a second point, this is required for CAS-elements.
     * Here, function inlining seems to be worthwile (for plotting).
     * @param {JXG.Point} point2 The point to which the distance shall be calculated.
     * @returns {Number} Distance in user coordinate to the given point
     */
    Dist: function(point2) {
      if (this.isReal && point2.isReal) {
        return this.coords.distance(constants_default.COORDS_BY_USER, point2.coords);
      }
      return NaN;
    },
    /**
     * Alias for {@link JXG.Element#handleSnapToGrid}
     * @param {Boolean} force force snapping independent of what the snaptogrid attribute says
     * @returns {JXG.CoordsElement} Reference to this element
     */
    snapToGrid: function(force) {
      return this.handleSnapToGrid(force);
    },
    /**
     * Let a point snap to the nearest point in distance of
     * {@link JXG.Point#attractorDistance}.
     * The function uses the coords object of the point as
     * its actual position.
     * @param {Boolean} force force snapping independent of what the snaptogrid attribute says
     * @returns {JXG.Point} Reference to this element
     */
    handleSnapToPoints: function(force) {
      var i2, pEl, pCoords, d = 0, len, dMax = Infinity, c = null, ev_au, ev_ad, ev_is2p = type_default.evaluate(this.visProp.ignoredsnaptopoints), len2, j, ignore = false;
      len = this.board.objectsList.length;
      if (ev_is2p) {
        len2 = ev_is2p.length;
      }
      if (type_default.evaluate(this.visProp.snaptopoints) || force) {
        ev_au = type_default.evaluate(this.visProp.attractorunit);
        ev_ad = type_default.evaluate(this.visProp.attractordistance);
        for (i2 = 0; i2 < len; i2++) {
          pEl = this.board.objectsList[i2];
          if (ev_is2p) {
            ignore = false;
            for (j = 0; j < len2; j++) {
              if (pEl === this.board.select(ev_is2p[j])) {
                ignore = true;
                break;
              }
            }
            if (ignore) {
              continue;
            }
          }
          if (type_default.isPoint(pEl) && pEl !== this && pEl.visPropCalc.visible) {
            pCoords = geometry_default.projectPointToPoint(this, pEl, this.board);
            if (ev_au === "screen") {
              d = pCoords.distance(constants_default.COORDS_BY_SCREEN, this.coords);
            } else {
              d = pCoords.distance(constants_default.COORDS_BY_USER, this.coords);
            }
            if (d < ev_ad && d < dMax) {
              dMax = d;
              c = pCoords;
            }
          }
        }
        if (c !== null) {
          this.coords.setCoordinates(constants_default.COORDS_BY_USER, c.usrCoords);
        }
      }
      return this;
    },
    /**
     * Alias for {@link JXG.CoordsElement#handleSnapToPoints}.
     *
     * @param {Boolean} force force snapping independent of what the snaptogrid attribute says
     * @returns {JXG.Point} Reference to this element
     */
    snapToPoints: function(force) {
      return this.handleSnapToPoints(force);
    },
    /**
     * A point can change its type from free point to glider
     * and vice versa. If it is given an array of attractor elements
     * (attribute attractors) and the attribute attractorDistance
     * then the point will be made a glider if it less than attractorDistance
     * apart from one of its attractor elements.
     * If attractorDistance is equal to zero, the point stays in its
     * current form.
     * @returns {JXG.Point} Reference to this element
     */
    handleAttractors: function() {
      var i2, el, projCoords, d = 0, projection, ev_au = type_default.evaluate(this.visProp.attractorunit), ev_ad = type_default.evaluate(this.visProp.attractordistance), ev_sd = type_default.evaluate(this.visProp.snatchdistance), ev_a = type_default.evaluate(this.visProp.attractors), len = ev_a.length;
      if (ev_ad === 0) {
        return;
      }
      for (i2 = 0; i2 < len; i2++) {
        el = this.board.select(ev_a[i2]);
        if (type_default.exists(el) && el !== this) {
          if (type_default.isPoint(el)) {
            projCoords = geometry_default.projectPointToPoint(this, el, this.board);
          } else if (el.elementClass === constants_default.OBJECT_CLASS_LINE) {
            projection = geometry_default.projectCoordsToSegment(
              this.coords.usrCoords,
              el.point1.coords.usrCoords,
              el.point2.coords.usrCoords
            );
            if (!type_default.evaluate(el.visProp.straightfirst) && projection[1] < 0) {
              projCoords = el.point1.coords;
            } else if (!type_default.evaluate(el.visProp.straightlast) && projection[1] > 1) {
              projCoords = el.point2.coords;
            } else {
              projCoords = new coords_default(
                constants_default.COORDS_BY_USER,
                projection[0],
                this.board
              );
            }
          } else if (el.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
            projCoords = geometry_default.projectPointToCircle(this, el, this.board);
          } else if (el.elementClass === constants_default.OBJECT_CLASS_CURVE) {
            projCoords = geometry_default.projectPointToCurve(this, el, this.board)[0];
          } else if (el.type === constants_default.OBJECT_TYPE_TURTLE) {
            projCoords = geometry_default.projectPointToTurtle(this, el, this.board)[0];
          } else if (el.type === constants_default.OBJECT_TYPE_POLYGON) {
            projCoords = new coords_default(
              constants_default.COORDS_BY_USER,
              geometry_default.projectCoordsToPolygon(this.coords.usrCoords, el),
              this.board
            );
          }
          if (ev_au === "screen") {
            d = projCoords.distance(constants_default.COORDS_BY_SCREEN, this.coords);
          } else {
            d = projCoords.distance(constants_default.COORDS_BY_USER, this.coords);
          }
          if (d < ev_ad) {
            if (!(this.type === constants_default.OBJECT_TYPE_GLIDER && (el === this.slideObject || this.slideObject && this.onPolygon && this.slideObject.parentPolygon === el))) {
              this.makeGlider(el);
            }
            break;
          }
          if (d >= ev_sd && (el === this.slideObject || this.slideObject && this.onPolygon && this.slideObject.parentPolygon === el)) {
            this.popSlideObject();
          }
        }
      }
      return this;
    },
    /**
     * Sets coordinates and calls the point's update() method.
     * @param {Number} method The type of coordinates used here.
     * Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.
     * @param {Array} coords coordinates <tt>([z], x, y)</tt> in screen/user units
     * @returns {JXG.Point} this element
     */
    setPositionDirectly: function(method, coords) {
      var i2, c, dc, oldCoords = this.coords, newCoords;
      if (this.relativeCoords) {
        c = new coords_default(method, coords, this.board);
        if (type_default.evaluate(this.visProp.islabel)) {
          dc = statistics_default.subtract(c.scrCoords, oldCoords.scrCoords);
          this.relativeCoords.scrCoords[1] += dc[1];
          this.relativeCoords.scrCoords[2] += dc[2];
        } else {
          dc = statistics_default.subtract(c.usrCoords, oldCoords.usrCoords);
          this.relativeCoords.usrCoords[1] += dc[1];
          this.relativeCoords.usrCoords[2] += dc[2];
        }
        return this;
      }
      this.coords.setCoordinates(method, coords);
      this.handleSnapToGrid();
      this.handleSnapToPoints();
      this.handleAttractors();
      for (i2 = this.transformations.length - 1; i2 >= 0; i2--) {
        if (method === constants_default.COORDS_BY_SCREEN) {
          newCoords = new coords_default(method, coords, this.board).usrCoords;
        } else {
          if (coords.length === 2) {
            coords = [1].concat(coords);
          }
          newCoords = coords;
        }
        this.initialCoords.setCoordinates(
          constants_default.COORDS_BY_USER,
          math_default.matVecMult(math_default.inverse(this.transformations[i2].matrix), newCoords)
        );
      }
      this.prepareUpdate().update();
      if (this.board.isSuspendedUpdate && this.type === constants_default.OBJECT_TYPE_GLIDER) {
        this.updateGlider();
      }
      return this;
    },
    /**
     * Translates the point by <tt>tv = (x, y)</tt>.
     * @param {Number} method The type of coordinates used here.
     * Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.
     * @param {Array} tv (x, y)
     * @returns {JXG.Point}
     */
    setPositionByTransform: function(method, tv) {
      var t;
      tv = new coords_default(method, tv, this.board);
      t = this.board.create("transform", tv.usrCoords.slice(1), {
        type: "translate"
      });
      if (this.transformations.length > 0 && this.transformations[this.transformations.length - 1].isNumericMatrix) {
        this.transformations[this.transformations.length - 1].melt(t);
      } else {
        this.addTransform(this, t);
      }
      this.prepareUpdate().update();
      return this;
    },
    /**
     * Sets coordinates and calls the point's update() method.
     * @param {Number} method The type of coordinates used here.
     * Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.
     * @param {Array} coords coordinates in screen/user units
     * @returns {JXG.Point}
     */
    setPosition: function(method, coords) {
      return this.setPositionDirectly(method, coords);
    },
    /**
     * Sets the position of a glider relative to the defining elements
     * of the {@link JXG.Point#slideObject}.
     * @param {Number} x
     * @returns {JXG.Point} Reference to the point element.
     */
    setGliderPosition: function(x) {
      if (this.type === constants_default.OBJECT_TYPE_GLIDER) {
        this.position = x;
        this.board.update();
      }
      return this;
    },
    /**
     * Convert the point to glider and update the construction.
     * To move the point visual onto the glider, a call of board update is necessary.
     * @param {String|Object} slide The object the point will be bound to.
     */
    makeGlider: function(slide) {
      var slideobj = this.board.select(slide), onPolygon = false, min, i2, dist;
      if (slideobj.type === constants_default.OBJECT_TYPE_POLYGON) {
        min = Number.MAX_VALUE;
        for (i2 = 0; i2 < slideobj.borders.length; i2++) {
          dist = jxg_default.Math.Geometry.distPointLine(
            this.coords.usrCoords,
            slideobj.borders[i2].stdform
          );
          if (dist < min) {
            min = dist;
            slide = slideobj.borders[i2];
          }
        }
        slideobj = this.board.select(slide);
        onPolygon = true;
      }
      if (!type_default.exists(slideobj)) {
        throw new Error("JSXGraph: slide object undefined.");
      } else if (slideobj.type === constants_default.OBJECT_TYPE_TICKS) {
        throw new Error("JSXGraph: gliders on ticks are not possible.");
      }
      this.slideObject = this.board.select(slide);
      this.slideObjects.push(this.slideObject);
      this.addParents(slide);
      this.type = constants_default.OBJECT_TYPE_GLIDER;
      this.elType = "glider";
      this.visProp.snapwidth = -1;
      this.slideObject.addChild(this);
      this.isDraggable = true;
      this.onPolygon = onPolygon;
      this.generatePolynomial = function() {
        return this.slideObject.generatePolynomial(this);
      };
      this.updateGlider();
      this.needsUpdateFromParent = true;
      this.updateGliderFromParent();
      return this;
    },
    /**
     * Remove the last slideObject. If there are more than one elements the point is bound to,
     * the second last element is the new active slideObject.
     */
    popSlideObject: function() {
      if (this.slideObjects.length > 0) {
        this.slideObjects.pop();
        this.slideObject.removeChild(this);
        if (this.slideObjects.length === 0) {
          this.type = this._org_type;
          if (this.type === constants_default.OBJECT_TYPE_POINT) {
            this.elType = "point";
          } else if (this.elementClass === constants_default.OBJECT_CLASS_TEXT) {
            this.elType = "text";
          } else if (this.type === constants_default.OBJECT_TYPE_IMAGE) {
            this.elType = "image";
          } else if (this.type === constants_default.OBJECT_TYPE_FOREIGNOBJECT) {
            this.elType = "foreignobject";
          }
          this.slideObject = null;
        } else {
          this.slideObject = this.slideObjects[this.slideObjects.length - 1];
        }
      }
    },
    /**
     * Converts a calculated element into a free element,
     * i.e. it will delete all ancestors and transformations and,
     * if the element is currently a glider, will remove the slideObject reference.
     */
    free: function() {
      var ancestorId, ancestor;
      if (this.type !== constants_default.OBJECT_TYPE_GLIDER) {
        this.transformations.length = 0;
        delete this.updateConstraint;
        this.isConstrained = false;
        if (!this.isDraggable) {
          this.isDraggable = true;
          if (this.elementClass === constants_default.OBJECT_CLASS_POINT) {
            this.type = constants_default.OBJECT_TYPE_POINT;
            this.elType = "point";
          }
          this.XEval = function() {
            return this.coords.usrCoords[1];
          };
          this.YEval = function() {
            return this.coords.usrCoords[2];
          };
          this.ZEval = function() {
            return this.coords.usrCoords[0];
          };
          this.Xjc = null;
          this.Yjc = null;
        } else {
          return;
        }
      }
      for (ancestorId in this.board.objects) {
        if (this.board.objects.hasOwnProperty(ancestorId)) {
          ancestor = this.board.objects[ancestorId];
          if (ancestor.descendants) {
            delete ancestor.descendants[this.id];
            delete ancestor.childElements[this.id];
            if (this.hasLabel) {
              delete ancestor.descendants[this.label.id];
              delete ancestor.childElements[this.label.id];
            }
          }
        }
      }
      this.ancestors = {};
      this.parents = [];
      this.slideObject = null;
      this.slideObjects = [];
      if (this.elementClass === constants_default.OBJECT_CLASS_POINT) {
        this.type = constants_default.OBJECT_TYPE_POINT;
        this.elType = "point";
      } else if (this.elementClass === constants_default.OBJECT_CLASS_TEXT) {
        this.type = this._org_type;
        this.elType = "text";
      } else if (this.elementClass === constants_default.OBJECT_CLASS_OTHER) {
        this.type = this._org_type;
        this.elType = "image";
      }
    },
    /**
     * Convert the point to CAS point and call update().
     * @param {Array} terms [[zterm], xterm, yterm] defining terms for the z, x and y coordinate.
     * The z-coordinate is optional and it is used for homogeneous coordinates.
     * The coordinates may be either <ul>
     *   <li>a JavaScript function,</li>
     *   <li>a string containing GEONExT syntax. This string will be converted into a JavaScript
     *     function here,</li>
     *   <li>a Number</li>
     *   <li>a pointer to a slider object. This will be converted into a call of the Value()-method
     *     of this slider.</li>
     *   </ul>
     * @see JXG.GeonextParser#geonext2JS
     */
    addConstraint: function(terms) {
      var i2, v, newfuncs = [], what = ["X", "Y"], makeConstFunction = function(z) {
        return function() {
          return z;
        };
      }, makeSliderFunction = function(a) {
        return function() {
          return a.Value();
        };
      };
      if (this.elementClass === constants_default.OBJECT_CLASS_POINT) {
        this.type = constants_default.OBJECT_TYPE_CAS;
      }
      this.isDraggable = false;
      for (i2 = 0; i2 < terms.length; i2++) {
        v = terms[i2];
        if (type_default.isString(v)) {
          newfuncs[i2] = this.board.jc.snippet(v, true, null, true);
          this.addParentsFromJCFunctions([newfuncs[i2]]);
          if (terms.length === 2) {
            this[what[i2] + "jc"] = terms[i2];
          }
        } else if (type_default.isFunction(v)) {
          newfuncs[i2] = v;
        } else if (type_default.isNumber(v)) {
          newfuncs[i2] = makeConstFunction(v);
        } else if (type_default.isObject(v) && type_default.isFunction(v.Value)) {
          newfuncs[i2] = makeSliderFunction(v);
        }
        newfuncs[i2].origin = v;
      }
      if (terms.length === 1) {
        this.updateConstraint = function() {
          var c = newfuncs[0]();
          if (type_default.isArray(c)) {
            this.coords.setCoordinates(constants_default.COORDS_BY_USER, c);
          } else {
            this.coords = c;
          }
          return this;
        };
      } else if (terms.length === 2) {
        this.XEval = newfuncs[0];
        this.YEval = newfuncs[1];
        this.addParents([newfuncs[0].origin, newfuncs[1].origin]);
        this.updateConstraint = function() {
          this.coords.setCoordinates(constants_default.COORDS_BY_USER, [
            this.XEval(),
            this.YEval()
          ]);
          return this;
        };
      } else {
        this.ZEval = newfuncs[0];
        this.XEval = newfuncs[1];
        this.YEval = newfuncs[2];
        this.addParents([newfuncs[0].origin, newfuncs[1].origin, newfuncs[2].origin]);
        this.updateConstraint = function() {
          this.coords.setCoordinates(constants_default.COORDS_BY_USER, [
            this.ZEval(),
            this.XEval(),
            this.YEval()
          ]);
          return this;
        };
      }
      this.isConstrained = true;
      this.prepareUpdate().update();
      if (!this.board.isSuspendedUpdate) {
        this.updateVisibility().updateRenderer();
        if (this.hasLabel) {
          this.label.fullUpdate();
        }
      }
      return this;
    },
    /**
     * In case there is an attribute "anchor", the element is bound to
     * this anchor element.
     * This is handled with this.relativeCoords. If the element is a label
     * relativeCoords are given in scrCoords, otherwise in usrCoords.
     * @param{Array} coordinates Offset from the anchor element. These are the values for this.relativeCoords.
     * In case of a label, coordinates are screen coordinates. Otherwise, coordinates are user coordinates.
     * @param{Boolean} isLabel Yes/no
     * @private
     */
    addAnchor: function(coordinates, isLabel) {
      if (isLabel) {
        this.relativeCoords = new coords_default(
          constants_default.COORDS_BY_SCREEN,
          coordinates.slice(0, 2),
          this.board
        );
      } else {
        this.relativeCoords = new coords_default(constants_default.COORDS_BY_USER, coordinates, this.board);
      }
      this.element.addChild(this);
      if (isLabel) {
        this.addParents(this.element);
      }
      this.XEval = function() {
        var sx, coords, anchor, ev_o;
        if (type_default.evaluate(this.visProp.islabel)) {
          ev_o = type_default.evaluate(this.visProp.offset);
          sx = parseFloat(ev_o[0]);
          anchor = this.element.getLabelAnchor();
          coords = new coords_default(
            constants_default.COORDS_BY_SCREEN,
            [sx + this.relativeCoords.scrCoords[1] + anchor.scrCoords[1], 0],
            this.board
          );
          return coords.usrCoords[1];
        }
        anchor = this.element.getTextAnchor();
        return this.relativeCoords.usrCoords[1] + anchor.usrCoords[1];
      };
      this.YEval = function() {
        var sy, coords, anchor, ev_o;
        if (type_default.evaluate(this.visProp.islabel)) {
          ev_o = type_default.evaluate(this.visProp.offset);
          sy = -parseFloat(ev_o[1]);
          anchor = this.element.getLabelAnchor();
          coords = new coords_default(
            constants_default.COORDS_BY_SCREEN,
            [0, sy + this.relativeCoords.scrCoords[2] + anchor.scrCoords[2]],
            this.board
          );
          return coords.usrCoords[2];
        }
        anchor = this.element.getTextAnchor();
        return this.relativeCoords.usrCoords[2] + anchor.usrCoords[2];
      };
      this.ZEval = type_default.createFunction(1, this.board, "");
      this.updateConstraint = function() {
        this.coords.setCoordinates(constants_default.COORDS_BY_USER, [
          this.ZEval(),
          this.XEval(),
          this.YEval()
        ]);
      };
      this.isConstrained = true;
      this.updateConstraint();
    },
    /**
     * Applies the transformations of the element.
     * This method applies to text and images. Point transformations are handled differently.
     * @param {Boolean} fromParent True if the drag comes from a child element. Unused.
     * @returns {JXG.CoordsElement} Reference to itself.
     */
    updateTransform: function(fromParent) {
      var i2;
      if (this.transformations.length === 0) {
        return this;
      }
      for (i2 = 0; i2 < this.transformations.length; i2++) {
        this.transformations[i2].update();
      }
      return this;
    },
    /**
     * Add transformations to this element.
     * @param {JXG.GeometryElement} el
     * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation}
     * or an array of {@link JXG.Transformation}s.
     * @returns {JXG.CoordsElement} Reference to itself.
     */
    addTransform: function(el, transform) {
      var i2, list2 = type_default.isArray(transform) ? transform : [transform], len = list2.length;
      if (this.transformations.length === 0) {
        this.baseElement = el;
      }
      for (i2 = 0; i2 < len; i2++) {
        this.transformations.push(list2[i2]);
      }
      return this;
    },
    /**
     * Animate the point.
     * @param {Number|Function} direction The direction the glider is animated. Can be +1 or -1.
     * @param {Number|Function} stepCount The number of steps in which the parent element is divided.
     * Must be at least 1.
     * @param {Number|Function} delay Time in msec between two animation steps. Default is 250.
     * @returns {JXG.CoordsElement} Reference to iself.
     *
     * @name Glider#startAnimation
     * @see Glider#stopAnimation
     * @function
     * @example
     * // Divide the circle line into 6 steps and
     * // visit every step 330 msec counterclockwise.
     * var ci = board.create('circle', [[-1,2], [2,1]]);
     * var gl = board.create('glider', [0,2, ci]);
     * gl.startAnimation(-1, 6, 330);
     *
     * </pre><div id="JXG0f35a50e-e99d-11e8-a1ca-04d3b0c2aad3" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG0f35a50e-e99d-11e8-a1ca-04d3b0c2aad3',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     // Divide the circle line into 6 steps and
     *     // visit every step 330 msec counterclockwise.
     *     var ci = board.create('circle', [[-1,2], [2,1]]);
     *     var gl = board.create('glider', [0,2, ci]);
     *     gl.startAnimation(-1, 6, 330);
     *
     *     })();
     *
     * <\/script><pre>
     *
     * @example
     * // Divide the slider area into 20 steps and
     * // visit every step 30 msec.
     * var n = board.create('slider',[[-2,4],[2,4],[1,5,100]],{name:'n'});
     * n.startAnimation(1, 20, 30);
     *
     * </pre><div id="JXG40ce04b8-e99c-11e8-a1ca-04d3b0c2aad3" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG40ce04b8-e99c-11e8-a1ca-04d3b0c2aad3',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     // Divide the slider area into 20 steps and
     *     // visit every step 30 msec.
     *     var n = board.create('slider',[[-2,4],[2,4],[1,5,100]],{name:'n'});
     *     n.startAnimation(1, 20, 30);
     *
     *     })();
     * <\/script><pre>
     *
     */
    startAnimation: function(direction, stepCount, delay) {
      var dir = type_default.evaluate(direction), sc = type_default.evaluate(stepCount), that2 = this;
      delay = type_default.evaluate(delay) || 250;
      if (this.type === constants_default.OBJECT_TYPE_GLIDER && !type_default.exists(this.intervalCode)) {
        this.intervalCode = window.setInterval(function() {
          that2._anim(dir, sc);
        }, delay);
        if (!type_default.exists(this.intervalCount)) {
          this.intervalCount = 0;
        }
      }
      return this;
    },
    /**
     * Stop animation.
     * @name Glider#stopAnimation
     * @see Glider#startAnimation
     * @function
     * @returns {JXG.CoordsElement} Reference to itself.
     */
    stopAnimation: function() {
      if (type_default.exists(this.intervalCode)) {
        window.clearInterval(this.intervalCode);
        delete this.intervalCode;
      }
      return this;
    },
    /**
     * Starts an animation which moves the point along a given path in given time.
     * @param {Array|function} path The path the point is moved on.
     * This can be either an array of arrays or containing x and y values of the points of
     * the path, or an array of points, or a function taking the amount of elapsed time since the animation
     * has started and returns an array containing a x and a y value or NaN.
     * In case of NaN the animation stops.
     * @param {Number} time The time in milliseconds in which to finish the animation
     * @param {Object} [options] Optional settings for the animation.
     * @param {function} [options.callback] A function that is called as soon as the animation is finished.
     * @param {Boolean} [options.interpolate=true] If <tt>path</tt> is an array moveAlong()
     * will interpolate the path
     * using {@link JXG.Math.Numerics.Neville}. Set this flag to false if you don't want to use interpolation.
     * @returns {JXG.CoordsElement} Reference to itself.
     * @see JXG.CoordsElement#moveAlong
     * @see JXG.CoordsElement#moveTo
     * @see JXG.GeometryElement#animate
     */
    moveAlong: function(path, time, options) {
      options = options || {};
      var i2, neville, interpath = [], p = [], delay = this.board.attr.animationdelay, steps = time / delay, len, pos, part, makeFakeFunction = function(i3, j) {
        return function() {
          return path[i3][j];
        };
      };
      if (type_default.isArray(path)) {
        len = path.length;
        for (i2 = 0; i2 < len; i2++) {
          if (type_default.isPoint(path[i2])) {
            p[i2] = path[i2];
          } else {
            p[i2] = {
              elementClass: constants_default.OBJECT_CLASS_POINT,
              X: makeFakeFunction(i2, 0),
              Y: makeFakeFunction(i2, 1)
            };
          }
        }
        time = time || 0;
        if (time === 0) {
          this.setPosition(constants_default.COORDS_BY_USER, [
            p[p.length - 1].X(),
            p[p.length - 1].Y()
          ]);
          return this.board.update(this);
        }
        if (!type_default.exists(options.interpolate) || options.interpolate) {
          neville = numerics_default.Neville(p);
          for (i2 = 0; i2 < steps; i2++) {
            interpath[i2] = [];
            interpath[i2][0] = neville[0]((steps - i2) / steps * neville[3]());
            interpath[i2][1] = neville[1]((steps - i2) / steps * neville[3]());
          }
        } else {
          len = path.length - 1;
          for (i2 = 0; i2 < steps; ++i2) {
            pos = Math.floor(i2 / steps * len);
            part = i2 / steps * len - pos;
            interpath[i2] = [];
            interpath[i2][0] = (1 - part) * p[pos].X() + part * p[pos + 1].X();
            interpath[i2][1] = (1 - part) * p[pos].Y() + part * p[pos + 1].Y();
          }
          interpath.push([p[len].X(), p[len].Y()]);
          interpath.reverse();
        }
        this.animationPath = interpath;
      } else if (type_default.isFunction(path)) {
        this.animationPath = path;
        this.animationStart = new Date().getTime();
      }
      this.animationCallback = options.callback;
      this.board.addAnimation(this);
      return this;
    },
    /**
     * Starts an animated point movement towards the given coordinates <tt>where</tt>.
     * The animation is done after <tt>time</tt> milliseconds.
     * If the second parameter is not given or is equal to 0, setPosition() is called, see #setPosition,
     * i.e. the coordinates are changed without animation.
     * @param {Array} where Array containing the x and y coordinate of the target location.
     * @param {Number} [time] Number of milliseconds the animation should last.
     * @param {Object} [options] Optional settings for the animation
     * @param {function} [options.callback] A function that is called as soon as the animation is finished.
     * @param {String} [options.effect='<>'] animation effects like speed fade in and out. possible values are
     * '<>' for speed increase on start and slow down at the end (default) and '--' for constant speed during
     * the whole animation.
     * @returns {JXG.CoordsElement} Reference to itself.
     * @see JXG.CoordsElement#moveAlong
     * @see JXG.CoordsElement#visit
     * @see JXG.GeometryElement#animate
     */
    moveTo: function(where, time, options) {
      options = options || {};
      where = new coords_default(constants_default.COORDS_BY_USER, where, this.board);
      var i2, delay = this.board.attr.animationdelay, steps = Math.ceil(time / delay), coords = [], X = this.coords.usrCoords[1], Y = this.coords.usrCoords[2], dX = where.usrCoords[1] - X, dY = where.usrCoords[2] - Y, stepFun = function(i3) {
        if (options.effect && options.effect === "<>") {
          return Math.pow(Math.sin(i3 / steps * Math.PI / 2), 2);
        }
        return i3 / steps;
      };
      if (!type_default.exists(time) || time === 0 || Math.abs(where.usrCoords[0] - this.coords.usrCoords[0]) > math_default.eps) {
        this.setPosition(constants_default.COORDS_BY_USER, where.usrCoords);
        return this.board.update(this);
      }
      if (!type_default.exists(options.callback) && Math.abs(dX) < math_default.eps && Math.abs(dY) < math_default.eps) {
        return this;
      }
      for (i2 = steps; i2 >= 0; i2--) {
        coords[steps - i2] = [
          where.usrCoords[0],
          X + dX * stepFun(i2),
          Y + dY * stepFun(i2)
        ];
      }
      this.animationPath = coords;
      this.animationCallback = options.callback;
      this.board.addAnimation(this);
      return this;
    },
    /**
     * Starts an animated point movement towards the given coordinates <tt>where</tt>. After arriving at
     * <tt>where</tt> the point moves back to where it started. The animation is done after <tt>time</tt>
     * milliseconds.
     * @param {Array} where Array containing the x and y coordinate of the target location.
     * @param {Number} time Number of milliseconds the animation should last.
     * @param {Object} [options] Optional settings for the animation
     * @param {function} [options.callback] A function that is called as soon as the animation is finished.
     * @param {String} [options.effect='<>'] animation effects like speed fade in and out. possible values are
     * '<>' for speed increase on start and slow down at the end (default) and '--' for constant speed during
     * the whole animation.
     * @param {Number} [options.repeat=1] How often this animation should be repeated.
     * @returns {JXG.CoordsElement} Reference to itself.
     * @see JXG.CoordsElement#moveAlong
     * @see JXG.CoordsElement#moveTo
     * @see JXG.GeometryElement#animate
     */
    visit: function(where, time, options) {
      where = new coords_default(constants_default.COORDS_BY_USER, where, this.board);
      var i2, j, steps, delay = this.board.attr.animationdelay, coords = [], X = this.coords.usrCoords[1], Y = this.coords.usrCoords[2], dX = where.usrCoords[1] - X, dY = where.usrCoords[2] - Y, stepFun = function(i3) {
        var x = i3 < steps / 2 ? 2 * i3 / steps : 2 * (steps - i3) / steps;
        if (options.effect && options.effect === "<>") {
          return Math.pow(Math.sin(x * Math.PI / 2), 2);
        }
        return x;
      };
      if (type_default.isNumber(options)) {
        options = { repeat: options };
      } else {
        options = options || {};
        if (!type_default.exists(options.repeat)) {
          options.repeat = 1;
        }
      }
      steps = Math.ceil(time / (delay * options.repeat));
      for (j = 0; j < options.repeat; j++) {
        for (i2 = steps; i2 >= 0; i2--) {
          coords[j * (steps + 1) + steps - i2] = [
            where.usrCoords[0],
            X + dX * stepFun(i2),
            Y + dY * stepFun(i2)
          ];
        }
      }
      this.animationPath = coords;
      this.animationCallback = options.callback;
      this.board.addAnimation(this);
      return this;
    },
    /**
     * Animates a glider. Is called by the browser after startAnimation is called.
     * @param {Number} direction The direction the glider is animated.
     * @param {Number} stepCount The number of steps in which the parent element is divided.
     * Must be at least 1.
     * @see #startAnimation
     * @see #stopAnimation
     * @private
     * @returns {JXG.CoordsElement} Reference to itself.
     */
    _anim: function(direction, stepCount) {
      var dX, dY, alpha, startPoint, newX, radius, sp1c, sp2c, res;
      this.intervalCount += 1;
      if (this.intervalCount > stepCount) {
        this.intervalCount = 0;
      }
      if (this.slideObject.elementClass === constants_default.OBJECT_CLASS_LINE) {
        sp1c = this.slideObject.point1.coords.scrCoords;
        sp2c = this.slideObject.point2.coords.scrCoords;
        dX = Math.round((sp2c[1] - sp1c[1]) * this.intervalCount / stepCount);
        dY = Math.round((sp2c[2] - sp1c[2]) * this.intervalCount / stepCount);
        if (direction > 0) {
          startPoint = this.slideObject.point1;
        } else {
          startPoint = this.slideObject.point2;
          dX *= -1;
          dY *= -1;
        }
        this.coords.setCoordinates(constants_default.COORDS_BY_SCREEN, [
          startPoint.coords.scrCoords[1] + dX,
          startPoint.coords.scrCoords[2] + dY
        ]);
      } else if (this.slideObject.elementClass === constants_default.OBJECT_CLASS_CURVE) {
        if (direction > 0) {
          newX = Math.round(
            this.intervalCount / stepCount * this.board.canvasWidth
          );
        } else {
          newX = Math.round(
            (stepCount - this.intervalCount) / stepCount * this.board.canvasWidth
          );
        }
        this.coords.setCoordinates(constants_default.COORDS_BY_SCREEN, [newX, 0]);
        res = geometry_default.projectPointToCurve(this, this.slideObject, this.board);
        this.coords = res[0];
        this.position = res[1];
      } else if (this.slideObject.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
        alpha = 2 * Math.PI;
        if (direction < 0) {
          alpha *= this.intervalCount / stepCount;
        } else {
          alpha *= (stepCount - this.intervalCount) / stepCount;
        }
        radius = this.slideObject.Radius();
        this.coords.setCoordinates(constants_default.COORDS_BY_USER, [
          this.slideObject.center.coords.usrCoords[1] + radius * Math.cos(alpha),
          this.slideObject.center.coords.usrCoords[2] + radius * Math.sin(alpha)
        ]);
      }
      this.board.update(this);
      return this;
    },
    // documented in GeometryElement
    getTextAnchor: function() {
      return this.coords;
    },
    // documented in GeometryElement
    getLabelAnchor: function() {
      return this.coords;
    },
    // documented in element.js
    getParents: function() {
      var p = [this.Z(), this.X(), this.Y()];
      if (this.parents.length !== 0) {
        p = this.parents;
      }
      if (this.type === constants_default.OBJECT_TYPE_GLIDER) {
        p = [this.X(), this.Y(), this.slideObject.id];
      }
      return p;
    }
  }
);
jxg_default.CoordsElement.create = function(Callback, board, coords, attr, arg1, arg2) {
  var el, isConstrained = false, i2;
  for (i2 = 0; i2 < coords.length; i2++) {
    if (type_default.isFunction(coords[i2]) || type_default.isString(coords[i2])) {
      isConstrained = true;
    }
  }
  if (!isConstrained) {
    if (type_default.isNumber(coords[0]) && type_default.isNumber(coords[1])) {
      el = new Callback(board, coords, attr, arg1, arg2);
      if (type_default.exists(attr.slideobject)) {
        el.makeGlider(attr.slideobject);
      } else {
        el.baseElement = el;
      }
      el.isDraggable = true;
    } else if (type_default.isObject(coords[0]) && type_default.isTransformationOrArray(coords[1])) {
      el = new Callback(board, [0, 0], attr, arg1, arg2);
      el.addTransform(coords[0], coords[1]);
      el.isDraggable = false;
    } else {
      return false;
    }
  } else {
    el = new Callback(board, [0, 0], attr, arg1, arg2);
    el.addConstraint(coords);
  }
  el.handleSnapToGrid();
  el.handleSnapToPoints();
  el.handleAttractors();
  el.addParents(coords);
  return el;
};
var coordselement_default = jxg_default.CoordsElement;

// node_modules/jsxgraph/src/base/text.js
var priv = {
  /**
   * @class
   * @ignore
   */
  HTMLSliderInputEventHandler: function() {
    this._val = parseFloat(this.rendNodeRange.value);
    this.rendNodeOut.value = this.rendNodeRange.value;
    this.board.update();
  }
};
jxg_default.Text = function(board, coords, attributes, content) {
  var tmp;
  this.constructor(board, attributes, constants_default.OBJECT_TYPE_TEXT, constants_default.OBJECT_CLASS_TEXT);
  this.element = this.board.select(attributes.anchor);
  this.coordsConstructor(coords, type_default.evaluate(this.visProp.islabel));
  this.content = "";
  this.plaintext = "";
  this.plaintextOld = null;
  this.orgText = "";
  this.needsSizeUpdate = false;
  this.hiddenByParent = false;
  this.size = [1, 1];
  this.id = this.board.setId(this, "T");
  this.board.renderer.drawText(this);
  this.board.finalizeAdding(this);
  tmp = this.visProp.visible;
  this.visProp.visible = true;
  this.setText(content);
  this.visProp.visible = tmp;
  if (type_default.isString(this.content)) {
    this.notifyParents(this.content);
  }
  this.elType = "text";
  this.methodMap = type_default.deepCopy(this.methodMap, {
    setText: "setTextJessieCode",
    // free: 'free',
    move: "setCoords",
    Size: "getSize",
    setAutoPosition: "setAutoPosition"
  });
};
jxg_default.Text.prototype = new element_default();
type_default.copyPrototypeMethods(jxg_default.Text, coordselement_default, "coordsConstructor");
jxg_default.extend(
  jxg_default.Text.prototype,
  /** @lends JXG.Text.prototype */
  {
    /**
     * @private
     * @param {Number} x
     * @param {Number} y
     * @returns {Boolean}
    */
    // Test if the screen coordinates (x,y) are in a small stripe
    // at the left side or at the right side of the text.
    // Sensitivity is set in this.board.options.precision.hasPoint.
    // If dragarea is set to 'all' (default), tests if the screen
    // coordinates (x,y) are in within the text boundary.
    hasPoint: function(x, y) {
      var lft, rt, top, bot, ax, ay, type, r;
      if (type_default.isObject(type_default.evaluate(this.visProp.precision))) {
        type = this.board._inputDevice;
        r = type_default.evaluate(this.visProp.precision[type]);
      } else {
        r = this.board.options.precision.hasPoint;
      }
      if (this.transformations.length > 0) {
        lft = math_default.matVecMult(
          math_default.inverse(this.board.renderer.joinTransforms(this, this.transformations)),
          [1, x, y]
        );
        x = lft[1];
        y = lft[2];
      }
      ax = this.getAnchorX();
      if (ax === "right") {
        lft = this.coords.scrCoords[1] - this.size[0];
      } else if (ax === "middle") {
        lft = this.coords.scrCoords[1] - 0.5 * this.size[0];
      } else {
        lft = this.coords.scrCoords[1];
      }
      rt = lft + this.size[0];
      ay = this.getAnchorY();
      if (ay === "top") {
        bot = this.coords.scrCoords[2] + this.size[1];
      } else if (ay === "middle") {
        bot = this.coords.scrCoords[2] + 0.5 * this.size[1];
      } else {
        bot = this.coords.scrCoords[2];
      }
      top = bot - this.size[1];
      if (type_default.evaluate(this.visProp.dragarea) === "all") {
        return x >= lft - r && x < rt + r && y >= top - r && y <= bot + r;
      }
      return y >= top - r && y <= bot + r && (x >= lft - r && x <= lft + 2 * r || x >= rt - 2 * r && x <= rt + r);
    },
    /**
     * This sets the updateText function of this element depending on the type of text content passed.
     * Used by {@link JXG.Text#_setText}.
     * @param {String|Function|Number} text
     * @private
     * @see JXG.Text#_setText
     */
    _createFctUpdateText: function(text) {
      var updateText, e, digits, resolvedText, i2, that2, ev_p = type_default.evaluate(this.visProp.parse), ev_um = type_default.evaluate(this.visProp.usemathjax), ev_uk = type_default.evaluate(this.visProp.usekatex), convertJessieCode = false;
      this.orgText = text;
      if (type_default.isFunction(text)) {
        this.updateText = function() {
          resolvedText = text().toString();
          if (ev_p && !ev_um && !ev_uk) {
            this.plaintext = this.replaceSub(
              this.replaceSup(
                this.convertGeonextAndSketchometry2CSS(resolvedText, false)
              )
            );
          } else {
            this.plaintext = resolvedText;
          }
        };
      } else {
        if (type_default.isNumber(text) && type_default.evaluate(this.visProp.formatnumber)) {
          if (type_default.evaluate(this.visProp.tofraction)) {
            if (ev_um) {
              this.content = "\\(" + type_default.toFraction(text, true) + "\\)";
            } else {
              this.content = type_default.toFraction(text, ev_uk);
            }
          } else {
            digits = type_default.evaluate(this.visProp.digits);
            if (this.useLocale()) {
              this.content = this.formatNumberLocale(text, digits);
            } else {
              this.content = type_default.toFixed(text, digits);
            }
          }
        } else if (type_default.isString(text) && ev_p) {
          if (type_default.evaluate(this.visProp.useasciimathml)) {
            this.content = "'`" + text + "`'";
          } else if (ev_um || ev_uk) {
            this.content = this.valueTagToJessieCode(text);
            if (!type_default.isArray(this.content)) {
              this.content = this.content.replace(/\\/g, "\\\\");
            }
          } else {
            this.content = this.poorMansTeX(this.valueTagToJessieCode(text));
          }
          convertJessieCode = true;
        } else {
          this.content = text;
        }
        if (convertJessieCode) {
          if (type_default.isArray(this.content)) {
            that2 = this;
            for (i2 = 0; i2 < this.content.length; i2++) {
              if (this.content[i2][0] !== '"') {
                this.content[i2] = this.board.jc.snippet(this.content[i2], true, "", false);
                for (e in this.content[i2].deps) {
                  this.addParents(this.content[i2].deps[e]);
                  this.content[i2].deps[e].addChild(this);
                }
              }
            }
            updateText = function() {
              var i3, t, digits2 = type_default.evaluate(that2.visProp.digits), txt = "";
              for (i3 = 0; i3 < that2.content.length; i3++) {
                if (type_default.isFunction(that2.content[i3])) {
                  t = that2.content[i3]();
                  if (that2.useLocale()) {
                    t = that2.formatNumberLocale(t, digits2);
                  } else {
                    t = type_default.toFixed(t, digits2);
                  }
                } else {
                  t = that2.content[i3];
                  if (t.at(0) === '"' && t.at(-1) === '"') {
                    t = t.slice(1, -1);
                  }
                }
                txt += t;
              }
              return txt;
            };
          } else {
            updateText = this.board.jc.snippet(this.content, true, "", false);
            for (e in updateText.deps) {
              this.addParents(updateText.deps[e]);
              updateText.deps[e].addChild(this);
            }
          }
          this.updateText = function() {
            this.plaintext = this.unescapeTicks(updateText());
          };
        } else {
          this.updateText = function() {
            this.plaintext = this.content;
          };
        }
      }
    },
    /**
     * Defines new content. This is used by {@link JXG.Text#setTextJessieCode} and {@link JXG.Text#setText}. This is required because
     * JessieCode needs to filter all Texts inserted into the DOM and thus has to replace setText by setTextJessieCode.
     * @param {String|Function|Number} text
     * @returns {JXG.Text}
     * @private
     */
    _setText: function(text) {
      this._createFctUpdateText(text);
      this.updateText();
      this.fullUpdate();
      if (!this.board.infobox || this.id !== this.board.infobox.id) {
        this.updateSize();
      }
      return this;
    },
    /**
     * Defines new content but converts &lt; and &gt; to HTML entities before updating the DOM.
     * @param {String|function} text
     */
    setTextJessieCode: function(text) {
      var s;
      this.visProp.castext = text;
      if (type_default.isFunction(text)) {
        s = function() {
          return type_default.sanitizeHTML(text());
        };
      } else {
        if (type_default.isNumber(text)) {
          s = text;
        } else {
          s = type_default.sanitizeHTML(text);
        }
      }
      return this._setText(s);
    },
    /**
     * Defines new content.
     * @param {String|function} text
     * @returns {JXG.Text} Reference to the text object.
     */
    setText: function(text) {
      return this._setText(text);
    },
    /**
     * Recompute the width and the height of the text box.
     * Updates the array {@link JXG.Text#size} with pixel values.
     * The result may differ from browser to browser
     * by some pixels.
     * In canvas an old IEs we use a very crude estimation of the dimensions of
     * the textbox.
     * JSXGraph needs {@link JXG.Text#size} for applying rotations in IE and
     * for aligning text.
     *
     * @return {this} [description]
     */
    updateSize: function() {
      var tmp, that2, node2, ev_d = type_default.evaluate(this.visProp.display);
      if (!env_default.isBrowser || this.board.renderer.type === "no") {
        return this;
      }
      node2 = this.rendNode;
      if (ev_d === "html" || this.board.renderer.type === "vml") {
        if (type_default.exists(node2.offsetWidth)) {
          that2 = this;
          window.setTimeout(function() {
            that2.size = [node2.offsetWidth, node2.offsetHeight];
            that2.needsUpdate = true;
            that2.updateRenderer();
          }, 0);
        } else {
          this.size = this.crudeSizeEstimate();
        }
      } else if (ev_d === "internal") {
        if (this.board.renderer.type === "svg") {
          that2 = this;
          window.setTimeout(function() {
            try {
              tmp = node2.getBBox();
              that2.size = [tmp.width, tmp.height];
              that2.needsUpdate = true;
              that2.updateRenderer();
            } catch (e) {
            }
          }, 0);
        } else if (this.board.renderer.type === "canvas") {
          this.size = this.crudeSizeEstimate();
        }
      }
      return this;
    },
    /**
     * A very crude estimation of the dimensions of the textbox in case nothing else is available.
     * @returns {Array}
     */
    crudeSizeEstimate: function() {
      var ev_fs = parseFloat(type_default.evaluate(this.visProp.fontsize));
      return [ev_fs * this.plaintext.length * 0.45, ev_fs * 0.9];
    },
    /**
     * Decode unicode entities into characters.
     * @param {String} string
     * @returns {String}
     */
    utf8_decode: function(string) {
      return string.replace(/&#x(\w+);/g, function(m, p1) {
        return String.fromCharCode(parseInt(p1, 16));
      });
    },
    /**
     * Replace _{} by &lt;sub&gt;
     * @param {String} te String containing _{}.
     * @returns {String} Given string with _{} replaced by &lt;sub&gt;.
     */
    replaceSub: function(te) {
      if (!te.indexOf) {
        return te;
      }
      var j, i2 = te.indexOf("_{");
      while (i2 >= 0) {
        te = te.slice(0, i2) + te.slice(i2).replace(/_\{/, "<sub>");
        j = te.indexOf("}", i2 + 4);
        if (j >= 0) {
          te = te.slice(0, j) + te.slice(j).replace(/\}/, "</sub>");
        }
        i2 = te.indexOf("_{");
      }
      i2 = te.indexOf("_");
      while (i2 >= 0) {
        te = te.slice(0, i2) + te.slice(i2).replace(/_(.?)/, "<sub>$1</sub>");
        i2 = te.indexOf("_");
      }
      return te;
    },
    /**
     * Replace ^{} by &lt;sup&gt;
     * @param {String} te String containing ^{}.
     * @returns {String} Given string with ^{} replaced by &lt;sup&gt;.
     */
    replaceSup: function(te) {
      if (!te.indexOf) {
        return te;
      }
      var j, i2 = te.indexOf("^{");
      while (i2 >= 0) {
        te = te.slice(0, i2) + te.slice(i2).replace(/\^\{/, "<sup>");
        j = te.indexOf("}", i2 + 4);
        if (j >= 0) {
          te = te.slice(0, j) + te.slice(j).replace(/\}/, "</sup>");
        }
        i2 = te.indexOf("^{");
      }
      i2 = te.indexOf("^");
      while (i2 >= 0) {
        te = te.slice(0, i2) + te.slice(i2).replace(/\^(.?)/, "<sup>$1</sup>");
        i2 = te.indexOf("^");
      }
      return te;
    },
    /**
     * Return the width of the text element.
     * @returns {Array} [width, height] in pixel
     */
    getSize: function() {
      return this.size;
    },
    /**
     * Move the text to new coordinates.
     * @param {number} x
     * @param {number} y
     * @returns {object} reference to the text object.
     */
    setCoords: function(x, y) {
      var coordsAnchor, dx, dy;
      if (type_default.isArray(x) && x.length > 1) {
        y = x[1];
        x = x[0];
      }
      if (type_default.evaluate(this.visProp.islabel) && type_default.exists(this.element)) {
        coordsAnchor = this.element.getLabelAnchor();
        dx = (x - coordsAnchor.usrCoords[1]) * this.board.unitX;
        dy = -(y - coordsAnchor.usrCoords[2]) * this.board.unitY;
        this.relativeCoords.setCoordinates(constants_default.COORDS_BY_SCREEN, [dx, dy]);
      } else {
        this.coords.setCoordinates(constants_default.COORDS_BY_USER, [x, y]);
      }
      this.fullUpdate();
      return this;
    },
    /**
     * Evaluates the text.
     * Then, the update function of the renderer
     * is called.
     */
    update: function(fromParent) {
      if (!this.needsUpdate) {
        return this;
      }
      this.updateCoords(fromParent);
      this.updateText();
      if (type_default.evaluate(this.visProp.display) === "internal") {
        if (type_default.isString(this.plaintext)) {
          this.plaintext = this.utf8_decode(this.plaintext);
        }
      }
      this.checkForSizeUpdate();
      if (this.needsSizeUpdate) {
        this.updateSize();
      }
      return this;
    },
    /**
     * Used to save updateSize() calls.
     * Called in JXG.Text.update
     * That means this.update() has been called.
     * More tests are in JXG.Renderer.updateTextStyle. The latter tests
     * are one update off. But this should pose not too many problems, since
     * it affects fontSize and cssClass changes.
     *
     * @private
     */
    checkForSizeUpdate: function() {
      if (this.board.infobox && this.id === this.board.infobox.id) {
        this.needsSizeUpdate = false;
      } else {
        this.needsSizeUpdate = this.plaintextOld !== this.plaintext;
        if (this.needsSizeUpdate) {
          this.plaintextOld = this.plaintext;
        }
      }
    },
    /**
     * The update function of the renderer
     * is called.
     * @private
     */
    updateRenderer: function() {
      if (
        //this.board.updateQuality === this.board.BOARD_QUALITY_HIGH &&
        type_default.evaluate(this.visProp.autoposition)
      ) {
        this.setAutoPosition().updateConstraint();
      }
      return this.updateRendererGeneric("updateText");
    },
    /**
     * Converts shortened math syntax into correct syntax:  3x instead of 3*x or
     * (a+b)(3+1) instead of (a+b)*(3+1).
     *
     * @private
     * @param{String} expr Math term
     * @returns {string} expanded String
     */
    expandShortMath: function(expr) {
      var re = /([)0-9.])\s*([(a-zA-Z_])/g;
      return expr.replace(re, "$1*$2");
    },
    /**
     * Converts the GEONExT syntax of the <value> terms into JavaScript.
     * Also, all Objects whose name appears in the term are searched and
     * the text is added as child to these objects.
     * This method is called if the attribute parse==true is set.
     *
     * Obsolete, replaced by JXG.Text.valueTagToJessieCode
     *
     * @param{String} contentStr String to be parsed
     * @param{Boolean} [expand] Optional flag if shortened math syntax is allowed (e.g. 3x instead of 3*x).
     * @param{Boolean} [avoidGeonext2JS] Optional flag if geonext2JS should be called. For backwards compatibility
     * this has to be set explicitly to true.
     * @param{Boolean} [outputTeX] Optional flag which has to be true if the resulting term will be sent to MathJax or KaTeX.
     * If true, "_" and "^" are NOT replaced by HTML tags sub and sup. Default: false, i.e. the replacement is done.
     * This flag allows the combination of &lt;value&gt; tag containing calculations with TeX output.
     *
     * @deprecated
     * @private
     * @see JXG.GeonextParser#geonext2JS
     * @see JXG.Text#valueTagToJessieCode
     *
     */
    generateTerm: function(contentStr, expand, avoidGeonext2JS) {
      var res, term, i2, j, plaintext = '""';
      contentStr = contentStr || "";
      contentStr = contentStr.replace(/\r/g, "");
      contentStr = contentStr.replace(/\n/g, "");
      contentStr = contentStr.replace(/"/g, "'");
      contentStr = contentStr.replace(/'/g, "\\'");
      contentStr = contentStr.replace(/&amp;arc;/g, "&ang;");
      contentStr = contentStr.replace(/<arc\s*\/>/g, "&ang;");
      contentStr = contentStr.replace(/&lt;arc\s*\/&gt;/g, "&ang;");
      contentStr = contentStr.replace(/&lt;sqrt\s*\/&gt;/g, "&radic;");
      contentStr = contentStr.replace(/&lt;value&gt;/g, "<value>");
      contentStr = contentStr.replace(/&lt;\/value&gt;/g, "</value>");
      i2 = contentStr.indexOf("<value>");
      j = contentStr.indexOf("</value>");
      if (i2 >= 0) {
        while (i2 >= 0) {
          plaintext += ' + "' + this.replaceSub(this.replaceSup(contentStr.slice(0, i2))) + '"';
          term = contentStr.slice(i2 + 7, j);
          term = term.replace(/\s+/g, "");
          if (expand === true) {
            term = this.expandShortMath(term);
          }
          if (avoidGeonext2JS) {
            res = term;
          } else {
            res = geonext_default.geonext2JS(term, this.board);
          }
          res = res.replace(/\\"/g, "'");
          res = res.replace(/\\'/g, "'");
          if (res.indexOf("toFixed") < 0) {
            if (type_default.isNumber(
              type_default.bind(this.board.jc.snippet(res, true, "", false), this)()
            )) {
              plaintext += "+(" + res + ").toFixed(" + type_default.evaluate(this.visProp.digits) + ")";
            } else {
              plaintext += "+(" + res + ")";
            }
          } else {
            plaintext += "+(" + res + ")";
          }
          contentStr = contentStr.slice(j + 8);
          i2 = contentStr.indexOf("<value>");
          j = contentStr.indexOf("</value>");
        }
      }
      plaintext += ' + "' + this.replaceSub(this.replaceSup(contentStr)) + '"';
      plaintext = this.convertGeonextAndSketchometry2CSS(plaintext);
      plaintext = plaintext.replace(/&amp;/g, "&");
      plaintext = plaintext.replace(/"/g, "'");
      return plaintext;
    },
    /**
     * Replace value-tags in string by JessieCode functions.
     * @param {String} contentStr
     * @returns String
     * @private
     * @example
     * "The x-coordinate of A is &lt;value&gt;X(A)&lt;/value&gt;"
     *
     */
    valueTagToJessieCode: function(contentStr) {
      var res, term, i2, j, expandShortMath = true, textComps = [], tick = '"';
      contentStr = contentStr || "";
      contentStr = contentStr.replace(/\r/g, "");
      contentStr = contentStr.replace(/\n/g, "");
      contentStr = contentStr.replace(/&lt;value&gt;/g, "<value>");
      contentStr = contentStr.replace(/&lt;\/value&gt;/g, "</value>");
      i2 = contentStr.indexOf("<value>");
      j = contentStr.indexOf("</value>");
      if (i2 >= 0) {
        while (i2 >= 0) {
          textComps.push(tick + this.escapeTicks(contentStr.slice(0, i2)) + tick);
          term = contentStr.slice(i2 + 7, j);
          term = term.replace(/\s+/g, "");
          if (expandShortMath === true) {
            term = this.expandShortMath(term);
          }
          res = term;
          res = res.replace(/\\"/g, "'").replace(/\\'/g, "'");
          textComps.push("(" + res + ")");
          contentStr = contentStr.slice(j + 8);
          i2 = contentStr.indexOf("<value>");
          j = contentStr.indexOf("</value>");
        }
      }
      textComps.push(tick + this.escapeTicks(contentStr) + tick);
      for (i2 = 0; i2 < textComps.length; i2++) {
        textComps[i2] = textComps[i2].replace(/&amp;/g, "&");
      }
      return textComps;
    },
    /**
     * Simple math rendering using HTML / CSS only. In case of array,
     * handle each entry separately and return array with the
     * rendering strings.
     *
     * @param {String|Array} s
     * @returns {String|Array}
     * @see JXG.Text#convertGeonextAndSketchometry2CSS
     * @private
     * @see JXG.Text#replaceSub
     * @see JXG.Text#replaceSup
     * @see JXG.Text#convertGeonextAndSketchometry2CSS
     */
    poorMansTeX: function(s) {
      var i2, a;
      if (type_default.isArray(s)) {
        a = [];
        for (i2 = 0; i2 < s.length; i2++) {
          a.push(this.poorMansTeX(s[i2]));
        }
        return a;
      }
      s = s.replace(/<arc\s*\/*>/g, "&ang;").replace(/&lt;arc\s*\/*&gt;/g, "&ang;").replace(/<sqrt\s*\/*>/g, "&radic;").replace(/&lt;sqrt\s*\/*&gt;/g, "&radic;");
      return this.convertGeonextAndSketchometry2CSS(this.replaceSub(this.replaceSup(s)), true);
    },
    /**
     * Replace ticks by URI escape sequences
     *
     * @param {String} s
     * @returns String
     * @private
     *
     */
    escapeTicks: function(s) {
      return s.replace(/"/g, "%22").replace(/'/g, "%27");
    },
    /**
     * Replace escape sequences for ticks by ticks
     *
     * @param {String} s
     * @returns String
     * @private
     */
    unescapeTicks: function(s) {
      return s.replace(/%22/g, '"').replace(/%27/g, "'");
    },
    /**
     * Converts the GEONExT tags <overline> and <arrow> to
     * HTML span tags with proper CSS formatting.
     * @private
     * @see JXG.Text.poorMansTeX
     * @see JXG.Text._setText
     */
    convertGeonext2CSS: function(s) {
      if (type_default.isString(s)) {
        s = s.replace(
          /(<|&lt;)overline(>|&gt;)/g,
          "<span style=text-decoration:overline;>"
        );
        s = s.replace(/(<|&lt;)\/overline(>|&gt;)/g, "</span>");
        s = s.replace(
          /(<|&lt;)arrow(>|&gt;)/g,
          "<span style=text-decoration:overline;>"
        );
        s = s.replace(/(<|&lt;)\/arrow(>|&gt;)/g, "</span>");
      }
      return s;
    },
    /**
     * Converts the sketchometry tag <sketchofont> to
     * HTML span tags with proper CSS formatting.
     *
     * @param {String|Function|Number} s Text
     * @param {Boolean} escape Flag if ticks should be escaped. Escaping is necessary
     * if s is a text. It has to be avoided if s is a function returning text.
     * @private
     * @see JXG.Text._setText
     * @see JXG.Text.convertGeonextAndSketchometry2CSS
     *
     */
    convertSketchometry2CSS: function(s, escape2) {
      var t1 = '<span class="sketcho sketcho-inherit sketcho-', t2 = '"></span>';
      if (type_default.isString(s)) {
        if (escape2) {
          t1 = this.escapeTicks(t1);
          t2 = this.escapeTicks(t2);
        }
        s = s.replace(/(<|&lt;)sketchofont(>|&gt;)/g, t1);
        s = s.replace(/(<|&lt;)\/sketchofont(>|&gt;)/g, t2);
      }
      return s;
    },
    /**
     * Alias for convertGeonext2CSS and convertSketchometry2CSS
     *
     * @param {String|Function|Number} s Text
     * @param {Boolean} escape Flag if ticks should be escaped
     * @private
     * @see JXG.Text.convertGeonext2CSS
     * @see JXG.Text.convertSketchometry2CSS
     */
    convertGeonextAndSketchometry2CSS: function(s, escape2) {
      s = this.convertGeonext2CSS(s);
      s = this.convertSketchometry2CSS(s, escape2);
      return s;
    },
    /**
     * Finds dependencies in a given term and notifies the parents by adding the
     * dependent object to the found objects child elements.
     * @param {String} content String containing dependencies for the given object.
     * @private
     */
    notifyParents: function(content) {
      var search, res = null;
      content = content.replace(/&lt;value&gt;/g, "<value>");
      content = content.replace(/&lt;\/value&gt;/g, "</value>");
      do {
        search = /<value>([\w\s*/^\-+()[\],<>=!]+)<\/value>/;
        res = search.exec(content);
        if (res !== null) {
          geonext_default.findDependencies(this, res[1], this.board);
          content = content.slice(res.index);
          content = content.replace(search, "");
        }
      } while (res !== null);
      return this;
    },
    // documented in element.js
    getParents: function() {
      var p;
      if (this.relativeCoords !== void 0) {
        p = [
          this.relativeCoords.usrCoords[1],
          this.relativeCoords.usrCoords[2],
          this.orgText
        ];
      } else {
        p = [this.Z(), this.X(), this.Y(), this.orgText];
      }
      if (this.parents.length !== 0) {
        p = this.parents;
      }
      return p;
    },
    /**
     * Returns the bounding box of the text element in user coordinates as an
     * array of length 4: [upper left x, upper left y, lower right x, lower right y].
     * The method assumes that the lower left corner is at position [el.X(), el.Y()]
     * of the text element el, i.e. the attributes anchorX, anchorY are ignored.
     *
     * <p>
     * or labels, [0, 0, 0, 0] is returned.
     *
     * @returns Array
     */
    bounds: function() {
      var c = this.coords.usrCoords;
      if (type_default.evaluate(this.visProp.islabel) || this.board.unitY === 0 || this.board.unitX === 0) {
        return [0, 0, 0, 0];
      }
      return [
        c[1],
        c[2] + this.size[1] / this.board.unitY,
        c[1] + this.size[0] / this.board.unitX,
        c[2]
      ];
    },
    /**
     * Returns the value of the attribute "anchorX". If this equals "auto",
     * returns "left", "middle", or "right", depending on the
     * value of the attribute "position".
     * @returns String
     */
    getAnchorX: function() {
      var a = type_default.evaluate(this.visProp.anchorx);
      if (a === "auto") {
        switch (this.visProp.position) {
          case "top":
          case "bot":
            return "middle";
          case "rt":
          case "lrt":
          case "urt":
            return "left";
          case "lft":
          case "llft":
          case "ulft":
          default:
            return "right";
        }
      }
      return a;
    },
    /**
     * Returns the value of the attribute "anchorY". If this equals "auto",
     * returns "bottom", "middle", or "top", depending on the
     * value of the attribute "position".
     * @returns String
     */
    getAnchorY: function() {
      var a = type_default.evaluate(this.visProp.anchory);
      if (a === "auto") {
        switch (this.visProp.position) {
          case "top":
          case "ulft":
          case "urt":
            return "bottom";
          case "bot":
          case "lrt":
          case "llft":
            return "top";
          case "rt":
          case "lft":
          default:
            return "middle";
        }
      }
      return a;
    },
    /**
     * Computes the number of overlaps of a box of w pixels width, h pixels height
     * and center (x, y)
     *
     * @private
     * @param  {Number} x x-coordinate of the center (screen coordinates)
     * @param  {Number} y y-coordinate of the center (screen coordinates)
     * @param  {Number} w width of the box in pixel
     * @param  {Number} h width of the box in pixel
     * @return {Number}   Number of overlapping elements
     */
    getNumberOfConflicts: function(x, y, w, h) {
      var count = 0, i2, obj, le, savePointPrecision;
      savePointPrecision = this.board.options.precision.hasPoint;
      this.board.options.precision.hasPoint = (w + h) * 0.25;
      for (i2 = 0, le = this.board.objectsList.length; i2 < le; i2++) {
        obj = this.board.objectsList[i2];
        if (obj.visPropCalc.visible && obj.elType !== "axis" && obj.elType !== "ticks" && obj !== this.board.infobox && obj !== this && obj.hasPoint(x, y)) {
          count++;
        }
      }
      this.board.options.precision.hasPoint = savePointPrecision;
      return count;
    },
    /**
     * Sets the offset of a label element to the position with the least number
     * of overlaps with other elements, while retaining the distance to its
     * anchor element. Twelve different angles are possible.
     *
     * @returns {JXG.Text} Reference to the text object.
     */
    setAutoPosition: function() {
      var x, y, cx, cy, anchorCoords, w = this.size[0], h = this.size[1], start_angle, angle, optimum = {
        conflicts: Infinity,
        angle: 0,
        r: 0
      }, max_r, delta_r, conflicts, offset, r, num_positions = 12, step = 2 * Math.PI / num_positions, j, dx, dy, co, si;
      if (this === this.board.infobox || !this.visPropCalc.visible || !type_default.evaluate(this.visProp.islabel) || !this.element) {
        return this;
      }
      offset = type_default.evaluate(this.visProp.offset);
      anchorCoords = this.element.getLabelAnchor();
      cx = anchorCoords.scrCoords[1];
      cy = anchorCoords.scrCoords[2];
      dx = offset[0];
      dy = offset[1];
      conflicts = this.getNumberOfConflicts(cx + dx, cy - dy, w, h);
      if (conflicts === 0) {
        return this;
      }
      r = type_default.evaluate(this.visProp.autopositionmindistance);
      max_r = type_default.evaluate(this.visProp.autopositionmaxdistance);
      delta_r = 0.2 * r;
      start_angle = Math.atan2(dy, dx);
      optimum.conflicts = conflicts;
      optimum.angle = start_angle;
      optimum.r = r;
      while (optimum.conflicts > 0 && r <= max_r) {
        for (j = 1, angle = start_angle + step; j < num_positions && optimum.conflicts > 0; j++) {
          co = Math.cos(angle);
          si = Math.sin(angle);
          x = cx + r * co;
          y = cy - r * si;
          conflicts = this.getNumberOfConflicts(x, y, w, h);
          if (conflicts < optimum.conflicts) {
            optimum.conflicts = conflicts;
            optimum.angle = angle;
            optimum.r = r;
          }
          if (optimum.conflicts === 0) {
            break;
          }
          angle += step;
        }
        r += delta_r;
      }
      r = optimum.r;
      co = Math.cos(optimum.angle);
      si = Math.sin(optimum.angle);
      this.visProp.offset = [r * co, r * si];
      if (co < -0.2) {
        this.visProp.anchorx = "right";
      } else if (co > 0.2) {
        this.visProp.anchorx = "left";
      } else {
        this.visProp.anchorx = "middle";
      }
      return this;
    }
  }
);
jxg_default.createText = function(board, parents, attributes) {
  var t, attr = type_default.copyAttributes(attributes, board.options, "text"), coords = parents.slice(0, -1), content = parents[parents.length - 1];
  attr.anchor = attr.parent || attr.anchor;
  t = coordselement_default.create(jxg_default.Text, board, coords, attr, content);
  if (!t) {
    throw new Error(
      "JSXGraph: Can't create text with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [x,y], [z,x,y], [element,transformation]"
    );
  }
  if (attr.rotate !== 0) {
    t.addRotation(attr.rotate);
  }
  return t;
};
jxg_default.registerElement("text", jxg_default.createText);
jxg_default.createHTMLSlider = function(board, parents, attributes) {
  var t, par, attr = type_default.copyAttributes(attributes, board.options, "htmlslider");
  if (parents.length !== 2 || parents[0].length !== 2 || parents[1].length !== 3) {
    throw new Error(
      "JSXGraph: Can't create htmlslider with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parents are: [[x,y], [min, start, max]]"
    );
  }
  attr.anchor = attr.parent || attr.anchor;
  attr.fixed = attr.fixed || true;
  par = [
    parents[0][0],
    parents[0][1],
    '<form style="display:inline"><input type="range" /><span></span><input type="text" /></form>'
  ];
  t = jxg_default.createText(board, par, attr);
  t.type = type_default.OBJECT_TYPE_HTMLSLIDER;
  t.rendNodeForm = t.rendNode.childNodes[0];
  t.rendNodeRange = t.rendNodeForm.childNodes[0];
  t.rendNodeRange.min = parents[1][0];
  t.rendNodeRange.max = parents[1][2];
  t.rendNodeRange.step = attr.step;
  t.rendNodeRange.value = parents[1][1];
  t.rendNodeLabel = t.rendNodeForm.childNodes[1];
  t.rendNodeLabel.id = t.rendNode.id + "_label";
  if (attr.withlabel) {
    t.rendNodeLabel.innerHTML = t.name + "=";
  }
  t.rendNodeOut = t.rendNodeForm.childNodes[2];
  t.rendNodeOut.value = parents[1][1];
  try {
    t.rendNodeForm.id = t.rendNode.id + "_form";
    t.rendNodeRange.id = t.rendNode.id + "_range";
    t.rendNodeOut.id = t.rendNode.id + "_out";
  } catch (e) {
    jxg_default.debug(e);
  }
  t.rendNodeRange.style.width = attr.widthrange + "px";
  t.rendNodeRange.style.verticalAlign = "middle";
  t.rendNodeOut.style.width = attr.widthout + "px";
  t._val = parents[1][1];
  if (jxg_default.supportsVML()) {
    env_default.addEvent(t.rendNodeForm, "change", priv.HTMLSliderInputEventHandler, t);
  } else {
    env_default.addEvent(t.rendNodeForm, "input", priv.HTMLSliderInputEventHandler, t);
  }
  t.Value = function() {
    return this._val;
  };
  return t;
};
jxg_default.registerElement("htmlslider", jxg_default.createHTMLSlider);
var text_default = jxg_default.Text;

// node_modules/jsxgraph/src/parser/jessiecode.js
if (!Object.create) {
  Object.create = function(o, properties) {
    if (typeof o !== "object" && typeof o !== "function")
      throw new TypeError("Object prototype may only be an Object: " + o);
    else if (o === null)
      throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.");
    if (typeof properties != "undefined")
      throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument.");
    function F() {
    }
    F.prototype = o;
    return new F();
  };
}
var priv2 = {
  modules: {
    "math": math_default,
    "math/geometry": geometry_default,
    "math/statistics": statistics_default,
    "math/numerics": math_default.Numerics
  }
};
jxg_default.JessieCode = function(code, geonext) {
  this.scope = {
    id: 0,
    hasChild: true,
    args: [],
    locals: {},
    context: null,
    previous: null
  };
  this.scopes = [];
  this.scopes.push(this.scope);
  this.dpstack = [[]];
  this.pscope = 0;
  this.propstack = [{}];
  this.propscope = 0;
  this.lhs = [];
  this.isLHS = false;
  this.warnLog = "jcwarn";
  this.$log = [];
  this.builtIn = this.defineBuiltIn();
  this.operands = this.getPossibleOperands();
  this.board = null;
  this.forceValueCall = false;
  this.lineToElement = {};
  this.parCurLine = 1;
  this.parCurColumn = 0;
  this.line = 1;
  this.col = 1;
  if (jxg_default.CA) {
    this.CA = new jxg_default.CA(this.node, this.createNode, this);
  }
  this.code = "";
  if (typeof code === "string") {
    this.parse(code, geonext);
  }
};
jxg_default.extend(
  jxg_default.JessieCode.prototype,
  /** @lends JXG.JessieCode.prototype */
  {
    /**
     * Create a new parse tree node.
     * @param {String} type Type of node, e.g. node_op, node_var, or node_const
     * @param value The nodes value, e.g. a variables value or a functions body.
     * @param {Array} children Arbitrary number of child nodes.
     */
    node: function(type, value, children) {
      return {
        type,
        value,
        children
      };
    },
    /**
     * Create a new parse tree node. Basically the same as node(), but this builds
     * the children part out of an arbitrary number of parameters, instead of one
     * array parameter.
     * @param {String} type Type of node, e.g. node_op, node_var, or node_const
     * @param value The nodes value, e.g. a variables value or a functions body.
     * @param children Arbitrary number of parameters; define the child nodes.
     */
    createNode: function(type, value, children) {
      var n = this.node(type, value, []), i2;
      for (i2 = 2; i2 < arguments.length; i2++) {
        n.children.push(arguments[i2]);
      }
      if (n.type === "node_const" && type_default.isNumber(n.value)) {
        n.isMath = true;
      }
      n.line = this.parCurLine;
      n.col = this.parCurColumn;
      return n;
    },
    /**
     * Create a new scope.
     * @param {Array} args
     * @returns {Object}
     */
    pushScope: function(args2) {
      var scope2 = {
        args: args2,
        locals: {},
        context: null,
        previous: this.scope
      };
      this.scope.hasChild = true;
      this.scope = scope2;
      scope2.id = this.scopes.push(scope2) - 1;
      return scope2;
    },
    /**
     * Remove the current scope and reinstate the previous scope
     * @returns {Object}
     */
    popScope: function() {
      var s = this.scope.previous;
      this.scope = s !== null ? s : this.scope;
      return this.scope;
    },
    /**
     * Looks up an {@link JXG.GeometryElement} by its id.
     * @param {String} id
     * @returns {JXG.GeometryElement}
     */
    getElementById: function(id) {
      return this.board.objects[id];
    },
    log: function() {
      this.$log.push(arguments);
      if (typeof console === "object" && console.log) {
        console.log.apply(console, arguments);
      }
    },
    /**
     * Returns a element creator function which takes two parameters: the parents array and the attributes object.
     * @param {String} vname The element type, e.g. 'point', 'line', 'midpoint'
     * @returns {function}
     */
    creator: function() {
      var _ccache = {}, r;
      r = function(vname) {
        var f;
        if (typeof _ccache[this.board.id + vname] === "function") {
          f = _ccache[this.board.id + vname];
        } else {
          f = function(that2) {
            return function(parameters, attributes) {
              var attr;
              if (type_default.exists(attributes)) {
                attr = attributes;
              } else {
                attr = {};
              }
              if (attr.name === void 0 && attr.id === void 0) {
                attr.name = that2.lhs[that2.scope.id] !== 0 ? that2.lhs[that2.scope.id] : "";
              }
              return that2.board.create(vname, parameters, attr);
            };
          }(this);
          f.creator = true;
          _ccache[this.board.id + vname] = f;
        }
        return f;
      };
      r.clearCache = function() {
        _ccache = {};
      };
      return r;
    }(),
    /**
     * Assigns a value to a variable in the current scope.
     * @param {String} vname Variable name
     * @param value Anything
     * @see JXG.JessieCode#sstack
     * @see JXG.JessieCode#scope
     */
    letvar: function(vname, value) {
      if (this.builtIn[vname]) {
        this._warn('"' + vname + '" is a predefined value.');
      }
      this.scope.locals[vname] = value;
    },
    /**
     * Checks if the given variable name can be found in the current scope chain.
     * @param {String} vname
     * @returns {Object} A reference to the scope object the variable can be found in or null if it can't be found.
     */
    isLocalVariable: function(vname) {
      var s = this.scope;
      while (s !== null) {
        if (type_default.exists(s.locals[vname])) {
          return s;
        }
        s = s.previous;
      }
      return null;
    },
    /**
     * Checks if the given variable name is a parameter in any scope from the current to the global scope.
     * @param {String} vname
     * @returns {Object} A reference to the scope object that contains the variable in its arg list.
     */
    isParameter: function(vname) {
      var s = this.scope;
      while (s !== null) {
        if (type_default.indexOf(s.args, vname) > -1) {
          return s;
        }
        s = s.previous;
      }
      return null;
    },
    /**
     * Checks if the given variable name is a valid creator method.
     * @param {String} vname
     * @returns {Boolean}
     */
    isCreator: function(vname) {
      return !!jxg_default.elements[vname];
    },
    /**
     * Checks if the given variable identifier is a valid member of the JavaScript Math Object.
     * @param {String} vname
     * @returns {Boolean}
     */
    isMathMethod: function(vname) {
      return vname !== "E" && !!Math[vname];
    },
    /**
     * Returns true if the given identifier is a builtIn variable/function.
     * @param {String} vname
     * @returns {Boolean}
     */
    isBuiltIn: function(vname) {
      return !!this.builtIn[vname];
    },
    /**
     * Looks up the value of the given variable. We use a simple type inspection.
     *
     * @param {String} vname Name of the variable
     * @param {Boolean} [local=false] Only look up the internal symbol table and don't look for
     * the <tt>vname</tt> in Math or the element list.
     * @param {Boolean} [isFunctionName=false] Lookup function of type builtIn, Math.*, creator.
     *
     * @see JXG.JessieCode#resolveType
     */
    getvar: function(vname, local, isFunctionName) {
      var s;
      local = type_default.def(local, false);
      s = this.isLocalVariable(vname);
      if (s !== null) {
        return s.locals[vname];
      }
      if (vname === "$board" || vname === "EULER" || vname === "PI") {
        return this.builtIn[vname];
      }
      if (isFunctionName) {
        if (this.isBuiltIn(vname)) {
          return this.builtIn[vname];
        }
        if (this.isMathMethod(vname)) {
          return Math[vname];
        }
        if (this.isCreator(vname)) {
          return this.creator(vname);
        }
      }
      if (!local) {
        s = this.board.select(vname);
        if (s !== vname) {
          return s;
        }
      }
    },
    /**
     * Look up the value of a local variable.
     * @param {string} vname
     * @returns {*}
     */
    resolve: function(vname) {
      var s = this.scope;
      while (s !== null) {
        if (type_default.exists(s.locals[vname])) {
          return s.locals[vname];
        }
        s = s.previous;
      }
    },
    /**
     * TODO this needs to be called from JS and should not generate JS code
     * Looks up a variable identifier in various tables and generates JavaScript code that could be eval'd to get the value.
     * @param {String} vname Identifier
     * @param {Boolean} [local=false] Don't resolve ids and names of elements
     * @param {Boolean} [withProps=false]
     */
    getvarJS: function(vname, local, withProps) {
      var s, r = "", re;
      local = type_default.def(local, false);
      withProps = type_default.def(withProps, false);
      s = this.isParameter(vname);
      if (s !== null) {
        return vname;
      }
      s = this.isLocalVariable(vname);
      if (s !== null && !withProps) {
        return "$jc$.resolve('" + vname + "')";
      }
      if (this.isCreator(vname)) {
        return "(function () { var a = Array.prototype.slice.call(arguments, 0), props = " + (withProps ? "a.pop()" : "{}") + "; return $jc$.board.create.apply($jc$.board, ['" + vname + "'].concat([a, props])); })";
      }
      if (withProps) {
        this._error("Syntax error (attribute values are allowed with element creators only)");
      }
      if (this.isBuiltIn(vname)) {
        r = this.builtIn[vname].src || this.builtIn[vname];
        if (type_default.isNumber(r)) {
          return r;
        }
        if (r.match(/board\.select/)) {
          return r;
        }
        vname = r.split(".").pop();
        if (type_default.exists(this.board.mathLib)) {
          re = new RegExp("^Math." + vname);
          if (re.exec(r) !== null) {
            return r.replace(re, "$jc$.board.mathLib." + vname);
          }
        }
        if (type_default.exists(this.board.mathLibJXG)) {
          re = new RegExp("^JXG.Math.");
          if (re.exec(r) !== null) {
            return r.replace(re, "$jc$.board.mathLibJXG.");
          }
          return r;
        }
        return r;
      }
      if (this.isMathMethod(vname)) {
        return "$jc$.board.mathLib." + vname;
      }
      if (!local) {
        if (type_default.isId(this.board, vname)) {
          r = "$jc$.board.objects['" + vname + "']";
          if (this.board.objects[vname].elType === "slider") {
            r += ".Value()";
          }
        } else if (type_default.isName(this.board, vname)) {
          r = "$jc$.board.elementsByName['" + vname + "']";
          if (this.board.elementsByName[vname].elType === "slider") {
            r += ".Value()";
          }
        } else if (type_default.isGroup(this.board, vname)) {
          r = "$jc$.board.groups['" + vname + "']";
        }
        return r;
      }
      return "";
    },
    /**
     * Adds the property <tt>isMap</tt> to a function and sets it to true.
     * @param {function} f
     * @returns {function}
     */
    makeMap: function(f) {
      f.isMap = true;
      return f;
    },
    functionCodeJS: function(node2) {
      var p = node2.children[0].join(", "), bo = "", bc = "";
      if (node2.value === "op_map") {
        bo = "{ return  ";
        bc = " }";
      }
      return "function (" + p + ") {\nvar $oldscope$ = $jc$.scope;\n$jc$.scope = $jc$.scopes[" + this.scope.id + "];\nvar r = (function () " + bo + this.compile(node2.children[1], true) + bc + ")();\n$jc$.scope = $oldscope$;\nreturn r;\n}";
    },
    /**
     * Converts a node type <tt>node_op</tt> and value <tt>op_map</tt> or <tt>op_function</tt> into a executable
     * function. Does a simple type inspection.
     * @param {Object} node
     * @returns {function}
     * @see JXG.JessieCode#resolveType
     */
    defineFunction: function(node) {
      var fun, i, that = this, list = node.children[0], scope = this.pushScope(list);
      if (this.board.options.jc.compile) {
        this.isLHS = false;
        for (i = 0; i < list.length; i++) {
          scope.locals[list[i]] = list[i];
        }
        this.replaceNames(node.children[1]);
        fun = function(jc) {
          var fun, str = "var f = function($jc$) { return " + jc.functionCodeJS(node) + "}; f;";
          try {
            fun = eval(str)(jc);
            scope.argtypes = [];
            for (i = 0; i < list.length; i++) {
              scope.argtypes.push(that.resolveType(list[i], node));
            }
            return fun;
          } catch (e) {
            jc._warn("error compiling function\n\n" + str + "\n\n" + e.toString());
            return function() {
            };
          }
        }(this);
        this.popScope();
      } else {
        fun = function(_pstack, that2, id) {
          return function() {
            var r, oldscope;
            oldscope = that2.scope;
            that2.scope = that2.scopes[id];
            for (r = 0; r < _pstack.length; r++) {
              that2.scope.locals[_pstack[r]] = arguments[r];
            }
            r = that2.execute(node.children[1]);
            that2.scope = oldscope;
            return r;
          };
        }(list, this, scope.id);
      }
      fun.node = node;
      fun.scope = scope;
      fun.toJS = fun.toString;
      fun.toString = function(_that) {
        return function() {
          return _that.compile(_that.replaceIDs(type_default.deepCopy(node)));
        };
      }(this);
      fun.deps = {};
      this.collectDependencies(node.children[1], node.children[0], fun.deps);
      return fun;
    },
    /**
     * Merge all attribute values given with an element creator into one object.
     * @param {Object} o An arbitrary number of objects
     * @returns {Object} All given objects merged into one. If properties appear in more (case sensitive) than one
     * object the last value is taken.
     */
    mergeAttributes: function(o) {
      var i2, attr = {};
      for (i2 = 0; i2 < arguments.length; i2++) {
        attr = type_default.deepCopy(attr, arguments[i2], true);
      }
      return attr;
    },
    /**
     * Sets the property <tt>what</tt> of <tt>o</tt> to <tt>value</tt>
     * @param {JXG.Point|JXG.Text} o
     * @param {String} what
     * @param value
     */
    setProp: function(o, what, value) {
      var par = {}, x, y;
      if (o.elementClass === constants_default.OBJECT_CLASS_POINT && (what === "X" || what === "Y")) {
        what = what.toLowerCase();
        if (o.isDraggable && typeof value === "number") {
          x = what === "x" ? value : o.X();
          y = what === "y" ? value : o.Y();
          o.setPosition(constants_default.COORDS_BY_USER, [x, y]);
        } else if (o.isDraggable && (typeof value === "function" || typeof value === "string")) {
          x = what === "x" ? value : o.coords.usrCoords[1];
          y = what === "y" ? value : o.coords.usrCoords[2];
          o.addConstraint([x, y]);
        } else if (!o.isDraggable) {
          x = what === "x" ? value : o.XEval.origin;
          y = what === "y" ? value : o.YEval.origin;
          o.addConstraint([x, y]);
        }
        this.board.update();
      } else if (o.elementClass === constants_default.OBJECT_CLASS_TEXT && (what === "X" || what === "Y")) {
        if (typeof value === "number") {
          o[what] = function() {
            return value;
          };
        } else if (typeof value === "function") {
          o.isDraggable = false;
          o[what] = value;
        } else if (typeof value === "string") {
          o.isDraggable = false;
          o[what] = type_default.createFunction(value, this.board);
          o[what + "jc"] = value;
        }
        o[what].origin = value;
        this.board.update();
      } else if (o.type && o.elementClass && o.visProp) {
        if (type_default.exists(o[o.methodMap[what]]) && typeof o[o.methodMap[what]] !== "function") {
          o[o.methodMap[what]] = value;
        } else {
          par[what] = value;
          o.setAttribute(par);
        }
      } else {
        o[what] = value;
      }
    },
    /**
     * Generic method to parse JessieCode.
     * This consists of generating an AST with parser.parse,
     * apply simplifying rules from CA and
     * manipulate the AST according to the second parameter "cmd".
     * @param  {String} code      JessieCode code to be parsed
     * @param  {String} cmd       Type of manipulation to be done with AST
     * @param {Boolean} [geonext=false] Geonext compatibility mode.
     * @param {Boolean} [dontstore=false] If false, the code string is stored in this.code,
     *  i.e. in the JessieCode object, e.g. in board.jc.
     * @return {Object} Returns result of computation as directed in cmd.
     */
    _genericParse: function(code, cmd, geonext, dontstore) {
      var i2, setTextBackup, ast, result, ccode = code.replace(/\r\n/g, "\n").split("\n"), cleaned = [];
      if (!dontstore) {
        this.code += code + "\n";
      }
      if (text_default) {
        setTextBackup = text_default.prototype.setText;
        text_default.prototype.setText = text_default.prototype.setTextJessieCode;
      }
      try {
        if (!type_default.exists(geonext)) {
          geonext = false;
        }
        for (i2 = 0; i2 < ccode.length; i2++) {
          if (geonext) {
            ccode[i2] = jxg_default.GeonextParser.geonext2JS(ccode[i2], this.board);
          }
          cleaned.push(ccode[i2]);
        }
        code = cleaned.join("\n");
        ast = parser.parse(code);
        if (this.CA) {
          ast = this.CA.expandDerivatives(ast, null, ast);
          ast = this.CA.removeTrivialNodes(ast);
        }
        switch (cmd) {
          case "parse":
            result = this.execute(ast);
            break;
          case "manipulate":
            result = this.compile(ast);
            break;
          case "getAst":
            result = ast;
            break;
          default:
            result = false;
        }
      } catch (e) {
        throw e;
      } finally {
        if (text_default) {
          text_default.prototype.setText = setTextBackup;
        }
      }
      return result;
    },
    /**
     * Parses JessieCode.
     * This consists of generating an AST with parser.parse, apply simplifying rules
     * from CA and executing the ast by calling this.execute(ast).
     *
     * @param {String} code             JessieCode code to be parsed
     * @param {Boolean} [geonext=false] Geonext compatibility mode.
     * @param {Boolean} [dontstore=false] If false, the code string is stored in this.code.
     * @return {Object}                 Parse JessieCode code and execute it.
     */
    parse: function(code, geonext, dontstore) {
      return this._genericParse(code, "parse", geonext, dontstore);
    },
    /**
     * Manipulate JessieCode.
     * This consists of generating an AST with parser.parse,
     * apply simplifying rules from CA
     * and compile the AST back to JessieCode.
     *
     * @param {String} code             JessieCode code to be parsed
     * @param {Boolean} [geonext=false] Geonext compatibility mode.
     * @param {Boolean} [dontstore=false] If false, the code string is stored in this.code.
     * @return {String}                 Simplified JessieCode code
     */
    manipulate: function(code, geonext, dontstore) {
      return this._genericParse(code, "manipulate", geonext, dontstore);
    },
    /**
     * Get abstract syntax tree (AST) from JessieCode code.
     * This consists of generating an AST with parser.parse.
     *
     * @param {String} code
     * @param {Boolean} [geonext=false] Geonext compatibility mode.
     * @param {Boolean} [dontstore=false] If false, the code string is stored in this.code.
     * @return {Node}  AST
     */
    getAST: function(code, geonext, dontstore) {
      return this._genericParse(code, "getAst", geonext, dontstore);
    },
    /**
     * Parses a JessieCode snippet, e.g. "3+4", and wraps it into a function, if desired.
     * @param {String} code A small snippet of JessieCode. Must not be an assignment.
     * @param {Boolean} [funwrap=true] If true, the code is wrapped in a function.
     * @param {String} [varname=''] Name of the parameter(s)
     * @param {Boolean} [geonext=false] Geonext compatibility mode.
     * @param {Boolean} [forceValueCall=true] Force evaluation of value method of sliders.
     */
    snippet: function(code, funwrap, varname, geonext, forceValueCall) {
      var c;
      funwrap = type_default.def(funwrap, true);
      varname = type_default.def(varname, "");
      geonext = type_default.def(geonext, false);
      this.forceValueCall = type_default.def(forceValueCall, true);
      c = (funwrap ? " function (" + varname + ") { return " : "") + code + (funwrap ? "; }" : "") + ";";
      return this.parse(c, geonext, true);
    },
    /**
     * Traverses through the given subtree and changes all values of nodes with the replaced flag set by
     * {@link JXG.JessieCode#replaceNames} to the name of the element (if not empty).
     * @param {Object} node
     */
    replaceIDs: function(node2) {
      var i2, v;
      if (node2.replaced) {
        v = this.board.objects[node2.children[1][0].value];
        if (type_default.exists(v) && v.name !== "") {
          node2.type = "node_var";
          node2.value = v.name;
          node2.children.length = 0;
          delete node2.replaced;
        }
      }
      if (type_default.isArray(node2)) {
        for (i2 = 0; i2 < node2.length; i2++) {
          node2[i2] = this.replaceIDs(node2[i2]);
        }
      }
      if (node2.children) {
        for (i2 = node2.children.length; i2 > 0; i2--) {
          if (type_default.exists(node2.children[i2 - 1])) {
            node2.children[i2 - 1] = this.replaceIDs(node2.children[i2 - 1]);
          }
        }
      }
      return node2;
    },
    /**
     * Traverses through the given subtree and changes all elements referenced by names through referencing them by ID.
     * An identifier is only replaced if it is not found in all scopes above the current scope and if it
     * has not been blacklisted within the codeblock determined by the given subtree.
     * @param {Object} node
     * @param {Boolean} [callValuePar=false] if true, uses $value() instead of $() in createReplacementNode
     */
    replaceNames: function(node2, callValuePar) {
      var i2, v, callValue = false;
      if (callValuePar !== void 0) {
        callValue = callValuePar;
      }
      v = node2.value;
      if (node2.type === "node_op" && v === "op_lhs" && node2.children.length === 1) {
        this.isLHS = true;
      } else if (node2.type === "node_var") {
        if (this.isLHS) {
          this.letvar(v, true);
        } else if (!type_default.exists(this.getvar(v, true)) && type_default.exists(this.board.elementsByName[v])) {
          if (callValue && this.board.elementsByName[v].elType !== "slider") {
            callValue = false;
          }
          node2 = this.createReplacementNode(node2, callValue);
        }
      }
      if (type_default.isArray(node2)) {
        for (i2 = 0; i2 < node2.length; i2++) {
          node2[i2] = this.replaceNames(node2[i2], callValue);
        }
      }
      if (node2.children) {
        if (this.forceValueCall && // It must be enforced, see snippet.
        // 1. case: sin(a), max(a, 0), ...
        (node2.value === "op_execfun" && // Not in cases V(a), $(a)
        node2.children[0].value !== "V" && node2.children[0].value !== "$" && // Function must be a math function. This ensures that a number is required as input.
        (type_default.exists(Math[node2.children[0].value]) || type_default.exists(math_default[node2.children[0].value])) && // node.children[1].length === 1 &&
        node2.children[1][0].type === "node_var" || // 2. case: slider is the whole expression: 'a'
        node2.value === "op_return" && node2.children.length === 1 && node2.children[0].type === "node_var")) {
          callValue = true;
        }
        for (i2 = node2.children.length; i2 > 0; i2--) {
          if (type_default.exists(node2.children[i2 - 1])) {
            node2.children[i2 - 1] = this.replaceNames(node2.children[i2 - 1], callValue);
          }
        }
      }
      if (node2.type === "node_op" && node2.value === "op_lhs" && node2.children.length === 1) {
        this.isLHS = false;
      }
      return node2;
    },
    /**
     * Replaces node_var nodes with node_op&gt;op_execfun nodes, calling the internal $() function with the id of the
     * element accessed by the node_var node.
     * @param {Object} node
     * @param {Boolean} [callValue=undefined] if true, uses $value() instead of $()
     * @returns {Object} op_execfun node
     */
    createReplacementNode: function(node2, callValue) {
      var v = node2.value, el = this.board.elementsByName[v];
      node2 = this.createNode(
        "node_op",
        "op_execfun",
        this.createNode("node_var", callValue === true ? "$value" : "$"),
        [this.createNode("node_str", el.id)]
      );
      node2.replaced = true;
      return node2;
    },
    /**
     * Search the parse tree below <tt>node</tt> for <em>stationary</em> dependencies, i.e. dependencies hard coded into
     * the function.
     * @param {Object} node
     * @param {Array} varnames List of variable names of the function
     * @param {Object} result An object where the referenced elements will be stored. Access key is their id.
     */
    collectDependencies: function(node2, varnames, result) {
      var i2, v, e, le;
      if (type_default.isArray(node2)) {
        le = node2.length;
        for (i2 = 0; i2 < le; i2++) {
          this.collectDependencies(node2[i2], varnames, result);
        }
        return;
      }
      v = node2.value;
      if (node2.type === "node_var" && varnames.indexOf(v) < 0) {
        e = this.getvar(v);
        if (e && e.visProp && e.type && e.elementClass && e.id && e.type === constants_default.OBJECT_TYPE_SLIDER) {
          result[e.id] = e;
        }
      }
      if (node2.type === "node_op" && node2.value === "op_execfun" && node2.children.length > 1 && node2.children[0].value === "$" && node2.children[1].length > 0) {
        e = node2.children[1][0].value;
        result[e] = this.board.objects[e];
      }
      if (node2.children) {
        for (i2 = node2.children.length; i2 > 0; i2--) {
          if (type_default.exists(node2.children[i2 - 1])) {
            this.collectDependencies(node2.children[i2 - 1], varnames, result);
          }
        }
      }
    },
    resolveProperty: function(e, v, compile) {
      compile = type_default.def(compile, false);
      if (e && e.methodMap) {
        if (type_default.exists(e.subs) && type_default.exists(e.subs[v])) {
          e = e.subs;
        } else if (type_default.exists(e.methodMap[v])) {
          v = e.methodMap[v];
        } else {
          e = e.visProp;
          v = v.toLowerCase();
        }
      }
      if (type_default.isFunction(e)) {
        this._error("Accessing function properties is not allowed.");
      }
      if (!type_default.exists(e)) {
        this._error(e + " is not an object");
      }
      if (!type_default.exists(e[v])) {
        this._error("unknown property " + v);
      }
      if (compile && typeof e[v] === "function") {
        return function() {
          return e[v].apply(e, arguments);
        };
      }
      return e[v];
    },
    /**
     * Type inspection: check if the string vname appears as function name in the
     * AST node. Used in "op_execfun". This allows the JessieCode examples below.
     *
     * @private
     * @param {String} vname
     * @param {Object} node
     * @returns 'any' or 'function'
     * @see JXG.JessieCode#execute
     * @see JXG.JessieCode#getvar
     *
     * @example
     *  var p = board.create('point', [2, 0], {name: 'X'});
     *  var txt = 'X(X)';
     *  console.log(board.jc.parse(txt));
     *
     * @example
     *  var p = board.create('point', [2, 0], {name: 'X'});
     *  var txt = 'f = function(el, X) { return X(el); }; f(X, X);';
     *  console.log(board.jc.parse(txt));
     *
     * @example
     *  var p = board.create('point', [2, 0], {name: 'point'});
     *  var txt = 'B = point(1,3); X(point);';
     *  console.log(board.jc.parse(txt));
     *
     * @example
     *  var p = board.create('point', [2, 0], {name: 'A'});
     *  var q = board.create('point', [-2, 0], {name: 'X'});
     *  var txt = 'getCoord=function(p, f){ return f(p); }; getCoord(A, X);';
     *  console.log(board.jc.parse(txt));
     */
    resolveType: function(vname, node2) {
      var i2, t, type = "any";
      if (type_default.isArray(node2)) {
        for (i2 = 0; i2 < node2.length; i2++) {
          t = this.resolveType(vname, node2[i2]);
          if (t !== "any") {
            type = t;
            return type;
          }
        }
      }
      if (node2.type === "node_op" && node2.value === "op_execfun" && node2.children[0].type === "node_var" && node2.children[0].value === vname) {
        return "function";
      }
      if (node2.type === "node_op") {
        for (i2 = 0; i2 < node2.children.length; i2++) {
          if (node2.children[0].type === "node_var" && node2.children[0].value === vname && (node2.value === "op_add" || node2.value === "op_sub" || node2.value === "op_mul" || node2.value === "op_div" || node2.value === "op_mod" || node2.value === "op_exp" || node2.value === "op_neg")) {
            return "any";
          }
        }
        for (i2 = 0; i2 < node2.children.length; i2++) {
          t = this.resolveType(vname, node2.children[i2]);
          if (t !== "any") {
            type = t;
            return type;
          }
        }
      }
      return "any";
    },
    /**
     * Resolves the lefthand side of an assignment operation
     * @param node
     * @returns {Object} An object with two properties. <strong>o</strong> which contains the object, and
     * a string <strong>what</strong> which contains the property name.
     */
    getLHS: function(node2) {
      var res;
      if (node2.type === "node_var") {
        res = {
          o: this.scope.locals,
          what: node2.value
        };
      } else if (node2.type === "node_op" && node2.value === "op_property") {
        res = {
          o: this.execute(node2.children[0]),
          what: node2.children[1]
        };
      } else if (node2.type === "node_op" && node2.value === "op_extvalue") {
        res = {
          o: this.execute(node2.children[0]),
          what: this.execute(node2.children[1])
        };
      } else {
        throw new Error("Syntax error: Invalid left-hand side of assignment.");
      }
      return res;
    },
    getLHSCompiler: function(node2, js) {
      var res;
      if (node2.type === "node_var") {
        res = node2.value;
      } else if (node2.type === "node_op" && node2.value === "op_property") {
        res = [
          this.compile(node2.children[0], js),
          "'" + node2.children[1] + "'"
        ];
      } else if (node2.type === "node_op" && node2.value === "op_extvalue") {
        res = [
          this.compile(node2.children[0], js),
          node2.children[1].type === "node_const" ? node2.children[1].value : this.compile(node2.children[1], js)
        ];
      } else {
        throw new Error("Syntax error: Invalid left-hand side of assignment.");
      }
      return res;
    },
    /**
     * Executes a parse subtree.
     * @param {Object} node
     * @returns {Number|String|Object|Boolean} Something
     * @private
     */
    execute: function(node2) {
      var ret, v, i2, e, l, undef3, list2, ilist, parents = [], fun2, attr, sc;
      ret = 0;
      if (!node2) {
        return ret;
      }
      this.line = node2.line;
      this.col = node2.col;
      switch (node2.type) {
        case "node_op":
          switch (node2.value) {
            case "op_none":
              if (node2.children[0]) {
                this.execute(node2.children[0]);
              }
              if (node2.children[1]) {
                ret = this.execute(node2.children[1]);
              }
              break;
            case "op_assign":
              v = this.getLHS(node2.children[0]);
              this.lhs[this.scope.id] = v.what;
              if (v.o.type && v.o.elementClass && v.o.methodMap && v.what === "label") {
                this._error("Left-hand side of assignment is read-only.");
              }
              ret = this.execute(node2.children[1]);
              if (v.o !== this.scope.locals || type_default.isArray(v.o) && typeof v.what === "number") {
                this.setProp(v.o, v.what, ret);
              } else {
                this.letvar(v.what, ret);
              }
              this.lhs[this.scope.id] = 0;
              break;
            case "op_if":
              if (this.execute(node2.children[0])) {
                ret = this.execute(node2.children[1]);
              }
              break;
            case "op_conditional":
            case "op_if_else":
              if (this.execute(node2.children[0])) {
                ret = this.execute(node2.children[1]);
              } else {
                ret = this.execute(node2.children[2]);
              }
              break;
            case "op_while":
              while (this.execute(node2.children[0])) {
                this.execute(node2.children[1]);
              }
              break;
            case "op_do":
              do {
                this.execute(node2.children[0]);
              } while (this.execute(node2.children[1]));
              break;
            case "op_for":
              for (this.execute(node2.children[0]); this.execute(node2.children[1]); this.execute(node2.children[2])) {
                this.execute(node2.children[3]);
              }
              break;
            case "op_proplst":
              if (node2.children[0]) {
                this.execute(node2.children[0]);
              }
              if (node2.children[1]) {
                this.execute(node2.children[1]);
              }
              break;
            case "op_emptyobject":
              ret = {};
              break;
            case "op_proplst_val":
              this.propstack.push({});
              this.propscope++;
              this.execute(node2.children[0]);
              ret = this.propstack[this.propscope];
              this.propstack.pop();
              this.propscope--;
              break;
            case "op_prop":
              this.propstack[this.propscope][node2.children[0]] = this.execute(node2.children[1]);
              break;
            case "op_array":
              ret = [];
              l = node2.children[0].length;
              for (i2 = 0; i2 < l; i2++) {
                ret.push(this.execute(node2.children[0][i2]));
              }
              break;
            case "op_extvalue":
              ret = this.execute(node2.children[0]);
              i2 = this.execute(node2.children[1]);
              if (typeof i2 === "number" && Math.abs(Math.round(i2) - i2) < math_default.eps) {
                ret = ret[i2];
              } else {
                ret = undef3;
              }
              break;
            case "op_return":
              if (this.scope === 0) {
                this._error("Unexpected return.");
              } else {
                return this.execute(node2.children[0]);
              }
              break;
            case "op_map":
              if (!node2.children[1].isMath && node2.children[1].type !== "node_var") {
                this._error("execute: In a map only function calls and mathematical expressions are allowed.");
              }
              fun2 = this.defineFunction(node2);
              fun2.isMap = true;
              ret = fun2;
              break;
            case "op_function":
              fun2 = this.defineFunction(node2);
              fun2.isMap = false;
              ret = fun2;
              break;
            case "op_execfun":
              this.dpstack.push([]);
              this.pscope++;
              list2 = node2.children[1];
              if (type_default.exists(node2.children[2])) {
                if (node2.children[3]) {
                  ilist = node2.children[2];
                  attr = {};
                  for (i2 = 0; i2 < ilist.length; i2++) {
                    attr = type_default.deepCopy(attr, this.execute(ilist[i2]), true);
                  }
                } else {
                  attr = this.execute(node2.children[2]);
                }
              }
              node2.children[0]._isFunctionName = true;
              fun2 = this.execute(node2.children[0]);
              delete node2.children[0]._isFunctionName;
              if (type_default.exists(fun2) && type_default.exists(fun2.sc)) {
                sc = fun2.sc;
              } else {
                sc = this;
              }
              if (!fun2.creator && type_default.exists(node2.children[2])) {
                this._error("Unexpected value. Only element creators are allowed to have a value after the function call.");
              }
              for (i2 = 0; i2 < list2.length; i2++) {
                if (type_default.exists(fun2.scope) && type_default.exists(fun2.scope.argtypes) && fun2.scope.argtypes[i2] === "function") {
                  list2[i2]._isFunctionName = true;
                  parents[i2] = this.execute(list2[i2]);
                  delete list2[i2]._isFunctionName;
                } else {
                  parents[i2] = this.execute(list2[i2]);
                }
                this.dpstack[this.pscope].push({
                  line: node2.children[1][i2].line,
                  // SketchBin currently works only if the last column of the
                  // parent position is taken. This is due to how I patched JS/CC
                  // to count the lines and columns. So, ecol will do for now
                  col: node2.children[1][i2].ecol
                });
              }
              if (typeof fun2 === "function" && !fun2.creator) {
                ret = fun2.apply(sc, parents);
              } else if (typeof fun2 === "function" && !!fun2.creator) {
                e = this.line;
                try {
                  ret = fun2(parents, attr);
                  ret.jcLineStart = e;
                  ret.jcLineEnd = node2.eline;
                  for (i2 = e; i2 <= node2.line; i2++) {
                    this.lineToElement[i2] = ret;
                  }
                  ret.debugParents = this.dpstack[this.pscope];
                } catch (ex) {
                  this._error(ex.toString());
                }
              } else {
                this._error("Function '" + fun2 + "' is undefined.");
              }
              this.dpstack.pop();
              this.pscope--;
              break;
            case "op_property":
              e = this.execute(node2.children[0]);
              v = node2.children[1];
              ret = this.resolveProperty(e, v, false);
              if (type_default.exists(ret) && ["number", "string", "boolean"].indexOf(typeof ret) < 0) {
                ret.sc = e;
              }
              break;
            case "op_use":
              this._warn("Use of the 'use' operator is deprecated.");
              this.use(node2.children[0].toString());
              break;
            case "op_delete":
              this._warn("Use of the 'delete' operator is deprecated. Please use the remove() function.");
              v = this.getvar(node2.children[0]);
              ret = this.del(v);
              break;
            case "op_eq":
              ret = this.execute(node2.children[0]) == this.execute(node2.children[1]);
              break;
            case "op_neq":
              ret = this.execute(node2.children[0]) != this.execute(node2.children[1]);
              break;
            case "op_approx":
              ret = Math.abs(this.execute(node2.children[0]) - this.execute(node2.children[1])) < math_default.eps;
              break;
            case "op_gt":
              ret = this.execute(node2.children[0]) > this.execute(node2.children[1]);
              break;
            case "op_lt":
              ret = this.execute(node2.children[0]) < this.execute(node2.children[1]);
              break;
            case "op_geq":
              ret = this.execute(node2.children[0]) >= this.execute(node2.children[1]);
              break;
            case "op_leq":
              ret = this.execute(node2.children[0]) <= this.execute(node2.children[1]);
              break;
            case "op_or":
              ret = this.execute(node2.children[0]) || this.execute(node2.children[1]);
              break;
            case "op_and":
              ret = this.execute(node2.children[0]) && this.execute(node2.children[1]);
              break;
            case "op_not":
              ret = !this.execute(node2.children[0]);
              break;
            case "op_add":
              ret = this.add(this.execute(node2.children[0]), this.execute(node2.children[1]));
              break;
            case "op_sub":
              ret = this.sub(this.execute(node2.children[0]), this.execute(node2.children[1]));
              break;
            case "op_div":
              ret = this.div(this.execute(node2.children[0]), this.execute(node2.children[1]));
              break;
            case "op_mod":
              ret = this.mod(this.execute(node2.children[0]), this.execute(node2.children[1]), true);
              break;
            case "op_mul":
              ret = this.mul(this.execute(node2.children[0]), this.execute(node2.children[1]));
              break;
            case "op_exp":
              ret = this.pow(this.execute(node2.children[0]), this.execute(node2.children[1]));
              break;
            case "op_neg":
              ret = this.neg(this.execute(node2.children[0]));
              break;
          }
          break;
        case "node_var":
          ret = this.getvar(node2.value, false, node2._isFunctionName);
          break;
        case "node_const":
          if (node2.value === null) {
            ret = null;
          } else {
            ret = Number(node2.value);
          }
          break;
        case "node_const_bool":
          ret = node2.value;
          break;
        case "node_str":
          ret = node2.value.replace(/\\(.)/g, "$1");
          break;
      }
      return ret;
    },
    /**
     * Compiles a parse tree back to JessieCode.
     * @param {Object} node
     * @param {Boolean} [js=false] Compile either to JavaScript or back to JessieCode (required for the UI).
     * @returns Something
     * @private
     */
    compile: function(node2, js) {
      var e, i2, list2, scope2, ret = "";
      if (!type_default.exists(js)) {
        js = false;
      }
      if (!node2) {
        return ret;
      }
      switch (node2.type) {
        case "node_op":
          switch (node2.value) {
            case "op_none":
              if (node2.children[0]) {
                ret = this.compile(node2.children[0], js);
              }
              if (node2.children[1]) {
                ret += this.compile(node2.children[1], js);
              }
              break;
            case "op_assign":
              if (js) {
                e = this.getLHSCompiler(node2.children[0], js);
                if (type_default.isArray(e)) {
                  ret = "$jc$.setProp(" + e[0] + ", " + e[1] + ", " + this.compile(node2.children[1], js) + ");\n";
                } else {
                  if (this.isLocalVariable(e) !== this.scope) {
                    this.scope.locals[e] = true;
                  }
                  ret = "$jc$.scopes[" + this.scope.id + "].locals['" + e + "'] = " + this.compile(node2.children[1], js) + ";\n";
                }
              } else {
                e = this.compile(node2.children[0]);
                ret = e + " = " + this.compile(node2.children[1], js) + ";\n";
              }
              break;
            case "op_if":
              ret = " if (" + this.compile(node2.children[0], js) + ") " + this.compile(node2.children[1], js);
              break;
            case "op_if_else":
              ret = " if (" + this.compile(node2.children[0], js) + ")" + this.compile(node2.children[1], js);
              ret += " else " + this.compile(node2.children[2], js);
              break;
            case "op_conditional":
              ret = "((" + this.compile(node2.children[0], js) + ")?(" + this.compile(node2.children[1], js);
              ret += "):(" + this.compile(node2.children[2], js) + "))";
              break;
            case "op_while":
              ret = " while (" + this.compile(node2.children[0], js) + ") {\n" + this.compile(node2.children[1], js) + "}\n";
              break;
            case "op_do":
              ret = " do {\n" + this.compile(node2.children[0], js) + "} while (" + this.compile(node2.children[1], js) + ");\n";
              break;
            case "op_for":
              ret = " for (" + this.compile(node2.children[0], js) + // Assignment ends with ";"
              this.compile(node2.children[1], js) + "; " + // Logical test comes without ";"
              this.compile(node2.children[2], js).slice(0, -2) + // Counting comes with ";" which has to be removed
              ") {\n" + this.compile(node2.children[3], js) + "\n}\n";
              break;
            case "op_proplst":
              if (node2.children[0]) {
                ret = this.compile(node2.children[0], js) + ", ";
              }
              ret += this.compile(node2.children[1], js);
              break;
            case "op_prop":
              ret = node2.children[0] + ": " + this.compile(node2.children[1], js);
              break;
            case "op_emptyobject":
              ret = js ? "{}" : "<< >>";
              break;
            case "op_proplst_val":
              ret = this.compile(node2.children[0], js);
              break;
            case "op_array":
              list2 = [];
              for (i2 = 0; i2 < node2.children[0].length; i2++) {
                list2.push(this.compile(node2.children[0][i2], js));
              }
              ret = "[" + list2.join(", ") + "]";
              break;
            case "op_extvalue":
              ret = this.compile(node2.children[0], js) + "[" + this.compile(node2.children[1], js) + "]";
              break;
            case "op_return":
              ret = " return " + this.compile(node2.children[0], js) + ";\n";
              break;
            case "op_map":
              if (!node2.children[1].isMath && node2.children[1].type !== "node_var") {
                this._error("compile: In a map only function calls and mathematical expressions are allowed.");
              }
              list2 = node2.children[0];
              if (js) {
                ret = " $jc$.makeMap(function (" + list2.join(", ") + ") { return " + this.compile(node2.children[1], js) + "; })";
              } else {
                ret = "map (" + list2.join(", ") + ") -> " + this.compile(node2.children[1], js);
              }
              break;
            case "op_function":
              list2 = node2.children[0];
              scope2 = this.pushScope(list2);
              if (js) {
                ret = this.functionCodeJS(node2);
              } else {
                ret = " function (" + list2.join(", ") + ") " + this.compile(node2.children[1], js);
              }
              this.popScope();
              break;
            case "op_execfunmath":
              console.log("op_execfunmath: TODO");
              ret = "-1";
              break;
            case "op_execfun":
              if (node2.children[2]) {
                list2 = [];
                for (i2 = 0; i2 < node2.children[2].length; i2++) {
                  list2.push(this.compile(node2.children[2][i2], js));
                }
                if (js) {
                  e = "$jc$.mergeAttributes(" + list2.join(", ") + ")";
                } else {
                  e = list2.join(", ");
                }
              }
              node2.children[0].withProps = !!node2.children[2];
              list2 = [];
              for (i2 = 0; i2 < node2.children[1].length; i2++) {
                list2.push(this.compile(node2.children[1][i2], js));
              }
              ret = this.compile(node2.children[0], js) + "(" + list2.join(", ") + (node2.children[2] && js ? ", " + e : "") + ")" + (node2.children[2] && !js ? " " + e : "");
              if (js) {
                ret += "\n";
              }
              if (js && node2.children[0].value === "$") {
                ret = "$jc$.board.objects[" + this.compile(node2.children[1][0], js) + "]";
              }
              break;
            case "op_property":
              if (js && node2.children[1] !== "X" && node2.children[1] !== "Y") {
                ret = "$jc$.resolveProperty(" + this.compile(node2.children[0], js) + ", '" + node2.children[1] + "', true)";
              } else {
                ret = this.compile(node2.children[0], js) + "." + node2.children[1];
              }
              break;
            case "op_use":
              this._warn("Use of the 'use' operator is deprecated.");
              if (js) {
                ret = "$jc$.use('";
              } else {
                ret = "use('";
              }
              ret += node2.children[0].toString() + "');";
              break;
            case "op_delete":
              this._warn("Use of the 'delete' operator is deprecated. Please use the remove() function.");
              if (js) {
                ret = "$jc$.del(";
              } else {
                ret = "remove(";
              }
              ret += this.compile(node2.children[0], js) + ")";
              break;
            case "op_eq":
              ret = "(" + this.compile(node2.children[0], js) + " === " + this.compile(node2.children[1], js) + ")";
              break;
            case "op_neq":
              ret = "(" + this.compile(node2.children[0], js) + " !== " + this.compile(node2.children[1], js) + ")";
              break;
            case "op_approx":
              ret = "(" + this.compile(node2.children[0], js) + " ~= " + this.compile(node2.children[1], js) + ")";
              break;
            case "op_gt":
              if (js) {
                ret = "$jc$.gt(" + this.compile(node2.children[0], js) + ", " + this.compile(node2.children[1], js) + ")";
              } else {
                ret = "(" + this.compile(node2.children[0], js) + " > " + this.compile(node2.children[1], js) + ")";
              }
              break;
            case "op_lt":
              if (js) {
                ret = "$jc$.lt(" + this.compile(node2.children[0], js) + ", " + this.compile(node2.children[1], js) + ")";
              } else {
                ret = "(" + this.compile(node2.children[0], js) + " < " + this.compile(node2.children[1], js) + ")";
              }
              break;
            case "op_geq":
              if (js) {
                ret = "$jc$.geq(" + this.compile(node2.children[0], js) + ", " + this.compile(node2.children[1], js) + ")";
              } else {
                ret = "(" + this.compile(node2.children[0], js) + " >= " + this.compile(node2.children[1], js) + ")";
              }
              break;
            case "op_leq":
              if (js) {
                ret = "$jc$.leq(" + this.compile(node2.children[0], js) + ", " + this.compile(node2.children[1], js) + ")";
              } else {
                ret = "(" + this.compile(node2.children[0], js) + " <= " + this.compile(node2.children[1], js) + ")";
              }
              break;
            case "op_or":
              ret = "(" + this.compile(node2.children[0], js) + " || " + this.compile(node2.children[1], js) + ")";
              break;
            case "op_and":
              ret = "(" + this.compile(node2.children[0], js) + " && " + this.compile(node2.children[1], js) + ")";
              break;
            case "op_not":
              ret = "!(" + this.compile(node2.children[0], js) + ")";
              break;
            case "op_add":
              if (js) {
                ret = "$jc$.add(" + this.compile(node2.children[0], js) + ", " + this.compile(node2.children[1], js) + ")";
              } else {
                ret = "(" + this.compile(node2.children[0], js) + " + " + this.compile(node2.children[1], js) + ")";
              }
              break;
            case "op_sub":
              if (js) {
                ret = "$jc$.sub(" + this.compile(node2.children[0], js) + ", " + this.compile(node2.children[1], js) + ")";
              } else {
                ret = "(" + this.compile(node2.children[0], js) + " - " + this.compile(node2.children[1], js) + ")";
              }
              break;
            case "op_div":
              if (js) {
                ret = "$jc$.div(" + this.compile(node2.children[0], js) + ", " + this.compile(node2.children[1], js) + ")";
              } else {
                ret = "(" + this.compile(node2.children[0], js) + " / " + this.compile(node2.children[1], js) + ")";
              }
              break;
            case "op_mod":
              if (js) {
                ret = "$jc$.mod(" + this.compile(node2.children[0], js) + ", " + this.compile(node2.children[1], js) + ", true)";
              } else {
                ret = "(" + this.compile(node2.children[0], js) + " % " + this.compile(node2.children[1], js) + ")";
              }
              break;
            case "op_mul":
              if (js) {
                ret = "$jc$.mul(" + this.compile(node2.children[0], js) + ", " + this.compile(node2.children[1], js) + ")";
              } else {
                ret = "(" + this.compile(node2.children[0], js) + " * " + this.compile(node2.children[1], js) + ")";
              }
              break;
            case "op_exp":
              if (js) {
                ret = "$jc$.pow(" + this.compile(node2.children[0], js) + ", " + this.compile(node2.children[1], js) + ")";
              } else {
                ret = "(" + this.compile(node2.children[0], js) + "^" + this.compile(node2.children[1], js) + ")";
              }
              break;
            case "op_neg":
              if (js) {
                ret = "$jc$.neg(" + this.compile(node2.children[0], js) + ")";
              } else {
                ret = "(-" + this.compile(node2.children[0], js) + ")";
              }
              break;
          }
          break;
        case "node_var":
          if (js) {
            ret = this.getvarJS(node2.value, false, node2.withProps);
          } else {
            ret = node2.value;
          }
          break;
        case "node_const":
          ret = node2.value;
          break;
        case "node_const_bool":
          ret = node2.value;
          break;
        case "node_str":
          ret = "'" + node2.value + "'";
          break;
      }
      if (node2.needsBrackets) {
        ret = "{\n" + ret + " }\n";
      }
      if (node2.needsAngleBrackets) {
        if (js) {
          ret = "{\n" + ret + " }\n";
        } else {
          ret = "<< " + ret + " >>\n";
        }
      }
      return ret;
    },
    /**
     * This is used as the global getName() function.
     * @param {JXG.GeometryElement} obj
     * @param {Boolean} useId
     * @returns {String}
     */
    getName: function(obj, useId) {
      var name = "";
      if (type_default.exists(obj) && type_default.exists(obj.getName)) {
        name = obj.getName();
        if ((!type_default.exists(name) || name === "") && useId) {
          name = obj.id;
        }
      } else if (useId) {
        name = obj.id;
      }
      return name;
    },
    /**
     * This is used as the global X() function.
     * @param {JXG.Point|JXG.Text} e
     * @returns {Number}
     */
    X: function(e) {
      return e.X();
    },
    /**
     * This is used as the global Y() function.
     * @param {JXG.Point|JXG.Text} e
     * @returns {Number}
     */
    Y: function(e) {
      return e.Y();
    },
    /**
     * This is used as the global V() function.
     * @param {Glider|Slider} e
     * @returns {Number}
     */
    V: function(e) {
      return e.Value();
    },
    /**
     * This is used as the global L() function.
     * @param {JXG.Line} e
     * @returns {Number}
     */
    L: function(e) {
      return e.L();
    },
    /**
     * This is used as the global area() function.
     * @param {JXG.Circle|JXG.Polygon} obj
     * @returns {Number}
     */
    area: function(obj) {
      if (!type_default.exists(obj) || !type_default.exists(obj.Area)) {
        this._error("Error: Can't calculate area.");
      }
      return obj.Area();
    },
    /**
     * This is used as the global perimeter() function.
     * @param {JXG.Circle|JXG.Polygon} obj
     * @returns {Number}
     */
    perimeter: function(obj) {
      if (!type_default.exists(obj) || !type_default.exists(obj.Perimeter)) {
        this._error("Error: Can't calculate perimeter.");
      }
      return obj.Perimeter();
    },
    /**
     * This is used as the global dist() function.
     * @param {JXG.Point} p1
     * @param {JXG.Point} p2
     * @returns {Number}
     */
    dist: function(p1, p2) {
      if (!type_default.exists(p1) || !type_default.exists(p1.Dist)) {
        this._error("Error: Can't calculate distance.");
      }
      return p1.Dist(p2);
    },
    /**
     * This is used as the global radius() function.
     * @param {JXG.Circle|Sector} obj
     * @returns {Number}
     */
    radius: function(obj) {
      if (!type_default.exists(obj) || !type_default.exists(obj.Radius)) {
        this._error("Error: Can't calculate radius.");
      }
      return obj.Radius();
    },
    /**
     * This is used as the global slope() function.
     * @param {JXG.Line} obj
     * @returns {Number}
     */
    slope: function(obj) {
      if (!type_default.exists(obj) || !type_default.exists(obj.Slope)) {
        this._error("Error: Can't calculate slope.");
      }
      return obj.Slope();
    },
    /**
     * + operator implementation
     * @param {Number|Array|JXG.Point} a
     * @param {Number|Array|JXG.Point} b
     * @returns {Number|Array}
     */
    add: function(a, b) {
      var i2, len, res;
      a = type_default.evalSlider(a);
      b = type_default.evalSlider(b);
      if (ia_default.isInterval(a) || ia_default.isInterval(b)) {
        res = ia_default.add(a, b);
      } else if (type_default.isArray(a) && type_default.isArray(b)) {
        len = Math.min(a.length, b.length);
        res = [];
        for (i2 = 0; i2 < len; i2++) {
          res[i2] = a[i2] + b[i2];
        }
      } else if (type_default.isNumber(a) && type_default.isNumber(b)) {
        res = a + b;
      } else if (type_default.isString(a) || type_default.isString(b)) {
        res = a.toString() + b.toString();
      } else {
        this._error("Operation + not defined on operands " + typeof a + " and " + typeof b);
      }
      return res;
    },
    /**
     * - operator implementation
     * @param {Number|Array|JXG.Point} a
     * @param {Number|Array|JXG.Point} b
     * @returns {Number|Array}
     */
    sub: function(a, b) {
      var i2, len, res;
      a = type_default.evalSlider(a);
      b = type_default.evalSlider(b);
      if (ia_default.isInterval(a) || ia_default.isInterval(b)) {
        res = ia_default.sub(a, b);
      } else if (type_default.isArray(a) && type_default.isArray(b)) {
        len = Math.min(a.length, b.length);
        res = [];
        for (i2 = 0; i2 < len; i2++) {
          res[i2] = a[i2] - b[i2];
        }
      } else if (type_default.isNumber(a) && type_default.isNumber(b)) {
        res = a - b;
      } else {
        this._error("Operation - not defined on operands " + typeof a + " and " + typeof b);
      }
      return res;
    },
    /**
     * unary - operator implementation
     * @param {Number|Array|JXG.Point} a
     * @returns {Number|Array}
     */
    neg: function(a) {
      var i2, len, res;
      a = type_default.evalSlider(a);
      if (ia_default.isInterval(a)) {
        res = ia_default.negative(a);
      } else if (type_default.isArray(a)) {
        len = a.length;
        res = [];
        for (i2 = 0; i2 < len; i2++) {
          res[i2] = -a[i2];
        }
      } else if (type_default.isNumber(a)) {
        res = -a;
      } else {
        this._error("Unary operation - not defined on operand " + typeof a);
      }
      return res;
    },
    /**
     * Multiplication of vectors and numbers
     * @param {Number|Array} a
     * @param {Number|Array} b
     * @returns {Number|Array} (Inner) product of the given input values.
     */
    mul: function(a, b) {
      var i2, len, res;
      a = type_default.evalSlider(a);
      b = type_default.evalSlider(b);
      if (type_default.isArray(a) && type_default.isNumber(b)) {
        i2 = a;
        a = b;
        b = a;
      }
      if (ia_default.isInterval(a) || ia_default.isInterval(b)) {
        res = ia_default.mul(a, b);
      } else if (type_default.isArray(a) && type_default.isArray(b)) {
        len = Math.min(a.length, b.length);
        res = math_default.innerProduct(a, b, len);
      } else if (type_default.isNumber(a) && type_default.isArray(b)) {
        len = b.length;
        res = [];
        for (i2 = 0; i2 < len; i2++) {
          res[i2] = a * b[i2];
        }
      } else if (type_default.isNumber(a) && type_default.isNumber(b)) {
        res = a * b;
      } else {
        this._error("Operation * not defined on operands " + typeof a + " and " + typeof b);
      }
      return res;
    },
    /**
     * Implementation of the / operator.
     * @param {Number|Array} a
     * @param {Number} b
     * @returns {Number|Array}
     */
    div: function(a, b) {
      var i2, len, res;
      a = type_default.evalSlider(a);
      b = type_default.evalSlider(b);
      if (ia_default.isInterval(a) || ia_default.isInterval(b)) {
        res = ia_default.div(a, b);
      } else if (type_default.isArray(a) && type_default.isNumber(b)) {
        len = a.length;
        res = [];
        for (i2 = 0; i2 < len; i2++) {
          res[i2] = a[i2] / b;
        }
      } else if (type_default.isNumber(a) && type_default.isNumber(b)) {
        res = a / b;
      } else {
        this._error("Operation * not defined on operands " + typeof a + " and " + typeof b);
      }
      return res;
    },
    /**
     * Implementation of the % operator.
     * @param {Number|Array} a
     * @param {Number} b
     * @returns {Number|Array}
     */
    mod: function(a, b) {
      var i2, len, res;
      a = type_default.evalSlider(a);
      b = type_default.evalSlider(b);
      if (ia_default.isInterval(a) || ia_default.isInterval(b)) {
        return ia_default.fmod(a, b);
      } else if (type_default.isArray(a) && type_default.isNumber(b)) {
        len = a.length;
        res = [];
        for (i2 = 0; i2 < len; i2++) {
          res[i2] = math_default.mod(a[i2], b, true);
        }
      } else if (type_default.isNumber(a) && type_default.isNumber(b)) {
        res = math_default.mod(a, b, true);
      } else {
        this._error("Operation * not defined on operands " + typeof a + " and " + typeof b);
      }
      return res;
    },
    /**
     * Pow function wrapper to allow direct usage of sliders.
     * @param {Number|Slider} a
     * @param {Number|Slider} b
     * @returns {Number}
     */
    pow: function(a, b) {
      a = type_default.evalSlider(a);
      b = type_default.evalSlider(b);
      if (ia_default.isInterval(a) || ia_default.isInterval(b)) {
        return ia_default.pow(a, b);
      }
      return math_default.pow(a, b);
    },
    lt: function(a, b) {
      if (ia_default.isInterval(a) || ia_default.isInterval(b)) {
        return ia_default.lt(a, b);
      }
      return a < b;
    },
    leq: function(a, b) {
      if (ia_default.isInterval(a) || ia_default.isInterval(b)) {
        return ia_default.leq(a, b);
      }
      return a <= b;
    },
    gt: function(a, b) {
      if (ia_default.isInterval(a) || ia_default.isInterval(b)) {
        return ia_default.gt(a, b);
      }
      return a > b;
    },
    geq: function(a, b) {
      if (ia_default.isInterval(a) || ia_default.isInterval(b)) {
        return ia_default.geq(a, b);
      }
      return a >= b;
    },
    randint: function(min, max, step) {
      if (!type_default.exists(step)) {
        step = 1;
      }
      return Math.round(Math.random() * (max - min) / step) * step + min;
    },
    DDD: function(f) {
      console.log("Dummy derivative function. This should never appear!");
    },
    /**
     * Implementation of the ?: operator
     * @param {Boolean} cond Condition
     * @param {*} v1
     * @param {*} v2
     * @returns {*} Either v1 or v2.
     */
    ifthen: function(cond, v1, v2) {
      if (cond) {
        return v1;
      }
      return v2;
    },
    /**
     * Implementation of the delete() builtin function
     * @param {JXG.GeometryElement} element
     */
    del: function(element) {
      if (typeof element === "object" && jxg_default.exists(element.type) && jxg_default.exists(element.elementClass)) {
        this.board.removeObject(element);
      }
    },
    /**
     * Implementation of the eval() builtin function. Calls JXG.evaluate().
     * @param {String|Number|Function} v
     */
    eval: function(v) {
      return jxg_default.evaluate(v);
    },
    /**
     * Implementation of the use() builtin function
     * @param {String} board
     */
    use: function(board) {
      var b, ref, found = false;
      if (typeof board === "string") {
        for (b in jxg_default.boards) {
          if (jxg_default.boards.hasOwnProperty(b) && jxg_default.boards[b].container === board) {
            ref = jxg_default.boards[b];
            found = true;
            break;
          }
        }
      } else {
        ref = board;
        found = true;
      }
      if (found) {
        this.board = ref;
        this.builtIn.$board = ref;
        this.builtIn.$board.src = "$jc$.board";
      } else {
        this._error("Board '" + board + "' not found!");
      }
    },
    /**
     * Find the first symbol to the given value from the given scope upwards.
     * @param v Value
     * @param {Number} [scope=-1] The scope, default is to start with current scope (-1).
     * @returns {Array} An array containing the symbol and the scope if a symbol could be found,
     * an empty array otherwise;
     */
    findSymbol: function(v, scope2) {
      var i2, s;
      scope2 = type_default.def(scope2, -1);
      if (scope2 === -1) {
        s = this.scope;
      } else {
        s = this.scopes[scope2];
      }
      while (s !== null) {
        for (i2 in s.locals) {
          if (s.locals.hasOwnProperty(i2) && s.locals[i2] === v) {
            return [i2, s];
          }
        }
        s = s.previous;
      }
      return [];
    },
    /**
     * Import modules into a JessieCode script.
     * @param {String} module
     */
    importModule: function(module2) {
      return priv2.modules[module2.toLowerCase()];
    },
    /**
     * Defines built in methods and constants.
     * @returns {Object} BuiltIn control object
     */
    defineBuiltIn: function() {
      var that2 = this, builtIn = {
        PI: Math.PI,
        EULER: Math.E,
        D: that2.DDD,
        X: that2.X,
        Y: that2.Y,
        V: that2.V,
        Value: that2.V,
        L: that2.L,
        Length: that2.L,
        acosh: math_default.acosh,
        acot: math_default.acot,
        asinh: math_default.asinh,
        binomial: math_default.binomial,
        cbrt: math_default.cbrt,
        cosh: math_default.cosh,
        cot: math_default.cot,
        deg: geometry_default.trueAngle,
        A: that2.area,
        area: that2.area,
        Area: that2.area,
        perimeter: that2.perimeter,
        Perimeter: that2.perimeter,
        dist: that2.dist,
        Dist: that2.dist,
        R: that2.radius,
        radius: that2.radius,
        Radius: that2.radius,
        erf: math_default.erf,
        erfc: math_default.erfc,
        erfi: math_default.erfi,
        factorial: math_default.factorial,
        gcd: math_default.gcd,
        lb: math_default.log2,
        lcm: math_default.lcm,
        ld: math_default.log2,
        lg: math_default.log10,
        ln: Math.log,
        log: math_default.log,
        log10: math_default.log10,
        log2: math_default.log2,
        ndtr: math_default.ndtr,
        ndtri: math_default.ndtri,
        nthroot: math_default.nthroot,
        pow: math_default.pow,
        rad: geometry_default.rad,
        ratpow: math_default.ratpow,
        trunc: type_default.trunc,
        sinh: math_default.sinh,
        slope: that2.slope,
        Slope: that2.slope,
        randint: that2.randint,
        IfThen: that2.ifthen,
        "import": that2.importModule,
        "eval": that2.eval,
        "use": that2.use,
        "remove": that2.del,
        "$": that2.getElementById,
        "$value": function(e) {
          return that2.getElementById(e).Value();
        },
        getName: that2.getName,
        name: that2.getName,
        "$board": that2.board,
        "$log": that2.log
      };
      builtIn.rad.sc = geometry_default;
      builtIn.deg.sc = geometry_default;
      builtIn.factorial.sc = math_default;
      builtIn.X.src = "$jc$.X";
      builtIn.Y.src = "$jc$.Y";
      builtIn.V.src = "$jc$.V";
      builtIn.Value.src = "$jc$.V";
      builtIn.L.src = "$jc$.L";
      builtIn.Length.src = "$jc$.L";
      builtIn.acosh.src = "JXG.Math.acosh";
      builtIn.acot.src = "JXG.Math.acot";
      builtIn.asinh.src = "JXG.Math.asinh";
      builtIn.binomial.src = "JXG.Math.binomial";
      builtIn.cbrt.src = "JXG.Math.cbrt";
      builtIn.cot.src = "JXG.Math.cot";
      builtIn.cosh.src = "JXG.Math.cosh";
      builtIn.deg.src = "JXG.Math.Geometry.trueAngle";
      builtIn.erf.src = "JXG.Math.erf";
      builtIn.erfc.src = "JXG.Math.erfc";
      builtIn.erfi.src = "JXG.Math.erfi";
      builtIn.A.src = "$jc$.area";
      builtIn.area.src = "$jc$.area";
      builtIn.Area.src = "$jc$.area";
      builtIn.perimeter.src = "$jc$.perimeter";
      builtIn.Perimeter.src = "$jc$.perimeter";
      builtIn.dist.src = "$jc$.dist";
      builtIn.Dist.src = "$jc$.dist";
      builtIn.R.src = "$jc$.radius";
      builtIn.radius.src = "$jc$.radius";
      builtIn.Radius.src = "$jc$.radius";
      builtIn.factorial.src = "JXG.Math.factorial";
      builtIn.gcd.src = "JXG.Math.gcd";
      builtIn.lb.src = "JXG.Math.log2";
      builtIn.lcm.src = "JXG.Math.lcm";
      builtIn.ld.src = "JXG.Math.log2";
      builtIn.lg.src = "JXG.Math.log10";
      builtIn.ln.src = "Math.log";
      builtIn.log.src = "JXG.Math.log";
      builtIn.log10.src = "JXG.Math.log10";
      builtIn.log2.src = "JXG.Math.log2";
      builtIn.ndtr.src = "JXG.Math.ndtr";
      builtIn.ndtri.src = "JXG.Math.ndtri";
      builtIn.nthroot.src = "JXG.Math.nthroot";
      builtIn.pow.src = "JXG.Math.pow";
      builtIn.rad.src = "JXG.Math.Geometry.rad";
      builtIn.ratpow.src = "JXG.Math.ratpow";
      builtIn.trunc.src = "JXG.trunc";
      builtIn.sinh.src = "JXG.Math.sinh";
      builtIn.slope.src = "$jc$.slope";
      builtIn.Slope.src = "$jc$.slope";
      builtIn.randint.src = "$jc$.randint";
      builtIn["import"].src = "$jc$.importModule";
      builtIn.eval.src = "$jc$.eval";
      builtIn.use.src = "$jc$.use";
      builtIn.remove.src = "$jc$.del";
      builtIn.IfThen.src = "$jc$.ifthen";
      builtIn.$.src = "(function (n) { return $jc$.board.select(n); })";
      builtIn.$value.src = "(function (n) { return $jc$.board.select(n).Value(); })";
      builtIn.getName.src = "$jc$.getName";
      builtIn.name.src = "$jc$.getName";
      if (builtIn.$board) {
        builtIn.$board.src = "$jc$.board";
      }
      builtIn.$log.src = "$jc$.log";
      builtIn = jxg_default.merge(builtIn, that2._addedBuiltIn);
      return builtIn;
    },
    _addedBuiltIn: {},
    addBuiltIn: function(name, func) {
      if (type_default.exists(this.builtIn)) {
        if (type_default.exists(this.builtIn[name])) {
          return;
        }
        this.builtIn[name] = func;
        this.builtIn[name].src = "$jc$." + name;
      }
      if (type_default.exists(this._addedBuiltIn[name])) {
        return;
      }
      this._addedBuiltIn[name] = func;
      this._addedBuiltIn[name].src = "$jc$." + name;
      jxg_default.JessieCode.prototype[name] = func;
    },
    /**
     * Returns information about the possible functions and constants.
     * @returns {Object}
     */
    getPossibleOperands: function() {
      var FORBIDDEN = ["E"], jessiecode = this.builtIn || this.defineBuiltIn(), math = Math, jc2, ma, merge2, i2, j, p, len, e, funcs, funcsJC, consts, operands, sort, pack;
      sort = function(a, b) {
        return a.toLowerCase().localeCompare(b.toLowerCase());
      };
      pack = function(name, origin) {
        var that2 = null;
        if (origin === "jc")
          that2 = jessiecode[name];
        else if (origin === "Math")
          that2 = math[name];
        else
          return;
        if (FORBIDDEN.indexOf(name) >= 0) {
          return;
        } else if (jxg_default.isFunction(that2)) {
          return {
            name,
            type: "function",
            numParams: that2.length,
            origin
          };
        } else if (jxg_default.isNumber(that2)) {
          return {
            name,
            type: "constant",
            value: that2,
            origin
          };
        } else if (name.startsWith("$")) {
        } else if (that2 !== void 0) {
          console.error("undefined type", that2);
        }
      };
      jc2 = Object.getOwnPropertyNames(jessiecode).sort(sort);
      ma = Object.getOwnPropertyNames(math).sort(sort);
      merge2 = [];
      i2 = 0;
      j = 0;
      while (i2 < jc2.length || j < ma.length) {
        if (jc2[i2] === ma[j]) {
          p = pack(ma[j], "Math");
          if (jxg_default.exists(p))
            merge2.push(p);
          i2++;
          j++;
        } else if (!jxg_default.exists(ma[j]) || jc2[i2].toLowerCase().localeCompare(ma[j].toLowerCase()) < 0) {
          p = pack(jc2[i2], "jc");
          if (jxg_default.exists(p))
            merge2.push(p);
          i2++;
        } else {
          p = pack(ma[j], "Math");
          if (jxg_default.exists(p))
            merge2.push(p);
          j++;
        }
      }
      funcs = [];
      funcsJC = [];
      consts = [];
      operands = {};
      len = merge2.length;
      for (i2 = 0; i2 < len; i2++) {
        e = merge2[i2];
        switch (e.type) {
          case "function":
            funcs.push(e.name);
            if (e.origin === "jc")
              funcsJC.push(e.name);
            break;
          case "constant":
            consts.push(e.name);
            break;
        }
        operands[e.name] = e;
      }
      return {
        all: operands,
        list: merge2,
        functions: funcs,
        functions_jessiecode: funcsJC,
        constants: consts
      };
    },
    /**
     * Output a debugging message. Uses debug console, if available. Otherwise an HTML element with the
     * id "debug" and an innerHTML property is used.
     * @param {String} log
     * @private
     */
    _debug: function(log) {
      if (typeof console === "object") {
        console.log(log);
      } else if (env_default.isBrowser && document && document.getElementById("debug") !== null) {
        document.getElementById("debug").innerHTML += log + "<br />";
      }
    },
    /**
     * Throws an exception with the given error message.
     * @param {String} msg Error message
     */
    _error: function(msg) {
      var e = new Error("Error(" + this.line + "): " + msg);
      e.line = this.line;
      throw e;
    },
    /**
     * Output a warning message using {@link JXG#debug} and precedes the message with "Warning: ".
     * @param {String} msg
     */
    _warn: function(msg) {
      if (typeof console === "object") {
        console.log("Warning(" + this.line + "): " + msg);
      } else if (env_default.isBrowser && document && document.getElementById(this.warnLog) !== null) {
        document.getElementById(this.warnLog).innerHTML += "Warning(" + this.line + "): " + msg + "<br />";
      }
    },
    _log: function(msg) {
      if (typeof window !== "object" && typeof self === "object" && self.postMessage) {
        self.postMessage({ type: "log", msg: "Log: " + msg.toString() });
      } else {
        console.log("Log: ", arguments);
      }
    }
  }
);
var parser = function() {
  var o = function(k, v, o2, l) {
    for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v)
      ;
    return o2;
  }, $V0 = [2, 14], $V1 = [1, 13], $V2 = [1, 37], $V3 = [1, 14], $V4 = [1, 15], $V5 = [1, 21], $V6 = [1, 16], $V7 = [1, 17], $V8 = [1, 33], $V9 = [1, 18], $Va = [1, 19], $Vb = [1, 12], $Vc = [1, 59], $Vd = [1, 60], $Ve = [1, 58], $Vf = [1, 46], $Vg = [1, 48], $Vh = [1, 49], $Vi = [1, 50], $Vj = [1, 51], $Vk = [1, 52], $Vl = [1, 53], $Vm = [1, 54], $Vn = [1, 45], $Vo = [1, 38], $Vp = [1, 39], $Vq = [5, 7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 50, 51, 58, 65, 74, 75, 76, 77, 78, 79, 80, 82, 91, 93], $Vr = [5, 7, 8, 12, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 50, 51, 58, 65, 74, 75, 76, 77, 78, 79, 80, 82, 91, 93], $Vs = [8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], $Vt = [2, 48], $Vu = [1, 72], $Vv = [10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 66, 83, 86], $Vw = [1, 78], $Vx = [8, 10, 16, 32, 34, 35, 37, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], $Vy = [1, 82], $Vz = [8, 10, 16, 32, 34, 35, 37, 39, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], $VA = [1, 83], $VB = [1, 84], $VC = [1, 85], $VD = [8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], $VE = [1, 89], $VF = [1, 90], $VG = [1, 91], $VH = [1, 92], $VI = [1, 97], $VJ = [8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 53, 54, 55, 57, 64, 65, 66, 83, 86], $VK = [1, 103], $VL = [1, 104], $VM = [8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 57, 64, 65, 66, 83, 86], $VN = [1, 105], $VO = [1, 106], $VP = [1, 107], $VQ = [1, 126], $VR = [1, 139], $VS = [83, 86], $VT = [1, 150], $VU = [10, 66, 86], $VV = [8, 10, 16, 20, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 82, 83, 86], $VW = [1, 167], $VX = [10, 86];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "Program": 3, "StatementList": 4, "EOF": 5, "IfStatement": 6, "IF": 7, "(": 8, "Expression": 9, ")": 10, "Statement": 11, "ELSE": 12, "LoopStatement": 13, "WHILE": 14, "FOR": 15, ";": 16, "DO": 17, "UnaryStatement": 18, "USE": 19, "IDENTIFIER": 20, "DELETE": 21, "ReturnStatement": 22, "RETURN": 23, "EmptyStatement": 24, "StatementBlock": 25, "{": 26, "}": 27, "ExpressionStatement": 28, "AssignmentExpression": 29, "ConditionalExpression": 30, "LeftHandSideExpression": 31, "=": 32, "LogicalORExpression": 33, "?": 34, ":": 35, "LogicalANDExpression": 36, "||": 37, "EqualityExpression": 38, "&&": 39, "RelationalExpression": 40, "==": 41, "!=": 42, "~=": 43, "AdditiveExpression": 44, "<": 45, ">": 46, "<=": 47, ">=": 48, "MultiplicativeExpression": 49, "+": 50, "-": 51, "UnaryExpression": 52, "*": 53, "/": 54, "%": 55, "ExponentExpression": 56, "^": 57, "!": 58, "MemberExpression": 59, "CallExpression": 60, "PrimaryExpression": 61, "FunctionExpression": 62, "MapExpression": 63, ".": 64, "[": 65, "]": 66, "BasicLiteral": 67, "ObjectLiteral": 68, "ArrayLiteral": 69, "NullLiteral": 70, "BooleanLiteral": 71, "StringLiteral": 72, "NumberLiteral": 73, "NULL": 74, "TRUE": 75, "FALSE": 76, "STRING": 77, "NUMBER": 78, "NAN": 79, "INFINITY": 80, "ElementList": 81, "<<": 82, ">>": 83, "PropertyList": 84, "Property": 85, ",": 86, "PropertyName": 87, "Arguments": 88, "AttributeList": 89, "Attribute": 90, "FUNCTION": 91, "ParameterDefinitionList": 92, "MAP": 93, "->": 94, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 5: "EOF", 7: "IF", 8: "(", 10: ")", 12: "ELSE", 14: "WHILE", 15: "FOR", 16: ";", 17: "DO", 19: "USE", 20: "IDENTIFIER", 21: "DELETE", 23: "RETURN", 26: "{", 27: "}", 32: "=", 34: "?", 35: ":", 37: "||", 39: "&&", 41: "==", 42: "!=", 43: "~=", 45: "<", 46: ">", 47: "<=", 48: ">=", 50: "+", 51: "-", 53: "*", 54: "/", 55: "%", 57: "^", 58: "!", 64: ".", 65: "[", 66: "]", 74: "NULL", 75: "TRUE", 76: "FALSE", 77: "STRING", 78: "NUMBER", 79: "NAN", 80: "INFINITY", 82: "<<", 83: ">>", 86: ",", 91: "FUNCTION", 93: "MAP", 94: "->" },
    productions_: [0, [3, 2], [6, 5], [6, 7], [13, 5], [13, 9], [13, 7], [18, 2], [18, 2], [22, 2], [22, 3], [24, 1], [25, 3], [4, 2], [4, 0], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [28, 2], [9, 1], [29, 1], [29, 3], [30, 1], [30, 5], [33, 1], [33, 3], [36, 1], [36, 3], [38, 1], [38, 3], [38, 3], [38, 3], [40, 1], [40, 3], [40, 3], [40, 3], [40, 3], [44, 1], [44, 3], [44, 3], [49, 1], [49, 3], [49, 3], [49, 3], [56, 1], [56, 3], [52, 1], [52, 2], [52, 2], [52, 2], [31, 1], [31, 1], [59, 1], [59, 1], [59, 1], [59, 3], [59, 4], [61, 1], [61, 1], [61, 1], [61, 1], [61, 3], [67, 1], [67, 1], [67, 1], [67, 1], [70, 1], [71, 1], [71, 1], [72, 1], [73, 1], [73, 1], [73, 1], [69, 2], [69, 3], [68, 2], [68, 3], [84, 1], [84, 3], [85, 3], [87, 1], [87, 1], [87, 1], [60, 2], [60, 3], [60, 2], [60, 4], [60, 3], [88, 2], [88, 3], [89, 1], [89, 3], [90, 1], [90, 1], [81, 1], [81, 3], [62, 4], [62, 5], [63, 5], [63, 6], [92, 1], [92, 3]],
    /**
     * @class
     * @ignore
     */
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          return $$[$0 - 1];
          break;
        case 2:
          this.$ = AST.createNode(lc(_$[$0 - 4]), "node_op", "op_if", $$[$0 - 2], $$[$0]);
          break;
        case 3:
          this.$ = AST.createNode(lc(_$[$0 - 6]), "node_op", "op_if_else", $$[$0 - 4], $$[$0 - 2], $$[$0]);
          break;
        case 4:
          this.$ = AST.createNode(lc(_$[$0 - 4]), "node_op", "op_while", $$[$0 - 2], $$[$0]);
          break;
        case 5:
          this.$ = AST.createNode(lc(_$[$0 - 8]), "node_op", "op_for", $$[$0 - 6], $$[$0 - 4], $$[$0 - 2], $$[$0]);
          break;
        case 6:
          this.$ = AST.createNode(lc(_$[$0 - 6]), "node_op", "op_do", $$[$0 - 5], $$[$0 - 2]);
          break;
        case 7:
          this.$ = AST.createNode(lc(_$[$0 - 1]), "node_op", "op_use", $$[$0]);
          break;
        case 8:
          this.$ = AST.createNode(lc(_$[$0 - 1]), "node_op", "op_delete", $$[$0]);
          break;
        case 9:
          this.$ = AST.createNode(lc(_$[$0 - 1]), "node_op", "op_return", void 0);
          break;
        case 10:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_return", $$[$0 - 1]);
          break;
        case 11:
        case 14:
          this.$ = AST.createNode(lc(_$[$0]), "node_op", "op_none");
          break;
        case 12:
          this.$ = $$[$0 - 1];
          this.$.needsBrackets = true;
          break;
        case 13:
          this.$ = AST.createNode(lc(_$[$0 - 1]), "node_op", "op_none", $$[$0 - 1], $$[$0]);
          break;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 23:
        case 24:
        case 26:
        case 28:
        case 30:
        case 32:
        case 36:
        case 41:
        case 44:
        case 48:
        case 50:
        case 52:
        case 54:
        case 55:
        case 56:
        case 58:
        case 62:
        case 81:
        case 84:
        case 85:
        case 86:
          this.$ = $$[$0];
          break;
        case 22:
        case 65:
        case 93:
          this.$ = $$[$0 - 1];
          break;
        case 25:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_assign", $$[$0 - 2], $$[$0]);
          this.$.isMath = false;
          break;
        case 27:
          this.$ = AST.createNode(lc(_$[$0 - 4]), "node_op", "op_conditional", $$[$0 - 4], $$[$0 - 2], $$[$0]);
          this.$.isMath = false;
          break;
        case 29:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_or", $$[$0 - 2], $$[$0]);
          this.$.isMath = false;
          break;
        case 31:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_and", $$[$0 - 2], $$[$0]);
          this.$.isMath = false;
          break;
        case 33:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_eq", $$[$0 - 2], $$[$0]);
          this.$.isMath = false;
          break;
        case 34:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_neq", $$[$0 - 2], $$[$0]);
          this.$.isMath = false;
          break;
        case 35:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_approx", $$[$0 - 2], $$[$0]);
          this.$.isMath = false;
          break;
        case 37:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_lt", $$[$0 - 2], $$[$0]);
          this.$.isMath = false;
          break;
        case 38:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_gt", $$[$0 - 2], $$[$0]);
          this.$.isMath = false;
          break;
        case 39:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_leq", $$[$0 - 2], $$[$0]);
          this.$.isMath = false;
          break;
        case 40:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_geq", $$[$0 - 2], $$[$0]);
          this.$.isMath = false;
          break;
        case 42:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_add", $$[$0 - 2], $$[$0]);
          this.$.isMath = true;
          break;
        case 43:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_sub", $$[$0 - 2], $$[$0]);
          this.$.isMath = true;
          break;
        case 45:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_mul", $$[$0 - 2], $$[$0]);
          this.$.isMath = true;
          break;
        case 46:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_div", $$[$0 - 2], $$[$0]);
          this.$.isMath = true;
          break;
        case 47:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_mod", $$[$0 - 2], $$[$0]);
          this.$.isMath = true;
          break;
        case 49:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_exp", $$[$0 - 2], $$[$0]);
          this.$.isMath = true;
          break;
        case 51:
          this.$ = AST.createNode(lc(_$[$0 - 1]), "node_op", "op_not", $$[$0]);
          this.$.isMath = false;
          break;
        case 53:
          this.$ = AST.createNode(lc(_$[$0 - 1]), "node_op", "op_neg", $$[$0]);
          this.$.isMath = true;
          break;
        case 57:
        case 63:
        case 64:
        case 66:
        case 67:
        case 68:
        case 97:
          this.$ = $$[$0];
          this.$.isMath = false;
          break;
        case 59:
        case 91:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_property", $$[$0 - 2], $$[$0]);
          this.$.isMath = true;
          break;
        case 60:
        case 90:
          this.$ = AST.createNode(lc(_$[$0 - 3]), "node_op", "op_extvalue", $$[$0 - 3], $$[$0 - 1]);
          this.$.isMath = true;
          break;
        case 61:
          this.$ = AST.createNode(lc(_$[$0]), "node_var", $$[$0]);
          break;
        case 69:
          this.$ = $$[$0];
          this.$.isMath = true;
          break;
        case 70:
          this.$ = AST.createNode(lc(_$[$0]), "node_const", null);
          break;
        case 71:
          this.$ = AST.createNode(lc(_$[$0]), "node_const_bool", true);
          break;
        case 72:
          this.$ = AST.createNode(lc(_$[$0]), "node_const_bool", false);
          break;
        case 73:
          this.$ = AST.createNode(lc(_$[$0]), "node_str", $$[$0].substring(1, $$[$0].length - 1));
          break;
        case 74:
          this.$ = AST.createNode(lc(_$[$0]), "node_const", parseFloat($$[$0]));
          break;
        case 75:
          this.$ = AST.createNode(lc(_$[$0]), "node_const", NaN);
          break;
        case 76:
          this.$ = AST.createNode(lc(_$[$0]), "node_const", Infinity);
          break;
        case 77:
          this.$ = AST.createNode(lc(_$[$0 - 1]), "node_op", "op_array", []);
          break;
        case 78:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_array", $$[$0 - 1]);
          break;
        case 79:
          this.$ = AST.createNode(lc(_$[$0 - 1]), "node_op", "op_emptyobject", {});
          this.$.needsAngleBrackets = true;
          break;
        case 80:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_proplst_val", $$[$0 - 1]);
          this.$.needsAngleBrackets = true;
          break;
        case 82:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_proplst", $$[$0 - 2], $$[$0]);
          break;
        case 83:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_prop", $$[$0 - 2], $$[$0]);
          break;
        case 87:
        case 89:
          this.$ = AST.createNode(lc(_$[$0 - 1]), "node_op", "op_execfun", $$[$0 - 1], $$[$0]);
          this.$.isMath = true;
          break;
        case 88:
          this.$ = AST.createNode(lc(_$[$0 - 2]), "node_op", "op_execfun", $$[$0 - 2], $$[$0 - 1], $$[$0], true);
          this.$.isMath = false;
          break;
        case 92:
          this.$ = [];
          break;
        case 94:
        case 98:
        case 104:
          this.$ = [$$[$0]];
          break;
        case 95:
        case 99:
        case 105:
          this.$ = $$[$0 - 2].concat($$[$0]);
          break;
        case 96:
          this.$ = AST.createNode(lc(_$[$0]), "node_var", $$[$0]);
          this.$.isMath = true;
          break;
        case 100:
          this.$ = AST.createNode(lc(_$[$0 - 3]), "node_op", "op_function", [], $$[$0]);
          this.$.isMath = false;
          break;
        case 101:
          this.$ = AST.createNode(lc(_$[$0 - 4]), "node_op", "op_function", $$[$0 - 2], $$[$0]);
          this.$.isMath = false;
          break;
        case 102:
          this.$ = AST.createNode(lc(_$[$0 - 4]), "node_op", "op_map", [], $$[$0]);
          break;
        case 103:
          this.$ = AST.createNode(lc(_$[$0 - 5]), "node_op", "op_map", $$[$0 - 3], $$[$0]);
          break;
      }
    },
    table: [o([5, 7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 26, 50, 51, 58, 65, 74, 75, 76, 77, 78, 79, 80, 82, 91, 93], $V0, { 3: 1, 4: 2 }), { 1: [3] }, { 5: [1, 3], 6: 6, 7: $V1, 8: $V2, 9: 20, 11: 4, 13: 7, 14: $V3, 15: $V4, 16: $V5, 17: $V6, 18: 8, 19: $V7, 20: $V8, 21: $V9, 22: 9, 23: $Va, 24: 11, 25: 5, 26: $Vb, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 1: [2, 1] }, o($Vq, [2, 13]), o($Vr, [2, 15]), o($Vr, [2, 16]), o($Vr, [2, 17]), o($Vr, [2, 18]), o($Vr, [2, 19]), o($Vr, [2, 20]), o($Vr, [2, 21]), o([7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 50, 51, 58, 65, 74, 75, 76, 77, 78, 79, 80, 82, 91, 93], $V0, { 4: 61 }), { 8: [1, 62] }, { 8: [1, 63] }, { 8: [1, 64] }, { 6: 6, 7: $V1, 8: $V2, 9: 20, 11: 65, 13: 7, 14: $V3, 15: $V4, 16: $V5, 17: $V6, 18: 8, 19: $V7, 20: $V8, 21: $V9, 22: 9, 23: $Va, 24: 11, 25: 5, 26: $Vb, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 20: [1, 66] }, { 20: [1, 67] }, { 8: $V2, 9: 69, 16: [1, 68], 20: $V8, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 16: [1, 70] }, o($Vr, [2, 11]), o($Vs, [2, 23]), o($Vs, [2, 24]), o([8, 10, 16, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 64, 65, 66, 83, 86], $Vt, { 32: [1, 71], 57: $Vu }), o([8, 10, 16, 32, 35, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], [2, 26], { 34: [1, 73], 37: [1, 74] }), o($Vv, [2, 54], { 88: 77, 8: $Vw, 64: [1, 75], 65: [1, 76] }), o($Vv, [2, 55], { 88: 79, 8: $Vw, 64: [1, 81], 65: [1, 80] }), o($Vx, [2, 28], { 39: $Vy }), o($Vs, [2, 56]), o($Vs, [2, 57]), o($Vs, [2, 58]), o($Vz, [2, 30], { 41: $VA, 42: $VB, 43: $VC }), o($Vs, [2, 61]), o($Vs, [2, 62]), o($Vs, [2, 63]), o($Vs, [2, 64]), { 8: $V2, 9: 86, 20: $V8, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: [1, 87] }, { 8: [1, 88] }, o($VD, [2, 32], { 45: $VE, 46: $VF, 47: $VG, 48: $VH }), o($Vs, [2, 66]), o($Vs, [2, 67]), o($Vs, [2, 68]), o($Vs, [2, 69]), { 20: $VI, 72: 98, 73: 99, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 83: [1, 93], 84: 94, 85: 95, 87: 96 }, { 8: $V2, 20: $V8, 29: 102, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 66: [1, 100], 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 81: 101, 82: $Vn, 91: $Vo, 93: $Vp }, o($VJ, [2, 36], { 50: $VK, 51: $VL }), o($Vs, [2, 70]), o($Vs, [2, 71]), o($Vs, [2, 72]), o($Vs, [2, 73]), o($Vs, [2, 74]), o($Vs, [2, 75]), o($Vs, [2, 76]), o($VM, [2, 41], { 53: $VN, 54: $VO, 55: $VP }), o($Vs, [2, 44]), o($Vs, [2, 50]), { 8: $V2, 20: $V8, 31: 109, 50: $Vc, 51: $Vd, 52: 108, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 50: $Vc, 51: $Vd, 52: 110, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 50: $Vc, 51: $Vd, 52: 111, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 6: 6, 7: $V1, 8: $V2, 9: 20, 11: 4, 13: 7, 14: $V3, 15: $V4, 16: $V5, 17: $V6, 18: 8, 19: $V7, 20: $V8, 21: $V9, 22: 9, 23: $Va, 24: 11, 25: 5, 26: $Vb, 27: [1, 112], 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 9: 113, 20: $V8, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 9: 114, 20: $V8, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 9: 115, 20: $V8, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 14: [1, 116] }, o($Vr, [2, 7]), o($Vr, [2, 8]), o($Vr, [2, 9]), { 16: [1, 117] }, o($Vr, [2, 22]), { 8: $V2, 20: $V8, 29: 118, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 50: $Vc, 51: $Vd, 52: 119, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 29: 120, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 36: 121, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 20: [1, 122] }, { 8: $V2, 9: 123, 20: $V8, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, o($Vs, [2, 87], { 89: 124, 90: 125, 68: 127, 20: $VQ, 82: $Vn }), { 8: $V2, 10: [1, 128], 20: $V8, 29: 102, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 81: 129, 82: $Vn, 91: $Vo, 93: $Vp }, o($Vs, [2, 89]), { 8: $V2, 9: 130, 20: $V8, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 20: [1, 131] }, { 8: $V2, 20: $V8, 31: 109, 38: 132, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 40: 133, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 40: 134, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 40: 135, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 10: [1, 136] }, { 10: [1, 137], 20: $VR, 92: 138 }, { 10: [1, 140], 20: $VR, 92: 141 }, { 8: $V2, 20: $V8, 31: 109, 44: 142, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 44: 143, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 44: 144, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 44: 145, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, o($Vs, [2, 79]), { 83: [1, 146], 86: [1, 147] }, o($VS, [2, 81]), { 35: [1, 148] }, { 35: [2, 84] }, { 35: [2, 85] }, { 35: [2, 86] }, o($Vs, [2, 77]), { 66: [1, 149], 86: $VT }, o($VU, [2, 98]), { 8: $V2, 20: $V8, 31: 109, 49: 151, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 49: 152, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 50: $Vc, 51: $Vd, 52: 153, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 50: $Vc, 51: $Vd, 52: 154, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 31: 109, 50: $Vc, 51: $Vd, 52: 155, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, o($Vs, [2, 51]), o([8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 64, 65, 66, 83, 86], $Vt, { 57: $Vu }), o($Vs, [2, 52]), o($Vs, [2, 53]), o([5, 7, 8, 10, 12, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 58, 64, 65, 66, 74, 75, 76, 77, 78, 79, 80, 82, 83, 86, 91, 93], [2, 12]), { 10: [1, 156] }, { 10: [1, 157] }, { 16: [1, 158] }, { 8: [1, 159] }, o($Vr, [2, 10]), o($Vs, [2, 25]), o($Vs, [2, 49]), { 35: [1, 160] }, o($Vx, [2, 29], { 39: $Vy }), o($Vs, [2, 59]), { 66: [1, 161] }, o([8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83], [2, 88], { 86: [1, 162] }), o($Vs, [2, 94]), o($Vs, [2, 96]), o($Vs, [2, 97]), o($VV, [2, 92]), { 10: [1, 163], 86: $VT }, { 66: [1, 164] }, o($Vs, [2, 91]), o($Vz, [2, 31], { 41: $VA, 42: $VB, 43: $VC }), o($VD, [2, 33], { 45: $VE, 46: $VF, 47: $VG, 48: $VH }), o($VD, [2, 34], { 45: $VE, 46: $VF, 47: $VG, 48: $VH }), o($VD, [2, 35], { 45: $VE, 46: $VF, 47: $VG, 48: $VH }), o($Vs, [2, 65]), { 25: 165, 26: $Vb }, { 10: [1, 166], 86: $VW }, o($VX, [2, 104]), { 94: [1, 168] }, { 10: [1, 169], 86: $VW }, o($VJ, [2, 37], { 50: $VK, 51: $VL }), o($VJ, [2, 38], { 50: $VK, 51: $VL }), o($VJ, [2, 39], { 50: $VK, 51: $VL }), o($VJ, [2, 40], { 50: $VK, 51: $VL }), o($Vs, [2, 80]), { 20: $VI, 72: 98, 73: 99, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 85: 170, 87: 96 }, { 8: $V2, 20: $V8, 29: 171, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, o($Vs, [2, 78]), { 8: $V2, 20: $V8, 29: 172, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, o($VM, [2, 42], { 53: $VN, 54: $VO, 55: $VP }), o($VM, [2, 43], { 53: $VN, 54: $VO, 55: $VP }), o($Vs, [2, 45]), o($Vs, [2, 46]), o($Vs, [2, 47]), { 6: 6, 7: $V1, 8: $V2, 9: 20, 11: 173, 13: 7, 14: $V3, 15: $V4, 16: $V5, 17: $V6, 18: 8, 19: $V7, 20: $V8, 21: $V9, 22: 9, 23: $Va, 24: 11, 25: 5, 26: $Vb, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 6: 6, 7: $V1, 8: $V2, 9: 20, 11: 174, 13: 7, 14: $V3, 15: $V4, 16: $V5, 17: $V6, 18: 8, 19: $V7, 20: $V8, 21: $V9, 22: 9, 23: $Va, 24: 11, 25: 5, 26: $Vb, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 9: 175, 20: $V8, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 9: 176, 20: $V8, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 20: $V8, 29: 177, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, o($Vs, [2, 60]), { 20: $VQ, 68: 127, 82: $Vn, 90: 178 }, o($VV, [2, 93]), o($Vs, [2, 90]), o($Vs, [2, 100]), { 25: 179, 26: $Vb }, { 20: [1, 180] }, { 8: $V2, 9: 181, 20: $V8, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 94: [1, 182] }, o($VS, [2, 82]), o($VS, [2, 83]), o($VU, [2, 99]), o($Vq, [2, 2], { 12: [1, 183] }), o($Vr, [2, 4]), { 16: [1, 184] }, { 10: [1, 185] }, o($Vs, [2, 27]), o($Vs, [2, 95]), o($Vs, [2, 101]), o($VX, [2, 105]), o($Vs, [2, 102]), { 8: $V2, 9: 186, 20: $V8, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 6: 6, 7: $V1, 8: $V2, 9: 20, 11: 187, 13: 7, 14: $V3, 15: $V4, 16: $V5, 17: $V6, 18: 8, 19: $V7, 20: $V8, 21: $V9, 22: 9, 23: $Va, 24: 11, 25: 5, 26: $Vb, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 8: $V2, 9: 188, 20: $V8, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, { 16: [1, 189] }, o($Vs, [2, 103]), o($Vr, [2, 3]), { 10: [1, 190] }, o($Vr, [2, 6]), { 6: 6, 7: $V1, 8: $V2, 9: 20, 11: 191, 13: 7, 14: $V3, 15: $V4, 16: $V5, 17: $V6, 18: 8, 19: $V7, 20: $V8, 21: $V9, 22: 9, 23: $Va, 24: 11, 25: 5, 26: $Vb, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: $Vc, 51: $Vd, 52: 56, 56: 57, 58: $Ve, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: $Vf, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: $Vg, 75: $Vh, 76: $Vi, 77: $Vj, 78: $Vk, 79: $Vl, 80: $Vm, 82: $Vn, 91: $Vo, 93: $Vp }, o($Vr, [2, 5])],
    defaultActions: { 3: [2, 1], 97: [2, 84], 98: [2, 85], 99: [2, 86] },
    parseError: function parseError(str2, hash) {
      if (hash.recoverable) {
        this.trace(str2);
      } else {
        var error = new Error(str2);
        error.hash = hash;
        throw error;
      }
    },
    /**
     * @class
     * @ignore
     */
    parse: function parse(input) {
      var self2 = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
      var args2 = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
          sharedState.yy[k] = this.yy[k];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
      }
      _token_stack:
        var lex = function() {
          var token;
          token = lexer2.lex() || EOF;
          if (typeof token !== "number") {
            token = self2.symbols_[token] || token;
          }
          return token;
        };
      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == "undefined") {
            symbol = lex();
          }
          action = table[state] && table[state][symbol];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol] || symbol,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
        }
        switch (action[0]) {
          case 1:
            stack.push(symbol);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
              if (recovering > 0) {
                recovering--;
              }
            } else {
              symbol = preErrorSymbol;
              preErrorSymbol = null;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args2));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var AST = {
    node: function(type, value, children) {
      return {
        type,
        value,
        children
      };
    },
    createNode: function(pos, type, value, children) {
      var i2, n = this.node(type, value, []);
      for (i2 = 3; i2 < arguments.length; i2++) {
        n.children.push(arguments[i2]);
      }
      n.line = pos[0];
      n.col = pos[1];
      n.eline = pos[2];
      n.ecol = pos[3];
      return n;
    }
  };
  var lc = function(lc1) {
    return [lc1.first_line, lc1.first_column, lc1.last_line, lc1.last_column];
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str2, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str2, hash);
        } else {
          throw new Error(str2);
        }
      },
      // resets the lexer, sets new input
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      // consumes and returns one char from the input
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      // unshifts one char (or a string) into the input
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        this._more = true;
        return this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      // retain first n characters of the match
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(match, indexed_rule) {
        var token, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          for (var k in backup) {
            this[k] = backup[k];
          }
          return false;
        }
        return false;
      },
      // return next match in input
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token, match, tempMatch, index;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i2 = 0; i2 < rules.length; i2++) {
          tempMatch = this._input.match(this.rules[rules[i2]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i2;
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rules[i2]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rules[index]);
          if (token !== false) {
            return token;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      // return next match that has a token
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      // alias for begin(condition)
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      // return the number of states currently on the stack
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {},
      /**
       * @class
       * @ignore
       */
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        var YYSTATE = YY_START;
        switch ($avoiding_name_collisions) {
          case 0:
            break;
          case 1:
            return 78;
            break;
          case 2:
            return 78;
            break;
          case 3:
            return 77;
            break;
          case 4:
            return 77;
            break;
          case 5:
            break;
          case 6:
            break;
          case 7:
            return 7;
            break;
          case 8:
            return 12;
            break;
          case 9:
            return 14;
            break;
          case 10:
            return 17;
            break;
          case 11:
            return 15;
            break;
          case 12:
            return 91;
            break;
          case 13:
            return 93;
            break;
          case 14:
            return 19;
            break;
          case 15:
            return 23;
            break;
          case 16:
            return 21;
            break;
          case 17:
            return 75;
            break;
          case 18:
            return 76;
            break;
          case 19:
            return 74;
            break;
          case 20:
            return 80;
            break;
          case 21:
            return 94;
            break;
          case 22:
            return 94;
            break;
          case 23:
            return 82;
            break;
          case 24:
            return 83;
            break;
          case 25:
            return 26;
            break;
          case 26:
            return 27;
            break;
          case 27:
            return 16;
            break;
          case 28:
            return "#";
            break;
          case 29:
            return 34;
            break;
          case 30:
            return 35;
            break;
          case 31:
            return 79;
            break;
          case 32:
            return 64;
            break;
          case 33:
            return 65;
            break;
          case 34:
            return 66;
            break;
          case 35:
            return 8;
            break;
          case 36:
            return 10;
            break;
          case 37:
            return 58;
            break;
          case 38:
            return 57;
            break;
          case 39:
            return 57;
            break;
          case 40:
            return 53;
            break;
          case 41:
            return 54;
            break;
          case 42:
            return 55;
            break;
          case 43:
            return 50;
            break;
          case 44:
            return 51;
            break;
          case 45:
            return 47;
            break;
          case 46:
            return 45;
            break;
          case 47:
            return 48;
            break;
          case 48:
            return 46;
            break;
          case 49:
            return 41;
            break;
          case 50:
            return 43;
            break;
          case 51:
            return 42;
            break;
          case 52:
            return 39;
            break;
          case 53:
            return 37;
            break;
          case 54:
            return 32;
            break;
          case 55:
            return 86;
            break;
          case 56:
            return 5;
            break;
          case 57:
            return 20;
            break;
          case 58:
            return "INVALID";
            break;
        }
      },
      rules: [/^(?:\s+)/, /^(?:[0-9]+\.[0-9]*|[0-9]*\.[0-9]+\b)/, /^(?:[0-9]+)/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:\/\/.*)/, /^(?:\/\*(.|\n|\r)*?\*\/)/, /^(?:if\b)/, /^(?:else\b)/, /^(?:while\b)/, /^(?:do\b)/, /^(?:for\b)/, /^(?:function\b)/, /^(?:map\b)/, /^(?:use\b)/, /^(?:return\b)/, /^(?:delete\b)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:null\b)/, /^(?:Infinity\b)/, /^(?:->)/, /^(?:=>)/, /^(?:<<)/, /^(?:>>)/, /^(?:\{)/, /^(?:\})/, /^(?:;)/, /^(?:#)/, /^(?:\?)/, /^(?::)/, /^(?:NaN\b)/, /^(?:\.)/, /^(?:\[)/, /^(?:\])/, /^(?:\()/, /^(?:\))/, /^(?:!)/, /^(?:\^)/, /^(?:\*\*)/, /^(?:\*)/, /^(?:\/)/, /^(?:%)/, /^(?:\+)/, /^(?:-)/, /^(?:<=)/, /^(?:<)/, /^(?:>=)/, /^(?:>)/, /^(?:==)/, /^(?:~=)/, /^(?:!=)/, /^(?:&&)/, /^(?:\|\|)/, /^(?:=)/, /^(?:,)/, /^(?:$)/, /^(?:[A-Za-z_\$][A-Za-z0-9_]*)/, /^(?:.)/],
      conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser2;
  parser2.Parser = Parser;
  return new Parser();
}();
parser.yy.parseError = parser.parseError;
var jessiecode_default = jxg_default.JessieCode;

// node_modules/jsxgraph/src/base/composition.js
jxg_default.Composition = function(elements2) {
  var e, that2 = this, genericMethods = [
    /**
     * Invokes setAttribute for every stored element with a setAttribute method and hands over the given arguments.
     * See {@link JXG.GeometryElement#setAttribute} for further description, valid parameters and return values.
     * @name setAttribute
     * @memberOf JXG.Composition.prototype
     * @function
     */
    "setAttribute",
    /**
     * Invokes setParents for every stored element with a setParents method and hands over the given arguments.
     * See {@link JXG.GeometryElement#setParents} for further description, valid parameters and return values.
     * @name setParents
     * @memberOf JXG.Composition.prototype
     * @function
     */
    "setParents",
    /**
     * Invokes prepareUpdate for every stored element with a prepareUpdate method and hands over the given arguments.
     * See {@link JXG.GeometryElement#prepareUpdate} for further description, valid parameters and return values.
     * @name prepareUpdate
     * @memberOf JXG.Composition.prototype
     * @function
     */
    "prepareUpdate",
    /**
     * Invokes updateRenderer for every stored element with a updateRenderer method and hands over the given arguments.
     * See {@link JXG.GeometryElement#updateRenderer} for further description, valid parameters and return values.
     * @name updateRenderer
     * @memberOf JXG.Composition.prototype
     * @function
     */
    "updateRenderer",
    /**
     * Invokes update for every stored element with a update method and hands over the given arguments.
     * See {@link JXG.GeometryElement#update} for further description, valid parameters and return values.
     * @name update
     * @memberOf JXG.Composition.prototype
     * @function
     */
    "update",
    /**
     * Invokes fullUpdate for every stored element with a fullUpdate method and hands over the given arguments.
     * See {@link JXG.GeometryElement#fullUpdate} for further description, valid parameters and return values.
     * @name fullUpdate
     * @memberOf JXG.Composition.prototype
     * @function
     */
    "fullUpdate",
    /**
     * Invokes highlight for every stored element with a highlight method and hands over the given arguments.
     * See {@link JXG.GeometryElement#highlight} for further description, valid parameters and return values.
     * @name highlight
     * @memberOf JXG.Composition.prototype
     * @function
     */
    "highlight",
    /**
     * Invokes noHighlight for every stored element with a noHighlight method and hands over the given arguments.
     * See {@link JXG.GeometryElement#noHighlight} for further description, valid parameters and return values.
     * @name noHighlight
     * @memberOf JXG.Composition.prototype
     * @function
     */
    "noHighlight"
  ], generateMethod = function(what) {
    return function() {
      var i2;
      for (i2 in that2.elements) {
        if (that2.elements.hasOwnProperty(i2)) {
          if (type_default.exists(that2.elements[i2][what])) {
            that2.elements[i2][what].apply(that2.elements[i2], arguments);
          }
        }
      }
      return that2;
    };
  };
  for (e = 0; e < genericMethods.length; e++) {
    this[genericMethods[e]] = generateMethod(genericMethods[e]);
  }
  this.elements = {};
  this.objects = this.elements;
  this.elementsByName = {};
  this.objectsList = [];
  this.groups = {};
  this.methodMap = {
    setAttribute: "setAttribute",
    setProperty: "setAttribute",
    setParents: "setParents",
    add: "add",
    remove: "remove",
    select: "select"
  };
  for (e in elements2) {
    if (elements2.hasOwnProperty(e)) {
      this.add(e, elements2[e]);
    }
  }
  this.dump = true;
  this.subs = {};
};
jxg_default.extend(
  jxg_default.Composition.prototype,
  /** @lends JXG.Composition.prototype */
  {
    /**
     * Adds an element to the composition container.
     * @param {String} what Descriptive name for the element, e.g. <em>startpoint</em> or <em>area</em>. This is used to
     * access the element later on. There are some reserved names: <em>elements, add, remove, update, prepareUpdate,
     * updateRenderer, highlight, noHighlight</em>, and all names that would form invalid object property names in
     * JavaScript.
     * @param {JXG.GeometryElement|JXG.Composition} element A reference to the element that is to be added. This can be
     * another composition, too.
     * @returns {Boolean} True, if the element was added successfully. Reasons why adding the element failed include
     * using a reserved name and providing an invalid element.
     */
    add: function(what, element) {
      if (!type_default.exists(this[what]) && type_default.exists(element)) {
        if (type_default.exists(element.id)) {
          this.elements[element.id] = element;
        } else {
          this.elements[what] = element;
        }
        if (type_default.exists(element.name)) {
          this.elementsByName[element.name] = element;
        }
        element.on("attribute:name", this.nameListener, this);
        this.objectsList.push(element);
        this[what] = element;
        this.methodMap[what] = element;
        return true;
      }
      return false;
    },
    /**
     * Remove an element from the composition container.
     * @param {String} what The name used to access the element.
     * @returns {Boolean} True, if the element has been removed successfully.
     */
    remove: function(what) {
      var found = false, e;
      for (e in this.elements) {
        if (this.elements.hasOwnProperty(e)) {
          if (this.elements[e].id === this[what].id) {
            found = true;
            break;
          }
        }
      }
      if (found) {
        delete this.elements[this[what].id];
        delete this[what];
      }
      return found;
    },
    nameListener: function(oval, nval, el) {
      delete this.elementsByName[oval];
      this.elementsByName[nval] = el;
    },
    select: function(filter) {
      if (type_default.exists(jxg_default.Board)) {
        return jxg_default.Board.prototype.select.call(this, filter);
      }
      return new jxg_default.Composition();
    },
    getParents: function() {
      return this.parents;
    },
    getType: function() {
      return this.elType;
    },
    getAttributes: function() {
      var attr = {}, e;
      for (e in this.subs) {
        if (this.subs.hasOwnProperty(e)) {
          attr[e] = this.subs[e].visProp;
        }
      }
      return this.attr;
    }
  }
);
var composition_default = jxg_default.Composition;

// node_modules/jsxgraph/src/base/board.js
jxg_default.Board = function(container, renderer, id, origin, zoomX, zoomY, unitX, unitY, canvasWidth, canvasHeight, attributes) {
  this.BOARD_MODE_NONE = 0;
  this.BOARD_MODE_DRAG = 1;
  this.BOARD_MODE_MOVE_ORIGIN = 2;
  this.BOARD_MODE_ZOOM = 17;
  this.BOARD_QUALITY_LOW = 1;
  this.BOARD_QUALITY_HIGH = 2;
  if (type_default.exists(attributes.document) && attributes.document !== false) {
    this.document = attributes.document;
  } else if (env_default.isBrowser) {
    this.document = document;
  }
  this.container = "";
  this.containerObj = null;
  if (type_default.isString(container)) {
    this.container = container;
    this.containerObj = env_default.isBrowser ? this.document.getElementById(this.container) : null;
  } else if (env_default.isBrowser) {
    this.containerObj = container;
    this.container = this.containerObj.getAttribute("id");
    if (this.container === null) {
      this.container = "null" + parseInt(Math.random() * 1e8).toString();
    }
  }
  if (env_default.isBrowser && renderer.type !== "no" && this.containerObj === null) {
    throw new Error('\nJSXGraph: HTML container element "' + container + '" not found.');
  }
  this.renderer = renderer;
  this.grids = [];
  this.options = type_default.deepCopy(options_default);
  this.attr = attributes;
  if (this.attr.theme !== "default" && type_default.exists(jxg_default.themes[this.attr.theme])) {
    type_default.mergeAttr(this.options, jxg_default.themes[this.attr.theme], true);
  }
  this.dimension = 2;
  this.jc = new jessiecode_default();
  this.jc.use(this);
  this.origin = {};
  this.origin.usrCoords = [1, 0, 0];
  this.origin.scrCoords = [1, origin[0], origin[1]];
  this.zoomX = zoomX;
  this.zoomY = zoomY;
  this.unitX = unitX * this.zoomX;
  this.unitY = unitY * this.zoomY;
  this.keepaspectratio = false;
  this.canvasWidth = canvasWidth;
  this.canvasHeight = canvasHeight;
  if (type_default.exists(id) && id !== "" && env_default.isBrowser && !type_default.exists(this.document.getElementById(id))) {
    this.id = id;
  } else {
    this.id = this.generateId();
  }
  event_default.eventify(this);
  this.hooks = [];
  this.dependentBoards = [];
  this.inUpdate = false;
  this.objects = {};
  this.objectsList = [];
  this.groups = {};
  this.animationObjects = {};
  this.highlightedObjects = {};
  this.numObjects = 0;
  this.elementsByName = {};
  this.mode = this.BOARD_MODE_NONE;
  this.updateQuality = this.BOARD_QUALITY_HIGH;
  this.isSuspendedRedraw = false;
  this.calculateSnapSizes();
  this.drag_dx = 0;
  this.drag_dy = 0;
  this.drag_position = [0, 0];
  this.mouse = {};
  this.touches = [];
  this.xmlString = "";
  this.cPos = [];
  this.touchMoveLast = 0;
  this.touchMoveLastId = Infinity;
  this.positionAccessLast = 0;
  this.downObjects = [];
  this.focusObjects = [];
  if (this.attr.showcopyright) {
    this.renderer.displayCopyright(constants_default.licenseText, parseInt(this.options.text.fontSize, 10));
  }
  this.needsFullUpdate = false;
  this.reducedUpdate = false;
  this.currentCBDef = "none";
  this.geonextCompatibilityMode = false;
  if (this.options.text.useASCIIMathML && translateASCIIMath) {
    init();
  } else {
    this.options.text.useASCIIMathML = false;
  }
  this.hasMouseHandlers = false;
  this.hasTouchHandlers = false;
  this.hasPointerHandlers = false;
  this.hasWheelHandlers = false;
  this.hasMouseUp = false;
  this.hasTouchEnd = false;
  this.hasPointerUp = false;
  this._drag_offset = [0, 0];
  this._inputDevice = "mouse";
  this._board_touches = [];
  this.selectingMode = false;
  this.isSelecting = false;
  this._isScrolling = false;
  this._isResizing = false;
  this.selectingBox = [[0, 0], [0, 0]];
  this.userLog = [];
  this.mathLib = Math;
  this.mathLibJXG = jxg_default.Math;
  if (this.attr.registerevents === true) {
    this.attr.registerevents = {
      fullscreen: true,
      keyboard: true,
      pointer: true,
      resize: true,
      wheel: true
    };
  } else if (typeof this.attr.registerevents === "object") {
    if (!type_default.exists(this.attr.registerevents.fullscreen)) {
      this.attr.registerevents.fullscreen = true;
    }
    if (!type_default.exists(this.attr.registerevents.keyboard)) {
      this.attr.registerevents.keyboard = true;
    }
    if (!type_default.exists(this.attr.registerevents.pointer)) {
      this.attr.registerevents.pointer = true;
    }
    if (!type_default.exists(this.attr.registerevents.resize)) {
      this.attr.registerevents.resize = true;
    }
    if (!type_default.exists(this.attr.registerevents.wheel)) {
      this.attr.registerevents.wheel = true;
    }
  }
  if (this.attr.registerevents !== false) {
    if (this.attr.registerevents.fullscreen) {
      this.addFullscreenEventHandlers();
    }
    if (this.attr.registerevents.keyboard) {
      this.addKeyboardEventHandlers();
    }
    if (this.attr.registerevents.pointer) {
      this.addEventHandlers();
    }
    if (this.attr.registerevents.resize) {
      this.addResizeEventHandlers();
    }
    if (this.attr.registerevents.wheel) {
      this.addWheelEventHandlers();
    }
  }
  this.methodMap = {
    update: "update",
    fullUpdate: "fullUpdate",
    on: "on",
    off: "off",
    trigger: "trigger",
    setAttribute: "setAttribute",
    setBoundingBox: "setBoundingBox",
    setView: "setBoundingBox",
    getBoundingBox: "getBoundingBox",
    BoundingBox: "getBoundingBox",
    getView: "getBoundingBox",
    View: "getBoundingBox",
    migratePoint: "migratePoint",
    colorblind: "emulateColorblindness",
    suspendUpdate: "suspendUpdate",
    unsuspendUpdate: "unsuspendUpdate",
    clearTraces: "clearTraces",
    left: "clickLeftArrow",
    right: "clickRightArrow",
    up: "clickUpArrow",
    down: "clickDownArrow",
    zoomIn: "zoomIn",
    zoomOut: "zoomOut",
    zoom100: "zoom100",
    zoomElements: "zoomElements",
    remove: "removeObject",
    removeObject: "removeObject"
  };
};
jxg_default.extend(
  jxg_default.Board.prototype,
  /** @lends JXG.Board.prototype */
  {
    /**
     * Generates an unique name for the given object. The result depends on the objects type, if the
     * object is a {@link JXG.Point}, capital characters are used, if it is of type {@link JXG.Line}
     * only lower case characters are used. If object is of type {@link JXG.Polygon}, a bunch of lower
     * case characters prefixed with P_ are used. If object is of type {@link JXG.Circle} the name is
     * generated using lower case characters. prefixed with k_ is used. In any other case, lower case
     * chars prefixed with s_ is used.
     * @param {Object} object Reference of an JXG.GeometryElement that is to be named.
     * @returns {String} Unique name for the object.
     */
    generateName: function(object) {
      var possibleNames, i2, maxNameLength = this.attr.maxnamelength, pre = "", post = "", indices = [], name = "";
      if (object.type === constants_default.OBJECT_TYPE_TICKS) {
        return "";
      }
      if (type_default.isPoint(object) || type_default.isPoint3D(object)) {
        possibleNames = [
          "",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z"
        ];
      } else if (object.type === constants_default.OBJECT_TYPE_ANGLE) {
        possibleNames = [
          "",
          "&alpha;",
          "&beta;",
          "&gamma;",
          "&delta;",
          "&epsilon;",
          "&zeta;",
          "&eta;",
          "&theta;",
          "&iota;",
          "&kappa;",
          "&lambda;",
          "&mu;",
          "&nu;",
          "&xi;",
          "&omicron;",
          "&pi;",
          "&rho;",
          "&sigma;",
          "&tau;",
          "&upsilon;",
          "&phi;",
          "&chi;",
          "&psi;",
          "&omega;"
        ];
      } else {
        possibleNames = [
          "",
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g",
          "h",
          "i",
          "j",
          "k",
          "l",
          "m",
          "n",
          "o",
          "p",
          "q",
          "r",
          "s",
          "t",
          "u",
          "v",
          "w",
          "x",
          "y",
          "z"
        ];
      }
      if (!type_default.isPoint(object) && object.elementClass !== constants_default.OBJECT_CLASS_LINE && object.type !== constants_default.OBJECT_TYPE_ANGLE) {
        if (object.type === constants_default.OBJECT_TYPE_POLYGON) {
          pre = "P_{";
        } else if (object.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
          pre = "k_{";
        } else if (object.elementClass === constants_default.OBJECT_CLASS_TEXT) {
          pre = "t_{";
        } else {
          pre = "s_{";
        }
        post = "}";
      }
      for (i2 = 0; i2 < maxNameLength; i2++) {
        indices[i2] = 0;
      }
      while (indices[maxNameLength - 1] < possibleNames.length) {
        for (indices[0] = 1; indices[0] < possibleNames.length; indices[0]++) {
          name = pre;
          for (i2 = maxNameLength; i2 > 0; i2--) {
            name += possibleNames[indices[i2 - 1]];
          }
          if (!type_default.exists(this.elementsByName[name + post])) {
            return name + post;
          }
        }
        indices[0] = possibleNames.length;
        for (i2 = 1; i2 < maxNameLength; i2++) {
          if (indices[i2 - 1] === possibleNames.length) {
            indices[i2 - 1] = 1;
            indices[i2] += 1;
          }
        }
      }
      return "";
    },
    /**
     * Generates unique id for a board. The result is randomly generated and prefixed with 'jxgBoard'.
     * @returns {String} Unique id for a board.
     */
    generateId: function() {
      var r = 1;
      while (type_default.exists(jxg_default.boards["jxgBoard" + r])) {
        r = Math.round(Math.random() * 65535);
      }
      return "jxgBoard" + r;
    },
    /**
     * Composes an id for an element. If the ID is empty ('' or null) a new ID is generated, depending on the
     * object type. As a side effect {@link JXG.Board#numObjects}
     * is updated.
     * @param {Object} obj Reference of an geometry object that needs an id.
     * @param {Number} type Type of the object.
     * @returns {String} Unique id for an element.
     */
    setId: function(obj, type) {
      var randomNumber, num = this.numObjects, elId = obj.id;
      this.numObjects += 1;
      if (elId === "" || !type_default.exists(elId)) {
        elId = this.id + type + num;
        while (type_default.exists(this.objects[elId])) {
          randomNumber = Math.round(Math.random() * 65535);
          elId = this.id + type + num + "-" + randomNumber;
        }
      }
      obj.id = elId;
      this.objects[elId] = obj;
      obj._pos = this.objectsList.length;
      this.objectsList[this.objectsList.length] = obj;
      return elId;
    },
    /**
     * After construction of the object the visibility is set
     * and the label is constructed if necessary.
     * @param {Object} obj The object to add.
     */
    finalizeAdding: function(obj) {
      if (type_default.evaluate(obj.visProp.visible) === false) {
        this.renderer.display(obj, false);
      }
    },
    finalizeLabel: function(obj) {
      if (obj.hasLabel && !type_default.evaluate(obj.label.visProp.islabel) && type_default.evaluate(obj.label.visProp.visible) === false) {
        this.renderer.display(obj.label, false);
      }
    },
    /**********************************************************
     *
     * Event Handler helpers
     *
     **********************************************************/
    /**
     * Returns false if the event has been triggered faster than the maximum frame rate.
     *
     * @param {Event} evt Event object given by the browser (unused)
     * @returns {Boolean} If the event has been triggered faster than the maximum frame rate, false is returned.
     * @private
     * @see JXG.Board#pointerMoveListener
     * @see JXG.Board#touchMoveListener
     * @see JXG.Board#mouseMoveListener
     */
    checkFrameRate: function(evt) {
      var handleEvt = false, time = new Date().getTime();
      if (type_default.exists(evt.pointerId) && this.touchMoveLastId !== evt.pointerId) {
        handleEvt = true;
        this.touchMoveLastId = evt.pointerId;
      }
      if (!handleEvt && (time - this.touchMoveLast) * this.attr.maxframerate >= 1e3) {
        handleEvt = true;
      }
      if (handleEvt) {
        this.touchMoveLast = time;
      }
      return handleEvt;
    },
    /**
     * Calculates mouse coordinates relative to the boards container.
     * @returns {Array} Array of coordinates relative the boards container top left corner.
     */
    getCoordsTopLeftCorner: function() {
      var cPos, doc, crect, ownerDoc = this.document.ownerDocument || this.document, docElement = ownerDoc.documentElement || this.document.body.parentNode, docBody = ownerDoc.body, container = this.containerObj, zoom, o;
      if (this.cPos.length > 0 && (this.mode === this.BOARD_MODE_DRAG || this.mode === this.BOARD_MODE_MOVE_ORIGIN || new Date().getTime() - this.positionAccessLast < 1e3)) {
        return this.cPos;
      }
      this.positionAccessLast = new Date().getTime();
      if (container.getBoundingClientRect) {
        crect = container.getBoundingClientRect();
        zoom = 1;
        o = container;
        while (o && type_default.exists(o.parentNode)) {
          if (type_default.exists(o.style) && type_default.exists(o.style.zoom) && o.style.zoom !== "") {
            zoom *= parseFloat(o.style.zoom);
          }
          o = o.parentNode;
        }
        cPos = [crect.left * zoom, crect.top * zoom];
        cPos[0] += env_default.getProp(container, "border-left-width");
        cPos[1] += env_default.getProp(container, "border-top-width");
        if (this.renderer.type !== "vml") {
          cPos[0] += env_default.getProp(container, "padding-left");
          cPos[1] += env_default.getProp(container, "padding-top");
        }
        this.cPos = cPos.slice();
        return this.cPos;
      }
      cPos = env_default.getOffset(container);
      doc = this.document.documentElement.ownerDocument;
      if (!this.containerObj.currentStyle && doc.defaultView) {
        cPos[0] += env_default.getProp(docElement, "margin-left");
        cPos[1] += env_default.getProp(docElement, "margin-top");
        cPos[0] += env_default.getProp(docElement, "border-left-width");
        cPos[1] += env_default.getProp(docElement, "border-top-width");
        cPos[0] += env_default.getProp(docElement, "padding-left");
        cPos[1] += env_default.getProp(docElement, "padding-top");
      }
      if (docBody) {
        cPos[0] += env_default.getProp(docBody, "left");
        cPos[1] += env_default.getProp(docBody, "top");
      }
      if (typeof google === "object" && google.translate) {
        cPos[0] += 10;
        cPos[1] += 25;
      }
      cPos[0] += env_default.getProp(container, "border-left-width");
      cPos[1] += env_default.getProp(container, "border-top-width");
      if (this.renderer.type !== "vml") {
        cPos[0] += env_default.getProp(container, "padding-left");
        cPos[1] += env_default.getProp(container, "padding-top");
      }
      cPos[0] += this.attr.offsetx;
      cPos[1] += this.attr.offsety;
      this.cPos = cPos.slice();
      return this.cPos;
    },
    /**
     * This function divides the board into 9 sections and returns an array <tt>[u,v]</tt> which symbolizes the location of <tt>position</tt>.
     * Optional a <tt>margin</tt> to the inner of the board is respected.<br>
     *
     * @name Board#getPointLoc
     * @param {Array} position Array of requested position <tt>[x, y]</tt> or <tt>[w, x, y]</tt>.
     * @param {Array|Number} [margin] Optional margin for the inner of the board: <tt>[top, right, bottom, left]</tt>. A single number <tt>m</tt> is interpreted as <tt>[m, m, m, m]</tt>.
     * @returns {Array} [u,v] with the following meanings:
     * <pre>
     *     v    u > |   -1    |    0   |    1   |
     * ------------------------------------------
     *     1        | [-1,1]  |  [0,1] |  [1,1] |
     * ------------------------------------------
     *     0        | [-1,0]  |  Board |  [1,0] |
     * ------------------------------------------
     *    -1        | [-1,-1] | [0,-1] | [1,-1] |
     * </pre>
     * Positions inside the board (minus margin) return the value <tt>[0,0]</tt>.
     *
     * @example
     *      var point1, point2, point3, point4, margin,
     *             p1Location, p2Location, p3Location, p4Location,
     *             helppoint1, helppoint2, helppoint3, helppoint4;
     *
     *      // margin to make the boundingBox virtually smaller
     *      margin = [2,2,2,2];
     *
     *      // Points which are seen on screen
     *      point1 = board.create('point', [0,0]);
     *      point2 = board.create('point', [0,7]);
     *      point3 = board.create('point', [7,7]);
     *      point4 = board.create('point', [-7,-5]);
     *
     *      p1Location = board.getPointLoc(point1.coords.usrCoords, margin);
     *      p2Location = board.getPointLoc(point2.coords.usrCoords, margin);
     *      p3Location = board.getPointLoc(point3.coords.usrCoords, margin);
     *      p4Location = board.getPointLoc(point4.coords.usrCoords, margin);
     *
     *      // Text seen on screen
     *      board.create('text', [1,-1, "getPointLoc(A): " + "[" + p1Location + "]"])
     *      board.create('text', [1,-2, "getPointLoc(B): " + "[" + p2Location + "]"])
     *      board.create('text', [1,-3, "getPointLoc(C): " + "[" + p3Location + "]"])
     *      board.create('text', [1,-4, "getPointLoc(D): " + "[" + p4Location + "]"])
     *
     *
     *      // Helping points that are used to create the helping lines
     *      helppoint1 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[2] - 2, bbx[1] -2];
     *      })], {
     *          visible: false,
     *      })
     *
     *      helppoint2 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[0] + 2, bbx[1] -2];
     *      })], {
     *          visible: false,
     *      })
     *
     *      helppoint3 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[0]+ 2, bbx[3] + 2];
     *      })],{
     *          visible: false,
     *      })
     *
     *      helppoint4 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[2] -2, bbx[3] + 2];
     *      })], {
     *          visible: false,
     *      })
     *
     *      // Helping lines to visualize the 9 sectors and the margin
     *      board.create('line', [helppoint1, helppoint2]);
     *      board.create('line', [helppoint2, helppoint3]);
     *      board.create('line', [helppoint3, helppoint4]);
     *      board.create('line', [helppoint4, helppoint1]);
     *
     * </pre><div id="JXG4b3efef5-839d-4fac-bad1-7a14c0a89c70" class="jxgbox" style="width: 500px; height: 500px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG4b3efef5-839d-4fac-bad1-7a14c0a89c70',
     *             {boundingbox: [-8, 8, 8,-8], maxboundingbox: [-7.5,7.5,7.5,-7.5], axis: true, showcopyright: false, shownavigation: false, showZoom: false});
     *     var point1, point2, point3, point4, margin,
     *             p1Location, p2Location, p3Location, p4Location,
     *             helppoint1, helppoint2, helppoint3, helppoint4;
     *
     *      // margin to make the boundingBox virtually smaller
     *      margin = [2,2,2,2];
     *
     *      // Points which are seen on screen
     *      point1 = board.create('point', [0,0]);
     *      point2 = board.create('point', [0,7]);
     *      point3 = board.create('point', [7,7]);
     *      point4 = board.create('point', [-7,-5]);
     *
     *      p1Location = board.getPointLoc(point1.coords.usrCoords, margin);
     *      p2Location = board.getPointLoc(point2.coords.usrCoords, margin);
     *      p3Location = board.getPointLoc(point3.coords.usrCoords, margin);
     *      p4Location = board.getPointLoc(point4.coords.usrCoords, margin);
     *
     *      // Text seen on screen
     *      board.create('text', [1,-1, "getPointLoc(A): " + "[" + p1Location + "]"])
     *      board.create('text', [1,-2, "getPointLoc(B): " + "[" + p2Location + "]"])
     *      board.create('text', [1,-3, "getPointLoc(C): " + "[" + p3Location + "]"])
     *      board.create('text', [1,-4, "getPointLoc(D): " + "[" + p4Location + "]"])
     *
     *
     *      // Helping points that are used to create the helping lines
     *      helppoint1 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[2] - 2, bbx[1] -2];
     *      })], {
     *          visible: false,
     *      })
     *
     *      helppoint2 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[0] + 2, bbx[1] -2];
     *      })], {
     *          visible: false,
     *      })
     *
     *      helppoint3 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[0]+ 2, bbx[3] + 2];
     *      })],{
     *          visible: false,
     *      })
     *
     *      helppoint4 = board.create('point', [(function (){
     *          var bbx = board.getBoundingBox();
     *          return [bbx[2] -2, bbx[3] + 2];
     *      })], {
     *          visible: false,
     *      })
     *
     *      // Helping lines to visualize the 9 sectors and the margin
     *      board.create('line', [helppoint1, helppoint2]);
     *      board.create('line', [helppoint2, helppoint3]);
     *      board.create('line', [helppoint3, helppoint4]);
     *      board.create('line', [helppoint4, helppoint1]);
     *  })();
     *
     * <\/script><pre>
     *
     */
    getPointLoc: function(position, margin) {
      var bbox, pos, res, marg;
      bbox = this.getBoundingBox();
      pos = position;
      if (pos.length === 2) {
        pos.unshift(void 0);
      }
      res = [0, 0];
      marg = margin || 0;
      if (type_default.isNumber(marg)) {
        marg = [marg, marg, marg, marg];
      }
      if (pos[1] > bbox[2] - marg[1]) {
        res[0] = 1;
      }
      if (pos[1] < bbox[0] + marg[3]) {
        res[0] = -1;
      }
      if (pos[2] > bbox[1] - marg[0]) {
        res[1] = 1;
      }
      if (pos[2] < bbox[3] + marg[2]) {
        res[1] = -1;
      }
      return res;
    },
    /**
     * This function calculates where the origin is located (@link Board#getPointLoc).
     * Optional a <tt>margin</tt> to the inner of the board is respected.<br>
     *
     * @name Board#getLocationOrigin
     * @param {Array|Number} [margin] Optional margin for the inner of the board: <tt>[top, right, bottom, left]</tt>. A single number <tt>m</tt> is interpreted as <tt>[m, m, m, m]</tt>.
     * @returns {Array} [u,v] which shows where the origin is located (@link Board#getPointLoc).
     */
    getLocationOrigin: function(margin) {
      return this.getPointLoc([0, 0], margin);
    },
    /**
     * Get the position of the pointing device in screen coordinates, relative to the upper left corner
     * of the host tag.
     * @param {Event} e Event object given by the browser.
     * @param {Number} [i] Only use in case of touch events. This determines which finger to use and should not be set
     * for mouseevents.
     * @returns {Array} Contains the mouse coordinates in screen coordinates, ready for {@link JXG.Coords}
     */
    getMousePosition: function(e, i2) {
      var cPos = this.getCoordsTopLeftCorner(), absPos, v;
      absPos = env_default.getPosition(e, i2, this.document);
      this.updateCSSTransforms();
      v = [1, absPos[0] - cPos[0], absPos[1] - cPos[1]];
      v = math_default.matVecMult(this.cssTransMat, v);
      v[1] /= v[0];
      v[2] /= v[0];
      return [v[1], v[2]];
    },
    /**
     * Initiate moving the origin. This is used in mouseDown and touchStart listeners.
     * @param {Number} x Current mouse/touch coordinates
     * @param {Number} y Current mouse/touch coordinates
     */
    initMoveOrigin: function(x, y) {
      this.drag_dx = x - this.origin.scrCoords[1];
      this.drag_dy = y - this.origin.scrCoords[2];
      this.mode = this.BOARD_MODE_MOVE_ORIGIN;
      this.updateQuality = this.BOARD_QUALITY_LOW;
    },
    /**
     * Collects all elements below the current mouse pointer and fulfilling the following constraints:
     * <ul><li>isDraggable</li><li>visible</li><li>not fixed</li><li>not frozen</li></ul>
     * @param {Number} x Current mouse/touch coordinates
     * @param {Number} y current mouse/touch coordinates
     * @param {Object} evt An event object
     * @param {String} type What type of event? 'touch', 'mouse' or 'pen'.
     * @returns {Array} A list of geometric elements.
     */
    initMoveObject: function(x, y, evt, type) {
      var pEl, el, collect = [], offset = [], haspoint, len = this.objectsList.length, dragEl = { visProp: { layer: -1e4 } };
      this._shiftKey = evt.shiftKey;
      this._ctrlKey = evt.ctrlKey;
      for (el = 0; el < len; el++) {
        pEl = this.objectsList[el];
        haspoint = pEl.hasPoint && pEl.hasPoint(x, y);
        if (pEl.visPropCalc.visible && haspoint) {
          pEl.triggerEventHandlers([type + "down", "down"], [evt]);
          this.downObjects.push(pEl);
        }
        if (haspoint && pEl.isDraggable && pEl.visPropCalc.visible && (this.geonextCompatibilityMode && (type_default.isPoint(pEl) || pEl.elementClass === constants_default.OBJECT_CLASS_TEXT) || !this.geonextCompatibilityMode) && !type_default.evaluate(pEl.visProp.fixed)) {
          if (pEl.visProp.layer > dragEl.visProp.layer || pEl.visProp.layer === dragEl.visProp.layer && pEl.lastDragTime.getTime() >= dragEl.lastDragTime.getTime()) {
            if (!this.attr.ignorelabels || !type_default.exists(dragEl.label) || pEl !== dragEl.label) {
              dragEl = pEl;
              collect.push(dragEl);
              if (type_default.exists(dragEl.coords)) {
                offset.push(
                  statistics_default.subtract(dragEl.coords.scrCoords.slice(1), [
                    x,
                    y
                  ])
                );
              } else {
                offset.push([0, 0]);
              }
            }
          }
        }
      }
      if (this.attr.drag.enabled && collect.length > 0) {
        this.mode = this.BOARD_MODE_DRAG;
      }
      if (this.attr.takefirst) {
        collect.length = 1;
        this._drag_offset = offset[0];
      } else {
        collect = collect.slice(-1);
        this._drag_offset = offset[offset.length - 1];
      }
      if (!this._drag_offset) {
        this._drag_offset = [0, 0];
      }
      if (this.renderer.type === "svg" && type_default.exists(collect[0]) && type_default.evaluate(collect[0].visProp.dragtotopoflayer) && collect.length === 1 && type_default.exists(collect[0].rendNode)) {
        collect[0].rendNode.parentNode.appendChild(collect[0].rendNode);
      }
      if (collect.length >= 1) {
        collect[0].highlight(true);
        this.triggerEventHandlers(["mousehit", "hit"], [evt, collect[0]]);
      }
      return collect;
    },
    /**
     * Moves an object.
     * @param {Number} x Coordinate
     * @param {Number} y Coordinate
     * @param {Object} o The touch object that is dragged: {JXG.Board#mouse} or {JXG.Board#touches}.
     * @param {Object} evt The event object.
     * @param {String} type Mouse or touch event?
     */
    moveObject: function(x, y, o, evt, type) {
      var newPos = new coords_default(
        constants_default.COORDS_BY_SCREEN,
        this.getScrCoordsOfMouse(x, y),
        this
      ), drag, dragScrCoords, newDragScrCoords;
      if (!(o && o.obj)) {
        return;
      }
      drag = o.obj;
      if (drag.coords) {
        dragScrCoords = drag.coords.scrCoords.slice();
      }
      this.addLogEntry("drag", drag, newPos.usrCoords.slice(1));
      this.drag_position = [newPos.scrCoords[1], newPos.scrCoords[2]];
      this.drag_position = statistics_default.add(this.drag_position, this._drag_offset);
      this._shiftKey = evt.shiftKey;
      this._ctrlKey = evt.ctrlKey;
      if (type_default.exists(drag.coords)) {
        drag.setPositionDirectly(constants_default.COORDS_BY_SCREEN, this.drag_position);
      } else {
        this.displayInfobox(false);
        if (!isNaN(o.targets[0].Xprev + o.targets[0].Yprev)) {
          drag.setPositionDirectly(
            constants_default.COORDS_BY_SCREEN,
            [newPos.scrCoords[1], newPos.scrCoords[2]],
            [o.targets[0].Xprev, o.targets[0].Yprev]
          );
        }
        o.targets[0].Xprev = newPos.scrCoords[1];
        o.targets[0].Yprev = newPos.scrCoords[2];
      }
      if (type_default.exists(drag.coords)) {
        drag.prepareUpdate().update(false).updateRenderer();
        this.updateInfobox(drag);
        drag.prepareUpdate().update(true).updateRenderer();
      }
      if (drag.coords) {
        newDragScrCoords = drag.coords.scrCoords;
      }
      if (!drag.coords || dragScrCoords[1] !== newDragScrCoords[1] || dragScrCoords[2] !== newDragScrCoords[2]) {
        drag.triggerEventHandlers([type + "drag", "drag"], [evt]);
        this.update();
      }
      drag.highlight(true);
      this.triggerEventHandlers(["mousehit", "hit"], [evt, drag]);
      drag.lastDragTime = new Date();
    },
    /**
     * Moves elements in multitouch mode.
     * @param {Array} p1 x,y coordinates of first touch
     * @param {Array} p2 x,y coordinates of second touch
     * @param {Object} o The touch object that is dragged: {JXG.Board#touches}.
     * @param {Object} evt The event object that lead to this movement.
     */
    twoFingerMove: function(o, id, evt) {
      var drag;
      if (type_default.exists(o) && type_default.exists(o.obj)) {
        drag = o.obj;
      } else {
        return;
      }
      if (drag.elementClass === constants_default.OBJECT_CLASS_LINE || drag.type === constants_default.OBJECT_TYPE_POLYGON) {
        this.twoFingerTouchObject(o.targets, drag, id);
      } else if (drag.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
        this.twoFingerTouchCircle(o.targets, drag, id);
      }
      if (evt) {
        drag.triggerEventHandlers(["touchdrag", "drag"], [evt]);
      }
    },
    /**
     * Compute the transformation matrix to move an element according to the
     * previous and actual positions of finger 1 and finger 2.
     * See also https://math.stackexchange.com/questions/4010538/solve-for-2d-translation-rotation-and-scale-given-two-touch-point-movements
     *
     * @param {Object} finger1 Actual and previous position of finger 1
     * @param {Object} finger1 Actual and previous position of finger 1
     * @param {Boolean} scalable Flag if element may be scaled
     * @param {Boolean} rotatable Flag if element may be rotated
     * @returns {Array}
     */
    getTwoFingerTransform(finger1, finger2, scalable, rotatable) {
      var crd, x1, y1, x2, y2, dx, dy, xx1, yy1, xx2, yy2, dxx, dyy, C, S, LL, tx, ty, lbda;
      crd = new coords_default(constants_default.COORDS_BY_SCREEN, [finger1.Xprev, finger1.Yprev], this).usrCoords;
      x1 = crd[1];
      y1 = crd[2];
      crd = new coords_default(constants_default.COORDS_BY_SCREEN, [finger2.Xprev, finger2.Yprev], this).usrCoords;
      x2 = crd[1];
      y2 = crd[2];
      crd = new coords_default(constants_default.COORDS_BY_SCREEN, [finger1.X, finger1.Y], this).usrCoords;
      xx1 = crd[1];
      yy1 = crd[2];
      crd = new coords_default(constants_default.COORDS_BY_SCREEN, [finger2.X, finger2.Y], this).usrCoords;
      xx2 = crd[1];
      yy2 = crd[2];
      dx = x2 - x1;
      dy = y2 - y1;
      dxx = xx2 - xx1;
      dyy = yy2 - yy1;
      LL = dx * dx + dy * dy;
      C = (dxx * dx + dyy * dy) / LL;
      S = (dyy * dx - dxx * dy) / LL;
      if (!scalable) {
        lbda = math_default.hypot(C, S);
        C /= lbda;
        S /= lbda;
      }
      if (!rotatable) {
        S = 0;
      }
      tx = 0.5 * (xx1 + xx2 - C * (x1 + x2) + S * (y1 + y2));
      ty = 0.5 * (yy1 + yy2 - S * (x1 + x2) - C * (y1 + y2));
      return [
        1,
        0,
        0,
        tx,
        C,
        -S,
        ty,
        S,
        C
      ];
    },
    /**
     * Moves, rotates and scales a line or polygon with two fingers.
     * <p>
     * If one vertex of the polygon snaps to the grid or to points or is not draggable,
     * two-finger-movement is cancelled.
     *
     * @param {Array} tar Array containing touch event objects: {JXG.Board#touches.targets}.
     * @param {object} drag The object that is dragged:
     * @param {Number} id pointerId of the event. In case of old touch event this is emulated.
     */
    twoFingerTouchObject: function(tar, drag, id) {
      var t, T, ar, i2, len, vp, snap = false;
      if (type_default.exists(tar[0]) && type_default.exists(tar[1]) && !isNaN(tar[0].Xprev + tar[0].Yprev + tar[1].Xprev + tar[1].Yprev)) {
        T = this.getTwoFingerTransform(
          tar[0],
          tar[1],
          type_default.evaluate(drag.visProp.scalable),
          type_default.evaluate(drag.visProp.rotatable)
        );
        t = this.create("transform", T, { type: "generic" });
        t.update();
        if (drag.elementClass === constants_default.OBJECT_CLASS_LINE) {
          ar = [];
          if (drag.point1.draggable()) {
            ar.push(drag.point1);
          }
          if (drag.point2.draggable()) {
            ar.push(drag.point2);
          }
          t.applyOnce(ar);
        } else if (drag.type === constants_default.OBJECT_TYPE_POLYGON) {
          len = drag.vertices.length - 1;
          vp = drag.visProp;
          snap = type_default.evaluate(vp.snaptogrid) || type_default.evaluate(vp.snaptopoints);
          for (i2 = 0; i2 < len && !snap; ++i2) {
            vp = drag.vertices[i2].visProp;
            snap = snap || type_default.evaluate(vp.snaptogrid) || type_default.evaluate(vp.snaptopoints);
            snap = snap || !drag.vertices[i2].draggable();
          }
          if (!snap) {
            ar = [];
            for (i2 = 0; i2 < len; ++i2) {
              if (drag.vertices[i2].draggable()) {
                ar.push(drag.vertices[i2]);
              }
            }
            t.applyOnce(ar);
          }
        }
        this.update();
        drag.highlight(true);
      }
    },
    /*
     * Moves, rotates and scales a circle with two fingers.
     * @param {Array} tar Array containing touch event objects: {JXG.Board#touches.targets}.
     * @param {object} drag The object that is dragged:
     * @param {Number} id pointerId of the event. In case of old touch event this is emulated.
     */
    twoFingerTouchCircle: function(tar, drag, id) {
      var fixEl, moveEl, np, op, fix, d, alpha, t1, t2, t3, t4;
      if (drag.method === "pointCircle" || drag.method === "pointLine") {
        return;
      }
      if (type_default.exists(tar[0]) && type_default.exists(tar[1]) && !isNaN(tar[0].Xprev + tar[0].Yprev + tar[1].Xprev + tar[1].Yprev)) {
        if (id === tar[0].num) {
          fixEl = tar[1];
          moveEl = tar[0];
        } else {
          fixEl = tar[0];
          moveEl = tar[1];
        }
        fix = new coords_default(constants_default.COORDS_BY_SCREEN, [fixEl.Xprev, fixEl.Yprev], this).usrCoords;
        op = new coords_default(constants_default.COORDS_BY_SCREEN, [moveEl.Xprev, moveEl.Yprev], this).usrCoords;
        np = new coords_default(constants_default.COORDS_BY_SCREEN, [moveEl.X, moveEl.Y], this).usrCoords;
        alpha = geometry_default.rad(op.slice(1), fix.slice(1), np.slice(1));
        t1 = this.create("transform", [-fix[1], -fix[2]], {
          type: "translate"
        });
        t2 = this.create("transform", [alpha], { type: "rotate" });
        t1.melt(t2);
        if (type_default.evaluate(drag.visProp.scalable)) {
          d = geometry_default.distance(fix, np) / geometry_default.distance(fix, op);
          t3 = this.create("transform", [d, d], { type: "scale" });
          t1.melt(t3);
        }
        t4 = this.create("transform", [fix[1], fix[2]], {
          type: "translate"
        });
        t1.melt(t4);
        if (drag.center.draggable()) {
          t1.applyOnce([drag.center]);
        }
        if (drag.method === "twoPoints") {
          if (drag.point2.draggable()) {
            t1.applyOnce([drag.point2]);
          }
        } else if (drag.method === "pointRadius") {
          if (type_default.isNumber(drag.updateRadius.origin)) {
            drag.setRadius(drag.radius * d);
          }
        }
        this.update(drag.center);
        drag.highlight(true);
      }
    },
    highlightElements: function(x, y, evt, target) {
      var el, pEl, pId, overObjects = {}, len = this.objectsList.length;
      for (el = 0; el < len; el++) {
        pEl = this.objectsList[el];
        pId = pEl.id;
        if (type_default.exists(pEl.hasPoint) && pEl.visPropCalc.visible && pEl.hasPoint(x, y)) {
          this.updateInfobox(pEl);
          if (!type_default.exists(this.highlightedObjects[pId])) {
            overObjects[pId] = pEl;
            pEl.highlight();
            this.triggerEventHandlers(["mousehit", "hit"], [evt, pEl, target]);
          }
          if (pEl.mouseover) {
            pEl.triggerEventHandlers(["mousemove", "move"], [evt]);
          } else {
            pEl.triggerEventHandlers(["mouseover", "over"], [evt]);
            pEl.mouseover = true;
          }
        }
      }
      for (el = 0; el < len; el++) {
        pEl = this.objectsList[el];
        pId = pEl.id;
        if (pEl.mouseover) {
          if (!overObjects[pId]) {
            pEl.triggerEventHandlers(["mouseout", "out"], [evt]);
            pEl.mouseover = false;
          }
        }
      }
    },
    /**
     * Helper function which returns a reasonable starting point for the object being dragged.
     * Formerly known as initXYstart().
     * @private
     * @param {JXG.GeometryElement} obj The object to be dragged
     * @param {Array} targets Array of targets. It is changed by this function.
     */
    saveStartPos: function(obj, targets) {
      var xy = [], i2, len;
      if (obj.type === constants_default.OBJECT_TYPE_TICKS) {
        xy.push([1, NaN, NaN]);
      } else if (obj.elementClass === constants_default.OBJECT_CLASS_LINE) {
        xy.push(obj.point1.coords.usrCoords);
        xy.push(obj.point2.coords.usrCoords);
      } else if (obj.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
        xy.push(obj.center.coords.usrCoords);
        if (obj.method === "twoPoints") {
          xy.push(obj.point2.coords.usrCoords);
        }
      } else if (obj.type === constants_default.OBJECT_TYPE_POLYGON) {
        len = obj.vertices.length - 1;
        for (i2 = 0; i2 < len; i2++) {
          xy.push(obj.vertices[i2].coords.usrCoords);
        }
      } else if (obj.type === constants_default.OBJECT_TYPE_SECTOR) {
        xy.push(obj.point1.coords.usrCoords);
        xy.push(obj.point2.coords.usrCoords);
        xy.push(obj.point3.coords.usrCoords);
      } else if (type_default.isPoint(obj) || obj.type === constants_default.OBJECT_TYPE_GLIDER) {
        xy.push(obj.coords.usrCoords);
      } else if (obj.elementClass === constants_default.OBJECT_CLASS_CURVE) {
        if (obj.points.length > 0) {
          xy.push(obj.points[0].usrCoords);
        }
      } else {
        try {
          xy.push(obj.coords.usrCoords);
        } catch (e) {
          jxg_default.debug(
            "JSXGraph+ saveStartPos: obj.coords.usrCoords not available: " + e
          );
        }
      }
      len = xy.length;
      for (i2 = 0; i2 < len; i2++) {
        targets.Zstart.push(xy[i2][0]);
        targets.Xstart.push(xy[i2][1]);
        targets.Ystart.push(xy[i2][2]);
      }
    },
    mouseOriginMoveStart: function(evt) {
      var r, pos;
      r = this._isRequiredKeyPressed(evt, "pan");
      if (r) {
        pos = this.getMousePosition(evt);
        this.initMoveOrigin(pos[0], pos[1]);
      }
      return r;
    },
    mouseOriginMove: function(evt) {
      var r = this.mode === this.BOARD_MODE_MOVE_ORIGIN, pos;
      if (r) {
        pos = this.getMousePosition(evt);
        this.moveOrigin(pos[0], pos[1], true);
      }
      return r;
    },
    /**
     * Start moving the origin with one finger.
     * @private
     * @param  {Object} evt Event from touchStartListener
     * @return {Boolean}   returns if the origin is moved.
     */
    touchStartMoveOriginOneFinger: function(evt) {
      var touches = evt[jxg_default.touchProperty], conditions, pos;
      conditions = this.attr.pan.enabled && !this.attr.pan.needtwofingers && touches.length === 1;
      if (conditions) {
        pos = this.getMousePosition(evt, 0);
        this.initMoveOrigin(pos[0], pos[1]);
      }
      return conditions;
    },
    /**
     * Move the origin with one finger
     * @private
     * @param  {Object} evt Event from touchMoveListener
     * @return {Boolean}     returns if the origin is moved.
     */
    touchOriginMove: function(evt) {
      var r = this.mode === this.BOARD_MODE_MOVE_ORIGIN, pos;
      if (r) {
        pos = this.getMousePosition(evt, 0);
        this.moveOrigin(pos[0], pos[1], true);
      }
      return r;
    },
    /**
     * Stop moving the origin with one finger
     * @return {null} null
     * @private
     */
    originMoveEnd: function() {
      this.updateQuality = this.BOARD_QUALITY_HIGH;
      this.mode = this.BOARD_MODE_NONE;
    },
    /**********************************************************
     *
     * Event Handler
     *
     **********************************************************/
    /**
     * Add all possible event handlers to the board object
     * which move objects, i.e. mouse, pointer and touch events.
     */
    addEventHandlers: function() {
      if (env_default.supportsPointerEvents()) {
        this.addPointerEventHandlers();
      } else {
        this.addMouseEventHandlers();
        this.addTouchEventHandlers();
      }
      if (this.containerObj !== null) {
        this.containerObj.oncontextmenu = function(e) {
          if (type_default.exists(e)) {
            e.preventDefault();
          }
          return false;
        };
      }
    },
    /**
     * Add resize event handlers
     *
     */
    addResizeEventHandlers: function() {
      if (env_default.isBrowser) {
        try {
          this.startResizeObserver();
        } catch (err) {
          env_default.addEvent(window, "resize", this.resizeListener, this);
          this.startIntersectionObserver();
        }
        env_default.addEvent(window, "scroll", this.scrollListener, this);
      }
    },
    /**
     * Remove all event handlers from the board object
     */
    removeEventHandlers: function() {
      this.removeMouseEventHandlers();
      this.removeTouchEventHandlers();
      this.removePointerEventHandlers();
      this.removeFullscreenEventHandlers();
      this.removeKeyboardEventHandlers();
      if (env_default.isBrowser) {
        if (type_default.exists(this.resizeObserver)) {
          this.stopResizeObserver();
        } else {
          env_default.removeEvent(window, "resize", this.resizeListener, this);
          this.stopIntersectionObserver();
        }
        env_default.removeEvent(window, "scroll", this.scrollListener, this);
      }
    },
    /**
     * Registers pointer event handlers.
     */
    addPointerEventHandlers: function() {
      if (!this.hasPointerHandlers && env_default.isBrowser) {
        var moveTarget = this.attr.movetarget || this.containerObj;
        if (window.navigator.msPointerEnabled) {
          env_default.addEvent(this.containerObj, "MSPointerDown", this.pointerDownListener, this);
          env_default.addEvent(moveTarget, "MSPointerMove", this.pointerMoveListener, this);
        } else {
          env_default.addEvent(this.containerObj, "pointerdown", this.pointerDownListener, this);
          env_default.addEvent(moveTarget, "pointermove", this.pointerMoveListener, this);
          env_default.addEvent(moveTarget, "pointerleave", this.pointerLeaveListener, this);
          env_default.addEvent(moveTarget, "click", this.pointerClickListener, this);
          env_default.addEvent(moveTarget, "dblclick", this.pointerDblClickListener, this);
        }
        if (this.containerObj !== null) {
          this.containerObj.style.touchAction = "none";
        }
        this.hasPointerHandlers = true;
      }
    },
    /**
     * Registers mouse move, down and wheel event handlers.
     */
    addMouseEventHandlers: function() {
      if (!this.hasMouseHandlers && env_default.isBrowser) {
        var moveTarget = this.attr.movetarget || this.containerObj;
        env_default.addEvent(this.containerObj, "mousedown", this.mouseDownListener, this);
        env_default.addEvent(moveTarget, "mousemove", this.mouseMoveListener, this);
        env_default.addEvent(moveTarget, "click", this.mouseClickListener, this);
        env_default.addEvent(moveTarget, "dblclick", this.mouseDblClickListener, this);
        this.hasMouseHandlers = true;
      }
    },
    /**
     * Register touch start and move and gesture start and change event handlers.
     * @param {Boolean} appleGestures If set to false the gesturestart and gesturechange event handlers
     * will not be registered.
     *
     * Since iOS 13, touch events were abandoned in favour of pointer events
     */
    addTouchEventHandlers: function(appleGestures) {
      if (!this.hasTouchHandlers && env_default.isBrowser) {
        var moveTarget = this.attr.movetarget || this.containerObj;
        env_default.addEvent(this.containerObj, "touchstart", this.touchStartListener, this);
        env_default.addEvent(moveTarget, "touchmove", this.touchMoveListener, this);
        this.hasTouchHandlers = true;
      }
    },
    /**
     * Registers pointer event handlers.
     */
    addWheelEventHandlers: function() {
      if (!this.hasWheelHandlers && env_default.isBrowser) {
        env_default.addEvent(this.containerObj, "mousewheel", this.mouseWheelListener, this);
        env_default.addEvent(this.containerObj, "DOMMouseScroll", this.mouseWheelListener, this);
        this.hasWheelHandlers = true;
      }
    },
    /**
     * Add fullscreen events which update the CSS transformation matrix to correct
     * the mouse/touch/pointer positions in case of CSS transformations.
     */
    addFullscreenEventHandlers: function() {
      var i2, events = [
        "fullscreenchange",
        "mozfullscreenchange",
        "webkitfullscreenchange",
        "msfullscreenchange"
      ], le = events.length;
      if (!this.hasFullscreenEventHandlers && env_default.isBrowser) {
        for (i2 = 0; i2 < le; i2++) {
          env_default.addEvent(this.document, events[i2], this.fullscreenListener, this);
        }
        this.hasFullscreenEventHandlers = true;
      }
    },
    /**
     * Register keyboard event handlers.
     */
    addKeyboardEventHandlers: function() {
      if (this.attr.keyboard.enabled && !this.hasKeyboardHandlers && env_default.isBrowser) {
        env_default.addEvent(this.containerObj, "keydown", this.keyDownListener, this);
        env_default.addEvent(this.containerObj, "focusin", this.keyFocusInListener, this);
        env_default.addEvent(this.containerObj, "focusout", this.keyFocusOutListener, this);
        this.hasKeyboardHandlers = true;
      }
    },
    /**
     * Remove all registered touch event handlers.
     */
    removeKeyboardEventHandlers: function() {
      if (this.hasKeyboardHandlers && env_default.isBrowser) {
        env_default.removeEvent(this.containerObj, "keydown", this.keyDownListener, this);
        env_default.removeEvent(this.containerObj, "focusin", this.keyFocusInListener, this);
        env_default.removeEvent(this.containerObj, "focusout", this.keyFocusOutListener, this);
        this.hasKeyboardHandlers = false;
      }
    },
    /**
     * Remove all registered event handlers regarding fullscreen mode.
     */
    removeFullscreenEventHandlers: function() {
      var i2, events = [
        "fullscreenchange",
        "mozfullscreenchange",
        "webkitfullscreenchange",
        "msfullscreenchange"
      ], le = events.length;
      if (this.hasFullscreenEventHandlers && env_default.isBrowser) {
        for (i2 = 0; i2 < le; i2++) {
          env_default.removeEvent(this.document, events[i2], this.fullscreenListener, this);
        }
        this.hasFullscreenEventHandlers = false;
      }
    },
    /**
     * Remove MSPointer* Event handlers.
     */
    removePointerEventHandlers: function() {
      if (this.hasPointerHandlers && env_default.isBrowser) {
        var moveTarget = this.attr.movetarget || this.containerObj;
        if (window.navigator.msPointerEnabled) {
          env_default.removeEvent(this.containerObj, "MSPointerDown", this.pointerDownListener, this);
          env_default.removeEvent(moveTarget, "MSPointerMove", this.pointerMoveListener, this);
        } else {
          env_default.removeEvent(this.containerObj, "pointerdown", this.pointerDownListener, this);
          env_default.removeEvent(moveTarget, "pointermove", this.pointerMoveListener, this);
          env_default.removeEvent(moveTarget, "pointerleave", this.pointerLeaveListener, this);
          env_default.removeEvent(moveTarget, "click", this.pointerClickListener, this);
          env_default.removeEvent(moveTarget, "dblclick", this.pointerDblClickListener, this);
        }
        if (this.hasWheelHandlers) {
          env_default.removeEvent(this.containerObj, "mousewheel", this.mouseWheelListener, this);
          env_default.removeEvent(this.containerObj, "DOMMouseScroll", this.mouseWheelListener, this);
        }
        if (this.hasPointerUp) {
          if (window.navigator.msPointerEnabled) {
            env_default.removeEvent(this.document, "MSPointerUp", this.pointerUpListener, this);
          } else {
            env_default.removeEvent(this.document, "pointerup", this.pointerUpListener, this);
            env_default.removeEvent(this.document, "pointercancel", this.pointerUpListener, this);
          }
          this.hasPointerUp = false;
        }
        this.hasPointerHandlers = false;
      }
    },
    /**
     * De-register mouse event handlers.
     */
    removeMouseEventHandlers: function() {
      if (this.hasMouseHandlers && env_default.isBrowser) {
        var moveTarget = this.attr.movetarget || this.containerObj;
        env_default.removeEvent(this.containerObj, "mousedown", this.mouseDownListener, this);
        env_default.removeEvent(moveTarget, "mousemove", this.mouseMoveListener, this);
        env_default.removeEvent(moveTarget, "click", this.mouseClickListener, this);
        env_default.removeEvent(moveTarget, "dblclick", this.mouseDblClickListener, this);
        if (this.hasMouseUp) {
          env_default.removeEvent(this.document, "mouseup", this.mouseUpListener, this);
          this.hasMouseUp = false;
        }
        if (this.hasWheelHandlers) {
          env_default.removeEvent(this.containerObj, "mousewheel", this.mouseWheelListener, this);
          env_default.removeEvent(
            this.containerObj,
            "DOMMouseScroll",
            this.mouseWheelListener,
            this
          );
        }
        this.hasMouseHandlers = false;
      }
    },
    /**
     * Remove all registered touch event handlers.
     */
    removeTouchEventHandlers: function() {
      if (this.hasTouchHandlers && env_default.isBrowser) {
        var moveTarget = this.attr.movetarget || this.containerObj;
        env_default.removeEvent(this.containerObj, "touchstart", this.touchStartListener, this);
        env_default.removeEvent(moveTarget, "touchmove", this.touchMoveListener, this);
        if (this.hasTouchEnd) {
          env_default.removeEvent(this.document, "touchend", this.touchEndListener, this);
          this.hasTouchEnd = false;
        }
        this.hasTouchHandlers = false;
      }
    },
    /**
     * Handler for click on left arrow in the navigation bar
     * @returns {JXG.Board} Reference to the board
     */
    clickLeftArrow: function() {
      this.moveOrigin(
        this.origin.scrCoords[1] + this.canvasWidth * 0.1,
        this.origin.scrCoords[2]
      );
      return this;
    },
    /**
     * Handler for click on right arrow in the navigation bar
     * @returns {JXG.Board} Reference to the board
     */
    clickRightArrow: function() {
      this.moveOrigin(
        this.origin.scrCoords[1] - this.canvasWidth * 0.1,
        this.origin.scrCoords[2]
      );
      return this;
    },
    /**
     * Handler for click on up arrow in the navigation bar
     * @returns {JXG.Board} Reference to the board
     */
    clickUpArrow: function() {
      this.moveOrigin(
        this.origin.scrCoords[1],
        this.origin.scrCoords[2] - this.canvasHeight * 0.1
      );
      return this;
    },
    /**
     * Handler for click on down arrow in the navigation bar
     * @returns {JXG.Board} Reference to the board
     */
    clickDownArrow: function() {
      this.moveOrigin(
        this.origin.scrCoords[1],
        this.origin.scrCoords[2] + this.canvasHeight * 0.1
      );
      return this;
    },
    /**
     * Triggered on iOS/Safari while the user inputs a gesture (e.g. pinch) and is used to zoom into the board.
     * Works on iOS/Safari and Android.
     * @param {Event} evt Browser event object
     * @returns {Boolean}
     */
    gestureChangeListener: function(evt) {
      var c, dir1 = [], dir2 = [], angle, mi = 10, isPinch = false, zx = this.attr.zoom.factorx, zy = this.attr.zoom.factory, factor, dist, theta, bound, doZoom = false, dx, dy, cx, cy;
      if (this.mode !== this.BOARD_MODE_ZOOM) {
        return true;
      }
      evt.preventDefault();
      dist = geometry_default.distance(
        [evt.touches[0].clientX, evt.touches[0].clientY],
        [evt.touches[1].clientX, evt.touches[1].clientY],
        2
      );
      if (evt.scale === void 0) {
        evt.scale = dist / this.prevDist;
      }
      if (!type_default.exists(this.prevCoords)) {
        return false;
      }
      dir1 = [
        evt.touches[0].clientX - this.prevCoords[0][0],
        evt.touches[0].clientY - this.prevCoords[0][1]
      ];
      dir2 = [
        evt.touches[1].clientX - this.prevCoords[1][0],
        evt.touches[1].clientY - this.prevCoords[1][1]
      ];
      if (dir1[0] * dir1[0] + dir1[1] * dir1[1] < mi * mi && dir2[0] * dir2[0] + dir2[1] * dir2[1] < mi * mi) {
        return false;
      }
      angle = geometry_default.rad(dir1, [0, 0], dir2);
      if (this.isPreviousGesture !== "pan" && Math.abs(angle) > Math.PI * 0.2 && Math.abs(angle) < Math.PI * 1.8) {
        isPinch = true;
      }
      if (this.isPreviousGesture !== "pan" && !isPinch) {
        if (Math.abs(evt.scale) < 0.77 || Math.abs(evt.scale) > 1.3) {
          isPinch = true;
        }
      }
      factor = evt.scale / this.prevScale;
      this.prevScale = evt.scale;
      this.prevCoords = [
        [evt.touches[0].clientX, evt.touches[0].clientY],
        [evt.touches[1].clientX, evt.touches[1].clientY]
      ];
      c = new coords_default(constants_default.COORDS_BY_SCREEN, this.getMousePosition(evt, 0), this);
      if (this.attr.pan.enabled && this.attr.pan.needtwofingers && !isPinch) {
        this.isPreviousGesture = "pan";
        this.moveOrigin(c.scrCoords[1], c.scrCoords[2], true);
      } else if (this.attr.zoom.enabled && Math.abs(factor - 1) < 0.5) {
        doZoom = false;
        if (this.attr.zoom.pinchhorizontal || this.attr.zoom.pinchvertical) {
          dx = Math.abs(evt.touches[0].clientX - evt.touches[1].clientX);
          dy = Math.abs(evt.touches[0].clientY - evt.touches[1].clientY);
          theta = Math.abs(Math.atan2(dy, dx));
          bound = Math.PI * this.attr.zoom.pinchsensitivity / 90;
        }
        if (!this.keepaspectratio && this.attr.zoom.pinchhorizontal && theta < bound) {
          this.attr.zoom.factorx = factor;
          this.attr.zoom.factory = 1;
          cx = 0;
          cy = 0;
          doZoom = true;
        } else if (!this.keepaspectratio && this.attr.zoom.pinchvertical && Math.abs(theta - Math.PI * 0.5) < bound) {
          this.attr.zoom.factorx = 1;
          this.attr.zoom.factory = factor;
          cx = 0;
          cy = 0;
          doZoom = true;
        } else if (this.attr.zoom.pinch) {
          this.attr.zoom.factorx = factor;
          this.attr.zoom.factory = factor;
          cx = c.usrCoords[1];
          cy = c.usrCoords[2];
          doZoom = true;
        }
        if (doZoom) {
          this.zoomIn(cx, cy);
          this.attr.zoom.factorx = zx;
          this.attr.zoom.factory = zy;
        }
      }
      return false;
    },
    /**
     * Called by iOS/Safari as soon as the user starts a gesture. Works natively on iOS/Safari,
     * on Android we emulate it.
     * @param {Event} evt
     * @returns {Boolean}
     */
    gestureStartListener: function(evt) {
      var pos;
      evt.preventDefault();
      this.prevScale = 1;
      this.prevDist = geometry_default.distance(
        [evt.touches[0].clientX, evt.touches[0].clientY],
        [evt.touches[1].clientX, evt.touches[1].clientY],
        2
      );
      this.prevCoords = [
        [evt.touches[0].clientX, evt.touches[0].clientY],
        [evt.touches[1].clientX, evt.touches[1].clientY]
      ];
      this.isPreviousGesture = "none";
      pos = this.getMousePosition(evt, 0);
      this.initMoveOrigin(pos[0], pos[1]);
      this.mode = this.BOARD_MODE_ZOOM;
      return false;
    },
    /**
     * Test if the required key combination is pressed for wheel zoom, move origin and
     * selection
     * @private
     * @param  {Object}  evt    Mouse or pen event
     * @param  {String}  action String containing the action: 'zoom', 'pan', 'selection'.
     * Corresponds to the attribute subobject.
     * @return {Boolean}        true or false.
     */
    _isRequiredKeyPressed: function(evt, action) {
      var obj = this.attr[action];
      if (!obj.enabled) {
        return false;
      }
      if ((obj.needshift && evt.shiftKey || !obj.needshift && !evt.shiftKey) && (obj.needctrl && evt.ctrlKey || !obj.needctrl && !evt.ctrlKey)) {
        return true;
      }
      return false;
    },
    /*
     * Pointer events
     */
    /**
     *
     * Check if pointer event is already registered in {@link JXG.Board#_board_touches}.
     *
     * @param  {Object} evt Event object
     * @return {Boolean} true if down event has already been sent.
     * @private
     */
    _isPointerRegistered: function(evt) {
      var i2, len = this._board_touches.length;
      for (i2 = 0; i2 < len; i2++) {
        if (this._board_touches[i2].pointerId === evt.pointerId) {
          return true;
        }
      }
      return false;
    },
    /**
     *
     * Store the position of a pointer event.
     * If not yet done, registers a pointer event in {@link JXG.Board#_board_touches}.
     * Allows to follow the path of that finger on the screen.
     * Only two simultaneous touches are supported.
     *
     * @param {Object} evt Event object
     * @returns {JXG.Board} Reference to the board
     * @private
     */
    _pointerStorePosition: function(evt) {
      var i2, found;
      for (i2 = 0, found = false; i2 < this._board_touches.length; i2++) {
        if (this._board_touches[i2].pointerId === evt.pointerId) {
          this._board_touches[i2].clientX = evt.clientX;
          this._board_touches[i2].clientY = evt.clientY;
          found = true;
          break;
        }
      }
      if (!found && this._board_touches.length < 2) {
        this._board_touches.push({
          pointerId: evt.pointerId,
          clientX: evt.clientX,
          clientY: evt.clientY
        });
      }
      return this;
    },
    /**
     * Deregisters a pointer event in {@link JXG.Board#_board_touches}.
     * It happens if a finger has been lifted from the screen.
     *
     * @param {Object} evt Event object
     * @returns {JXG.Board} Reference to the board
     * @private
     */
    _pointerRemoveTouches: function(evt) {
      var i2;
      for (i2 = 0; i2 < this._board_touches.length; i2++) {
        if (this._board_touches[i2].pointerId === evt.pointerId) {
          this._board_touches.splice(i2, 1);
          break;
        }
      }
      return this;
    },
    /**
     * Remove all registered fingers from {@link JXG.Board#_board_touches}.
     * This might be necessary if too many fingers have been registered.
     * @returns {JXG.Board} Reference to the board
     * @private
     */
    _pointerClearTouches: function(pId) {
      if (this._board_touches.length > 0) {
        this.dehighlightAll();
      }
      this.updateQuality = this.BOARD_QUALITY_HIGH;
      this.mode = this.BOARD_MODE_NONE;
      this._board_touches = [];
      this.touches = [];
    },
    /**
     * Determine which input device is used for this action.
     * Possible devices are 'touch', 'pen' and 'mouse'.
     * This affects the precision and certain events.
     * In case of no browser, 'mouse' is used.
     *
     * @see JXG.Board#pointerDownListener
     * @see JXG.Board#pointerMoveListener
     * @see JXG.Board#initMoveObject
     * @see JXG.Board#moveObject
     *
     * @param {Event} evt The browsers event object.
     * @returns {String} 'mouse', 'pen', or 'touch'
     * @private
     */
    _getPointerInputDevice: function(evt) {
      if (env_default.isBrowser) {
        if (evt.pointerType === "touch" || // New
        window.navigator.msMaxTouchPoints && // Old
        window.navigator.msMaxTouchPoints > 1) {
          return "touch";
        }
        if (evt.pointerType === "mouse") {
          return "mouse";
        }
        if (evt.pointerType === "pen") {
          return "pen";
        }
      }
      return "mouse";
    },
    /**
     * This method is called by the browser when a pointing device is pressed on the screen.
     * @param {Event} evt The browsers event object.
     * @param {Object} object If the object to be dragged is already known, it can be submitted via this parameter
     * @param {Boolean} [allowDefaultEventHandling=false] If true event is not canceled, i.e. prevent call of evt.preventDefault()
     * @returns {Boolean} false if the first finger event is sent twice, or not a browser, or in selection mode. Otherwise returns true.
     */
    pointerDownListener: function(evt, object, allowDefaultEventHandling) {
      var i2, j, k, pos, elements2, sel, target_obj, type = "mouse", found, target, ta;
      if (!object && this._isPointerRegistered(evt)) {
        return false;
      }
      if (type_default.evaluate(this.attr.movetarget) === null && type_default.exists(evt.target) && type_default.exists(evt.target.releasePointerCapture)) {
        evt.target.releasePointerCapture(evt.pointerId);
      }
      if (!object && evt.isPrimary) {
      }
      if (!this.hasPointerUp) {
        if (window.navigator.msPointerEnabled) {
          env_default.addEvent(this.document, "MSPointerUp", this.pointerUpListener, this);
        } else {
          env_default.addEvent(this.document, "pointerup", this.pointerUpListener, this);
          env_default.addEvent(this.document, "pointercancel", this.pointerUpListener, this);
        }
        this.hasPointerUp = true;
      }
      if (this.hasMouseHandlers) {
        this.removeMouseEventHandlers();
      }
      if (this.hasTouchHandlers) {
        this.removeTouchEventHandlers();
      }
      if (this.document.selection && type_default.isFunction(this.document.selection.empty)) {
        this.document.selection.empty();
      } else if (window.getSelection) {
        sel = window.getSelection();
        if (sel.removeAllRanges) {
          try {
            sel.removeAllRanges();
          } catch (e) {
          }
        }
      }
      this._inputDevice = this._getPointerInputDevice(evt);
      type = this._inputDevice;
      this.options.precision.hasPoint = this.options.precision[type];
      pos = this.getMousePosition(evt);
      this._testForSelection(evt);
      if (this.selectingMode) {
        this._startSelecting(pos);
        this.triggerEventHandlers(
          ["touchstartselecting", "pointerstartselecting", "startselecting"],
          [evt]
        );
        return;
      }
      if (this.attr.drag.enabled && object) {
        elements2 = [object];
        this.mode = this.BOARD_MODE_DRAG;
      } else {
        elements2 = this.initMoveObject(pos[0], pos[1], evt, type);
      }
      target_obj = {
        num: evt.pointerId,
        X: pos[0],
        Y: pos[1],
        Xprev: NaN,
        Yprev: NaN,
        Xstart: [],
        Ystart: [],
        Zstart: []
      };
      if (elements2.length > 0) {
        target = elements2[elements2.length - 1];
        found = false;
        for (i2 = 0; i2 < this.touches.length; i2++) {
          if (this.touches[i2].obj === target) {
            j = i2;
            k = this.touches[i2].targets.push(target_obj) - 1;
            found = true;
            break;
          }
        }
        if (!found) {
          k = 0;
          j = this.touches.push({
            obj: target,
            targets: [target_obj]
          }) - 1;
        }
        this.dehighlightAll();
        target.highlight(true);
        this.saveStartPos(target, this.touches[j].targets[k]);
        if (evt && evt.preventDefault && !allowDefaultEventHandling) {
          evt.preventDefault();
        }
      }
      if (this.touches.length > 0 && !allowDefaultEventHandling) {
        evt.preventDefault();
        evt.stopPropagation();
      }
      if (!env_default.isBrowser) {
        return false;
      }
      if (this._getPointerInputDevice(evt) !== "touch") {
        if (this.mode === this.BOARD_MODE_NONE) {
          this.mouseOriginMoveStart(evt);
        }
      } else {
        this._pointerStorePosition(evt);
        evt.touches = this._board_touches;
        if (evt.touches.length === 1 && this.mode === this.BOARD_MODE_NONE && this.touchStartMoveOriginOneFinger(evt)) {
        } else if (evt.touches.length === 2 && (this.mode === this.BOARD_MODE_NONE || this.mode === this.BOARD_MODE_MOVE_ORIGIN)) {
          if (this.mode === this.BOARD_MODE_MOVE_ORIGIN) {
            this.originMoveEnd();
          }
          this.gestureStartListener(evt);
        }
      }
      ta = "none";
      if (this.mode === this.BOARD_MODE_NONE && type_default.evaluate(this.attr.browserpan) && !(type_default.evaluate(this.attr.pan.enabled) && !type_default.evaluate(this.attr.pan.needtwofingers))) {
        ta = "pan-x pan-y";
      }
      this.containerObj.style.touchAction = ta;
      this.triggerEventHandlers(["touchstart", "down", "pointerdown", "MSPointerDown"], [evt]);
      return true;
    },
    /**
     * Handle entries of this.downObjects to control click and dblclick events.
     * @param {Number} i
     * @private
     */
    _waitForDblClick: function(i2) {
      var eh = this.downObjects[i2].eventHandlers;
      if (type_default.exists(eh.dblclick) && eh.dblclick.length > 0 || type_default.exists(eh.mousedblclick) && eh.mousedblclick.length > 0) {
        eh.clicks += 1;
        if (eh.clicks !== 2) {
          this.downObjects.splice(i2, 1);
          setTimeout(function() {
            eh.clicks = 0;
          }, 400);
        }
      } else {
        this.downObjects.splice(i2, 1);
      }
    },
    /**
     * This method is called by the browser when a pointer device clicks on the screen.
     * @param {Event} evt The browsers event object.
     */
    pointerClickListener: function(evt) {
      var i2;
      this.triggerEventHandlers(["click", "pointerclick"], [evt]);
      if (!this.selectingMode) {
        for (i2 = this.downObjects.length - 1; i2 > -1; i2--) {
          this.downObjects[i2].triggerEventHandlers(["click", "pointerclick"], [evt]);
          this._waitForDblClick(i2);
        }
      }
      evt.stopPropagation();
    },
    /**
     * This method is called by the browser when the mouse device clicks on the screen.
     * @param {Event} evt The browsers event object.
     */
    mouseClickListener: function(evt) {
      var i2;
      this.triggerEventHandlers(["click", "mouseclick"], [evt]);
      if (!this.selectingMode) {
        for (i2 = this.downObjects.length - 1; i2 > -1; i2--) {
          this.downObjects[i2].triggerEventHandlers(["click", "mouseclick"], [evt]);
          this._waitForDblClick(i2);
        }
      }
    },
    /**
     * This method is called by the browser when a pointer device double clicks on the screen.
     * @param {Event} evt The browsers event object.
     */
    pointerDblClickListener: function(evt) {
      var i2;
      this.triggerEventHandlers(["dblclick", "pointerdblclick"], [evt]);
      if (!this.selectingMode) {
        for (i2 = this.downObjects.length - 1; i2 > -1; i2--) {
          this.downObjects[i2].triggerEventHandlers(["dblclick", "pointerdblclick"], [evt]);
          this.downObjects[i2].eventHandlers.clicks = 0;
          this.downObjects.splice(i2, 1);
        }
      }
      evt.stopPropagation();
    },
    /**
     * This method is called by the browser when the mouse device double clicks on the screen.
     * @param {Event} evt The browsers event object.
     */
    mouseDblClickListener: function(evt) {
      var i2;
      this.triggerEventHandlers(["dblclick", "mousedblclick"], [evt]);
      if (!this.selectingMode) {
        for (i2 = this.downObjects.length - 1; i2 > -1; i2--) {
          this.downObjects[i2].triggerEventHandlers(["dblclick", "mousedblclick"], [evt]);
          this.downObjects[i2].eventHandlers.clicks = 0;
          this.downObjects.splice(i2, 1);
        }
      }
    },
    // /**
    //  * Called if pointer leaves an HTML tag. It is called by the inner-most tag.
    //  * That means, if a JSXGraph text, i.e. an HTML div, is placed close
    //  * to the border of the board, this pointerout event will be ignored.
    //  * @param  {Event} evt
    //  * @return {Boolean}
    //  */
    // pointerOutListener: function (evt) {
    //     if (evt.target === this.containerObj ||
    //         (this.renderer.type === 'svg' && evt.target === this.renderer.foreignObjLayer)) {
    //         this.pointerUpListener(evt);
    //     }
    //     return this.mode === this.BOARD_MODE_NONE;
    // },
    /**
     * Called periodically by the browser while the user moves a pointing device across the screen.
     * @param {Event} evt
     * @returns {Boolean}
     */
    pointerMoveListener: function(evt) {
      var i2, j, pos, eps, touchTargets, type = "mouse";
      if (this._getPointerInputDevice(evt) === "touch" && !this._isPointerRegistered(evt)) {
        return this.BOARD_MODE_NONE;
      }
      if (!this.checkFrameRate(evt)) {
        return false;
      }
      if (this.mode !== this.BOARD_MODE_DRAG) {
        this.dehighlightAll();
        this.displayInfobox(false);
      }
      if (this.mode !== this.BOARD_MODE_NONE) {
        evt.preventDefault();
        evt.stopPropagation();
      }
      this.updateQuality = this.BOARD_QUALITY_LOW;
      this._inputDevice = this._getPointerInputDevice(evt);
      type = this._inputDevice;
      this.options.precision.hasPoint = this.options.precision[type];
      eps = this.options.precision.hasPoint * 0.3333;
      pos = this.getMousePosition(evt);
      if (type_default.evaluate(this.attr.movetarget) === null && pos[0] <= eps || pos[1] <= eps || pos[0] >= this.canvasWidth - eps || pos[1] >= this.canvasHeight - eps) {
        return this.mode === this.BOARD_MODE_NONE;
      }
      if (this.selectingMode) {
        this._moveSelecting(pos);
        this.triggerEventHandlers(
          ["touchmoveselecting", "moveselecting", "pointermoveselecting"],
          [evt, this.mode]
        );
      } else if (!this.mouseOriginMove(evt)) {
        if (this.mode === this.BOARD_MODE_DRAG) {
          for (i2 = 0; i2 < this.touches.length; i2++) {
            touchTargets = this.touches[i2].targets;
            for (j = 0; j < touchTargets.length; j++) {
              if (touchTargets[j].num === evt.pointerId) {
                touchTargets[j].X = pos[0];
                touchTargets[j].Y = pos[1];
                if (touchTargets.length === 1) {
                  this.moveObject(pos[0], pos[1], this.touches[i2], evt, type);
                } else if (touchTargets.length === 2) {
                  this.twoFingerMove(this.touches[i2], evt.pointerId, evt);
                  touchTargets[j].Xprev = pos[0];
                  touchTargets[j].Yprev = pos[1];
                }
                break;
              }
            }
          }
        } else {
          if (this._getPointerInputDevice(evt) === "touch") {
            this._pointerStorePosition(evt);
            if (this._board_touches.length === 2) {
              evt.touches = this._board_touches;
              this.gestureChangeListener(evt);
            }
          }
          this.highlightElements(pos[0], pos[1], evt, -1);
        }
      }
      this.triggerEventHandlers(["pointermove", "MSPointerMove", "move"], [evt, this.mode]);
      this.updateQuality = this.BOARD_QUALITY_HIGH;
      return this.mode === this.BOARD_MODE_NONE;
    },
    /**
     * Triggered as soon as the user stops touching the device with at least one finger.
     *
     * @param {Event} evt
     * @returns {Boolean}
     */
    pointerUpListener: function(evt) {
      var i2, j, found, eh, touchTargets, updateNeeded = false;
      this.triggerEventHandlers(["touchend", "up", "pointerup", "MSPointerUp"], [evt]);
      this.displayInfobox(false);
      if (evt) {
        for (i2 = 0; i2 < this.touches.length; i2++) {
          touchTargets = this.touches[i2].targets;
          for (j = 0; j < touchTargets.length; j++) {
            if (touchTargets[j].num === evt.pointerId) {
              touchTargets.splice(j, 1);
              if (touchTargets.length === 0) {
                this.touches.splice(i2, 1);
              }
              break;
            }
          }
        }
      }
      this.originMoveEnd();
      this.update();
      if (this.selectingMode) {
        this._stopSelecting(evt);
        this.triggerEventHandlers(
          ["touchstopselecting", "pointerstopselecting", "stopselecting"],
          [evt]
        );
        this.stopSelectionMode();
      } else {
        for (i2 = this.downObjects.length - 1; i2 > -1; i2--) {
          found = false;
          for (j = 0; j < this.touches.length; j++) {
            if (this.touches[j].obj.id === this.downObjects[i2].id) {
              found = true;
            }
          }
          if (!found) {
            this.downObjects[i2].triggerEventHandlers(
              ["touchend", "up", "pointerup", "MSPointerUp"],
              [evt]
            );
            if (!type_default.exists(this.downObjects[i2].coords)) {
              this.downObjects[i2].snapToGrid();
              this.downObjects[i2].snapToPoints();
              updateNeeded = true;
            }
            eh = this.downObjects[i2].eventHandlers;
            if (!(type_default.exists(eh.click) && eh.click.length > 0) && !(type_default.exists(eh.pointerclick) && eh.pointerclick.length > 0) && !(type_default.exists(eh.dblclick) && eh.dblclick.length > 0) && !(type_default.exists(eh.pointerdblclick) && eh.pointerdblclick.length > 0)) {
              this.downObjects.splice(i2, 1);
            }
          }
        }
      }
      if (this.hasPointerUp) {
        if (window.navigator.msPointerEnabled) {
          env_default.removeEvent(this.document, "MSPointerUp", this.pointerUpListener, this);
        } else {
          env_default.removeEvent(this.document, "pointerup", this.pointerUpListener, this);
          env_default.removeEvent(
            this.document,
            "pointercancel",
            this.pointerUpListener,
            this
          );
        }
        this.hasPointerUp = false;
      }
      this._pointerClearTouches(evt.pointerId);
      if (this._getPointerInputDevice(evt) !== "touch") {
        this.dehighlightAll();
      }
      if (updateNeeded) {
        this.update();
      }
      return true;
    },
    /**
     * Triggered by the pointerleave event. This is needed in addition to
     * {@link JXG.Board#pointerUpListener} in the situation that a pen is used
     * and after an up event the pen leaves the hover range vertically. Here, it happens that
     * after the pointerup event further pointermove events are fired and elements get highlighted.
     * This highlighting has to be cancelled.
     *
     * @param {Event} evt
     * @returns {Boolean}
     */
    pointerLeaveListener: function(evt) {
      this.displayInfobox(false);
      this.dehighlightAll();
      return true;
    },
    /**
     * Touch-Events
     */
    /**
     * This method is called by the browser when a finger touches the surface of the touch-device.
     * @param {Event} evt The browsers event object.
     * @returns {Boolean} ...
     */
    touchStartListener: function(evt) {
      var i2, pos, elements2, j, k, eps = this.options.precision.touch, obj, found, targets, evtTouches = evt[jxg_default.touchProperty], target, touchTargets;
      if (!this.hasTouchEnd) {
        env_default.addEvent(this.document, "touchend", this.touchEndListener, this);
        this.hasTouchEnd = true;
      }
      if (this.document.selection && type_default.isFunction(this.document.selection.empty)) {
        this.document.selection.empty();
      } else if (window.getSelection) {
        window.getSelection().removeAllRanges();
      }
      this._inputDevice = "touch";
      this.options.precision.hasPoint = this.options.precision.touch;
      for (i2 = 0; i2 < evtTouches.length; i2++) {
        evtTouches[i2].jxg_isused = false;
      }
      for (i2 = 0; i2 < this.touches.length; i2++) {
        touchTargets = this.touches[i2].targets;
        for (j = 0; j < touchTargets.length; j++) {
          touchTargets[j].num = -1;
          eps = this.options.precision.touch;
          do {
            for (k = 0; k < evtTouches.length; k++) {
              if (Math.abs(
                Math.pow(evtTouches[k].screenX - touchTargets[j].X, 2) + Math.pow(evtTouches[k].screenY - touchTargets[j].Y, 2)
              ) < eps * eps) {
                touchTargets[j].num = k;
                touchTargets[j].X = evtTouches[k].screenX;
                touchTargets[j].Y = evtTouches[k].screenY;
                evtTouches[k].jxg_isused = true;
                break;
              }
            }
            eps *= 2;
          } while (touchTargets[j].num === -1 && eps < this.options.precision.touchMax);
          if (touchTargets[j].num === -1) {
            jxg_default.debug(
              "i couldn't find a targettouches for target no " + j + " on " + this.touches[i2].obj.name + " (" + this.touches[i2].obj.id + "). Removed the target."
            );
            jxg_default.debug(
              "eps = " + eps + ", touchMax = " + options_default.precision.touchMax
            );
            touchTargets.splice(i2, 1);
          }
        }
      }
      for (i2 = 0; i2 < evtTouches.length; i2++) {
        if (!evtTouches[i2].jxg_isused) {
          pos = this.getMousePosition(evt, i2);
          if (this.selectingMode) {
            this._startSelecting(pos);
            this.triggerEventHandlers(
              ["touchstartselecting", "startselecting"],
              [evt]
            );
            evt.preventDefault();
            evt.stopPropagation();
            this.options.precision.hasPoint = this.options.precision.mouse;
            return this.touches.length > 0;
          }
          elements2 = this.initMoveObject(pos[0], pos[1], evt, "touch");
          if (elements2.length !== 0) {
            obj = elements2[elements2.length - 1];
            target = {
              num: i2,
              X: evtTouches[i2].screenX,
              Y: evtTouches[i2].screenY,
              Xprev: NaN,
              Yprev: NaN,
              Xstart: [],
              Ystart: [],
              Zstart: []
            };
            if (type_default.isPoint(obj) || obj.elementClass === constants_default.OBJECT_CLASS_TEXT || obj.type === constants_default.OBJECT_TYPE_TICKS || obj.type === constants_default.OBJECT_TYPE_IMAGE) {
              targets = [target];
              this.saveStartPos(obj, targets[0]);
              this.touches.push({ obj, targets });
              obj.highlight(true);
            } else if (obj.elementClass === constants_default.OBJECT_CLASS_LINE || obj.elementClass === constants_default.OBJECT_CLASS_CIRCLE || obj.elementClass === constants_default.OBJECT_CLASS_CURVE || obj.type === constants_default.OBJECT_TYPE_POLYGON) {
              found = false;
              for (j = 0; j < this.touches.length; j++) {
                if (obj.id === this.touches[j].obj.id) {
                  found = true;
                  if (this.touches[j].targets.length === 1) {
                    this.saveStartPos(obj, target);
                    this.touches[j].targets.push(target);
                  }
                  evtTouches[i2].jxg_isused = true;
                }
              }
              if (!found) {
                targets = [target];
                this.saveStartPos(obj, targets[0]);
                this.touches.push({ obj, targets });
                obj.highlight(true);
              }
            }
          }
          evtTouches[i2].jxg_isused = true;
        }
      }
      if (this.touches.length > 0) {
        evt.preventDefault();
        evt.stopPropagation();
      }
      if (evtTouches.length === 1 && this.mode === this.BOARD_MODE_NONE && this.touchStartMoveOriginOneFinger(evt)) {
      } else if (evtTouches.length === 2 && (this.mode === this.BOARD_MODE_NONE || this.mode === this.BOARD_MODE_MOVE_ORIGIN)) {
        if (this.mode === this.BOARD_MODE_MOVE_ORIGIN) {
          this.originMoveEnd();
        }
        this.gestureStartListener(evt);
      }
      this.options.precision.hasPoint = this.options.precision.mouse;
      this.triggerEventHandlers(["touchstart", "down"], [evt]);
      return false;
    },
    /**
     * Called periodically by the browser while the user moves his fingers across the device.
     * @param {Event} evt
     * @returns {Boolean}
     */
    touchMoveListener: function(evt) {
      var i2, pos1, pos2, touchTargets, evtTouches = evt[jxg_default.touchProperty];
      if (!this.checkFrameRate(evt)) {
        return false;
      }
      if (this.mode !== this.BOARD_MODE_NONE) {
        evt.preventDefault();
        evt.stopPropagation();
      }
      if (this.mode !== this.BOARD_MODE_DRAG) {
        this.dehighlightAll();
        this.displayInfobox(false);
      }
      this._inputDevice = "touch";
      this.options.precision.hasPoint = this.options.precision.touch;
      this.updateQuality = this.BOARD_QUALITY_LOW;
      if (this.selectingMode) {
        for (i2 = 0; i2 < evtTouches.length; i2++) {
          if (!evtTouches[i2].jxg_isused) {
            pos1 = this.getMousePosition(evt, i2);
            this._moveSelecting(pos1);
            this.triggerEventHandlers(
              ["touchmoves", "moveselecting"],
              [evt, this.mode]
            );
            break;
          }
        }
      } else {
        if (!this.touchOriginMove(evt)) {
          if (this.mode === this.BOARD_MODE_DRAG) {
            for (i2 = 0; i2 < this.touches.length; i2++) {
              touchTargets = this.touches[i2].targets;
              if (touchTargets.length === 1) {
                if (evtTouches[touchTargets[0].num]) {
                  pos1 = this.getMousePosition(evt, touchTargets[0].num);
                  if (pos1[0] < 0 || pos1[0] > this.canvasWidth || pos1[1] < 0 || pos1[1] > this.canvasHeight) {
                    return;
                  }
                  touchTargets[0].X = pos1[0];
                  touchTargets[0].Y = pos1[1];
                  this.moveObject(
                    pos1[0],
                    pos1[1],
                    this.touches[i2],
                    evt,
                    "touch"
                  );
                }
              } else if (touchTargets.length === 2 && touchTargets[0].num > -1 && touchTargets[1].num > -1) {
                if (evtTouches[touchTargets[0].num] && evtTouches[touchTargets[1].num]) {
                  pos1 = this.getMousePosition(evt, touchTargets[0].num);
                  pos2 = this.getMousePosition(evt, touchTargets[1].num);
                  if (pos1[0] < 0 || pos1[0] > this.canvasWidth || pos1[1] < 0 || pos1[1] > this.canvasHeight || pos2[0] < 0 || pos2[0] > this.canvasWidth || pos2[1] < 0 || pos2[1] > this.canvasHeight) {
                    return;
                  }
                  touchTargets[0].X = pos1[0];
                  touchTargets[0].Y = pos1[1];
                  touchTargets[1].X = pos2[0];
                  touchTargets[1].Y = pos2[1];
                  this.twoFingerMove(
                    this.touches[i2],
                    touchTargets[0].num,
                    evt
                  );
                  touchTargets[0].Xprev = pos1[0];
                  touchTargets[0].Yprev = pos1[1];
                  touchTargets[1].Xprev = pos2[0];
                  touchTargets[1].Yprev = pos2[1];
                }
              }
            }
          } else {
            if (evtTouches.length === 2) {
              this.gestureChangeListener(evt);
            }
            pos1 = this.getMousePosition(evt, 0);
            this.highlightElements(pos1[0], pos1[1], evt, -1);
          }
        }
      }
      if (this.mode !== this.BOARD_MODE_DRAG) {
        this.displayInfobox(false);
      }
      this.triggerEventHandlers(["touchmove", "move"], [evt, this.mode]);
      this.options.precision.hasPoint = this.options.precision.mouse;
      this.updateQuality = this.BOARD_QUALITY_HIGH;
      return this.mode === this.BOARD_MODE_NONE;
    },
    /**
     * Triggered as soon as the user stops touching the device with at least one finger.
     * @param {Event} evt
     * @returns {Boolean}
     */
    touchEndListener: function(evt) {
      var i2, j, k, eps = this.options.precision.touch, tmpTouches = [], found, foundNumber, evtTouches = evt && evt[jxg_default.touchProperty], touchTargets, updateNeeded = false;
      this.triggerEventHandlers(["touchend", "up"], [evt]);
      this.displayInfobox(false);
      if (this.selectingMode) {
        this._stopSelecting(evt);
        this.triggerEventHandlers(["touchstopselecting", "stopselecting"], [evt]);
        this.stopSelectionMode();
      } else if (evtTouches && evtTouches.length > 0) {
        for (i2 = 0; i2 < this.touches.length; i2++) {
          tmpTouches[i2] = this.touches[i2];
        }
        this.touches.length = 0;
        for (i2 = 0; i2 < evtTouches.length; i2++) {
          evtTouches[i2].jxg_isused = false;
        }
        for (i2 = 0; i2 < tmpTouches.length; i2++) {
          found = false;
          foundNumber = 0;
          touchTargets = tmpTouches[i2].targets;
          for (j = 0; j < touchTargets.length; j++) {
            touchTargets[j].found = false;
            for (k = 0; k < evtTouches.length; k++) {
              if (Math.abs(
                Math.pow(evtTouches[k].screenX - touchTargets[j].X, 2) + Math.pow(evtTouches[k].screenY - touchTargets[j].Y, 2)
              ) < eps * eps) {
                touchTargets[j].found = true;
                touchTargets[j].num = k;
                touchTargets[j].X = evtTouches[k].screenX;
                touchTargets[j].Y = evtTouches[k].screenY;
                foundNumber += 1;
                break;
              }
            }
          }
          if (type_default.isPoint(tmpTouches[i2].obj)) {
            found = touchTargets[0] && touchTargets[0].found;
          } else if (tmpTouches[i2].obj.elementClass === constants_default.OBJECT_CLASS_LINE) {
            found = touchTargets[0] && touchTargets[0].found || touchTargets[1] && touchTargets[1].found;
          } else if (tmpTouches[i2].obj.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
            found = foundNumber === 1 || foundNumber === 3;
          }
          if (found) {
            this.touches.push({
              obj: tmpTouches[i2].obj,
              targets: []
            });
            for (j = 0; j < touchTargets.length; j++) {
              if (touchTargets[j].found) {
                this.touches[this.touches.length - 1].targets.push({
                  num: touchTargets[j].num,
                  X: touchTargets[j].screenX,
                  Y: touchTargets[j].screenY,
                  Xprev: NaN,
                  Yprev: NaN,
                  Xstart: touchTargets[j].Xstart,
                  Ystart: touchTargets[j].Ystart,
                  Zstart: touchTargets[j].Zstart
                });
              }
            }
          } else {
            tmpTouches[i2].obj.noHighlight();
          }
        }
      } else {
        this.touches.length = 0;
      }
      for (i2 = this.downObjects.length - 1; i2 > -1; i2--) {
        found = false;
        for (j = 0; j < this.touches.length; j++) {
          if (this.touches[j].obj.id === this.downObjects[i2].id) {
            found = true;
          }
        }
        if (!found) {
          this.downObjects[i2].triggerEventHandlers(["touchup", "up"], [evt]);
          if (!type_default.exists(this.downObjects[i2].coords)) {
            this.downObjects[i2].snapToGrid();
            this.downObjects[i2].snapToPoints();
            updateNeeded = true;
          }
          this.downObjects.splice(i2, 1);
        }
      }
      if (!evtTouches || evtTouches.length === 0) {
        if (this.hasTouchEnd) {
          env_default.removeEvent(this.document, "touchend", this.touchEndListener, this);
          this.hasTouchEnd = false;
        }
        this.dehighlightAll();
        this.updateQuality = this.BOARD_QUALITY_HIGH;
        this.originMoveEnd();
        if (updateNeeded) {
          this.update();
        }
      }
      return true;
    },
    /**
     * This method is called by the browser when the mouse button is clicked.
     * @param {Event} evt The browsers event object.
     * @returns {Boolean} True if no element is found under the current mouse pointer, false otherwise.
     */
    mouseDownListener: function(evt) {
      var pos, elements2, result;
      if (this.document.selection && type_default.isFunction(this.document.selection.empty)) {
        this.document.selection.empty();
      } else if (window.getSelection) {
        window.getSelection().removeAllRanges();
      }
      if (!this.hasMouseUp) {
        env_default.addEvent(this.document, "mouseup", this.mouseUpListener, this);
        this.hasMouseUp = true;
      } else {
        return;
      }
      this._inputDevice = "mouse";
      this.options.precision.hasPoint = this.options.precision.mouse;
      pos = this.getMousePosition(evt);
      this._testForSelection(evt);
      if (this.selectingMode) {
        this._startSelecting(pos);
        this.triggerEventHandlers(["mousestartselecting", "startselecting"], [evt]);
        return;
      }
      elements2 = this.initMoveObject(pos[0], pos[1], evt, "mouse");
      if (elements2.length === 0) {
        this.mode = this.BOARD_MODE_NONE;
        result = true;
      } else {
        this.mouse = {
          obj: null,
          targets: [
            {
              X: pos[0],
              Y: pos[1],
              Xprev: NaN,
              Yprev: NaN
            }
          ]
        };
        this.mouse.obj = elements2[elements2.length - 1];
        this.dehighlightAll();
        this.mouse.obj.highlight(true);
        this.mouse.targets[0].Xstart = [];
        this.mouse.targets[0].Ystart = [];
        this.mouse.targets[0].Zstart = [];
        this.saveStartPos(this.mouse.obj, this.mouse.targets[0]);
        if (evt && evt.preventDefault) {
          evt.preventDefault();
        } else if (window.event) {
          window.event.returnValue = false;
        }
      }
      if (this.mode === this.BOARD_MODE_NONE) {
        result = this.mouseOriginMoveStart(evt);
      }
      this.triggerEventHandlers(["mousedown", "down"], [evt]);
      return result;
    },
    /**
     * This method is called by the browser when the mouse is moved.
     * @param {Event} evt The browsers event object.
     */
    mouseMoveListener: function(evt) {
      var pos;
      if (!this.checkFrameRate(evt)) {
        return false;
      }
      pos = this.getMousePosition(evt);
      this.updateQuality = this.BOARD_QUALITY_LOW;
      if (this.mode !== this.BOARD_MODE_DRAG) {
        this.dehighlightAll();
        this.displayInfobox(false);
      }
      if (this.selectingMode) {
        this._moveSelecting(pos);
        this.triggerEventHandlers(
          ["mousemoveselecting", "moveselecting"],
          [evt, this.mode]
        );
      } else if (!this.mouseOriginMove(evt)) {
        if (this.mode === this.BOARD_MODE_DRAG) {
          this.moveObject(pos[0], pos[1], this.mouse, evt, "mouse");
        } else {
          this.highlightElements(pos[0], pos[1], evt, -1);
        }
        this.triggerEventHandlers(["mousemove", "move"], [evt, this.mode]);
      }
      this.updateQuality = this.BOARD_QUALITY_HIGH;
    },
    /**
     * This method is called by the browser when the mouse button is released.
     * @param {Event} evt
     */
    mouseUpListener: function(evt) {
      var i2;
      if (this.selectingMode === false) {
        this.triggerEventHandlers(["mouseup", "up"], [evt]);
      }
      this.updateQuality = this.BOARD_QUALITY_HIGH;
      if (this.mouse && this.mouse.obj) {
        if (!type_default.exists(this.mouse.obj.coords)) {
          this.mouse.obj.snapToGrid(this.mouse.targets[0]);
          this.mouse.obj.snapToPoints();
        }
      }
      this.originMoveEnd();
      this.dehighlightAll();
      this.update();
      if (this.selectingMode) {
        this._stopSelecting(evt);
        this.triggerEventHandlers(["mousestopselecting", "stopselecting"], [evt]);
        this.stopSelectionMode();
      } else {
        for (i2 = 0; i2 < this.downObjects.length; i2++) {
          this.downObjects[i2].triggerEventHandlers(["mouseup", "up"], [evt]);
        }
      }
      this.downObjects.length = 0;
      if (this.hasMouseUp) {
        env_default.removeEvent(this.document, "mouseup", this.mouseUpListener, this);
        this.hasMouseUp = false;
      }
      this.mouse = null;
    },
    /**
     * Handler for mouse wheel events. Used to zoom in and out of the board.
     * @param {Event} evt
     * @returns {Boolean}
     */
    mouseWheelListener: function(evt) {
      if (!this.attr.zoom.enabled || !this.attr.zoom.wheel || !this._isRequiredKeyPressed(evt, "zoom")) {
        return true;
      }
      evt = evt || window.event;
      var wd = evt.detail ? -evt.detail : evt.wheelDelta / 40, pos = new coords_default(constants_default.COORDS_BY_SCREEN, this.getMousePosition(evt), this);
      if (wd > 0) {
        this.zoomIn(pos.usrCoords[1], pos.usrCoords[2]);
      } else {
        this.zoomOut(pos.usrCoords[1], pos.usrCoords[2]);
      }
      this.triggerEventHandlers(["mousewheel"], [evt]);
      evt.preventDefault();
      return false;
    },
    /**
     * Allow moving of JSXGraph elements with arrow keys.
     * The selection of the element is done with the tab key. For this,
     * the attribute 'tabindex' of the element has to be set to some number (default=0).
     * tabindex corresponds to the HTML attribute of the same name.
     * <p>
     * Panning of the construction is done with arrow keys
     * if the pan key (shift or ctrl - depending on the board attributes) is pressed.
     * <p>
     * Zooming is triggered with the keys +, o, -, if
     * the pan key (shift or ctrl - depending on the board attributes) is pressed.
     * <p>
     * Keyboard control (move, pan, and zoom) is disabled if an HTML element of type input or textarea has received focus.
     *
     * @param  {Event} evt The browser's event object
     *
     * @see JXG.Board#keyboard
     * @see JXG.Board#keyFocusInListener
     * @see JXG.Board#keyFocusOutListener
     *
     */
    keyDownListener: function(evt) {
      var id_node = evt.target.id, id, el, res, doc, sX = 0, sY = 0, dx = type_default.evaluate(this.attr.keyboard.dx) / this.unitX, dy = type_default.evaluate(this.attr.keyboard.dy) / this.unitY, doZoom = false, done = true, dir, actPos;
      if (!this.attr.keyboard.enabled || id_node === "") {
        return false;
      }
      doc = this.containerObj.shadowRoot || document;
      if (doc.activeElement) {
        el = doc.activeElement;
        if (el.tagName === "INPUT" || el.tagName === "textarea") {
          return false;
        }
      }
      id = id_node.replace(this.containerObj.id + "_", "");
      el = this.select(id);
      if (type_default.exists(el.coords)) {
        actPos = el.coords.usrCoords.slice(1);
      }
      if (type_default.evaluate(this.attr.keyboard.panshift) && evt.shiftKey || type_default.evaluate(this.attr.keyboard.panctrl) && evt.ctrlKey) {
        if (type_default.evaluate(this.attr.zoom.enabled) === true) {
          doZoom = true;
        }
        if (evt.keyCode === 38) {
          this.clickUpArrow();
        } else if (evt.keyCode === 40) {
          this.clickDownArrow();
        } else if (evt.keyCode === 37) {
          this.clickLeftArrow();
        } else if (evt.keyCode === 39) {
          this.clickRightArrow();
        } else if (doZoom && evt.keyCode === 171) {
          this.zoomIn();
        } else if (doZoom && evt.keyCode === 173) {
          this.zoomOut();
        } else if (doZoom && evt.keyCode === 79) {
          this.zoom100();
        } else {
          done = false;
        }
      } else {
        if (type_default.exists(el.visProp)) {
          if (type_default.exists(el.visProp.snaptogrid) && el.visProp.snaptogrid && type_default.evaluate(el.visProp.snapsizex) && type_default.evaluate(el.visProp.snapsizey)) {
            res = el.getSnapSizes();
            sX = res[0];
            sY = res[1];
            dx = sX;
            dy = sY;
          } else if (type_default.exists(el.visProp.attracttogrid) && el.visProp.attracttogrid && type_default.evaluate(el.visProp.attractordistance) && type_default.evaluate(el.visProp.attractorunit)) {
            sX = 1.1 * type_default.evaluate(el.visProp.attractordistance);
            sY = sX;
            if (type_default.evaluate(el.visProp.attractorunit) === "screen") {
              sX /= this.unitX;
              sY /= this.unitX;
            }
            dx = Math.max(sX, dx);
            dy = Math.max(sY, dy);
          }
        }
        if (evt.keyCode === 38) {
          dir = [0, dy];
        } else if (evt.keyCode === 40) {
          dir = [0, -dy];
        } else if (evt.keyCode === 37) {
          dir = [-dx, 0];
        } else if (evt.keyCode === 39) {
          dir = [dx, 0];
        } else {
          done = false;
        }
        if (dir && el.isDraggable && el.visPropCalc.visible && (this.geonextCompatibilityMode && (type_default.isPoint(el) || el.elementClass === constants_default.OBJECT_CLASS_TEXT) || !this.geonextCompatibilityMode) && !type_default.evaluate(el.visProp.fixed)) {
          this.mode = this.BOARD_MODE_DRAG;
          if (type_default.exists(el.coords)) {
            dir[0] += actPos[0];
            dir[1] += actPos[1];
          }
          if (type_default.exists(el.coords)) {
            el.setPosition(jxg_default.COORDS_BY_USER, dir);
            this.updateInfobox(el);
          } else {
            this.displayInfobox(false);
            el.setPositionDirectly(
              constants_default.COORDS_BY_USER,
              dir,
              [0, 0]
            );
          }
          this.triggerEventHandlers(["keymove", "move"], [evt, this.mode]);
          el.triggerEventHandlers(["keydrag", "drag"], [evt]);
          this.mode = this.BOARD_MODE_NONE;
        }
      }
      this.update();
      if (done && type_default.exists(evt.preventDefault)) {
        evt.preventDefault();
      }
      return done;
    },
    /**
     * Event listener for SVG elements getting focus.
     * This is needed for highlighting when using keyboard control.
     * Only elements having the attribute 'tabindex' can receive focus.
     *
     * @see JXG.Board#keyFocusOutListener
     * @see JXG.Board#keyDownListener
     * @see JXG.Board#keyboard
     *
     * @param  {Event} evt The browser's event object
     */
    keyFocusInListener: function(evt) {
      var id_node = evt.target.id, id, el;
      if (!this.attr.keyboard.enabled || id_node === "") {
        return false;
      }
      id = id_node.replace(this.containerObj.id + "_", "");
      el = this.select(id);
      if (type_default.exists(el.highlight)) {
        el.highlight(true);
        this.focusObjects = [id];
        el.triggerEventHandlers(["hit"], [evt]);
      }
      if (type_default.exists(el.coords)) {
        this.updateInfobox(el);
      }
    },
    /**
     * Event listener for SVG elements losing focus.
     * This is needed for dehighlighting when using keyboard control.
     * Only elements having the attribute 'tabindex' can receive focus.
     *
     * @see JXG.Board#keyFocusInListener
     * @see JXG.Board#keyDownListener
     * @see JXG.Board#keyboard
     *
     * @param  {Event} evt The browser's event object
     */
    keyFocusOutListener: function(evt) {
      if (!this.attr.keyboard.enabled) {
        return false;
      }
      this.focusObjects = [];
      this.dehighlightAll();
      this.displayInfobox(false);
    },
    /**
     * Update the width and height of the JSXGraph container div element.
     * Read actual values with getBoundingClientRect(),
     * and call board.resizeContainer() with this values.
     * <p>
     * If necessary, also call setBoundingBox().
     *
     * @see JXG.Board#startResizeObserver
     * @see JXG.Board#resizeListener
     * @see JXG.Board#resizeContainer
     * @see JXG.Board#setBoundingBox
     *
     */
    updateContainerDims: function() {
      var w, h, bb, css, width_adjustment, height_adjustment;
      bb = this.containerObj.getBoundingClientRect();
      w = bb.width;
      h = bb.height;
      if (window && window.getComputedStyle) {
        css = window.getComputedStyle(this.containerObj, null);
        width_adjustment = parseFloat(css.getPropertyValue("border-left-width")) + parseFloat(css.getPropertyValue("border-right-width"));
        if (!isNaN(width_adjustment)) {
          w -= width_adjustment;
        }
        height_adjustment = parseFloat(css.getPropertyValue("border-top-width")) + parseFloat(css.getPropertyValue("border-bottom-width"));
        if (!isNaN(height_adjustment)) {
          h -= height_adjustment;
        }
      }
      if (w <= 0 || h <= 0 || isNaN(w) || isNaN(h)) {
        return;
      }
      if (isNaN(this.getBoundingBox()[0])) {
        this.setBoundingBox(this.attr.boundingbox, this.keepaspectratio, "keep");
      }
      if (type_default.exists(this._prevDim) && this._prevDim.w === w && this._prevDim.h === h) {
        return;
      }
      this.resizeContainer(w, h, true);
      this._prevDim = {
        w,
        h
      };
    },
    /**
     * Start observer which reacts to size changes of the JSXGraph
     * container div element. Calls updateContainerDims().
     * If not available, an event listener for the window-resize event is started.
     * On mobile devices also scrolling might trigger resizes.
     * However, resize events triggered by scrolling events should be ignored.
     * Therefore, also a scrollListener is started.
     * Resize can be controlled with the board attribute resize.
     *
     * @see JXG.Board#updateContainerDims
     * @see JXG.Board#resizeListener
     * @see JXG.Board#scrollListener
     * @see JXG.Board#resize
     *
     */
    startResizeObserver: function() {
      var that2 = this;
      if (!env_default.isBrowser || !this.attr.resize || !this.attr.resize.enabled) {
        return;
      }
      this.resizeObserver = new ResizeObserver(function(entries) {
        if (!that2._isResizing) {
          that2._isResizing = true;
          window.setTimeout(function() {
            try {
              that2.updateContainerDims();
            } catch (err) {
              that2.stopResizeObserver();
            } finally {
              that2._isResizing = false;
            }
          }, that2.attr.resize.throttle);
        }
      });
      this.resizeObserver.observe(this.containerObj);
    },
    /**
     * Stops the resize observer.
     * @see JXG.Board#startResizeObserver
     *
     */
    stopResizeObserver: function() {
      if (!env_default.isBrowser || !this.attr.resize || !this.attr.resize.enabled) {
        return;
      }
      if (type_default.exists(this.resizeObserver)) {
        this.resizeObserver.unobserve(this.containerObj);
      }
    },
    /**
     * Fallback solutions if there is no resizeObserver available in the browser.
     * Reacts to resize events of the window (only). Otherwise similar to
     * startResizeObserver(). To handle changes of the visibility
     * of the JSXGraph container element, additionally an intersection observer is used.
     * which watches changes in the visibility of the JSXGraph container element.
     * This is necessary e.g. for register tabs or dia shows.
     *
     * @see JXG.Board#startResizeObserver
     * @see JXG.Board#startIntersectionObserver
     */
    resizeListener: function() {
      var that2 = this;
      if (!env_default.isBrowser || !this.attr.resize || !this.attr.resize.enabled) {
        return;
      }
      if (!this._isScrolling && !this._isResizing) {
        this._isResizing = true;
        window.setTimeout(function() {
          that2.updateContainerDims();
          that2._isResizing = false;
        }, this.attr.resize.throttle);
      }
    },
    /**
     * Listener to watch for scroll events. Sets board._isScrolling = true
     * @param  {Event} evt The browser's event object
     *
     * @see JXG.Board#startResizeObserver
     * @see JXG.Board#resizeListener
     *
     */
    scrollListener: function(evt) {
      var that2 = this;
      if (!env_default.isBrowser) {
        return;
      }
      if (!this._isScrolling) {
        this._isScrolling = true;
        window.setTimeout(function() {
          that2._isScrolling = false;
        }, 66);
      }
    },
    /**
     * Watch for changes of the visibility of the JSXGraph container element.
     *
     * @see JXG.Board#startResizeObserver
     * @see JXG.Board#resizeListener
     *
     */
    startIntersectionObserver: function() {
      var that2 = this, options = {
        root: null,
        rootMargin: "0px",
        threshold: 0.8
      };
      try {
        this.intersectionObserver = new IntersectionObserver(function(entries) {
          if (isNaN(that2.getBoundingBox()[0])) {
            that2.updateContainerDims();
          }
        }, options);
        this.intersectionObserver.observe(that2.containerObj);
      } catch (err) {
        jxg_default.debug("JSXGraph: IntersectionObserver not available in this browser.");
      }
    },
    /**
     * Stop the intersection observer
     *
     * @see JXG.Board#startIntersectionObserver
     *
     */
    stopIntersectionObserver: function() {
      if (type_default.exists(this.intersectionObserver)) {
        this.intersectionObserver.unobserve(this.containerObj);
      }
    },
    /**********************************************************
     *
     * End of Event Handlers
     *
     **********************************************************/
    /**
     * Initialize the info box object which is used to display
     * the coordinates of points near the mouse pointer,
     * @returns {JXG.Board} Reference to the board
     */
    initInfobox: function(attributes) {
      var attr = type_default.copyAttributes(attributes, this.options, "infobox");
      attr.id = this.id + "_infobox";
      this.infobox = this.create("text", [0, 0, "0,0"], attr);
      this.infobox.dump = false;
      this.displayInfobox(false);
      return this;
    },
    /**
     * Updates and displays a little info box to show coordinates of current selected points.
     * @param {JXG.GeometryElement} el A GeometryElement
     * @returns {JXG.Board} Reference to the board
     * @see JXG.Board#displayInfobox
     * @see JXG.Board#showInfobox
     * @see Point#showInfobox
     *
     */
    updateInfobox: function(el) {
      var x, y, xc, yc, vpinfoboxdigits, distX, distY, vpsi = type_default.evaluate(el.visProp.showinfobox);
      if (!type_default.evaluate(this.attr.showinfobox) && vpsi === "inherit" || !vpsi) {
        return this;
      }
      if (type_default.isPoint(el)) {
        xc = el.coords.usrCoords[1];
        yc = el.coords.usrCoords[2];
        distX = type_default.evaluate(this.infobox.visProp.distancex);
        distY = type_default.evaluate(this.infobox.visProp.distancey);
        this.infobox.setCoords(
          xc + distX / this.unitX,
          yc + distY / this.unitY
        );
        vpinfoboxdigits = type_default.evaluate(el.visProp.infoboxdigits);
        if (typeof el.infoboxText !== "string") {
          if (vpinfoboxdigits === "auto") {
            if (this.infobox.useLocale()) {
              x = this.infobox.formatNumberLocale(xc);
              y = this.infobox.formatNumberLocale(yc);
            } else {
              x = type_default.autoDigits(xc);
              y = type_default.autoDigits(yc);
            }
          } else if (type_default.isNumber(vpinfoboxdigits)) {
            if (this.infobox.useLocale()) {
              x = this.infobox.formatNumberLocale(xc, vpinfoboxdigits);
              y = this.infobox.formatNumberLocale(yc, vpinfoboxdigits);
            } else {
              x = type_default.toFixed(xc, vpinfoboxdigits);
              y = type_default.toFixed(yc, vpinfoboxdigits);
            }
          } else {
            x = xc;
            y = yc;
          }
          this.highlightInfobox(x, y, el);
        } else {
          this.highlightCustomInfobox(el.infoboxText, el);
        }
        this.displayInfobox(true);
      }
      return this;
    },
    /**
     * Set infobox visible / invisible.
     *
     * It uses its property hiddenByParent to memorize its status.
     * In this way, many DOM access can be avoided.
     *
     * @param  {Boolean} val true for visible, false for invisible
     * @returns {JXG.Board} Reference to the board.
     * @see JXG.Board#updateInfobox
     *
     */
    displayInfobox: function(val) {
      if (!val && this.focusObjects.length > 0 && this.select(this.focusObjects[0]).elementClass === constants_default.OBJECT_CLASS_POINT) {
        return this;
      }
      if (this.infobox.hiddenByParent === val) {
        this.infobox.hiddenByParent = !val;
        this.infobox.prepareUpdate().updateVisibility(val).updateRenderer();
      }
      return this;
    },
    // Alias for displayInfobox to be backwards compatible.
    // The method showInfobox clashes with the board attribute showInfobox
    showInfobox: function(val) {
      return this.displayInfobox(val);
    },
    /**
     * Changes the text of the info box to show the given coordinates.
     * @param {Number} x
     * @param {Number} y
     * @param {JXG.GeometryElement} [el] The element the mouse is pointing at
     * @returns {JXG.Board} Reference to the board.
     */
    highlightInfobox: function(x, y, el) {
      this.highlightCustomInfobox("(" + x + ", " + y + ")", el);
      return this;
    },
    /**
     * Changes the text of the info box to what is provided via text.
     * @param {String} text
     * @param {JXG.GeometryElement} [el]
     * @returns {JXG.Board} Reference to the board.
     */
    highlightCustomInfobox: function(text, el) {
      this.infobox.setText(text);
      return this;
    },
    /**
     * Remove highlighting of all elements.
     * @returns {JXG.Board} Reference to the board.
     */
    dehighlightAll: function() {
      var el, pEl, stillHighlighted = {}, needsDeHighlight = false;
      for (el in this.highlightedObjects) {
        if (this.highlightedObjects.hasOwnProperty(el)) {
          pEl = this.highlightedObjects[el];
          if (this.focusObjects.indexOf(el) < 0) {
            if (this.hasMouseHandlers || this.hasPointerHandlers) {
              pEl.noHighlight();
            }
            needsDeHighlight = true;
          } else {
            stillHighlighted[el] = pEl;
          }
        }
      }
      this.highlightedObjects = stillHighlighted;
      if (this.renderer.type === "canvas" && needsDeHighlight) {
        this.prepareUpdate();
        this.renderer.suspendRedraw(this);
        this.updateRenderer();
        this.renderer.unsuspendRedraw();
      }
      return this;
    },
    /**
     * Returns the input parameters in an array. This method looks pointless and it really is, but it had a purpose
     * once.
     * @private
     * @param {Number} x X coordinate in screen coordinates
     * @param {Number} y Y coordinate in screen coordinates
     * @returns {Array} Coordinates [x, y] of the mouse in screen coordinates.
     * @see JXG.Board#getUsrCoordsOfMouse
     */
    getScrCoordsOfMouse: function(x, y) {
      return [x, y];
    },
    /**
     * This method calculates the user coords of the current mouse coordinates.
     * @param {Event} evt Event object containing the mouse coordinates.
     * @returns {Array} Coordinates [x, y] of the mouse in user coordinates.
     * @example
     * board.on('up', function (evt) {
     *         var a = board.getUsrCoordsOfMouse(evt),
     *             x = a[0],
     *             y = a[1],
     *             somePoint = board.create('point', [x,y], {name:'SomePoint',size:4});
     *             // Shorter version:
     *             //somePoint = board.create('point', a, {name:'SomePoint',size:4});
     *         });
     *
     * </pre><div id='JXG48d5066b-16ba-4920-b8ea-a4f8eff6b746' class='jxgbox' style='width: 300px; height: 300px;'></div>
     * <script type='text/javascript'>
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG48d5066b-16ba-4920-b8ea-a4f8eff6b746',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     board.on('up', function (evt) {
     *             var a = board.getUsrCoordsOfMouse(evt),
     *                 x = a[0],
     *                 y = a[1],
     *                 somePoint = board.create('point', [x,y], {name:'SomePoint',size:4});
     *                 // Shorter version:
     *                 //somePoint = board.create('point', a, {name:'SomePoint',size:4});
     *             });
     *
     *     })();
     *
     * <\/script><pre>
     *
     * @see JXG.Board#getScrCoordsOfMouse
     * @see JXG.Board#getAllUnderMouse
     */
    getUsrCoordsOfMouse: function(evt) {
      var cPos = this.getCoordsTopLeftCorner(), absPos = env_default.getPosition(evt, null, this.document), x = absPos[0] - cPos[0], y = absPos[1] - cPos[1], newCoords = new coords_default(constants_default.COORDS_BY_SCREEN, [x, y], this);
      return newCoords.usrCoords.slice(1);
    },
    /**
     * Collects all elements under current mouse position plus current user coordinates of mouse cursor.
     * @param {Event} evt Event object containing the mouse coordinates.
     * @returns {Array} Array of elements at the current mouse position plus current user coordinates of mouse.
     * @see JXG.Board#getUsrCoordsOfMouse
     * @see JXG.Board#getAllObjectsUnderMouse
     */
    getAllUnderMouse: function(evt) {
      var elList = this.getAllObjectsUnderMouse(evt);
      elList.push(this.getUsrCoordsOfMouse(evt));
      return elList;
    },
    /**
     * Collects all elements under current mouse position.
     * @param {Event} evt Event object containing the mouse coordinates.
     * @returns {Array} Array of elements at the current mouse position.
     * @see JXG.Board#getAllUnderMouse
     */
    getAllObjectsUnderMouse: function(evt) {
      var cPos = this.getCoordsTopLeftCorner(), absPos = env_default.getPosition(evt, null, this.document), dx = absPos[0] - cPos[0], dy = absPos[1] - cPos[1], elList = [], el, pEl, len = this.objectsList.length;
      for (el = 0; el < len; el++) {
        pEl = this.objectsList[el];
        if (pEl.visPropCalc.visible && pEl.hasPoint && pEl.hasPoint(dx, dy)) {
          elList[elList.length] = pEl;
        }
      }
      return elList;
    },
    /**
     * Update the coords object of all elements which possess this
     * property. This is necessary after changing the viewport.
     * @returns {JXG.Board} Reference to this board.
     **/
    updateCoords: function() {
      var el, ob, len = this.objectsList.length;
      for (ob = 0; ob < len; ob++) {
        el = this.objectsList[ob];
        if (type_default.exists(el.coords)) {
          if (type_default.evaluate(el.visProp.frozen)) {
            if (el.is3D) {
              el.element2D.coords.screen2usr();
            } else {
              el.coords.screen2usr();
            }
          } else {
            if (el.is3D) {
              el.element2D.coords.usr2screen();
            } else {
              el.coords.usr2screen();
            }
          }
        }
      }
      return this;
    },
    /**
     * Moves the origin and initializes an update of all elements.
     * @param {Number} x
     * @param {Number} y
     * @param {Boolean} [diff=false]
     * @returns {JXG.Board} Reference to this board.
     */
    moveOrigin: function(x, y, diff) {
      var ox, oy, ul, lr;
      if (type_default.exists(x) && type_default.exists(y)) {
        ox = this.origin.scrCoords[1];
        oy = this.origin.scrCoords[2];
        this.origin.scrCoords[1] = x;
        this.origin.scrCoords[2] = y;
        if (diff) {
          this.origin.scrCoords[1] -= this.drag_dx;
          this.origin.scrCoords[2] -= this.drag_dy;
        }
        ul = new coords_default(constants_default.COORDS_BY_SCREEN, [0, 0], this).usrCoords;
        lr = new coords_default(
          constants_default.COORDS_BY_SCREEN,
          [this.canvasWidth, this.canvasHeight],
          this
        ).usrCoords;
        if (ul[1] < this.maxboundingbox[0] || ul[2] > this.maxboundingbox[1] || lr[1] > this.maxboundingbox[2] || lr[2] < this.maxboundingbox[3]) {
          this.origin.scrCoords[1] = ox;
          this.origin.scrCoords[2] = oy;
        }
      }
      this.updateCoords().clearTraces().fullUpdate();
      this.triggerEventHandlers(["boundingbox"]);
      return this;
    },
    /**
     * Add conditional updates to the elements.
     * @param {String} str String containing conditional update in geonext syntax
     */
    addConditions: function(str2) {
      var term, m, left, right, name, el, property, functions = [], i2 = str2.indexOf("<data>"), j = str2.indexOf("</data>"), xyFun = function(board, el2, f, what) {
        return function() {
          var e, t;
          e = board.select(el2.id);
          t = e.coords.usrCoords[what];
          if (what === 2) {
            e.setPositionDirectly(constants_default.COORDS_BY_USER, [f(), t]);
          } else {
            e.setPositionDirectly(constants_default.COORDS_BY_USER, [t, f()]);
          }
          e.prepareUpdate().update();
        };
      }, visFun = function(board, el2, f) {
        return function() {
          var e, v;
          e = board.select(el2.id);
          v = f();
          e.setAttribute({ visible: v });
        };
      }, colFun = function(board, el2, f, what) {
        return function() {
          var e, v;
          e = board.select(el2.id);
          v = f();
          if (what === "strokewidth") {
            e.visProp.strokewidth = v;
          } else {
            v = color_default.rgba2rgbo(v);
            e.visProp[what + "color"] = v[0];
            e.visProp[what + "opacity"] = v[1];
          }
        };
      }, posFun = function(board, el2, f) {
        return function() {
          var e = board.select(el2.id);
          e.position = f();
        };
      }, styleFun = function(board, el2, f) {
        return function() {
          var e = board.select(el2.id);
          e.setStyle(f());
        };
      };
      if (i2 < 0) {
        return;
      }
      while (i2 >= 0) {
        term = str2.slice(i2 + 6, j);
        m = term.indexOf("=");
        left = term.slice(0, m);
        right = term.slice(m + 1);
        m = left.indexOf(".");
        name = left.slice(0, m);
        el = this.elementsByName[type_default.unescapeHTML(name)];
        property = left.slice(m + 1).replace(/\s+/g, "").toLowerCase();
        right = type_default.createFunction(right, this, "", true);
        if (!type_default.exists(this.elementsByName[name])) {
          jxg_default.debug("debug conditions: |" + name + "| undefined");
        } else {
          switch (property) {
            case "x":
              functions.push(xyFun(this, el, right, 2));
              break;
            case "y":
              functions.push(xyFun(this, el, right, 1));
              break;
            case "visible":
              functions.push(visFun(this, el, right));
              break;
            case "position":
              functions.push(posFun(this, el, right));
              break;
            case "stroke":
              functions.push(colFun(this, el, right, "stroke"));
              break;
            case "style":
              functions.push(styleFun(this, el, right));
              break;
            case "strokewidth":
              functions.push(colFun(this, el, right, "strokewidth"));
              break;
            case "fill":
              functions.push(colFun(this, el, right, "fill"));
              break;
            case "label":
              break;
            default:
              jxg_default.debug(
                'property "' + property + '" in conditions not yet implemented:' + right
              );
              break;
          }
        }
        str2 = str2.slice(j + 7);
        i2 = str2.indexOf("<data>");
        j = str2.indexOf("</data>");
      }
      this.updateConditions = function() {
        var i3;
        for (i3 = 0; i3 < functions.length; i3++) {
          functions[i3]();
        }
        this.prepareUpdate().updateElements();
        return true;
      };
      this.updateConditions();
    },
    /**
     * Computes the commands in the conditions-section of the gxt file.
     * It is evaluated after an update, before the unsuspendRedraw.
     * The function is generated in
     * @see JXG.Board#addConditions
     * @private
     */
    updateConditions: function() {
      return false;
    },
    /**
     * Calculates adequate snap sizes.
     * @returns {JXG.Board} Reference to the board.
     */
    calculateSnapSizes: function() {
      var p1, p2, bbox = this.getBoundingBox(), gridStep = type_default.evaluate(this.options.grid.majorStep), gridX = type_default.evaluate(this.options.grid.gridX), gridY = type_default.evaluate(this.options.grid.gridY), x, y;
      if (!type_default.isArray(gridStep)) {
        gridStep = [gridStep, gridStep];
      }
      if (gridStep.length < 2) {
        gridStep = [gridStep[0], gridStep[0]];
      }
      if (type_default.exists(gridX)) {
        gridStep[0] = gridX;
      }
      if (type_default.exists(gridY)) {
        gridStep[1] = gridY;
      }
      if (gridStep[0] === "auto") {
        gridStep[0] = 1;
      } else {
        gridStep[0] = type_default.parseNumber(gridStep[0], Math.abs(bbox[1] - bbox[3]), 1 / this.unitX);
      }
      if (gridStep[1] === "auto") {
        gridStep[1] = 1;
      } else {
        gridStep[1] = type_default.parseNumber(gridStep[1], Math.abs(bbox[0] - bbox[2]), 1 / this.unitY);
      }
      p1 = new coords_default(constants_default.COORDS_BY_USER, [0, 0], this);
      p2 = new coords_default(
        constants_default.COORDS_BY_USER,
        [gridStep[0], gridStep[1]],
        this
      );
      x = p1.scrCoords[1] - p2.scrCoords[1];
      y = p1.scrCoords[2] - p2.scrCoords[2];
      this.options.grid.snapSizeX = gridStep[0];
      while (Math.abs(x) > 25) {
        this.options.grid.snapSizeX *= 2;
        x /= 2;
      }
      this.options.grid.snapSizeY = gridStep[1];
      while (Math.abs(y) > 25) {
        this.options.grid.snapSizeY *= 2;
        y /= 2;
      }
      return this;
    },
    /**
     * Apply update on all objects with the new zoom-factors. Clears all traces.
     * @returns {JXG.Board} Reference to the board.
     */
    applyZoom: function() {
      this.updateCoords().calculateSnapSizes().clearTraces().fullUpdate();
      return this;
    },
    /**
     * Zooms into the board by the factors board.attr.zoom.factorX and board.attr.zoom.factorY and applies the zoom.
     * The zoom operation is centered at x, y.
     * @param {Number} [x]
     * @param {Number} [y]
     * @returns {JXG.Board} Reference to the board
     */
    zoomIn: function(x, y) {
      var bb = this.getBoundingBox(), zX = this.attr.zoom.factorx, zY = this.attr.zoom.factory, dX = (bb[2] - bb[0]) * (1 - 1 / zX), dY = (bb[1] - bb[3]) * (1 - 1 / zY), lr = 0.5, tr = 0.5, mi = this.attr.zoom.eps || this.attr.zoom.min || 1e-3;
      if (this.zoomX > this.attr.zoom.max && zX > 1 || this.zoomY > this.attr.zoom.max && zY > 1 || this.zoomX < mi && zX < 1 || // zoomIn is used for all zooms on touch devices
      this.zoomY < mi && zY < 1) {
        return this;
      }
      if (type_default.isNumber(x) && type_default.isNumber(y)) {
        lr = (x - bb[0]) / (bb[2] - bb[0]);
        tr = (bb[1] - y) / (bb[1] - bb[3]);
      }
      this.setBoundingBox(
        [
          bb[0] + dX * lr,
          bb[1] - dY * tr,
          bb[2] - dX * (1 - lr),
          bb[3] + dY * (1 - tr)
        ],
        this.keepaspectratio,
        "update"
      );
      return this.applyZoom();
    },
    /**
     * Zooms out of the board by the factors board.attr.zoom.factorX and board.attr.zoom.factorY and applies the zoom.
     * The zoom operation is centered at x, y.
     *
     * @param {Number} [x]
     * @param {Number} [y]
     * @returns {JXG.Board} Reference to the board
     */
    zoomOut: function(x, y) {
      var bb = this.getBoundingBox(), zX = this.attr.zoom.factorx, zY = this.attr.zoom.factory, dX = (bb[2] - bb[0]) * (1 - zX), dY = (bb[1] - bb[3]) * (1 - zY), lr = 0.5, tr = 0.5, mi = this.attr.zoom.eps || this.attr.zoom.min || 1e-3;
      if (this.zoomX < mi || this.zoomY < mi) {
        return this;
      }
      if (type_default.isNumber(x) && type_default.isNumber(y)) {
        lr = (x - bb[0]) / (bb[2] - bb[0]);
        tr = (bb[1] - y) / (bb[1] - bb[3]);
      }
      this.setBoundingBox(
        [
          bb[0] + dX * lr,
          bb[1] - dY * tr,
          bb[2] - dX * (1 - lr),
          bb[3] + dY * (1 - tr)
        ],
        this.keepaspectratio,
        "update"
      );
      return this.applyZoom();
    },
    /**
     * Reset the zoom level to the original zoom level from initBoard();
     * Additionally, if the board as been initialized with a boundingBox (which is the default),
     * restore the viewport to the original viewport during initialization. Otherwise,
     * (i.e. if the board as been initialized with unitX/Y and originX/Y),
     * just set the zoom level to 100%.
     *
     * @returns {JXG.Board} Reference to the board
     */
    zoom100: function() {
      var bb, dX, dY;
      if (type_default.exists(this.attr.boundingbox)) {
        this.setBoundingBox(this.attr.boundingbox, this.keepaspectratio, "reset");
      } else {
        bb = this.getBoundingBox();
        dX = (bb[2] - bb[0]) * (1 - this.zoomX) * 0.5;
        dY = (bb[1] - bb[3]) * (1 - this.zoomY) * 0.5;
        this.setBoundingBox(
          [bb[0] + dX, bb[1] - dY, bb[2] - dX, bb[3] + dY],
          this.keepaspectratio,
          "reset"
        );
      }
      return this.applyZoom();
    },
    /**
     * Zooms the board so every visible point is shown. Keeps aspect ratio.
     * @returns {JXG.Board} Reference to the board
     */
    zoomAllPoints: function() {
      var el, border2, borderX, borderY, pEl, minX = 0, maxX = 0, minY = 0, maxY = 0, len = this.objectsList.length;
      for (el = 0; el < len; el++) {
        pEl = this.objectsList[el];
        if (type_default.isPoint(pEl) && pEl.visPropCalc.visible) {
          if (pEl.coords.usrCoords[1] < minX) {
            minX = pEl.coords.usrCoords[1];
          } else if (pEl.coords.usrCoords[1] > maxX) {
            maxX = pEl.coords.usrCoords[1];
          }
          if (pEl.coords.usrCoords[2] > maxY) {
            maxY = pEl.coords.usrCoords[2];
          } else if (pEl.coords.usrCoords[2] < minY) {
            minY = pEl.coords.usrCoords[2];
          }
        }
      }
      border2 = 50;
      borderX = border2 / this.unitX;
      borderY = border2 / this.unitY;
      this.setBoundingBox(
        [minX - borderX, maxY + borderY, maxX + borderX, minY - borderY],
        this.keepaspectratio,
        "update"
      );
      return this.applyZoom();
    },
    /**
     * Reset the bounding box and the zoom level to 100% such that a given set of elements is
     * within the board's viewport.
     * @param {Array} elements A set of elements given by id, reference, or name.
     * @returns {JXG.Board} Reference to the board.
     */
    zoomElements: function(elements2) {
      var i2, e, box, newBBox = [Infinity, -Infinity, -Infinity, Infinity], cx, cy, dx, dy, d;
      if (!type_default.isArray(elements2) || elements2.length === 0) {
        return this;
      }
      for (i2 = 0; i2 < elements2.length; i2++) {
        e = this.select(elements2[i2]);
        box = e.bounds();
        if (type_default.isArray(box)) {
          if (box[0] < newBBox[0]) {
            newBBox[0] = box[0];
          }
          if (box[1] > newBBox[1]) {
            newBBox[1] = box[1];
          }
          if (box[2] > newBBox[2]) {
            newBBox[2] = box[2];
          }
          if (box[3] < newBBox[3]) {
            newBBox[3] = box[3];
          }
        }
      }
      if (type_default.isArray(newBBox)) {
        cx = 0.5 * (newBBox[0] + newBBox[2]);
        cy = 0.5 * (newBBox[1] + newBBox[3]);
        dx = 1.5 * (newBBox[2] - newBBox[0]) * 0.5;
        dy = 1.5 * (newBBox[1] - newBBox[3]) * 0.5;
        d = Math.max(dx, dy);
        this.setBoundingBox(
          [cx - d, cy + d, cx + d, cy - d],
          this.keepaspectratio,
          "update"
        );
      }
      return this;
    },
    /**
     * Sets the zoom level to <tt>fX</tt> resp <tt>fY</tt>.
     * @param {Number} fX
     * @param {Number} fY
     * @returns {JXG.Board} Reference to the board.
     */
    setZoom: function(fX, fY) {
      var oX = this.attr.zoom.factorx, oY = this.attr.zoom.factory;
      this.attr.zoom.factorx = fX / this.zoomX;
      this.attr.zoom.factory = fY / this.zoomY;
      this.zoomIn();
      this.attr.zoom.factorx = oX;
      this.attr.zoom.factory = oY;
      return this;
    },
    /**
     * Inner, recursive method of removeObject.
     *
     * @param {JXG.GeometryElement|Array} object The object to remove or array of objects to be removed.
     * The element(s) is/are given by name, id or a reference.
     * @param {Boolean} [saveMethod=false] If saveMethod=true, the algorithm runs through all elements
     * and tests if the element to be deleted is a child element. If this is the case, it will be
     * removed from the list of child elements. If saveMethod=false (default), the element
     * is removed from the lists of child elements of all its ancestors.
     * The latter should be much faster.
     * @returns {JXG.Board} Reference to the board
     * @private
     */
    _removeObj: function(object, saveMethod) {
      var el, i2;
      if (type_default.isArray(object)) {
        for (i2 = 0; i2 < object.length; i2++) {
          this._removeObj(object[i2], saveMethod);
        }
        return this;
      }
      object = this.select(object);
      if (!type_default.exists(object) || type_default.isString(object)) {
        return this;
      }
      try {
        for (el in object.childElements) {
          if (object.childElements.hasOwnProperty(el)) {
            object.childElements[el].board._removeObj(object.childElements[el]);
          }
        }
        for (el in object.objects) {
          if (object.objects.hasOwnProperty(el)) {
            object.objects[el].board._removeObj(object.objects[el]);
          }
        }
        if (saveMethod) {
          for (el in this.objects) {
            if (this.objects.hasOwnProperty(el)) {
              if (type_default.exists(this.objects[el].childElements) && type_default.exists(
                this.objects[el].childElements.hasOwnProperty(object.id)
              )) {
                delete this.objects[el].childElements[object.id];
                delete this.objects[el].descendants[object.id];
              }
            }
          }
        } else if (type_default.exists(object.ancestors)) {
          for (el in object.ancestors) {
            if (object.ancestors.hasOwnProperty(el)) {
              if (type_default.exists(object.ancestors[el].childElements) && type_default.exists(
                object.ancestors[el].childElements.hasOwnProperty(object.id)
              )) {
                delete object.ancestors[el].childElements[object.id];
                delete object.ancestors[el].descendants[object.id];
              }
            }
          }
        }
        if (object._pos > -1) {
          this.objectsList.splice(object._pos, 1);
          for (i2 = object._pos; i2 < this.objectsList.length; i2++) {
            this.objectsList[i2]._pos--;
          }
        } else if (object.type !== constants_default.OBJECT_TYPE_TURTLE) {
          jxg_default.debug(
            "Board.removeObject: object " + object.id + " not found in list."
          );
        }
        delete this.objects[object.id];
        delete this.elementsByName[object.name];
        if (object.visProp && type_default.evaluate(object.visProp.trace)) {
          object.clearTrace();
        }
        if (type_default.exists(object.remove)) {
          object.remove();
        }
      } catch (e) {
        jxg_default.debug(object.id + ": Could not be removed: " + e);
      }
      return this;
    },
    /**
     * Removes object from board and renderer.
     * <p>
     * <b>Performance hints:</b> It is recommended to use the object's id.
     * If many elements are removed, it is best to call <tt>board.suspendUpdate()</tt>
     * before looping through the elements to be removed and call
     * <tt>board.unsuspendUpdate()</tt> after the loop. Further, it is advisable to loop
     * in reverse order, i.e. remove the object in reverse order of their creation time.
     * @param {JXG.GeometryElement|Array} object The object to remove or array of objects to be removed.
     * The element(s) is/are given by name, id or a reference.
     * @param {Boolean} saveMethod If true, the algorithm runs through all elements
     * and tests if the element to be deleted is a child element. If yes, it will be
     * removed from the list of child elements. If false (default), the element
     * is removed from the lists of child elements of all its ancestors.
     * This should be much faster.
     * @returns {JXG.Board} Reference to the board
     */
    removeObject: function(object, saveMethod) {
      var i2;
      this.renderer.suspendRedraw(this);
      if (type_default.isArray(object)) {
        for (i2 = 0; i2 < object.length; i2++) {
          this._removeObj(object[i2], saveMethod);
        }
      } else {
        this._removeObj(object, saveMethod);
      }
      this.renderer.unsuspendRedraw();
      this.update();
      return this;
    },
    /**
     * Removes the ancestors of an object an the object itself from board and renderer.
     * @param {JXG.GeometryElement} object The object to remove.
     * @returns {JXG.Board} Reference to the board
     */
    removeAncestors: function(object) {
      var anc;
      for (anc in object.ancestors) {
        if (object.ancestors.hasOwnProperty(anc)) {
          this.removeAncestors(object.ancestors[anc]);
        }
      }
      this.removeObject(object);
      return this;
    },
    /**
     * Initialize some objects which are contained in every GEONExT construction by default,
     * but are not contained in the gxt files.
     * @returns {JXG.Board} Reference to the board
     */
    initGeonextBoard: function() {
      var p1, p2, p3;
      p1 = this.create("point", [0, 0], {
        id: this.id + "g00e0",
        name: "Ursprung",
        withLabel: false,
        visible: false,
        fixed: true
      });
      p2 = this.create("point", [1, 0], {
        id: this.id + "gX0e0",
        name: "Punkt_1_0",
        withLabel: false,
        visible: false,
        fixed: true
      });
      p3 = this.create("point", [0, 1], {
        id: this.id + "gY0e0",
        name: "Punkt_0_1",
        withLabel: false,
        visible: false,
        fixed: true
      });
      this.create("line", [p1, p2], {
        id: this.id + "gXLe0",
        name: "X-Achse",
        withLabel: false,
        visible: false
      });
      this.create("line", [p1, p3], {
        id: this.id + "gYLe0",
        name: "Y-Achse",
        withLabel: false,
        visible: false
      });
      return this;
    },
    /**
     * Change the height and width of the board's container.
     * After doing so, {@link JXG.JSXGraph.setBoundingBox} is called using
     * the actual size of the bounding box and the actual value of keepaspectratio.
     * If setBoundingbox() should not be called automatically,
     * call resizeContainer with dontSetBoundingBox == true.
     * @param {Number} canvasWidth New width of the container.
     * @param {Number} canvasHeight New height of the container.
     * @param {Boolean} [dontset=false] If true do not set the CSS width and height of the DOM element.
     * @param {Boolean} [dontSetBoundingBox=false] If true do not call setBoundingBox(), but keep view centered around original visible center.
     * @returns {JXG.Board} Reference to the board
     */
    resizeContainer: function(canvasWidth, canvasHeight, dontset, dontSetBoundingBox) {
      var box, oldWidth, oldHeight, oX, oY;
      oldWidth = this.canvasWidth;
      oldHeight = this.canvasHeight;
      if (!dontSetBoundingBox) {
        box = this.getBoundingBox();
      }
      this.canvasWidth = Math.max(parseFloat(canvasWidth), math_default.eps);
      this.canvasHeight = Math.max(parseFloat(canvasHeight), math_default.eps);
      if (!dontset) {
        this.containerObj.style.width = this.canvasWidth + "px";
        this.containerObj.style.height = this.canvasHeight + "px";
      }
      this.renderer.resize(this.canvasWidth, this.canvasHeight);
      if (!dontSetBoundingBox) {
        this.setBoundingBox(box, this.keepaspectratio, "keep");
      } else {
        oX = (this.canvasWidth - oldWidth) / 2;
        oY = (this.canvasHeight - oldHeight) / 2;
        this.moveOrigin(
          this.origin.scrCoords[1] + oX,
          this.origin.scrCoords[2] + oY
        );
      }
      return this;
    },
    /**
     * Lists the dependencies graph in a new HTML-window.
     * @returns {JXG.Board} Reference to the board
     */
    showDependencies: function() {
      var el, t, c, f, i2;
      t = "<p>\n";
      for (el in this.objects) {
        if (this.objects.hasOwnProperty(el)) {
          i2 = 0;
          for (c in this.objects[el].childElements) {
            if (this.objects[el].childElements.hasOwnProperty(c)) {
              i2 += 1;
            }
          }
          if (i2 >= 0) {
            t += "<strong>" + this.objects[el].id + ":</strong> ";
          }
          for (c in this.objects[el].childElements) {
            if (this.objects[el].childElements.hasOwnProperty(c)) {
              t += this.objects[el].childElements[c].id + "(" + this.objects[el].childElements[c].name + "), ";
            }
          }
          t += "<p>\n";
        }
      }
      t += "</p>\n";
      f = window.open();
      f.document.open();
      f.document.write(t);
      f.document.close();
      return this;
    },
    /**
     * Lists the XML code of the construction in a new HTML-window.
     * @returns {JXG.Board} Reference to the board
     */
    showXML: function() {
      var f = window.open("");
      f.document.open();
      f.document.write("<pre>" + type_default.escapeHTML(this.xmlString) + "</pre>");
      f.document.close();
      return this;
    },
    /**
     * Sets for all objects the needsUpdate flag to 'true'.
     * @returns {JXG.Board} Reference to the board
     */
    prepareUpdate: function() {
      var el, pEl, len = this.objectsList.length;
      for (el = 0; el < len; el++) {
        pEl = this.objectsList[el];
        pEl.needsUpdate = pEl.needsRegularUpdate || this.needsFullUpdate;
      }
      for (el in this.groups) {
        if (this.groups.hasOwnProperty(el)) {
          pEl = this.groups[el];
          pEl.needsUpdate = pEl.needsRegularUpdate || this.needsFullUpdate;
        }
      }
      return this;
    },
    /**
     * Runs through all elements and calls their update() method.
     * @param {JXG.GeometryElement} drag Element that caused the update.
     * @returns {JXG.Board} Reference to the board
     */
    updateElements: function(drag) {
      var el, pEl;
      drag = this.select(drag);
      for (el = 0; el < this.objectsList.length; el++) {
        pEl = this.objectsList[el];
        if (this.needsFullUpdate && pEl.elementClass === constants_default.OBJECT_CLASS_TEXT) {
          pEl.updateSize();
        }
        pEl.update(!type_default.exists(drag) || pEl.id !== drag.id).updateVisibility();
      }
      for (el in this.groups) {
        if (this.groups.hasOwnProperty(el)) {
          this.groups[el].update(drag);
        }
      }
      return this;
    },
    /**
     * Runs through all elements and calls their update() method.
     * @returns {JXG.Board} Reference to the board
     */
    updateRenderer: function() {
      var el, len = this.objectsList.length;
      if (!this.renderer) {
        return;
      }
      if (this.renderer.type === "canvas") {
        this.updateRendererCanvas();
      } else {
        for (el = 0; el < len; el++) {
          this.objectsList[el].updateRenderer();
        }
      }
      return this;
    },
    /**
     * Runs through all elements and calls their update() method.
     * This is a special version for the CanvasRenderer.
     * Here, we have to do our own layer handling.
     * @returns {JXG.Board} Reference to the board
     */
    updateRendererCanvas: function() {
      var el, pEl, i2, mini, la, olen = this.objectsList.length, layers = this.options.layer, len = this.options.layer.numlayers, last = Number.NEGATIVE_INFINITY;
      for (i2 = 0; i2 < len; i2++) {
        mini = Number.POSITIVE_INFINITY;
        for (la in layers) {
          if (layers.hasOwnProperty(la)) {
            if (layers[la] > last && layers[la] < mini) {
              mini = layers[la];
            }
          }
        }
        last = mini;
        for (el = 0; el < olen; el++) {
          pEl = this.objectsList[el];
          if (pEl.visProp.layer === mini) {
            pEl.prepareUpdate().updateRenderer();
          }
        }
      }
      return this;
    },
    /**
     * Please use {@link JXG.Board.on} instead.
     * @param {Function} hook A function to be called by the board after an update occurred.
     * @param {String} [m='update'] When the hook is to be called. Possible values are <i>mouseup</i>, <i>mousedown</i> and <i>update</i>.
     * @param {Object} [context=board] Determines the execution context the hook is called. This parameter is optional, default is the
     * board object the hook is attached to.
     * @returns {Number} Id of the hook, required to remove the hook from the board.
     * @deprecated
     */
    addHook: function(hook, m, context) {
      jxg_default.deprecated("Board.addHook()", "Board.on()");
      m = type_default.def(m, "update");
      context = type_default.def(context, this);
      this.hooks.push([m, hook]);
      this.on(m, hook, context);
      return this.hooks.length - 1;
    },
    /**
     * Alias of {@link JXG.Board.on}.
     */
    addEvent: jxg_default.shortcut(jxg_default.Board.prototype, "on"),
    /**
     * Please use {@link JXG.Board.off} instead.
     * @param {Number|function} id The number you got when you added the hook or a reference to the event handler.
     * @returns {JXG.Board} Reference to the board
     * @deprecated
     */
    removeHook: function(id) {
      jxg_default.deprecated("Board.removeHook()", "Board.off()");
      if (this.hooks[id]) {
        this.off(this.hooks[id][0], this.hooks[id][1]);
        this.hooks[id] = null;
      }
      return this;
    },
    /**
     * Alias of {@link JXG.Board.off}.
     */
    removeEvent: jxg_default.shortcut(jxg_default.Board.prototype, "off"),
    /**
     * Runs through all hooked functions and calls them.
     * @returns {JXG.Board} Reference to the board
     * @deprecated
     */
    updateHooks: function(m) {
      var arg = Array.prototype.slice.call(arguments, 0);
      jxg_default.deprecated("Board.updateHooks()", "Board.triggerEventHandlers()");
      arg[0] = type_default.def(arg[0], "update");
      this.triggerEventHandlers([arg[0]], arguments);
      return this;
    },
    /**
     * Adds a dependent board to this board.
     * @param {JXG.Board} board A reference to board which will be updated after an update of this board occurred.
     * @returns {JXG.Board} Reference to the board
     */
    addChild: function(board) {
      if (type_default.exists(board) && type_default.exists(board.containerObj)) {
        this.dependentBoards.push(board);
        this.update();
      }
      return this;
    },
    /**
     * Deletes a board from the list of dependent boards.
     * @param {JXG.Board} board Reference to the board which will be removed.
     * @returns {JXG.Board} Reference to the board
     */
    removeChild: function(board) {
      var i2;
      for (i2 = this.dependentBoards.length - 1; i2 >= 0; i2--) {
        if (this.dependentBoards[i2] === board) {
          this.dependentBoards.splice(i2, 1);
        }
      }
      return this;
    },
    /**
     * Runs through most elements and calls their update() method and update the conditions.
     * @param {JXG.GeometryElement} [drag] Element that caused the update.
     * @returns {JXG.Board} Reference to the board
     */
    update: function(drag) {
      var i2, len, b, insert, storeActiveEl;
      if (this.inUpdate || this.isSuspendedUpdate) {
        return this;
      }
      this.inUpdate = true;
      if (this.attr.minimizereflow === "all" && this.containerObj && this.renderer.type !== "vml") {
        storeActiveEl = this.document.activeElement;
        insert = this.renderer.removeToInsertLater(this.containerObj);
      }
      if (this.attr.minimizereflow === "svg" && this.renderer.type === "svg") {
        storeActiveEl = this.document.activeElement;
        insert = this.renderer.removeToInsertLater(this.renderer.svgRoot);
      }
      this.prepareUpdate().updateElements(drag).updateConditions();
      this.renderer.suspendRedraw(this);
      this.updateRenderer();
      this.renderer.unsuspendRedraw();
      this.triggerEventHandlers(["update"], []);
      if (insert) {
        insert();
        storeActiveEl.focus();
      }
      len = this.dependentBoards.length;
      for (i2 = 0; i2 < len; i2++) {
        b = this.dependentBoards[i2];
        if (type_default.exists(b) && b !== this) {
          b.updateQuality = this.updateQuality;
          b.prepareUpdate().updateElements().updateConditions();
          b.renderer.suspendRedraw(this);
          b.updateRenderer();
          b.renderer.unsuspendRedraw();
          b.triggerEventHandlers(["update"], []);
        }
      }
      this.inUpdate = false;
      return this;
    },
    /**
     * Runs through all elements and calls their update() method and update the conditions.
     * This is necessary after zooming and changing the bounding box.
     * @returns {JXG.Board} Reference to the board
     */
    fullUpdate: function() {
      this.needsFullUpdate = true;
      this.update();
      this.needsFullUpdate = false;
      return this;
    },
    /**
     * Adds a grid to the board according to the settings given in board.options.
     * @returns {JXG.Board} Reference to the board.
     */
    addGrid: function() {
      this.create("grid", []);
      return this;
    },
    /**
     * Removes all grids assigned to this board. Warning: This method also removes all objects depending on one or
     * more of the grids.
     * @returns {JXG.Board} Reference to the board object.
     */
    removeGrids: function() {
      var i2;
      for (i2 = 0; i2 < this.grids.length; i2++) {
        this.removeObject(this.grids[i2]);
      }
      this.grids.length = 0;
      this.update();
      return this;
    },
    /**
     * Creates a new geometric element of type elementType.
     * @param {String} elementType Type of the element to be constructed given as a string e.g. 'point' or 'circle'.
     * @param {Array} parents Array of parent elements needed to construct the element e.g. coordinates for a point or two
     * points to construct a line. This highly depends on the elementType that is constructed. See the corresponding JXG.create*
     * methods for a list of possible parameters.
     * @param {Object} [attributes] An object containing the attributes to be set. This also depends on the elementType.
     * Common attributes are name, visible, strokeColor.
     * @returns {Object} Reference to the created element. This is usually a GeometryElement, but can be an array containing
     * two or more elements.
     */
    create: function(elementType, parents, attributes) {
      var el, i2;
      elementType = elementType.toLowerCase();
      if (!type_default.exists(parents)) {
        parents = [];
      }
      if (!type_default.exists(attributes)) {
        attributes = {};
      }
      for (i2 = 0; i2 < parents.length; i2++) {
        if (type_default.isString(parents[i2]) && !(elementType === "text" && i2 === 2) && !(elementType === "solidofrevolution3d" && i2 === 2) && !((elementType === "input" || elementType === "checkbox" || elementType === "button") && (i2 === 2 || i2 === 3)) && !(elementType === "curve") && // Allow curve plots with jessiecode, parents[0] is the
        // variable name
        !(elementType === "functiongraph") && // Prevent problems with function terms like 'x', 'y'
        !(elementType === "implicitcurve")) {
          parents[i2] = this.select(parents[i2]);
        }
      }
      if (type_default.isFunction(jxg_default.elements[elementType])) {
        el = jxg_default.elements[elementType](this, parents, attributes);
      } else {
        throw new Error("JSXGraph: create: Unknown element type given: " + elementType);
      }
      if (!type_default.exists(el)) {
        jxg_default.debug("JSXGraph: create: failure creating " + elementType);
        return el;
      }
      if (el.prepareUpdate && el.update && el.updateRenderer) {
        el.fullUpdate();
      }
      return el;
    },
    /**
     * Deprecated name for {@link JXG.Board.create}.
     * @deprecated
     */
    createElement: function() {
      jxg_default.deprecated("Board.createElement()", "Board.create()");
      return this.create.apply(this, arguments);
    },
    /**
     * Delete the elements drawn as part of a trace of an element.
     * @returns {JXG.Board} Reference to the board
     */
    clearTraces: function() {
      var el;
      for (el = 0; el < this.objectsList.length; el++) {
        this.objectsList[el].clearTrace();
      }
      this.numTraces = 0;
      return this;
    },
    /**
     * Stop updates of the board.
     * @returns {JXG.Board} Reference to the board
     */
    suspendUpdate: function() {
      if (!this.inUpdate) {
        this.isSuspendedUpdate = true;
      }
      return this;
    },
    /**
     * Enable updates of the board.
     * @returns {JXG.Board} Reference to the board
     */
    unsuspendUpdate: function() {
      if (this.isSuspendedUpdate) {
        this.isSuspendedUpdate = false;
        this.fullUpdate();
      }
      return this;
    },
    /**
     * Set the bounding box of the board.
     * @param {Array} bbox New bounding box [x1,y1,x2,y2]
     * @param {Boolean} [keepaspectratio=false] If set to true, the aspect ratio will be 1:1, but
     * the resulting viewport may be larger.
     * @param {String} [setZoom='reset'] Reset, keep or update the zoom level of the board. 'reset'
     * sets {@link JXG.Board#zoomX} and {@link JXG.Board#zoomY} to the start values (or 1.0).
     * 'update' adapts these values accoring to the new bounding box and 'keep' does nothing.
     * @returns {JXG.Board} Reference to the board
     */
    setBoundingBox: function(bbox, keepaspectratio, setZoom) {
      var h, w, ux, uy, offX = 0, offY = 0, zoom_ratio = 1, ratio, dx, dy, prev_w, prev_h, dim = env_default.getDimensions(this.container, this.document);
      if (!type_default.isArray(bbox)) {
        return this;
      }
      if (bbox[0] < this.maxboundingbox[0] || bbox[1] > this.maxboundingbox[1] || bbox[2] > this.maxboundingbox[2] || bbox[3] < this.maxboundingbox[3]) {
        return this;
      }
      if (!type_default.exists(setZoom)) {
        setZoom = "reset";
      }
      ux = this.unitX;
      uy = this.unitY;
      this.canvasWidth = parseFloat(dim.width);
      this.canvasHeight = parseFloat(dim.height);
      w = this.canvasWidth;
      h = this.canvasHeight;
      if (keepaspectratio) {
        ratio = ux / uy;
        if (setZoom === "keep") {
          zoom_ratio = this.zoomX / this.zoomY;
        }
        dx = bbox[2] - bbox[0];
        dy = bbox[1] - bbox[3];
        prev_w = ux * dx;
        prev_h = uy * dy;
        if (w >= h) {
          if (prev_w >= prev_h) {
            this.unitY = h / dy;
            this.unitX = this.unitY * ratio;
          } else {
            this.unitY = h / Math.abs(dx) * math_default.sign(dy) / zoom_ratio;
            this.unitX = this.unitY * ratio;
          }
        } else {
          if (prev_h > prev_w) {
            this.unitX = w / dx;
            this.unitY = this.unitX / ratio;
          } else {
            this.unitX = w / Math.abs(dy) * math_default.sign(dx) * zoom_ratio;
            this.unitY = this.unitX / ratio;
          }
        }
        offX = (w / this.unitX - dx) * 0.5;
        offY = (h / this.unitY - dy) * 0.5;
        this.keepaspectratio = true;
      } else {
        this.unitX = w / (bbox[2] - bbox[0]);
        this.unitY = h / (bbox[1] - bbox[3]);
        this.keepaspectratio = false;
      }
      this.moveOrigin(-this.unitX * (bbox[0] - offX), this.unitY * (bbox[1] + offY));
      if (setZoom === "update") {
        this.zoomX *= this.unitX / ux;
        this.zoomY *= this.unitY / uy;
      } else if (setZoom === "reset") {
        this.zoomX = type_default.exists(this.attr.zoomx) ? this.attr.zoomx : 1;
        this.zoomY = type_default.exists(this.attr.zoomy) ? this.attr.zoomy : 1;
      }
      return this;
    },
    /**
     * Get the bounding box of the board.
     * @returns {Array} bounding box [x1,y1,x2,y2] upper left corner, lower right corner
     */
    getBoundingBox: function() {
      var ul = new coords_default(constants_default.COORDS_BY_SCREEN, [0, 0], this).usrCoords, lr = new coords_default(
        constants_default.COORDS_BY_SCREEN,
        [this.canvasWidth, this.canvasHeight],
        this
      ).usrCoords;
      return [ul[1], ul[2], lr[1], lr[2]];
    },
    /**
     * Sets the value of attribute <tt>key</tt> to <tt>value</tt>.
     * @param {String} key The attribute's name.
     * @param value The new value
     * @private
     */
    _set: function(key, value) {
      key = key.toLocaleLowerCase();
      if (value !== null && type_default.isObject(value) && !type_default.exists(value.id) && !type_default.exists(value.name)) {
        type_default.mergeAttr(this.attr[key], value);
      } else {
        this.attr[key] = value;
      }
    },
    /**
     * Sets an arbitrary number of attributes. This method has one or more
     * parameters of the following types:
     * <ul>
     * <li> object: {key1:value1,key2:value2,...}
     * <li> string: 'key:value'
     * <li> array: ['key', value]
     * </ul>
     * Some board attributes are immutable, like e.g. the renderer type.
     *
     * @param {Object} attributes An object with attributes.
     * @returns {JXG.Board} Reference to the board
     *
     * @example
     * const board = JXG.JSXGraph.initBoard('jxgbox', {
     *     boundingbox: [-5, 5, 5, -5],
     *     keepAspectRatio: false,
     *     axis:true,
     *     showFullscreen: true,
     *     showScreenshot: true,
     *     showCopyright: false
     * });
     *
     * board.setAttribute({
     *     animationDelay: 10,
     *     boundingbox: [-10, 5, 10, -5],
     *     defaultAxes: {
     *         x: { strokeColor: 'blue', ticks: { strokeColor: 'blue'}}
     *     },
     *     description: 'test',
     *     fullscreen: {
     *         scale: 0.5
     *     },
     *     intl: {
     *         enabled: true,
     *         locale: 'de-DE'
     *     }
     * });
     *
     * board.setAttribute({
     *     selection: {
     *         enabled: true,
     *         fillColor: 'blue'
     *     },
     *     showInfobox: false,
     *     zoomX: 0.5,
     *     zoomY: 2,
     *     fullscreen: { symbol: 'x' },
     *     screenshot: { symbol: 'y' },
     *     showCopyright: true,
     *     showFullscreen: false,
     *     showScreenshot: false,
     *     showZoom: false,
     *     showNavigation: false
     * });
     * board.setAttribute('showCopyright:false');
     *
     * var p = board.create('point', [1, 1], {size: 10,
     *     label: {
     *         fontSize: 24,
     *         highlightStrokeOpacity: 0.1,
     *         offset: [5, 0]
     *     }
     * });
     *
     *
     * </pre><div id="JXGea7b8e09-beac-4d95-9a0c-5fc1c761ffbc" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *     const board = JXG.JSXGraph.initBoard('JXGea7b8e09-beac-4d95-9a0c-5fc1c761ffbc', {
     *         boundingbox: [-5, 5, 5, -5],
     *         keepAspectRatio: false,
     *         axis:true,
     *         showFullscreen: true,
     *         showScreenshot: true,
     *         showCopyright: false
     *     });
     *
     *     board.setAttribute({
     *         animationDelay: 10,
     *         boundingbox: [-10, 5, 10, -5],
     *         defaultAxes: {
     *             x: { strokeColor: 'blue', ticks: { strokeColor: 'blue'}}
     *         },
     *         description: 'test',
     *         fullscreen: {
     *             scale: 0.5
     *         },
     *         intl: {
     *             enabled: true,
     *             locale: 'de-DE'
     *         }
     *     });
     *
     *     board.setAttribute({
     *         selection: {
     *             enabled: true,
     *             fillColor: 'blue'
     *         },
     *         showInfobox: false,
     *         zoomX: 0.5,
     *         zoomY: 2,
     *         fullscreen: { symbol: 'x' },
     *         screenshot: { symbol: 'y' },
     *         showCopyright: true,
     *         showFullscreen: false,
     *         showScreenshot: false,
     *         showZoom: false,
     *         showNavigation: false
     *     });
     *
     *     board.setAttribute('showCopyright:false');
     *
     *     var p = board.create('point', [1, 1], {size: 10,
     *         label: {
     *             fontSize: 24,
     *             highlightStrokeOpacity: 0.1,
     *             offset: [5, 0]
     *         }
     *     });
     *
     *
     *     })();
     *
     * <\/script><pre>
     *
     *
     */
    setAttribute: function(attr) {
      var i2, arg, pair, key, value, oldvalue, node2, attributes = {};
      for (i2 = 0; i2 < arguments.length; i2++) {
        arg = arguments[i2];
        if (type_default.isString(arg)) {
          pair = arg.split(":");
          attributes[type_default.trim(pair[0])] = type_default.trim(pair[1]);
        } else if (!type_default.isArray(arg)) {
          jxg_default.extend(attributes, arg);
        } else {
          attributes[arg[0]] = arg[1];
        }
      }
      for (i2 in attributes) {
        if (attributes.hasOwnProperty(i2)) {
          key = i2.replace(/\s+/g, "").toLowerCase();
          value = attributes[i2];
        }
        value = value.toLowerCase && value.toLowerCase() === "false" ? false : value;
        oldvalue = this.attr[key];
        switch (key) {
          case "axis":
            if (value === false) {
              if (type_default.exists(this.defaultAxes)) {
                this.defaultAxes.x.setAttribute({ visible: false });
                this.defaultAxes.y.setAttribute({ visible: false });
              }
            } else {
            }
            break;
          case "boundingbox":
            this.setBoundingBox(value, this.keepaspectratio);
            this._set(key, value);
            break;
          case "defaultaxes":
            if (type_default.exists(this.defaultAxes.x) && type_default.exists(value.x)) {
              this.defaultAxes.x.setAttribute(value.x);
            }
            if (type_default.exists(this.defaultAxes.y) && type_default.exists(value.y)) {
              this.defaultAxes.y.setAttribute(value.y);
            }
            break;
          case "description":
            this.document.getElementById(this.container + "_ARIAdescription").innerHTML = value;
            this._set(key, value);
            break;
          case "title":
            this.document.getElementById(this.container + "_ARIAlabel").innerHTML = value;
            this._set(key, value);
            break;
          case "keepaspectratio":
            this._set(key, value);
            oldvalue = this.getBoundingBox();
            this.setBoundingBox([0, this.canvasHeight, this.canvasWidth, 0], false, "keep");
            this.setBoundingBox(oldvalue, value, "keep");
            break;
          case "document":
          case "maxboundingbox":
            this[key] = value;
            this._set(key, value);
            break;
          case "zoomx":
          case "zoomy":
            this[key] = value;
            this._set(key, value);
            this.setZoom(this.attr.zoomx, this.attr.zoomy);
            break;
          case "registerevents":
          case "renderer":
            break;
          case "fullscreen":
          case "screenshot":
            node2 = this.containerObj.ownerDocument.getElementById(
              this.container + "_navigation_" + key
            );
            if (node2 && type_default.exists(value.symbol)) {
              node2.innerHTML = type_default.evaluate(value.symbol);
            }
            this._set(key, value);
            break;
          case "selection":
            value.visible = false;
            value.withLines = false;
            value.vertices = { visible: false };
            this._set(key, value);
            break;
          case "showcopyright":
            if (this.renderer.type === "svg") {
              node2 = this.containerObj.ownerDocument.getElementById(
                this.renderer.uniqName("licenseText")
              );
              if (node2) {
                node2.style.display = type_default.evaluate(value) ? "inline" : "none";
              } else if (type_default.evaluate(value)) {
                this.renderer.displayCopyright(constants_default.licenseText, parseInt(this.options.text.fontSize, 10));
              }
            }
          default:
            if (type_default.exists(this.attr[key])) {
              this._set(key, value);
            }
            break;
        }
      }
      this.containerObj.ownerDocument.getElementById(
        this.container + "_navigationbar"
      ).remove();
      this.renderer.drawNavigationBar(this, this.attr.navbar);
      this.triggerEventHandlers(["attribute"], [attributes, this]);
      this.fullUpdate();
      return this;
    },
    /**
     * Adds an animation. Animations are controlled by the boards, so the boards need to be aware of the
     * animated elements. This function tells the board about new elements to animate.
     * @param {JXG.GeometryElement} element The element which is to be animated.
     * @returns {JXG.Board} Reference to the board
     */
    addAnimation: function(element) {
      var that2 = this;
      this.animationObjects[element.id] = element;
      if (!this.animationIntervalCode) {
        this.animationIntervalCode = window.setInterval(function() {
          that2.animate();
        }, element.board.attr.animationdelay);
      }
      return this;
    },
    /**
     * Cancels all running animations.
     * @returns {JXG.Board} Reference to the board
     */
    stopAllAnimation: function() {
      var el;
      for (el in this.animationObjects) {
        if (this.animationObjects.hasOwnProperty(el) && type_default.exists(this.animationObjects[el])) {
          this.animationObjects[el] = null;
          delete this.animationObjects[el];
        }
      }
      window.clearInterval(this.animationIntervalCode);
      delete this.animationIntervalCode;
      return this;
    },
    /**
     * General purpose animation function. This currently only supports moving points from one place to another. This
     * is faster than managing the animation per point, especially if there is more than one animated point at the same time.
     * @returns {JXG.Board} Reference to the board
     */
    animate: function() {
      var props, el, o, newCoords, r, p, c, cbtmp, count = 0, obj = null;
      for (el in this.animationObjects) {
        if (this.animationObjects.hasOwnProperty(el) && type_default.exists(this.animationObjects[el])) {
          count += 1;
          o = this.animationObjects[el];
          if (o.animationPath) {
            if (type_default.isFunction(o.animationPath)) {
              newCoords = o.animationPath(
                new Date().getTime() - o.animationStart
              );
            } else {
              newCoords = o.animationPath.pop();
            }
            if (!type_default.exists(newCoords) || !type_default.isArray(newCoords) && isNaN(newCoords)) {
              delete o.animationPath;
            } else {
              o.setPositionDirectly(constants_default.COORDS_BY_USER, newCoords);
              o.fullUpdate();
              obj = o;
            }
          }
          if (o.animationData) {
            c = 0;
            for (r in o.animationData) {
              if (o.animationData.hasOwnProperty(r)) {
                p = o.animationData[r].pop();
                if (!type_default.exists(p)) {
                  delete o.animationData[p];
                } else {
                  c += 1;
                  props = {};
                  props[r] = p;
                  o.setAttribute(props);
                }
              }
            }
            if (c === 0) {
              delete o.animationData;
            }
          }
          if (!type_default.exists(o.animationData) && !type_default.exists(o.animationPath)) {
            this.animationObjects[el] = null;
            delete this.animationObjects[el];
            if (type_default.exists(o.animationCallback)) {
              cbtmp = o.animationCallback;
              o.animationCallback = null;
              cbtmp();
            }
          }
        }
      }
      if (count === 0) {
        window.clearInterval(this.animationIntervalCode);
        delete this.animationIntervalCode;
      } else {
        this.update(obj);
      }
      return this;
    },
    /**
     * Migrate the dependency properties of the point src
     * to the point dest and delete the point src.
     * For example, a circle around the point src
     * receives the new center dest. The old center src
     * will be deleted.
     * @param {JXG.Point} src Original point which will be deleted
     * @param {JXG.Point} dest New point with the dependencies of src.
     * @param {Boolean} copyName Flag which decides if the name of the src element is copied to the
     *  dest element.
     * @returns {JXG.Board} Reference to the board
     */
    migratePoint: function(src, dest, copyName) {
      var child, childId, prop, found, i2, srcLabelId, srcHasLabel = false;
      src = this.select(src);
      dest = this.select(dest);
      if (type_default.exists(src.label)) {
        srcLabelId = src.label.id;
        srcHasLabel = true;
        this.removeObject(src.label);
      }
      for (childId in src.childElements) {
        if (src.childElements.hasOwnProperty(childId)) {
          child = src.childElements[childId];
          found = false;
          for (prop in child) {
            if (child.hasOwnProperty(prop)) {
              if (child[prop] === src) {
                child[prop] = dest;
                found = true;
              }
            }
          }
          if (found) {
            delete src.childElements[childId];
          }
          for (i2 = 0; i2 < child.parents.length; i2++) {
            if (child.parents[i2] === src.id) {
              child.parents[i2] = dest.id;
            }
          }
          dest.addChild(child);
        }
      }
      if (copyName) {
        if (srcHasLabel) {
          delete dest.childElements[srcLabelId];
          delete dest.descendants[srcLabelId];
        }
        if (dest.label) {
          this.removeObject(dest.label);
        }
        delete this.elementsByName[dest.name];
        dest.name = src.name;
        if (srcHasLabel) {
          dest.createLabel();
        }
      }
      this.removeObject(src);
      if (type_default.exists(dest.name) && dest.name !== "") {
        this.elementsByName[dest.name] = dest;
      }
      this.fullUpdate();
      return this;
    },
    /**
     * Initializes color blindness simulation.
     * @param {String} deficiency Describes the color blindness deficiency which is simulated. Accepted values are 'protanopia', 'deuteranopia', and 'tritanopia'.
     * @returns {JXG.Board} Reference to the board
     */
    emulateColorblindness: function(deficiency) {
      var e, o;
      if (!type_default.exists(deficiency)) {
        deficiency = "none";
      }
      if (this.currentCBDef === deficiency) {
        return this;
      }
      for (e in this.objects) {
        if (this.objects.hasOwnProperty(e)) {
          o = this.objects[e];
          if (deficiency !== "none") {
            if (this.currentCBDef === "none") {
              o.visPropOriginal = {
                strokecolor: o.visProp.strokecolor,
                fillcolor: o.visProp.fillcolor,
                highlightstrokecolor: o.visProp.highlightstrokecolor,
                highlightfillcolor: o.visProp.highlightfillcolor
              };
            }
            o.setAttribute({
              strokecolor: color_default.rgb2cb(
                type_default.evaluate(o.visPropOriginal.strokecolor),
                deficiency
              ),
              fillcolor: color_default.rgb2cb(
                type_default.evaluate(o.visPropOriginal.fillcolor),
                deficiency
              ),
              highlightstrokecolor: color_default.rgb2cb(
                type_default.evaluate(o.visPropOriginal.highlightstrokecolor),
                deficiency
              ),
              highlightfillcolor: color_default.rgb2cb(
                type_default.evaluate(o.visPropOriginal.highlightfillcolor),
                deficiency
              )
            });
          } else if (type_default.exists(o.visPropOriginal)) {
            jxg_default.extend(o.visProp, o.visPropOriginal);
          }
        }
      }
      this.currentCBDef = deficiency;
      this.update();
      return this;
    },
    /**
     * Select a single or multiple elements at once.
     * @param {String|Object|function} str The name, id or a reference to a JSXGraph element on this board. An object will
     * be used as a filter to return multiple elements at once filtered by the properties of the object.
     * @param {Boolean} onlyByIdOrName If true (default:false) elements are only filtered by their id, name or groupId.
     * The advanced filters consisting of objects or functions are ignored.
     * @returns {JXG.GeometryElement|JXG.Composition}
     * @example
     * // select the element with name A
     * board.select('A');
     *
     * // select all elements with strokecolor set to 'red' (but not '#ff0000')
     * board.select({
     *   strokeColor: 'red'
     * });
     *
     * // select all points on or below the x axis and make them black.
     * board.select({
     *   elementClass: JXG.OBJECT_CLASS_POINT,
     *   Y: function (v) {
     *     return v <= 0;
     *   }
     * }).setAttribute({color: 'black'});
     *
     * // select all elements
     * board.select(function (el) {
     *   return true;
     * });
     */
    select: function(str2, onlyByIdOrName) {
      var flist, olist, i2, l, s = str2;
      if (s === null) {
        return s;
      }
      if (type_default.isString(s) && s !== "") {
        if (type_default.exists(this.objects[s])) {
          s = this.objects[s];
        } else if (type_default.exists(this.elementsByName[s])) {
          s = this.elementsByName[s];
        } else if (type_default.exists(this.groups[s])) {
          s = this.groups[s];
        }
      } else if (!onlyByIdOrName && (type_default.isFunction(s) || type_default.isObject(s) && !type_default.isFunction(s.setAttribute))) {
        flist = type_default.filterElements(this.objectsList, s);
        olist = {};
        l = flist.length;
        for (i2 = 0; i2 < l; i2++) {
          olist[flist[i2].id] = flist[i2];
        }
        s = new composition_default(olist);
      } else if (type_default.isObject(s) && type_default.exists(s.id) && !type_default.exists(this.objects[s.id])) {
        s = null;
      }
      return s;
    },
    /**
     * Checks if the given point is inside the boundingbox.
     * @param {Number|JXG.Coords} x User coordinate or {@link JXG.Coords} object.
     * @param {Number} [y] User coordinate. May be omitted in case <tt>x</tt> is a {@link JXG.Coords} object.
     * @returns {Boolean}
     */
    hasPoint: function(x, y) {
      var px = x, py = y, bbox = this.getBoundingBox();
      if (type_default.exists(x) && type_default.isArray(x.usrCoords)) {
        px = x.usrCoords[1];
        py = x.usrCoords[2];
      }
      return !!(type_default.isNumber(px) && type_default.isNumber(py) && bbox[0] < px && px < bbox[2] && bbox[1] > py && py > bbox[3]);
    },
    /**
     * Update CSS transformations of type scaling. It is used to correct the mouse position
     * in {@link JXG.Board.getMousePosition}.
     * The inverse transformation matrix is updated on each mouseDown and touchStart event.
     *
     * It is up to the user to call this method after an update of the CSS transformation
     * in the DOM.
     */
    updateCSSTransforms: function() {
      var obj = this.containerObj, o = obj, o2 = obj;
      this.cssTransMat = env_default.getCSSTransformMatrix(o);
      if (type_default.exists(o.getRootNode)) {
        o = o.parentNode === o.getRootNode() ? o.parentNode.host : o.parentNode;
        while (o) {
          this.cssTransMat = math_default.matMatMult(env_default.getCSSTransformMatrix(o), this.cssTransMat);
          o = o.parentNode === o.getRootNode() ? o.parentNode.host : o.parentNode;
        }
        this.cssTransMat = math_default.inverse(this.cssTransMat);
      } else {
        o = o.offsetParent;
        while (o) {
          this.cssTransMat = math_default.matMatMult(env_default.getCSSTransformMatrix(o), this.cssTransMat);
          o2 = o2.parentNode;
          while (o2 !== o) {
            this.cssTransMat = math_default.matMatMult(env_default.getCSSTransformMatrix(o), this.cssTransMat);
            o2 = o2.parentNode;
          }
          o = o.offsetParent;
        }
        this.cssTransMat = math_default.inverse(this.cssTransMat);
      }
      return this;
    },
    /**
     * Start selection mode. This function can either be triggered from outside or by
     * a down event together with correct key pressing. The default keys are
     * shift+ctrl. But this can be changed in the options.
     *
     * Starting from out side can be realized for example with a button like this:
     * <pre>
     * 	&lt;button onclick='board.startSelectionMode()'&gt;Start&lt;/button&gt;
     * </pre>
     * @example
     * //
     * // Set a new bounding box from the selection rectangle
     * //
     * var board = JXG.JSXGraph.initBoard('jxgbox', {
     *         boundingBox:[-3,2,3,-2],
     *         keepAspectRatio: false,
     *         axis:true,
     *         selection: {
     *             enabled: true,
     *             needShift: false,
     *             needCtrl: true,
     *             withLines: false,
     *             vertices: {
     *                 visible: false
     *             },
     *             fillColor: '#ffff00',
     *         }
     *      });
     *
     * var f = function f(x) { return Math.cos(x); },
     *     curve = board.create('functiongraph', [f]);
     *
     * board.on('stopselecting', function(){
     *     var box = board.stopSelectionMode(),
     *
     *         // bbox has the coordinates of the selection rectangle.
     *         // Attention: box[i].usrCoords have the form [1, x, y], i.e.
     *         // are homogeneous coordinates.
     *         bbox = box[0].usrCoords.slice(1).concat(box[1].usrCoords.slice(1));
     *
     *         // Set a new bounding box
     *         board.setBoundingBox(bbox, false);
     *  });
     *
     *
     * </pre><div class='jxgbox' id='JXG11eff3a6-8c50-11e5-b01d-901b0e1b8723' style='width: 300px; height: 300px;'></div>
     * <script type='text/javascript'>
     *     (function() {
     *     //
     *     // Set a new bounding box from the selection rectangle
     *     //
     *     var board = JXG.JSXGraph.initBoard('JXG11eff3a6-8c50-11e5-b01d-901b0e1b8723', {
     *             boundingBox:[-3,2,3,-2],
     *             keepAspectRatio: false,
     *             axis:true,
     *             selection: {
     *                 enabled: true,
     *                 needShift: false,
     *                 needCtrl: true,
     *                 withLines: false,
     *                 vertices: {
     *                     visible: false
     *                 },
     *                 fillColor: '#ffff00',
     *             }
     *        });
     *
     *     var f = function f(x) { return Math.cos(x); },
     *         curve = board.create('functiongraph', [f]);
     *
     *     board.on('stopselecting', function(){
     *         var box = board.stopSelectionMode(),
     *
     *             // bbox has the coordinates of the selection rectangle.
     *             // Attention: box[i].usrCoords have the form [1, x, y], i.e.
     *             // are homogeneous coordinates.
     *             bbox = box[0].usrCoords.slice(1).concat(box[1].usrCoords.slice(1));
     *
     *             // Set a new bounding box
     *             board.setBoundingBox(bbox, false);
     *      });
     *     })();
     *
     * <\/script><pre>
     *
     */
    startSelectionMode: function() {
      this.selectingMode = true;
      this.selectionPolygon.setAttribute({ visible: true });
      this.selectingBox = [
        [0, 0],
        [0, 0]
      ];
      this._setSelectionPolygonFromBox();
      this.selectionPolygon.fullUpdate();
    },
    /**
     * Finalize the selection: disable selection mode and return the coordinates
     * of the selection rectangle.
     * @returns {Array} Coordinates of the selection rectangle. The array
     * contains two {@link JXG.Coords} objects. One the upper left corner and
     * the second for the lower right corner.
     */
    stopSelectionMode: function() {
      this.selectingMode = false;
      this.selectionPolygon.setAttribute({ visible: false });
      return [
        this.selectionPolygon.vertices[0].coords,
        this.selectionPolygon.vertices[2].coords
      ];
    },
    /**
     * Start the selection of a region.
     * @private
     * @param  {Array} pos Screen coordiates of the upper left corner of the
     * selection rectangle.
     */
    _startSelecting: function(pos) {
      this.isSelecting = true;
      this.selectingBox = [
        [pos[0], pos[1]],
        [pos[0], pos[1]]
      ];
      this._setSelectionPolygonFromBox();
    },
    /**
     * Update the selection rectangle during a move event.
     * @private
     * @param  {Array} pos Screen coordiates of the move event
     */
    _moveSelecting: function(pos) {
      if (this.isSelecting) {
        this.selectingBox[1] = [pos[0], pos[1]];
        this._setSelectionPolygonFromBox();
        this.selectionPolygon.fullUpdate();
      }
    },
    /**
     * Update the selection rectangle during an up event. Stop selection.
     * @private
     * @param  {Object} evt Event object
     */
    _stopSelecting: function(evt) {
      var pos = this.getMousePosition(evt);
      this.isSelecting = false;
      this.selectingBox[1] = [pos[0], pos[1]];
      this._setSelectionPolygonFromBox();
    },
    /**
     * Update the Selection rectangle.
     * @private
     */
    _setSelectionPolygonFromBox: function() {
      var A = this.selectingBox[0], B = this.selectingBox[1];
      this.selectionPolygon.vertices[0].setPositionDirectly(jxg_default.COORDS_BY_SCREEN, [
        A[0],
        A[1]
      ]);
      this.selectionPolygon.vertices[1].setPositionDirectly(jxg_default.COORDS_BY_SCREEN, [
        A[0],
        B[1]
      ]);
      this.selectionPolygon.vertices[2].setPositionDirectly(jxg_default.COORDS_BY_SCREEN, [
        B[0],
        B[1]
      ]);
      this.selectionPolygon.vertices[3].setPositionDirectly(jxg_default.COORDS_BY_SCREEN, [
        B[0],
        A[1]
      ]);
    },
    /**
     * Test if a down event should start a selection. Test if the
     * required keys are pressed. If yes, {@link JXG.Board.startSelectionMode} is called.
     * @param  {Object} evt Event object
     */
    _testForSelection: function(evt) {
      if (this._isRequiredKeyPressed(evt, "selection")) {
        if (!type_default.exists(this.selectionPolygon)) {
          this._createSelectionPolygon(this.attr);
        }
        this.startSelectionMode();
      }
    },
    /**
     * Create the internal selection polygon, which will be available as board.selectionPolygon.
     * @private
     * @param  {Object} attr board attributes, e.g. the subobject board.attr.
     * @returns {Object} pointer to the board to enable chaining.
     */
    _createSelectionPolygon: function(attr) {
      var selectionattr;
      if (!type_default.exists(this.selectionPolygon)) {
        selectionattr = type_default.copyAttributes(attr, options_default, "board", "selection");
        if (selectionattr.enabled === true) {
          this.selectionPolygon = this.create(
            "polygon",
            [
              [0, 0],
              [0, 0],
              [0, 0],
              [0, 0]
            ],
            selectionattr
          );
        }
      }
      return this;
    },
    /* **************************
     *     EVENT DEFINITION
     * for documentation purposes
     * ************************** */
    //region Event handler documentation
    /**
     * @event
     * @description Whenever the {@link JXG.Board#setAttribute} is called.
     * @name JXG.Board#attribute
     * @param {Event} e The browser's event object.
     */
    __evt__attribute: function(e) {
    },
    /**
     * @event
     * @description Whenever the user starts to touch or click the board.
     * @name JXG.Board#down
     * @param {Event} e The browser's event object.
     */
    __evt__down: function(e) {
    },
    /**
     * @event
     * @description Whenever the user starts to click on the board.
     * @name JXG.Board#mousedown
     * @param {Event} e The browser's event object.
     */
    __evt__mousedown: function(e) {
    },
    /**
     * @event
     * @description Whenever the user taps the pen on the board.
     * @name JXG.Board#pendown
     * @param {Event} e The browser's event object.
     */
    __evt__pendown: function(e) {
    },
    /**
     * @event
     * @description Whenever the user starts to click on the board with a
     * device sending pointer events.
     * @name JXG.Board#pointerdown
     * @param {Event} e The browser's event object.
     */
    __evt__pointerdown: function(e) {
    },
    /**
     * @event
     * @description Whenever the user starts to touch the board.
     * @name JXG.Board#touchstart
     * @param {Event} e The browser's event object.
     */
    __evt__touchstart: function(e) {
    },
    /**
     * @event
     * @description Whenever the user stops to touch or click the board.
     * @name JXG.Board#up
     * @param {Event} e The browser's event object.
     */
    __evt__up: function(e) {
    },
    /**
     * @event
     * @description Whenever the user releases the mousebutton over the board.
     * @name JXG.Board#mouseup
     * @param {Event} e The browser's event object.
     */
    __evt__mouseup: function(e) {
    },
    /**
     * @event
     * @description Whenever the user releases the mousebutton over the board with a
     * device sending pointer events.
     * @name JXG.Board#pointerup
     * @param {Event} e The browser's event object.
     */
    __evt__pointerup: function(e) {
    },
    /**
     * @event
     * @description Whenever the user stops touching the board.
     * @name JXG.Board#touchend
     * @param {Event} e The browser's event object.
     */
    __evt__touchend: function(e) {
    },
    /**
     * @event
     * @description Whenever the user clicks on the board.
     * @name JXG.Board#click
     * @param {Event} e The browser's event object.
     */
    __evt__click: function(e) {
    },
    /**
     * @event
     * @description Whenever the user double clicks on the board.
     * This event works on desktop browser, but is undefined
     * on mobile browsers.
     * @name JXG.Board#dblclick
     * @param {Event} e The browser's event object.
     */
    __evt__dblclick: function(e) {
    },
    /**
     * @event
     * @description Whenever the user clicks on the board with a mouse device.
     * @name JXG.Board#mouseclick
     * @param {Event} e The browser's event object.
     */
    __evt__mouseclick: function(e) {
    },
    /**
     * @event
     * @description Whenever the user double clicks on the board with a mouse device.
     * @name JXG.Board#mousedblclick
     * @param {Event} e The browser's event object.
     */
    __evt__mousedblclick: function(e) {
    },
    /**
     * @event
     * @description Whenever the user clicks on the board with a pointer device.
     * @name JXG.Board#pointerclick
     * @param {Event} e The browser's event object.
     */
    __evt__pointerclick: function(e) {
    },
    /**
     * @event
     * @description Whenever the user double clicks on the board with a pointer device.
     * This event works on desktop browser, but is undefined
     * on mobile browsers.
     * @name JXG.Board#pointerdblclick
     * @param {Event} e The browser's event object.
     */
    __evt__pointerdblclick: function(e) {
    },
    /**
     * @event
     * @description This event is fired whenever the user is moving the finger or mouse pointer over the board.
     * @name JXG.Board#move
     * @param {Event} e The browser's event object.
     * @param {Number} mode The mode the board currently is in
     * @see JXG.Board#mode
     */
    __evt__move: function(e, mode) {
    },
    /**
     * @event
     * @description This event is fired whenever the user is moving the mouse over the board.
     * @name JXG.Board#mousemove
     * @param {Event} e The browser's event object.
     * @param {Number} mode The mode the board currently is in
     * @see JXG.Board#mode
     */
    __evt__mousemove: function(e, mode) {
    },
    /**
     * @event
     * @description This event is fired whenever the user is moving the pen over the board.
     * @name JXG.Board#penmove
     * @param {Event} e The browser's event object.
     * @param {Number} mode The mode the board currently is in
     * @see JXG.Board#mode
     */
    __evt__penmove: function(e, mode) {
    },
    /**
     * @event
     * @description This event is fired whenever the user is moving the mouse over the board with a
     * device sending pointer events.
     * @name JXG.Board#pointermove
     * @param {Event} e The browser's event object.
     * @param {Number} mode The mode the board currently is in
     * @see JXG.Board#mode
     */
    __evt__pointermove: function(e, mode) {
    },
    /**
     * @event
     * @description This event is fired whenever the user is moving the finger over the board.
     * @name JXG.Board#touchmove
     * @param {Event} e The browser's event object.
     * @param {Number} mode The mode the board currently is in
     * @see JXG.Board#mode
     */
    __evt__touchmove: function(e, mode) {
    },
    /**
     * @event
     * @description This event is fired whenever the user is moving an element over the board by
     * pressing arrow keys on a keyboard.
     * @name JXG.Board#keymove
     * @param {Event} e The browser's event object.
     * @param {Number} mode The mode the board currently is in
     * @see JXG.Board#mode
     */
    __evt__keymove: function(e, mode) {
    },
    /**
     * @event
     * @description Whenever an element is highlighted this event is fired.
     * @name JXG.Board#hit
     * @param {Event} e The browser's event object.
     * @param {JXG.GeometryElement} el The hit element.
     * @param target
     *
     * @example
     * var c = board.create('circle', [[1, 1], 2]);
     * board.on('hit', function(evt, el) {
     *     console.log('Hit element', el);
     * });
     *
     * </pre><div id='JXG19eb31ac-88e6-11e8-bcb5-901b0e1b8723' class='jxgbox' style='width: 300px; height: 300px;'></div>
     * <script type='text/javascript'>
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG19eb31ac-88e6-11e8-bcb5-901b0e1b8723',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var c = board.create('circle', [[1, 1], 2]);
     *     board.on('hit', function(evt, el) {
     *         console.log('Hit element', el);
     *     });
     *
     *     })();
     *
     * <\/script><pre>
     */
    __evt__hit: function(e, el, target) {
    },
    /**
     * @event
     * @description Whenever an element is highlighted this event is fired.
     * @name JXG.Board#mousehit
     * @see JXG.Board#hit
     * @param {Event} e The browser's event object.
     * @param {JXG.GeometryElement} el The hit element.
     * @param target
     */
    __evt__mousehit: function(e, el, target) {
    },
    /**
     * @event
     * @description This board is updated.
     * @name JXG.Board#update
     */
    __evt__update: function() {
    },
    /**
     * @event
     * @description The bounding box of the board has changed.
     * @name JXG.Board#boundingbox
     */
    __evt__boundingbox: function() {
    },
    /**
     * @event
     * @description Select a region is started during a down event or by calling
     * {@link JXG.Board.startSelectionMode}
     * @name JXG.Board#startselecting
     */
    __evt__startselecting: function() {
    },
    /**
     * @event
     * @description Select a region is started during a down event
     * from a device sending mouse events or by calling
     * {@link JXG.Board.startSelectionMode}.
     * @name JXG.Board#mousestartselecting
     */
    __evt__mousestartselecting: function() {
    },
    /**
     * @event
     * @description Select a region is started during a down event
     * from a device sending pointer events or by calling
     * {@link JXG.Board.startSelectionMode}.
     * @name JXG.Board#pointerstartselecting
     */
    __evt__pointerstartselecting: function() {
    },
    /**
     * @event
     * @description Select a region is started during a down event
     * from a device sending touch events or by calling
     * {@link JXG.Board.startSelectionMode}.
     * @name JXG.Board#touchstartselecting
     */
    __evt__touchstartselecting: function() {
    },
    /**
     * @event
     * @description Selection of a region is stopped during an up event.
     * @name JXG.Board#stopselecting
     */
    __evt__stopselecting: function() {
    },
    /**
     * @event
     * @description Selection of a region is stopped during an up event
     * from a device sending mouse events.
     * @name JXG.Board#mousestopselecting
     */
    __evt__mousestopselecting: function() {
    },
    /**
     * @event
     * @description Selection of a region is stopped during an up event
     * from a device sending pointer events.
     * @name JXG.Board#pointerstopselecting
     */
    __evt__pointerstopselecting: function() {
    },
    /**
     * @event
     * @description Selection of a region is stopped during an up event
     * from a device sending touch events.
     * @name JXG.Board#touchstopselecting
     */
    __evt__touchstopselecting: function() {
    },
    /**
     * @event
     * @description A move event while selecting of a region is active.
     * @name JXG.Board#moveselecting
     */
    __evt__moveselecting: function() {
    },
    /**
     * @event
     * @description A move event while selecting of a region is active
     * from a device sending mouse events.
     * @name JXG.Board#mousemoveselecting
     */
    __evt__mousemoveselecting: function() {
    },
    /**
     * @event
     * @description Select a region is started during a down event
     * from a device sending mouse events.
     * @name JXG.Board#pointermoveselecting
     */
    __evt__pointermoveselecting: function() {
    },
    /**
     * @event
     * @description Select a region is started during a down event
     * from a device sending touch events.
     * @name JXG.Board#touchmoveselecting
     */
    __evt__touchmoveselecting: function() {
    },
    /**
     * @ignore
     */
    __evt: function() {
    },
    //endregion
    /**
     * Expand the JSXGraph construction to fullscreen.
     * In order to preserve the proportions of the JSXGraph element,
     * a wrapper div is created which is set to fullscreen.
     * This function is called when fullscreen mode is triggered
     * <b>and</b> when it is closed.
     * <p>
     * The wrapping div has the CSS class 'jxgbox_wrap_private' which is
     * defined in the file 'jsxgraph.css'
     * <p>
     * This feature is not available on iPhones (as of December 2021).
     *
     * @param {String} id (Optional) id of the div element which is brought to fullscreen.
     * If not provided, this defaults to the JSXGraph div. However, it may be necessary for the aspect ratio trick
     * which using padding-bottom/top and an out div element. Then, the id of the outer div has to be supplied.
     *
     * @return {JXG.Board} Reference to the board
     *
     * @example
     * &lt;div id='jxgbox' class='jxgbox' style='width:500px; height:200px;'&gt;&lt;/div&gt;
     * &lt;button onClick='board.toFullscreen()'&gt;Fullscreen&lt;/button&gt;
     *
     * &lt;script language='Javascript' type='text/javascript'&gt;
     * var board = JXG.JSXGraph.initBoard('jxgbox', {axis:true, boundingbox:[-5,5,5,-5]});
     * var p = board.create('point', [0, 1]);
     * &lt;/script&gt;
     *
     * </pre><div id='JXGd5bab8b6-fd40-11e8-ab14-901b0e1b8723' class='jxgbox' style='width: 300px; height: 300px;'></div>
     * <script type='text/javascript'>
     *      var board_d5bab8b6;
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXGd5bab8b6-fd40-11e8-ab14-901b0e1b8723',
     *             {boundingbox:[-5,5,5,-5], axis: true, showcopyright: false, shownavigation: false});
     *         var p = board.create('point', [0, 1]);
     *         board_d5bab8b6 = board;
     *     })();
     * <\/script>
     * <button onClick='board_d5bab8b6.toFullscreen()'>Fullscreen</button>
     * <pre>
     *
     * @example
     * &lt;div id='outer' style='max-width: 500px; margin: 0 auto;'&gt;
     * &lt;div id='jxgbox' class='jxgbox' style='height: 0; padding-bottom: 100%'&gt;&lt;/div&gt;
     * &lt;/div&gt;
     * &lt;button onClick='board.toFullscreen('outer')'&gt;Fullscreen&lt;/button&gt;
     *
     * &lt;script language='Javascript' type='text/javascript'&gt;
     * var board = JXG.JSXGraph.initBoard('jxgbox', {
     *     axis:true,
     *     boundingbox:[-5,5,5,-5],
     *     fullscreen: { id: 'outer' },
     *     showFullscreen: true
     * });
     * var p = board.create('point', [-2, 3], {});
     * &lt;/script&gt;
     *
     * </pre><div id='JXG7103f6b_outer' style='max-width: 500px; margin: 0 auto;'>
     * <div id='JXG7103f6be-6993-4ff8-8133-c78e50a8afac' class='jxgbox' style='height: 0; padding-bottom: 100%;'></div>
     * </div>
     * <button onClick='board_JXG7103f6be.toFullscreen('JXG7103f6b_outer')'>Fullscreen</button>
     * <script type='text/javascript'>
     *     var board_JXG7103f6be;
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG7103f6be-6993-4ff8-8133-c78e50a8afac',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, fullscreen: { id: 'JXG7103f6b_outer' }, showFullscreen: true,
     *              showcopyright: false, shownavigation: false});
     *     var p = board.create('point', [-2, 3], {});
     *     board_JXG7103f6be = board;
     *     })();
     *
     * <\/script><pre>
     *
     *
     */
    toFullscreen: function(id) {
      var wrap_id, wrap_node, inner_node, dim, doc = this.document, fullscreenElement;
      id = id || this.container;
      this._fullscreen_inner_id = id;
      inner_node = doc.getElementById(id);
      wrap_id = "fullscreenwrap_" + id;
      if (!type_default.exists(inner_node._cssFullscreenStore)) {
        dim = this.containerObj.getBoundingClientRect();
        inner_node._cssFullscreenStore = {
          w: dim.width,
          h: dim.height
        };
      }
      if (doc.getElementById(wrap_id)) {
        wrap_node = doc.getElementById(wrap_id);
      } else {
        wrap_node = document.createElement("div");
        wrap_node.classList.add("JXG_wrap_private");
        wrap_node.setAttribute("id", wrap_id);
        inner_node.parentNode.insertBefore(wrap_node, inner_node);
        wrap_node.appendChild(inner_node);
      }
      wrap_node.requestFullscreen = wrap_node.requestFullscreen || wrap_node.webkitRequestFullscreen || wrap_node.mozRequestFullScreen || wrap_node.msRequestFullscreen;
      if (doc.fullscreenElement !== void 0) {
        fullscreenElement = doc.fullscreenElement;
      } else if (doc.webkitFullscreenElement !== void 0) {
        fullscreenElement = doc.webkitFullscreenElement;
      } else {
        fullscreenElement = doc.msFullscreenElement;
      }
      if (fullscreenElement === null) {
        if (wrap_node.requestFullscreen) {
          wrap_node.requestFullscreen();
          this.startFullscreenResizeObserver(wrap_node);
        }
      } else {
        this.stopFullscreenResizeObserver(wrap_node);
        if (type_default.exists(document.exitFullscreen)) {
          document.exitFullscreen();
        } else if (type_default.exists(document.webkitExitFullscreen)) {
          document.webkitExitFullscreen();
        }
      }
      return this;
    },
    /**
     * If fullscreen mode is toggled, the possible CSS transformations
     * which are applied to the JSXGraph canvas have to be reread.
     * Otherwise the position of upper left corner is wrongly interpreted.
     *
     * @param  {Object} evt fullscreen event object (unused)
     */
    fullscreenListener: function(evt) {
      var inner_id, inner_node, fullscreenElement, doc = this.document;
      inner_id = this._fullscreen_inner_id;
      if (!type_default.exists(inner_id)) {
        return;
      }
      if (doc.fullscreenElement !== void 0) {
        fullscreenElement = doc.fullscreenElement;
      } else if (doc.webkitFullscreenElement !== void 0) {
        fullscreenElement = doc.webkitFullscreenElement;
      } else {
        fullscreenElement = doc.msFullscreenElement;
      }
      inner_node = doc.getElementById(inner_id);
      if (fullscreenElement) {
        inner_node._cssFullscreenStore.id = fullscreenElement.id;
        inner_node._cssFullscreenStore.isFullscreen = true;
        inner_node._cssFullscreenStore.margin = inner_node.style.margin;
        inner_node._cssFullscreenStore.width = inner_node.style.width;
        inner_node._cssFullscreenStore.height = inner_node.style.height;
        inner_node._cssFullscreenStore.transform = inner_node.style.transform;
        inner_node.style.width = inner_node._cssFullscreenStore.w + "px";
        inner_node.style.height = inner_node._cssFullscreenStore.h + "px";
        inner_node.style.margin = "";
        env_default.scaleJSXGraphDiv(
          fullscreenElement.id,
          inner_id,
          doc,
          type_default.evaluate(this.attr.fullscreen.scale)
        );
        fullscreenElement = null;
      } else if (type_default.exists(inner_node._cssFullscreenStore)) {
        inner_node._cssFullscreenStore.isFullscreen = false;
        inner_node.style.margin = inner_node._cssFullscreenStore.margin;
        inner_node.style.width = inner_node._cssFullscreenStore.width;
        inner_node.style.height = inner_node._cssFullscreenStore.height;
        inner_node.style.transform = inner_node._cssFullscreenStore.transform;
        inner_node._cssFullscreenStore = null;
        inner_node.parentElement.replaceWith(inner_node);
      }
      this.updateCSSTransforms();
    },
    /**
     * Start resize observer to handle
     * orientation changes in fullscreen mode.
     *
     * @param {Object} node DOM object which is in fullscreen mode. It is the wrapper element
     * around the JSXGraph div.
     * @returns {JXG.Board} Reference to the board
     * @private
     * @see JXG.Board#toFullscreen
     *
     */
    startFullscreenResizeObserver: function(node2) {
      var that2 = this;
      if (!env_default.isBrowser || !this.attr.resize || !this.attr.resize.enabled) {
        return this;
      }
      this.resizeObserver = new ResizeObserver(function(entries) {
        var inner_id, fullscreenElement, doc = that2.document;
        if (!that2._isResizing) {
          that2._isResizing = true;
          window.setTimeout(function() {
            try {
              inner_id = that2._fullscreen_inner_id;
              if (doc.fullscreenElement !== void 0) {
                fullscreenElement = doc.fullscreenElement;
              } else if (doc.webkitFullscreenElement !== void 0) {
                fullscreenElement = doc.webkitFullscreenElement;
              } else {
                fullscreenElement = doc.msFullscreenElement;
              }
              if (fullscreenElement !== null) {
                env_default.scaleJSXGraphDiv(
                  fullscreenElement.id,
                  inner_id,
                  doc,
                  type_default.evaluate(that2.attr.fullscreen.scale)
                );
              }
            } catch (err) {
              that2.stopFullscreenResizeObserver(node2);
            } finally {
              that2._isResizing = false;
            }
          }, that2.attr.resize.throttle);
        }
      });
      this.resizeObserver.observe(node2);
      return this;
    },
    /**
     * Remove resize observer to handle orientation changes in fullscreen mode.
     * @param {Object} node DOM object which is in fullscreen mode. It is the wrapper element
     * around the JSXGraph div.
     * @returns {JXG.Board} Reference to the board
     * @private
     * @see JXG.Board#toFullscreen
     */
    stopFullscreenResizeObserver: function(node2) {
      if (!env_default.isBrowser || !this.attr.resize || !this.attr.resize.enabled) {
        return this;
      }
      if (type_default.exists(this.resizeObserver)) {
        this.resizeObserver.unobserve(node2);
      }
      return this;
    },
    /**
     * Add user activity to the array 'board.userLog'.
     *
     * @param {String} type Event type, e.g. 'drag'
     * @param {Object} obj JSXGraph element object
     *
     * @see JXG.Board#userLog
     * @return {JXG.Board} Reference to the board
     */
    addLogEntry: function(type, obj, pos) {
      var t, id, last = this.userLog.length - 1;
      if (type_default.exists(obj.elementClass)) {
        id = obj.id;
      }
      if (type_default.evaluate(this.attr.logging.enabled)) {
        t = new Date().getTime();
        if (last >= 0 && this.userLog[last].type === type && this.userLog[last].id === id && // Distinguish consecutive drag events of
        // the same element
        t - this.userLog[last].end < 500) {
          this.userLog[last].end = t;
          this.userLog[last].endpos = pos;
        } else {
          this.userLog.push({
            type,
            id,
            start: t,
            startpos: pos,
            end: t,
            endpos: pos,
            bbox: this.getBoundingBox(),
            canvas: [this.canvasWidth, this.canvasHeight],
            zoom: [this.zoomX, this.zoomY]
          });
        }
      }
      return this;
    },
    /**
     * Function to animate a curve rolling on another curve.
     * @param {Curve} c1 JSXGraph curve building the floor where c2 rolls
     * @param {Curve} c2 JSXGraph curve which rolls on c1.
     * @param {number} start_c1 The parameter t such that c1(t) touches c2. This is the start position of the
     *                          rolling process
     * @param {Number} stepsize Increase in t in each step for the curve c1
     * @param {Number} direction
     * @param {Number} time Delay time for setInterval()
     * @param {Array} pointlist Array of points which are rolled in each step. This list should contain
     *      all points which define c2 and gliders on c2.
     *
     * @example
     *
     * // Line which will be the floor to roll upon.
     * var line = board.create('curve', [function (t) { return t;}, function (t){ return 1;}], {strokeWidth:6});
     * // Center of the rolling circle
     * var C = board.create('point',[0,2],{name:'C'});
     * // Starting point of the rolling circle
     * var P = board.create('point',[0,1],{name:'P', trace:true});
     * // Circle defined as a curve. The circle 'starts' at P, i.e. circle(0) = P
     * var circle = board.create('curve',[
     *           function (t){var d = P.Dist(C),
     *                           beta = JXG.Math.Geometry.rad([C.X()+1,C.Y()],C,P);
     *                       t += beta;
     *                       return C.X()+d*Math.cos(t);
     *           },
     *           function (t){var d = P.Dist(C),
     *                           beta = JXG.Math.Geometry.rad([C.X()+1,C.Y()],C,P);
     *                       t += beta;
     *                       return C.Y()+d*Math.sin(t);
     *           },
     *           0,2*Math.PI],
     *           {strokeWidth:6, strokeColor:'green'});
     *
     * // Point on circle
     * var B = board.create('glider',[0,2,circle],{name:'B', color:'blue',trace:false});
     * var roll = board.createRoulette(line, circle, 0, Math.PI/20, 1, 100, [C,P,B]);
     * roll.start() // Start the rolling, to be stopped by roll.stop()
     *
     * </pre><div class='jxgbox' id='JXGe5e1b53c-a036-4a46-9e35-190d196beca5' style='width: 300px; height: 300px;'></div>
     * <script type='text/javascript'>
     * var brd = JXG.JSXGraph.initBoard('JXGe5e1b53c-a036-4a46-9e35-190d196beca5', {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright:false, shownavigation: false});
     * // Line which will be the floor to roll upon.
     * var line = brd.create('curve', [function (t) { return t;}, function (t){ return 1;}], {strokeWidth:6});
     * // Center of the rolling circle
     * var C = brd.create('point',[0,2],{name:'C'});
     * // Starting point of the rolling circle
     * var P = brd.create('point',[0,1],{name:'P', trace:true});
     * // Circle defined as a curve. The circle 'starts' at P, i.e. circle(0) = P
     * var circle = brd.create('curve',[
     *           function (t){var d = P.Dist(C),
     *                           beta = JXG.Math.Geometry.rad([C.X()+1,C.Y()],C,P);
     *                       t += beta;
     *                       return C.X()+d*Math.cos(t);
     *           },
     *           function (t){var d = P.Dist(C),
     *                           beta = JXG.Math.Geometry.rad([C.X()+1,C.Y()],C,P);
     *                       t += beta;
     *                       return C.Y()+d*Math.sin(t);
     *           },
     *           0,2*Math.PI],
     *           {strokeWidth:6, strokeColor:'green'});
     *
     * // Point on circle
     * var B = brd.create('glider',[0,2,circle],{name:'B', color:'blue',trace:false});
     * var roll = brd.createRoulette(line, circle, 0, Math.PI/20, 1, 100, [C,P,B]);
     * roll.start() // Start the rolling, to be stopped by roll.stop()
     * <\/script><pre>
     */
    createRoulette: function(c1, c2, start_c1, stepsize, direction, time, pointlist) {
      var brd = this, Roulette = function() {
        var alpha = 0, Tx = 0, Ty = 0, t1 = start_c1, t2 = numerics_default.root(
          function(t) {
            var c1x = c1.X(t1), c1y = c1.Y(t1), c2x = c2.X(t), c2y = c2.Y(t);
            return (c1x - c2x) * (c1x - c2x) + (c1y - c2y) * (c1y - c2y);
          },
          [0, Math.PI * 2]
        ), t1_new = 0, t2_new = 0, c1dist, rotation = brd.create(
          "transform",
          [
            function() {
              return alpha;
            }
          ],
          { type: "rotate" }
        ), rotationLocal = brd.create(
          "transform",
          [
            function() {
              return alpha;
            },
            function() {
              return c1.X(t1);
            },
            function() {
              return c1.Y(t1);
            }
          ],
          { type: "rotate" }
        ), translate = brd.create(
          "transform",
          [
            function() {
              return Tx;
            },
            function() {
              return Ty;
            }
          ],
          { type: "translate" }
        ), arclen = function(c, a, b) {
          var cpxa = numerics_default.D(c.X)(a), cpya = numerics_default.D(c.Y)(a), cpxb = numerics_default.D(c.X)(b), cpyb = numerics_default.D(c.Y)(b), cpxab = numerics_default.D(c.X)((a + b) * 0.5), cpyab = numerics_default.D(c.Y)((a + b) * 0.5), fa = math_default.hypot(cpxa, cpya), fb = math_default.hypot(cpxb, cpyb), fab = math_default.hypot(cpxab, cpyab);
          return (fa + 4 * fab + fb) * (b - a) / 6;
        }, exactDist = function(t) {
          return c1dist - arclen(c2, t2, t);
        }, beta = Math.PI / 18, beta9 = beta * 9, interval = null;
        this.rolling = function() {
          var h, g, hp, gp, z;
          t1_new = t1 + direction * stepsize;
          c1dist = arclen(c1, t1, t1_new);
          t2_new = numerics_default.root(exactDist, t2);
          h = new complex_default(c1.X(t1_new), c1.Y(t1_new));
          g = new complex_default(c2.X(t2_new), c2.Y(t2_new));
          hp = new complex_default(numerics_default.D(c1.X)(t1_new), numerics_default.D(c1.Y)(t1_new));
          gp = new complex_default(numerics_default.D(c2.X)(t2_new), numerics_default.D(c2.Y)(t2_new));
          z = complex_default.C.div(hp, gp);
          alpha = Math.atan2(z.imaginary, z.real);
          z.div(complex_default.C.abs(z));
          z.mult(g);
          Tx = h.real - z.real;
          Ty = h.imaginary - z.imaginary;
          if (alpha < -beta && alpha > -beta9) {
            alpha = -beta;
            rotationLocal.applyOnce(pointlist);
          } else if (alpha > beta && alpha < beta9) {
            alpha = beta;
            rotationLocal.applyOnce(pointlist);
          } else {
            rotation.applyOnce(pointlist);
            translate.applyOnce(pointlist);
            t1 = t1_new;
            t2 = t2_new;
          }
          brd.update();
        };
        this.start = function() {
          if (time > 0) {
            interval = window.setInterval(this.rolling, time);
          }
          return this;
        };
        this.stop = function() {
          window.clearInterval(interval);
          return this;
        };
        return this;
      };
      return new Roulette();
    }
  }
);
var board_default = jxg_default.Board;

// node_modules/jsxgraph/src/renderer/svg.js
jxg_default.SVGRenderer = function(container, dim) {
  var i2;
  this.type = "svg";
  this.isIE = navigator.appVersion.indexOf("MSIE") !== -1 || navigator.userAgent.match(/Trident\//);
  this.svgRoot = null;
  this.svgNamespace = "http://www.w3.org/2000/svg";
  this.xlinkNamespace = "http://www.w3.org/1999/xlink";
  this.container = container;
  this.container.style.MozUserSelect = "none";
  this.container.style.userSelect = "none";
  this.container.style.overflow = "hidden";
  if (this.container.style.position === "") {
    this.container.style.position = "relative";
  }
  this.svgRoot = this.container.ownerDocument.createElementNS(this.svgNamespace, "svg");
  this.svgRoot.style.overflow = "hidden";
  this.svgRoot.style.display = "block";
  this.resize(dim.width, dim.height);
  this.container.appendChild(this.svgRoot);
  this.defs = this.container.ownerDocument.createElementNS(this.svgNamespace, "defs");
  this.svgRoot.appendChild(this.defs);
  this.createShadowFilter = function(id, rgb, opacity, blend, blur, offset) {
    var filter = this.container.ownerDocument.createElementNS(this.svgNamespace, "filter"), feOffset, feColor, feGaussianBlur, feBlend, mat;
    filter.setAttributeNS(null, "id", id);
    filter.setAttributeNS(null, "width", "300%");
    filter.setAttributeNS(null, "height", "300%");
    filter.setAttributeNS(null, "filterUnits", "userSpaceOnUse");
    feOffset = this.container.ownerDocument.createElementNS(this.svgNamespace, "feOffset");
    feOffset.setAttributeNS(null, "in", "SourceGraphic");
    feOffset.setAttributeNS(null, "result", "offOut");
    feOffset.setAttributeNS(null, "dx", offset[0]);
    feOffset.setAttributeNS(null, "dy", offset[1]);
    filter.appendChild(feOffset);
    feColor = this.container.ownerDocument.createElementNS(this.svgNamespace, "feColorMatrix");
    feColor.setAttributeNS(null, "in", "offOut");
    feColor.setAttributeNS(null, "result", "colorOut");
    feColor.setAttributeNS(null, "type", "matrix");
    if (rgb === "none" || !type_default.isArray(rgb) || rgb.length < 3) {
      feColor.setAttributeNS(null, "values", "0.1 0 0 0 0  0 0.1 0 0 0  0 0 0.1 0 0  0 0 0 " + opacity + " 0");
    } else {
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;
      mat = blend + " 0 0 0 " + rgb[0] + "  0 " + blend + " 0 0 " + rgb[1] + "  0 0 " + blend + " 0 " + rgb[2] + "  0 0 0 " + opacity + " 0";
      feColor.setAttributeNS(null, "values", mat);
    }
    filter.appendChild(feColor);
    feGaussianBlur = this.container.ownerDocument.createElementNS(this.svgNamespace, "feGaussianBlur");
    feGaussianBlur.setAttributeNS(null, "in", "colorOut");
    feGaussianBlur.setAttributeNS(null, "result", "blurOut");
    feGaussianBlur.setAttributeNS(null, "stdDeviation", blur);
    filter.appendChild(feGaussianBlur);
    feBlend = this.container.ownerDocument.createElementNS(this.svgNamespace, "feBlend");
    feBlend.setAttributeNS(null, "in", "SourceGraphic");
    feBlend.setAttributeNS(null, "in2", "blurOut");
    feBlend.setAttributeNS(null, "mode", "normal");
    filter.appendChild(feBlend);
    return filter;
  };
  this.uniqName = function() {
    return this.container.id + "_" + Array.prototype.slice.call(arguments).join("_");
  };
  this.toStr = function() {
    var str2 = Array.prototype.slice.call(arguments).join("");
    if (type_default.exists(CSS) && type_default.exists(CSS.escape)) {
      str2 = CSS.escape(str2);
    }
    return str2;
  };
  this.toURL = function() {
    return "url(#" + this.toStr.apply(this, arguments) + // Pass the arguments to toStr
    ")";
  };
  this.defs.appendChild(this.createShadowFilter(this.uniqName("f1"), "none", 1, 0.1, 3, [5, 5]));
  this.layer = [];
  for (i2 = 0; i2 < options_default.layer.numlayers; i2++) {
    this.layer[i2] = this.container.ownerDocument.createElementNS(this.svgNamespace, "g");
    this.svgRoot.appendChild(this.layer[i2]);
  }
  try {
    this.foreignObjLayer = this.container.ownerDocument.createElementNS(
      this.svgNamespace,
      "foreignObject"
    );
    this.foreignObjLayer.setAttribute("display", "none");
    this.foreignObjLayer.setAttribute("x", 0);
    this.foreignObjLayer.setAttribute("y", 0);
    this.foreignObjLayer.setAttribute("width", "100%");
    this.foreignObjLayer.setAttribute("height", "100%");
    this.foreignObjLayer.setAttribute("id", this.uniqName("foreignObj"));
    this.svgRoot.appendChild(this.foreignObjLayer);
    this.supportsForeignObject = true;
  } catch (e) {
    this.supportsForeignObject = false;
  }
};
jxg_default.SVGRenderer.prototype = new abstract_default();
jxg_default.extend(
  jxg_default.SVGRenderer.prototype,
  /** @lends JXG.SVGRenderer.prototype */
  {
    /**
     * Creates an arrow DOM node. Arrows are displayed in SVG with a <em>marker</em> tag.
     * @private
     * @param {JXG.GeometryElement} el A JSXGraph element, preferably one that can have an arrow attached.
     * @param {String} [idAppendix=''] A string that is added to the node's id.
     * @returns {Node} Reference to the node added to the DOM.
     */
    _createArrowHead: function(el, idAppendix, type) {
      var node2, node3, id = el.id + "Triangle", v, h;
      if (type_default.exists(idAppendix)) {
        id += idAppendix;
      }
      if (type_default.exists(type)) {
        id += type;
      }
      node2 = this.createPrim("marker", id);
      node2.setAttributeNS(null, "stroke", type_default.evaluate(el.visProp.strokecolor));
      node2.setAttributeNS(
        null,
        "stroke-opacity",
        type_default.evaluate(el.visProp.strokeopacity)
      );
      node2.setAttributeNS(null, "fill", type_default.evaluate(el.visProp.strokecolor));
      node2.setAttributeNS(null, "fill-opacity", type_default.evaluate(el.visProp.strokeopacity));
      node2.setAttributeNS(null, "stroke-width", 0);
      node2.setAttributeNS(null, "orient", "auto");
      node2.setAttributeNS(null, "markerUnits", "strokeWidth");
      node3 = this.container.ownerDocument.createElementNS(this.svgNamespace, "path");
      h = 5;
      if (idAppendix === "Start") {
        v = 0;
        if (type === 2) {
          node3.setAttributeNS(null, "d", "M 10,0 L 0,5 L 10,10 L 5,5 z");
        } else if (type === 3) {
          node3.setAttributeNS(null, "d", "M 0,0 L 3.33,0 L 3.33,10 L 0,10 z");
        } else if (type === 4) {
          h = 3.31;
          node3.setAttributeNS(
            null,
            "d",
            "M 0.00,3.31 C 3.53,3.84 7.13,4.50 10.00,6.63 C 9.33,5.52 8.67,4.42 8.00,3.31 C 8.67,2.21 9.33,1.10 10.00,0.00 C 7.13,2.13 3.53,2.79 0.00,3.31"
          );
        } else if (type === 5) {
          h = 3.28;
          node3.setAttributeNS(
            null,
            "d",
            "M 0.00,3.28 C 3.39,4.19 6.81,5.07 10.00,6.55 C 9.38,5.56 9.00,4.44 9.00,3.28 C 9.00,2.11 9.38,0.99 10.00,0.00 C 6.81,1.49 3.39,2.37 0.00,3.28"
          );
        } else if (type === 6) {
          h = 2.84;
          node3.setAttributeNS(
            null,
            "d",
            "M 0.00,2.84 C 3.39,3.59 6.79,4.35 10.00,5.68 C 9.67,4.73 9.33,3.78 9.00,2.84 C 9.33,1.89 9.67,0.95 10.00,0.00 C 6.79,1.33 3.39,2.09 0.00,2.84"
          );
        } else if (type === 7) {
          h = 5.2;
          node3.setAttributeNS(
            null,
            "d",
            "M 0.00,5.20 C 4.04,5.20 7.99,6.92 10.00,10.39 M 10.00,0.00 C 7.99,3.47 4.04,5.20 0.00,5.20"
          );
        } else {
          node3.setAttributeNS(null, "d", "M 10,0 L 0,5 L 10,10 z");
        }
        if (
          // !Type.exists(el.rendNode.getTotalLength) &&
          el.elementClass === constants_default.OBJECT_CLASS_LINE
        ) {
          if (type === 2) {
            v = 4.9;
          } else if (type === 3) {
            v = 3.3;
          } else if (type === 4 || type === 5 || type === 6) {
            v = 6.66;
          } else if (type === 7) {
            v = 0;
          } else {
            v = 10;
          }
        }
      } else {
        v = 10;
        if (type === 2) {
          node3.setAttributeNS(null, "d", "M 0,0 L 10,5 L 0,10 L 5,5 z");
        } else if (type === 3) {
          v = 3.3;
          node3.setAttributeNS(null, "d", "M 0,0 L 3.33,0 L 3.33,10 L 0,10 z");
        } else if (type === 4) {
          h = 3.31;
          node3.setAttributeNS(
            null,
            "d",
            "M 10.00,3.31 C 6.47,3.84 2.87,4.50 0.00,6.63 C 0.67,5.52 1.33,4.42 2.00,3.31 C 1.33,2.21 0.67,1.10 0.00,0.00 C 2.87,2.13 6.47,2.79 10.00,3.31"
          );
        } else if (type === 5) {
          h = 3.28;
          node3.setAttributeNS(
            null,
            "d",
            "M 10.00,3.28 C 6.61,4.19 3.19,5.07 0.00,6.55 C 0.62,5.56 1.00,4.44 1.00,3.28 C 1.00,2.11 0.62,0.99 0.00,0.00 C 3.19,1.49 6.61,2.37 10.00,3.28"
          );
        } else if (type === 6) {
          h = 2.84;
          node3.setAttributeNS(
            null,
            "d",
            "M 10.00,2.84 C 6.61,3.59 3.21,4.35 0.00,5.68 C 0.33,4.73 0.67,3.78 1.00,2.84 C 0.67,1.89 0.33,0.95 0.00,0.00 C 3.21,1.33 6.61,2.09 10.00,2.84"
          );
        } else if (type === 7) {
          h = 5.2;
          node3.setAttributeNS(
            null,
            "d",
            "M 10.00,5.20 C 5.96,5.20 2.01,6.92 0.00,10.39 M 0.00,0.00 C 2.01,3.47 5.96,5.20 10.00,5.20"
          );
        } else {
          node3.setAttributeNS(null, "d", "M 0,0 L 10,5 L 0,10 z");
        }
        if (
          // !Type.exists(el.rendNode.getTotalLength) &&
          el.elementClass === constants_default.OBJECT_CLASS_LINE
        ) {
          if (type === 2) {
            v = 5.1;
          } else if (type === 3) {
            v = 0.02;
          } else if (type === 4 || type === 5 || type === 6) {
            v = 3.33;
          } else if (type === 7) {
            v = 10;
          } else {
            v = 0.05;
          }
        }
      }
      if (type === 7) {
        node2.setAttributeNS(null, "fill", "none");
        node2.setAttributeNS(null, "stroke-width", 1);
      }
      node2.setAttributeNS(null, "refY", h);
      node2.setAttributeNS(null, "refX", v);
      node2.appendChild(node3);
      return node2;
    },
    /**
     * Updates color of an arrow DOM node.
     * @param {Node} node The arrow node.
     * @param {String} color Color value in a HTML compatible format, e.g. <tt>#00ff00</tt> or <tt>green</tt> for green.
     * @param {Number} opacity
     * @param {JXG.GeometryElement} el The element the arrows are to be attached to
     */
    _setArrowColor: function(node2, color2, opacity, el, type) {
      if (node2) {
        if (type_default.isString(color2)) {
          if (type !== 7) {
            this._setAttribute(function() {
              node2.setAttributeNS(null, "stroke", color2);
              node2.setAttributeNS(null, "fill", color2);
              node2.setAttributeNS(null, "stroke-opacity", opacity);
              node2.setAttributeNS(null, "fill-opacity", opacity);
            }, el.visPropOld.fillcolor);
          } else {
            this._setAttribute(function() {
              node2.setAttributeNS(null, "fill", "none");
              node2.setAttributeNS(null, "stroke", color2);
              node2.setAttributeNS(null, "stroke-opacity", opacity);
            }, el.visPropOld.fillcolor);
          }
        }
        if (this.isIE) {
          el.rendNode.parentNode.insertBefore(el.rendNode, el.rendNode);
        }
      }
    },
    // Already documented in JXG.AbstractRenderer
    _setArrowWidth: function(node2, width, parentNode, size2) {
      var s, d;
      if (node2) {
        s = width;
        d = s * size2;
        node2.setAttributeNS(null, "viewBox", 0 + " " + 0 + " " + s * 10 + " " + s * 10);
        node2.setAttributeNS(null, "markerHeight", d);
        node2.setAttributeNS(null, "markerWidth", d);
        node2.setAttributeNS(null, "display", "inherit");
        if (this.isIE) {
          parentNode.parentNode.insertBefore(parentNode, parentNode);
        }
      }
    },
    /* ******************************** *
     *  This renderer does not need to
     *  override draw/update* methods
     *  since it provides draw/update*Prim
     *  methods except for some cases like
     *  internal texts or images.
     * ******************************** */
    /* **************************
     *    Lines
     * **************************/
    // documented in AbstractRenderer
    updateTicks: function(ticks) {
      var i2, j, c, node2, x, y, tickStr = "", len = ticks.ticks.length, len2, str2, isReal = true;
      for (i2 = 0; i2 < len; i2++) {
        c = ticks.ticks[i2];
        x = c[0];
        y = c[1];
        len2 = x.length;
        str2 = " M " + x[0] + " " + y[0];
        if (!type_default.isNumber(x[0])) {
          isReal = false;
        }
        for (j = 1; isReal && j < len2; ++j) {
          if (type_default.isNumber(x[j])) {
            str2 += " L " + x[j] + " " + y[j];
          } else {
            isReal = false;
          }
        }
        if (isReal) {
          tickStr += str2;
        }
      }
      node2 = ticks.rendNode;
      if (!type_default.exists(node2)) {
        node2 = this.createPrim("path", ticks.id);
        this.appendChildPrim(node2, type_default.evaluate(ticks.visProp.layer));
        ticks.rendNode = node2;
      }
      node2.setAttributeNS(null, "stroke", type_default.evaluate(ticks.visProp.strokecolor));
      node2.setAttributeNS(null, "fill", "none");
      node2.setAttributeNS(
        null,
        "stroke-opacity",
        type_default.evaluate(ticks.visProp.strokeopacity)
      );
      node2.setAttributeNS(null, "stroke-width", type_default.evaluate(ticks.visProp.strokewidth));
      this.updatePathPrim(node2, tickStr, ticks.board);
      this.setObjectViewport(ticks);
    },
    /* **************************
     *    Text related stuff
     * **************************/
    // Already documented in JXG.AbstractRenderer
    displayCopyright: function(str2, fontsize) {
      var node2 = this.createPrim("text", "licenseText"), t;
      node2.setAttributeNS(null, "x", "20px");
      node2.setAttributeNS(null, "y", 2 + fontsize + "px");
      node2.setAttributeNS(null, "style", "font-family:Arial,Helvetica,sans-serif; font-size:" + fontsize + "px; fill:#356AA0;  opacity:0.3;");
      t = this.container.ownerDocument.createTextNode(str2);
      node2.appendChild(t);
      this.appendChildPrim(node2, 0);
    },
    // Already documented in JXG.AbstractRenderer
    drawInternalText: function(el) {
      var node2 = this.createPrim("text", el.id);
      node2.style.whiteSpace = "nowrap";
      el.rendNodeText = this.container.ownerDocument.createTextNode("");
      node2.appendChild(el.rendNodeText);
      this.appendChildPrim(node2, type_default.evaluate(el.visProp.layer));
      return node2;
    },
    // Already documented in JXG.AbstractRenderer
    updateInternalText: function(el) {
      var content = el.plaintext, v, ev_ax = el.getAnchorX(), ev_ay = el.getAnchorY();
      if (el.rendNode.getAttributeNS(null, "class") !== el.visProp.cssclass) {
        el.rendNode.setAttributeNS(null, "class", type_default.evaluate(el.visProp.cssclass));
        el.needsSizeUpdate = true;
      }
      if (!isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])) {
        v = el.coords.scrCoords[1];
        if (el.visPropOld.left !== ev_ax + v) {
          el.rendNode.setAttributeNS(null, "x", v + "px");
          if (ev_ax === "left") {
            el.rendNode.setAttributeNS(null, "text-anchor", "start");
          } else if (ev_ax === "right") {
            el.rendNode.setAttributeNS(null, "text-anchor", "end");
          } else if (ev_ax === "middle") {
            el.rendNode.setAttributeNS(null, "text-anchor", "middle");
          }
          el.visPropOld.left = ev_ax + v;
        }
        v = el.coords.scrCoords[2];
        if (el.visPropOld.top !== ev_ay + v) {
          el.rendNode.setAttributeNS(null, "y", v + this.vOffsetText * 0.5 + "px");
          if (ev_ay === "bottom") {
            el.rendNode.setAttributeNS(null, "dy", "0");
            el.rendNode.setAttributeNS(null, "dominant-baseline", "auto");
          } else if (ev_ay === "top") {
            el.rendNode.setAttributeNS(null, "dy", "1.6ex");
            el.rendNode.setAttributeNS(null, "dominant-baseline", "auto");
          } else if (ev_ay === "middle") {
            el.rendNode.setAttributeNS(null, "dy", "0.6ex");
            el.rendNode.setAttributeNS(null, "dominant-baseline", "auto");
          }
          el.visPropOld.top = ev_ay + v;
        }
      }
      if (el.htmlStr !== content) {
        el.rendNodeText.data = content;
        el.htmlStr = content;
      }
      this.transformImage(el, el.transformations);
    },
    /**
     * Set color and opacity of internal texts.
     * @private
     * @see JXG.AbstractRenderer#updateTextStyle
     * @see JXG.AbstractRenderer#updateInternalTextStyle
     */
    updateInternalTextStyle: function(el, strokeColor, strokeOpacity, duration) {
      this.setObjectViewport(el);
      this.setObjectFillColor(el, strokeColor, strokeOpacity);
    },
    /* **************************
     *    Image related stuff
     * **************************/
    // Already documented in JXG.AbstractRenderer
    drawImage: function(el) {
      var node2 = this.createPrim("image", el.id);
      node2.setAttributeNS(null, "preserveAspectRatio", "none");
      this.appendChildPrim(node2, type_default.evaluate(el.visProp.layer));
      el.rendNode = node2;
      this.updateImage(el);
    },
    // Already documented in JXG.AbstractRenderer
    transformImage: function(el, t) {
      var s, m, node2 = el.rendNode, str2 = "", cx, cy, len = t.length;
      if (len > 0) {
        m = this.joinTransforms(el, t);
        s = [m[1][1], m[2][1], m[1][2], m[2][2], m[1][0], m[2][0]].join(",");
        if (s.indexOf("NaN") === -1) {
          str2 += " matrix(" + s + ") ";
          if (el.elementClass === constants_default.OBJECT_CLASS_TEXT && el.visProp.display === "html") {
            node2.style.transform = str2;
            cx = -el.coords.scrCoords[1];
            cy = -el.coords.scrCoords[2];
            switch (type_default.evaluate(el.visProp.anchorx)) {
              case "right":
                cx += el.size[0];
                break;
              case "middle":
                cx += el.size[0] * 0.5;
                break;
            }
            switch (type_default.evaluate(el.visProp.anchory)) {
              case "bottom":
                cy += el.size[1];
                break;
              case "middle":
                cy += el.size[1] * 0.5;
                break;
            }
            node2.style["transform-origin"] = cx + "px " + cy + "px";
          } else {
            node2.setAttributeNS(null, "transform", str2);
          }
        }
      }
    },
    // Already documented in JXG.AbstractRenderer
    updateImageURL: function(el) {
      var url = type_default.evaluate(el.url);
      if (el._src !== url) {
        el.imgIsLoaded = false;
        el.rendNode.setAttributeNS(this.xlinkNamespace, "xlink:href", url);
        el._src = url;
        return true;
      }
      return false;
    },
    // Already documented in JXG.AbstractRenderer
    updateImageStyle: function(el, doHighlight) {
      var css = type_default.evaluate(
        doHighlight ? el.visProp.highlightcssclass : el.visProp.cssclass
      );
      el.rendNode.setAttributeNS(null, "class", css);
    },
    // Already documented in JXG.AbstractRenderer
    drawForeignObject: function(el) {
      el.rendNode = this.appendChildPrim(
        this.createPrim("foreignObject", el.id),
        type_default.evaluate(el.visProp.layer)
      );
      this.appendNodesToElement(el, "foreignObject");
      this.updateForeignObject(el);
    },
    // Already documented in JXG.AbstractRenderer
    updateForeignObject: function(el) {
      if (el._useUserSize) {
        el.rendNode.style.overflow = "hidden";
      } else {
        el.rendNode.style.overflow = "visible";
      }
      this.updateRectPrim(
        el.rendNode,
        el.coords.scrCoords[1],
        el.coords.scrCoords[2] - el.size[1],
        el.size[0],
        el.size[1]
      );
      el.rendNode.innerHTML = el.content;
      this._updateVisual(el, { stroke: true, dash: true }, true);
    },
    /* **************************
     * Render primitive objects
     * **************************/
    // Already documented in JXG.AbstractRenderer
    appendChildPrim: function(node2, level) {
      if (!type_default.exists(level)) {
        level = 0;
      } else if (level >= options_default.layer.numlayers) {
        level = options_default.layer.numlayers - 1;
      }
      this.layer[level].appendChild(node2);
      return node2;
    },
    // Already documented in JXG.AbstractRenderer
    createPrim: function(type, id) {
      var node2 = this.container.ownerDocument.createElementNS(this.svgNamespace, type);
      node2.setAttributeNS(null, "id", this.uniqName(id));
      node2.style.position = "absolute";
      if (type === "path") {
        node2.setAttributeNS(null, "stroke-linecap", "round");
        node2.setAttributeNS(null, "stroke-linejoin", "round");
        node2.setAttributeNS(null, "fill-rule", "evenodd");
      }
      return node2;
    },
    // Already documented in JXG.AbstractRenderer
    remove: function(shape) {
      if (type_default.exists(shape) && type_default.exists(shape.parentNode)) {
        shape.parentNode.removeChild(shape);
      }
    },
    // Already documented in JXG.AbstractRenderer
    setLayer: function(el, level) {
      if (!type_default.exists(level)) {
        level = 0;
      } else if (level >= options_default.layer.numlayers) {
        level = options_default.layer.numlayers - 1;
      }
      this.layer[level].appendChild(el.rendNode);
    },
    // Already documented in JXG.AbstractRenderer
    makeArrows: function(el, a) {
      var node2, str2, ev_fa = a.evFirst, ev_la = a.evLast;
      if (this.isIE && el.visPropCalc.visible && (ev_fa || ev_la)) {
        el.rendNode.parentNode.insertBefore(el.rendNode, el.rendNode);
        return;
      }
      node2 = el.rendNodeTriangleStart;
      if (ev_fa) {
        str2 = this.toStr(this.container.id, "_", el.id, "TriangleStart", a.typeFirst);
        if (!type_default.exists(node2) || node2.id !== str2) {
          node2 = this.container.ownerDocument.getElementById(str2);
          if (node2 === null) {
            node2 = this._createArrowHead(el, "Start", a.typeFirst);
            this.defs.appendChild(node2);
          }
          el.rendNodeTriangleStart = node2;
          el.rendNode.setAttributeNS(null, "marker-start", this.toURL(str2));
        }
      } else if (type_default.exists(node2)) {
        this.remove(node2);
      }
      node2 = el.rendNodeTriangleEnd;
      if (ev_la) {
        str2 = this.toStr(this.container.id, "_", el.id, "TriangleEnd", a.typeLast);
        if (!type_default.exists(node2) || node2.id !== str2) {
          node2 = this.container.ownerDocument.getElementById(str2);
          if (node2 === null) {
            node2 = this._createArrowHead(el, "End", a.typeLast);
            this.defs.appendChild(node2);
          }
          el.rendNodeTriangleEnd = node2;
          el.rendNode.setAttributeNS(null, "marker-end", this.toURL(str2));
        }
      } else if (type_default.exists(node2)) {
        this.remove(node2);
      }
    },
    // Already documented in JXG.AbstractRenderer
    updateEllipsePrim: function(node2, x, y, rx, ry) {
      var huge = 1e6;
      huge = 2e5;
      x = Math.abs(x) < huge ? x : huge * x / Math.abs(x);
      y = Math.abs(y) < huge ? y : huge * y / Math.abs(y);
      rx = Math.abs(rx) < huge ? rx : huge * rx / Math.abs(rx);
      ry = Math.abs(ry) < huge ? ry : huge * ry / Math.abs(ry);
      node2.setAttributeNS(null, "cx", x);
      node2.setAttributeNS(null, "cy", y);
      node2.setAttributeNS(null, "rx", Math.abs(rx));
      node2.setAttributeNS(null, "ry", Math.abs(ry));
    },
    // Already documented in JXG.AbstractRenderer
    updateLinePrim: function(node2, p1x, p1y, p2x, p2y) {
      var huge = 1e6;
      huge = 2e5;
      if (!isNaN(p1x + p1y + p2x + p2y)) {
        p1x = Math.abs(p1x) < huge ? p1x : huge * p1x / Math.abs(p1x);
        p1y = Math.abs(p1y) < huge ? p1y : huge * p1y / Math.abs(p1y);
        p2x = Math.abs(p2x) < huge ? p2x : huge * p2x / Math.abs(p2x);
        p2y = Math.abs(p2y) < huge ? p2y : huge * p2y / Math.abs(p2y);
        node2.setAttributeNS(null, "x1", p1x);
        node2.setAttributeNS(null, "y1", p1y);
        node2.setAttributeNS(null, "x2", p2x);
        node2.setAttributeNS(null, "y2", p2y);
      }
    },
    // Already documented in JXG.AbstractRenderer
    updatePathPrim: function(node2, pointString) {
      if (pointString === "") {
        pointString = "M 0 0";
      }
      node2.setAttributeNS(null, "d", pointString);
    },
    // Already documented in JXG.AbstractRenderer
    updatePathStringPoint: function(el, size2, type) {
      var s = "", scr = el.coords.scrCoords, sqrt32 = size2 * Math.sqrt(3) * 0.5, s05 = size2 * 0.5;
      if (type === "x") {
        s = " M " + (scr[1] - size2) + " " + (scr[2] - size2) + " L " + (scr[1] + size2) + " " + (scr[2] + size2) + " M " + (scr[1] + size2) + " " + (scr[2] - size2) + " L " + (scr[1] - size2) + " " + (scr[2] + size2);
      } else if (type === "+") {
        s = " M " + (scr[1] - size2) + " " + scr[2] + " L " + (scr[1] + size2) + " " + scr[2] + " M " + scr[1] + " " + (scr[2] - size2) + " L " + scr[1] + " " + (scr[2] + size2);
      } else if (type === "|") {
        s = " M " + scr[1] + " " + (scr[2] - size2) + " L " + scr[1] + " " + (scr[2] + size2);
      } else if (type === "-") {
        s = " M " + (scr[1] - size2) + " " + scr[2] + " L " + (scr[1] + size2) + " " + scr[2];
      } else if (type === "<>" || type === "<<>>") {
        if (type === "<<>>") {
          size2 *= 1.41;
        }
        s = " M " + (scr[1] - size2) + " " + scr[2] + " L " + scr[1] + " " + (scr[2] + size2) + " L " + (scr[1] + size2) + " " + scr[2] + " L " + scr[1] + " " + (scr[2] - size2) + " Z ";
      } else if (type === "^") {
        s = " M " + scr[1] + " " + (scr[2] - size2) + " L " + (scr[1] - sqrt32) + " " + (scr[2] + s05) + " L " + (scr[1] + sqrt32) + " " + (scr[2] + s05) + " Z ";
      } else if (type === "v") {
        s = " M " + scr[1] + " " + (scr[2] + size2) + " L " + (scr[1] - sqrt32) + " " + (scr[2] - s05) + " L " + (scr[1] + sqrt32) + " " + (scr[2] - s05) + " Z ";
      } else if (type === ">") {
        s = " M " + (scr[1] + size2) + " " + scr[2] + " L " + (scr[1] - s05) + " " + (scr[2] - sqrt32) + " L " + (scr[1] - s05) + " " + (scr[2] + sqrt32) + " Z ";
      } else if (type === "<") {
        s = " M " + (scr[1] - size2) + " " + scr[2] + " L " + (scr[1] + s05) + " " + (scr[2] - sqrt32) + " L " + (scr[1] + s05) + " " + (scr[2] + sqrt32) + " Z ";
      }
      return s;
    },
    // Already documented in JXG.AbstractRenderer
    updatePathStringPrim: function(el) {
      var i2, scr, len, symbm = " M ", symbl = " L ", symbc = " C ", nextSymb = symbm, maxSize = 5e3, pStr = "";
      if (el.numberPoints <= 0) {
        return "";
      }
      len = Math.min(el.points.length, el.numberPoints);
      if (el.bezierDegree === 1) {
        for (i2 = 0; i2 < len; i2++) {
          scr = el.points[i2].scrCoords;
          if (isNaN(scr[1]) || isNaN(scr[2])) {
            nextSymb = symbm;
          } else {
            scr[1] = Math.max(Math.min(scr[1], maxSize), -maxSize);
            scr[2] = Math.max(Math.min(scr[2], maxSize), -maxSize);
            pStr += nextSymb + scr[1] + " " + scr[2];
            nextSymb = symbl;
          }
        }
      } else if (el.bezierDegree === 3) {
        i2 = 0;
        while (i2 < len) {
          scr = el.points[i2].scrCoords;
          if (isNaN(scr[1]) || isNaN(scr[2])) {
            nextSymb = symbm;
          } else {
            pStr += nextSymb + scr[1] + " " + scr[2];
            if (nextSymb === symbc) {
              i2 += 1;
              scr = el.points[i2].scrCoords;
              pStr += " " + scr[1] + " " + scr[2];
              i2 += 1;
              scr = el.points[i2].scrCoords;
              pStr += " " + scr[1] + " " + scr[2];
            }
            nextSymb = symbc;
          }
          i2 += 1;
        }
      }
      return pStr;
    },
    // Already documented in JXG.AbstractRenderer
    updatePathStringBezierPrim: function(el) {
      var i2, j, k, scr, lx, ly, len, symbm = " M ", symbl = " C ", nextSymb = symbm, maxSize = 5e3, pStr = "", f = type_default.evaluate(el.visProp.strokewidth), isNoPlot = type_default.evaluate(el.visProp.curvetype) !== "plot";
      if (el.numberPoints <= 0) {
        return "";
      }
      if (isNoPlot && el.board.options.curve.RDPsmoothing) {
        el.points = numerics_default.RamerDouglasPeucker(el.points, 0.5);
      }
      len = Math.min(el.points.length, el.numberPoints);
      for (j = 1; j < 3; j++) {
        nextSymb = symbm;
        for (i2 = 0; i2 < len; i2++) {
          scr = el.points[i2].scrCoords;
          if (isNaN(scr[1]) || isNaN(scr[2])) {
            nextSymb = symbm;
          } else {
            scr[1] = Math.max(Math.min(scr[1], maxSize), -maxSize);
            scr[2] = Math.max(Math.min(scr[2], maxSize), -maxSize);
            if (nextSymb === symbm) {
              pStr += nextSymb + scr[1] + " " + scr[2];
            } else {
              k = 2 * j;
              pStr += [
                nextSymb,
                lx + (scr[1] - lx) * 0.333 + f * (k * Math.random() - j),
                " ",
                ly + (scr[2] - ly) * 0.333 + f * (k * Math.random() - j),
                " ",
                lx + (scr[1] - lx) * 0.666 + f * (k * Math.random() - j),
                " ",
                ly + (scr[2] - ly) * 0.666 + f * (k * Math.random() - j),
                " ",
                scr[1],
                " ",
                scr[2]
              ].join("");
            }
            nextSymb = symbl;
            lx = scr[1];
            ly = scr[2];
          }
        }
      }
      return pStr;
    },
    // Already documented in JXG.AbstractRenderer
    updatePolygonPrim: function(node2, el) {
      var i2, pStr = "", scrCoords, len = el.vertices.length;
      node2.setAttributeNS(null, "stroke", "none");
      node2.setAttributeNS(null, "fill-rule", "evenodd");
      if (el.elType === "polygonalchain") {
        len++;
      }
      for (i2 = 0; i2 < len - 1; i2++) {
        if (el.vertices[i2].isReal) {
          scrCoords = el.vertices[i2].coords.scrCoords;
          pStr = pStr + scrCoords[1] + "," + scrCoords[2];
        } else {
          node2.setAttributeNS(null, "points", "");
          return;
        }
        if (i2 < len - 2) {
          pStr += " ";
        }
      }
      if (pStr.indexOf("NaN") === -1) {
        node2.setAttributeNS(null, "points", pStr);
      }
    },
    // Already documented in JXG.AbstractRenderer
    updateRectPrim: function(node2, x, y, w, h) {
      node2.setAttributeNS(null, "x", x);
      node2.setAttributeNS(null, "y", y);
      node2.setAttributeNS(null, "width", w);
      node2.setAttributeNS(null, "height", h);
    },
    /* **************************
     *  Set Attributes
     * **************************/
    // documented in JXG.AbstractRenderer
    setPropertyPrim: function(node2, key, val) {
      if (key === "stroked") {
        return;
      }
      node2.setAttributeNS(null, key, val);
    },
    display: function(el, val) {
      var node2;
      if (el && el.rendNode) {
        el.visPropOld.visible = val;
        node2 = el.rendNode;
        if (val) {
          node2.setAttributeNS(null, "display", "inline");
          node2.style.visibility = "inherit";
        } else {
          node2.setAttributeNS(null, "display", "none");
          node2.style.visibility = "hidden";
        }
      }
    },
    // documented in JXG.AbstractRenderer
    show: function(el) {
      jxg_default.deprecated("Board.renderer.show()", "Board.renderer.display()");
      this.display(el, true);
    },
    // documented in JXG.AbstractRenderer
    hide: function(el) {
      jxg_default.deprecated("Board.renderer.hide()", "Board.renderer.display()");
      this.display(el, false);
    },
    // documented in JXG.AbstractRenderer
    setBuffering: function(el, type) {
      el.rendNode.setAttribute("buffered-rendering", type);
    },
    // documented in JXG.AbstractRenderer
    setDashStyle: function(el) {
      var dashStyle = type_default.evaluate(el.visProp.dash), ds = type_default.evaluate(el.visProp.dashscale), sw = ds ? 0.5 * type_default.evaluate(el.visProp.strokewidth) : 1, node2 = el.rendNode;
      if (dashStyle > 0) {
        node2.setAttributeNS(
          null,
          "stroke-dasharray",
          // sw could distinguish highlighting or not.
          // But it seems to preferable to ignore this.
          this.dashArray[dashStyle - 1].map(function(x) {
            return x * sw;
          }).join(",")
        );
      } else {
        if (node2.hasAttributeNS(null, "stroke-dasharray")) {
          node2.removeAttributeNS(null, "stroke-dasharray");
        }
      }
    },
    // documented in JXG.AbstractRenderer
    setGradient: function(el) {
      var fillNode = el.rendNode, node2, node22, node3, ev_g = type_default.evaluate(el.visProp.gradient);
      if (ev_g === "linear" || ev_g === "radial") {
        node2 = this.createPrim(ev_g + "Gradient", el.id + "_gradient");
        node22 = this.createPrim("stop", el.id + "_gradient1");
        node3 = this.createPrim("stop", el.id + "_gradient2");
        node2.appendChild(node22);
        node2.appendChild(node3);
        this.defs.appendChild(node2);
        fillNode.setAttributeNS(
          null,
          "style",
          // "fill:url(#" + this.container.id + "_" + el.id + "_gradient)"
          "fill:" + this.toURL(this.container.id + "_" + el.id + "_gradient")
        );
        el.gradNode1 = node22;
        el.gradNode2 = node3;
        el.gradNode = node2;
      } else {
        fillNode.removeAttributeNS(null, "style");
      }
    },
    /**
     * Set the gradient angle for linear color gradients.
     *
     * @private
     * @param {SVGnode} node SVG gradient node of an arbitrary JSXGraph element.
     * @param {Number} radians angle value in radians. 0 is horizontal from left to right, Pi/4 is vertical from top to bottom.
     */
    updateGradientAngle: function(node2, radians) {
      var f = 1, co = Math.cos(radians), si = Math.sin(radians);
      if (Math.abs(co) > Math.abs(si)) {
        f /= Math.abs(co);
      } else {
        f /= Math.abs(si);
      }
      if (co >= 0) {
        node2.setAttributeNS(null, "x1", 0);
        node2.setAttributeNS(null, "x2", co * f);
      } else {
        node2.setAttributeNS(null, "x1", -co * f);
        node2.setAttributeNS(null, "x2", 0);
      }
      if (si >= 0) {
        node2.setAttributeNS(null, "y1", 0);
        node2.setAttributeNS(null, "y2", si * f);
      } else {
        node2.setAttributeNS(null, "y1", -si * f);
        node2.setAttributeNS(null, "y2", 0);
      }
    },
    /**
     * Set circles for radial color gradients.
     *
     * @private
     * @param {SVGnode} node SVG gradient node
     * @param {Number} cx SVG value cx (value between 0 and 1)
     * @param {Number} cy  SVG value cy (value between 0 and 1)
     * @param {Number} r  SVG value r (value between 0 and 1)
     * @param {Number} fx  SVG value fx (value between 0 and 1)
     * @param {Number} fy  SVG value fy (value between 0 and 1)
     * @param {Number} fr  SVG value fr (value between 0 and 1)
     */
    updateGradientCircle: function(node2, cx, cy, r, fx, fy, fr) {
      node2.setAttributeNS(null, "cx", cx * 100 + "%");
      node2.setAttributeNS(null, "cy", cy * 100 + "%");
      node2.setAttributeNS(null, "r", r * 100 + "%");
      node2.setAttributeNS(null, "fx", fx * 100 + "%");
      node2.setAttributeNS(null, "fy", fy * 100 + "%");
      node2.setAttributeNS(null, "fr", fr * 100 + "%");
    },
    // documented in JXG.AbstractRenderer
    updateGradient: function(el) {
      var col, op, node2 = el.gradNode1, node3 = el.gradNode2, ev_g = type_default.evaluate(el.visProp.gradient);
      if (!type_default.exists(node2) || !type_default.exists(node3)) {
        return;
      }
      op = type_default.evaluate(el.visProp.fillopacity);
      op = op > 0 ? op : 0;
      col = type_default.evaluate(el.visProp.fillcolor);
      node2.setAttributeNS(null, "style", "stop-color:" + col + ";stop-opacity:" + op);
      node3.setAttributeNS(
        null,
        "style",
        "stop-color:" + type_default.evaluate(el.visProp.gradientsecondcolor) + ";stop-opacity:" + type_default.evaluate(el.visProp.gradientsecondopacity)
      );
      node2.setAttributeNS(
        null,
        "offset",
        type_default.evaluate(el.visProp.gradientstartoffset) * 100 + "%"
      );
      node3.setAttributeNS(
        null,
        "offset",
        type_default.evaluate(el.visProp.gradientendoffset) * 100 + "%"
      );
      if (ev_g === "linear") {
        this.updateGradientAngle(el.gradNode, type_default.evaluate(el.visProp.gradientangle));
      } else if (ev_g === "radial") {
        this.updateGradientCircle(
          el.gradNode,
          type_default.evaluate(el.visProp.gradientcx),
          type_default.evaluate(el.visProp.gradientcy),
          type_default.evaluate(el.visProp.gradientr),
          type_default.evaluate(el.visProp.gradientfx),
          type_default.evaluate(el.visProp.gradientfy),
          type_default.evaluate(el.visProp.gradientfr)
        );
      }
    },
    // documented in JXG.AbstractRenderer
    setObjectTransition: function(el, duration) {
      var node2, props, transitionArr = [], transitionStr, i2, len = 0, nodes = ["rendNode", "rendNodeTriangleStart", "rendNodeTriangleEnd"];
      if (duration === void 0) {
        duration = type_default.evaluate(el.visProp.transitionduration);
      }
      props = type_default.evaluate(el.visProp.transitionproperties);
      if (duration === el.visPropOld.transitionduration && props === el.visPropOld.transitionproperties) {
        return;
      }
      if (type_default.exists(props)) {
        len = props.length;
      }
      for (i2 = 0; i2 < len; i2++) {
        transitionArr.push(props[i2] + " " + duration + "ms");
      }
      transitionStr = transitionArr.join(", ");
      len = nodes.length;
      for (i2 = 0; i2 < len; ++i2) {
        if (el[nodes[i2]]) {
          node2 = el[nodes[i2]];
          node2.style.transition = transitionStr;
        }
      }
      el.visPropOld.transitionduration = duration;
      el.visPropOld.transitionproperties = props;
    },
    // documented in JXG.AbstractRenderer
    setObjectViewport: function(el, isHtml) {
      var val = type_default.evaluate(el.visProp.viewport), vp, i2, len = 0, bb, bbc, l, t, r, b, nodes = ["rendNode"];
      if (val === "inherit") {
        val = type_default.evaluate(el.board.attr.viewport);
      }
      if (isHtml) {
        bb = el.rendNode.getBoundingClientRect();
        bbc = this.container.getBoundingClientRect();
        t = parseFloat(val[1]);
        r = parseFloat(val[2]);
        b = parseFloat(val[3]);
        l = parseFloat(val[0]);
        if (type_default.isString(val[1]) && val[1].indexOf("%") > 0) {
          t = bbc.height * t / 100;
        }
        if (type_default.isString(val[2]) && val[2].indexOf("%") > 0) {
          r = bbc.width * r / 100;
        }
        if (type_default.isString(val[3]) && val[3].indexOf("%") > 0) {
          b = bbc.height * b / 100;
        }
        if (type_default.isString(val[0]) && val[0].indexOf("%") > 0) {
          l = bbc.width * l / 100;
        }
        t = parseFloat(bbc.top) - parseFloat(bb.top) + t;
        r = parseFloat(bb.right) - parseFloat(bbc.right) + r;
        b = parseFloat(bb.bottom) - parseFloat(bbc.bottom) + b;
        l = parseFloat(bbc.left) - parseFloat(bb.left) + l;
        val = [l, t, r, b];
      }
      vp = [
        typeof val[1] === "number" ? val[1] + "px" : val[1],
        typeof val[2] === "number" ? val[2] + "px" : val[2],
        typeof val[3] === "number" ? val[3] + "px" : val[3],
        typeof val[0] === "number" ? val[0] + "px" : val[0]
      ].join(" ");
      len = nodes.length;
      for (i2 = 0; i2 < len; ++i2) {
        if (el[nodes[i2]]) {
          if (isHtml) {
            el[nodes[i2]].style.clipPath = "inset(" + vp + ")";
          } else {
            el[nodes[i2]].setAttributeNS(null, "clip-path", "view-box inset(" + vp + ")");
          }
        }
      }
    },
    /**
     * Call user-defined function to set visual attributes.
     * If "testAttribute" is the empty string, the function
     * is called immediately, otherwise it is called in a timeOut.
     *
     * This is necessary to realize smooth transitions but avoid transitions
     * when first creating the objects.
     *
     * Usually, the string in testAttribute is the visPropOld attribute
     * of the values which are set.
     *
     * @param {Function} setFunc       Some function which usually sets some attributes
     * @param {String} testAttribute If this string is the empty string  the function is called immediately,
     *                               otherwise it is called in a setImeout.
     * @see JXG.SVGRenderer#setObjectFillColor
     * @see JXG.SVGRenderer#setObjectStrokeColor
     * @see JXG.SVGRenderer#_setArrowColor
     * @private
     */
    _setAttribute: function(setFunc, testAttribute) {
      if (testAttribute === "") {
        setFunc();
      } else {
        window.setTimeout(setFunc, 1);
      }
    },
    // documented in JXG.AbstractRenderer
    setObjectFillColor: function(el, color2, opacity, rendNode) {
      var node2, c, rgbo, oo, rgba = type_default.evaluate(color2), o = type_default.evaluate(opacity), grad = type_default.evaluate(el.visProp.gradient);
      o = o > 0 ? o : 0;
      if (el.visPropOld.fillcolor === rgba && el.visPropOld.fillopacity === o && grad === null) {
        return;
      }
      if (type_default.exists(rgba) && rgba !== false) {
        if (rgba.length !== 9) {
          c = rgba;
          oo = o;
        } else {
          rgbo = color_default.rgba2rgbo(rgba);
          c = rgbo[0];
          oo = o * rgbo[1];
        }
        if (rendNode === void 0) {
          node2 = el.rendNode;
        } else {
          node2 = rendNode;
        }
        if (c !== "none") {
          this._setAttribute(function() {
            node2.setAttributeNS(null, "fill", c);
          }, el.visPropOld.fillcolor);
        }
        if (el.type === jxg_default.OBJECT_TYPE_IMAGE) {
          this._setAttribute(function() {
            node2.setAttributeNS(null, "opacity", oo);
          }, el.visPropOld.fillopacity);
        } else {
          if (c === "none") {
            oo = 0;
            node2.setAttributeNS(null, "pointer-events", "visibleStroke");
          } else {
            node2.setAttributeNS(null, "pointer-events", "visiblePainted");
          }
          this._setAttribute(function() {
            node2.setAttributeNS(null, "fill-opacity", oo);
          }, el.visPropOld.fillopacity);
        }
        if (grad === "linear" || grad === "radial") {
          this.updateGradient(el);
        }
      }
      el.visPropOld.fillcolor = rgba;
      el.visPropOld.fillopacity = o;
    },
    // documented in JXG.AbstractRenderer
    setObjectStrokeColor: function(el, color2, opacity) {
      var rgba = type_default.evaluate(color2), c, rgbo, o = type_default.evaluate(opacity), oo, node2;
      o = o > 0 ? o : 0;
      if (el.visPropOld.strokecolor === rgba && el.visPropOld.strokeopacity === o) {
        return;
      }
      if (type_default.exists(rgba) && rgba !== false) {
        if (rgba.length !== 9) {
          c = rgba;
          oo = o;
        } else {
          rgbo = color_default.rgba2rgbo(rgba);
          c = rgbo[0];
          oo = o * rgbo[1];
        }
        node2 = el.rendNode;
        if (el.elementClass === constants_default.OBJECT_CLASS_TEXT) {
          if (type_default.evaluate(el.visProp.display) === "html") {
            this._setAttribute(function() {
              node2.style.color = c;
              node2.style.opacity = oo;
            }, el.visPropOld.strokecolor);
          } else {
            this._setAttribute(function() {
              node2.setAttributeNS(null, "style", "fill:" + c);
              node2.setAttributeNS(null, "style", "fill-opacity:" + oo);
            }, el.visPropOld.strokecolor);
          }
        } else {
          this._setAttribute(function() {
            node2.setAttributeNS(null, "stroke", c);
            node2.setAttributeNS(null, "stroke-opacity", oo);
          }, el.visPropOld.strokecolor);
        }
        if (el.elementClass === constants_default.OBJECT_CLASS_CURVE || el.elementClass === constants_default.OBJECT_CLASS_LINE) {
          if (type_default.evaluate(el.visProp.firstarrow)) {
            this._setArrowColor(
              el.rendNodeTriangleStart,
              c,
              oo,
              el,
              el.visPropCalc.typeFirst
            );
          }
          if (type_default.evaluate(el.visProp.lastarrow)) {
            this._setArrowColor(
              el.rendNodeTriangleEnd,
              c,
              oo,
              el,
              el.visPropCalc.typeLast
            );
          }
        }
      }
      el.visPropOld.strokecolor = rgba;
      el.visPropOld.strokeopacity = o;
    },
    // documented in JXG.AbstractRenderer
    setObjectStrokeWidth: function(el, width) {
      var node2, w = type_default.evaluate(width);
      if (isNaN(w) || el.visPropOld.strokewidth === w) {
        return;
      }
      node2 = el.rendNode;
      this.setPropertyPrim(node2, "stroked", "true");
      if (type_default.exists(w)) {
        this.setPropertyPrim(node2, "stroke-width", w + "px");
      }
      el.visPropOld.strokewidth = w;
    },
    // documented in JXG.AbstractRenderer
    setLineCap: function(el) {
      var capStyle = type_default.evaluate(el.visProp.linecap);
      if (capStyle === void 0 || capStyle === "" || el.visPropOld.linecap === capStyle || !type_default.exists(el.rendNode)) {
        return;
      }
      this.setPropertyPrim(el.rendNode, "stroke-linecap", capStyle);
      el.visPropOld.linecap = capStyle;
    },
    // documented in JXG.AbstractRenderer
    setShadow: function(el) {
      var ev_s = type_default.evaluate(el.visProp.shadow), ev_s_json, c, b, bl, o, op, id, node2, use_board_filter = true, show = false;
      ev_s_json = JSON.stringify(ev_s);
      if (ev_s_json === el.visPropOld.shadow) {
        return;
      }
      if (typeof ev_s === "boolean") {
        use_board_filter = true;
        show = ev_s;
        c = "none";
        b = 3;
        bl = 0.1;
        o = [5, 5];
        op = 1;
      } else {
        if (type_default.evaluate(ev_s.enabled)) {
          use_board_filter = false;
          show = true;
          c = jxg_default.rgbParser(type_default.evaluate(ev_s.color));
          b = type_default.evaluate(ev_s.blur);
          bl = type_default.evaluate(ev_s.blend);
          o = type_default.evaluate(ev_s.offset);
          op = type_default.evaluate(ev_s.opacity);
        } else {
          show = false;
        }
      }
      if (type_default.exists(el.rendNode)) {
        if (show) {
          if (use_board_filter) {
            el.rendNode.setAttributeNS(null, "filter", this.toURL(this.container.id + "_f1"));
          } else {
            node2 = this.container.ownerDocument.getElementById(id);
            if (node2) {
              this.defs.removeChild(node2);
            }
            id = el.rendNode.id + "_f1";
            this.defs.appendChild(this.createShadowFilter(id, c, op, bl, b, o));
            el.rendNode.setAttributeNS(null, "filter", this.toURL(id));
          }
        } else {
          el.rendNode.removeAttributeNS(null, "filter");
        }
      }
      el.visPropOld.shadow = ev_s_json;
    },
    /* **************************
     * renderer control
     * **************************/
    // documented in JXG.AbstractRenderer
    suspendRedraw: function() {
      this.suspendHandle = this.svgRoot.suspendRedraw(1e4);
    },
    // documented in JXG.AbstractRenderer
    unsuspendRedraw: function() {
      this.svgRoot.unsuspendRedraw(this.suspendHandle);
    },
    // documented in AbstractRenderer
    resize: function(w, h) {
      this.svgRoot.setAttribute("width", parseFloat(w));
      this.svgRoot.setAttribute("height", parseFloat(h));
    },
    // documented in JXG.AbstractRenderer
    createTouchpoints: function(n) {
      var i2, na1, na2, node2;
      this.touchpoints = [];
      for (i2 = 0; i2 < n; i2++) {
        na1 = "touchpoint1_" + i2;
        node2 = this.createPrim("path", na1);
        this.appendChildPrim(node2, 19);
        node2.setAttributeNS(null, "d", "M 0 0");
        this.touchpoints.push(node2);
        this.setPropertyPrim(node2, "stroked", "true");
        this.setPropertyPrim(node2, "stroke-width", "1px");
        node2.setAttributeNS(null, "stroke", "#000000");
        node2.setAttributeNS(null, "stroke-opacity", 1);
        node2.setAttributeNS(null, "display", "none");
        na2 = "touchpoint2_" + i2;
        node2 = this.createPrim("ellipse", na2);
        this.appendChildPrim(node2, 19);
        this.updateEllipsePrim(node2, 0, 0, 0, 0);
        this.touchpoints.push(node2);
        this.setPropertyPrim(node2, "stroked", "true");
        this.setPropertyPrim(node2, "stroke-width", "1px");
        node2.setAttributeNS(null, "stroke", "#000000");
        node2.setAttributeNS(null, "stroke-opacity", 1);
        node2.setAttributeNS(null, "fill", "#ffffff");
        node2.setAttributeNS(null, "fill-opacity", 0);
        node2.setAttributeNS(null, "display", "none");
      }
    },
    // documented in JXG.AbstractRenderer
    showTouchpoint: function(i2) {
      if (this.touchpoints && i2 >= 0 && 2 * i2 < this.touchpoints.length) {
        this.touchpoints[2 * i2].setAttributeNS(null, "display", "inline");
        this.touchpoints[2 * i2 + 1].setAttributeNS(null, "display", "inline");
      }
    },
    // documented in JXG.AbstractRenderer
    hideTouchpoint: function(i2) {
      if (this.touchpoints && i2 >= 0 && 2 * i2 < this.touchpoints.length) {
        this.touchpoints[2 * i2].setAttributeNS(null, "display", "none");
        this.touchpoints[2 * i2 + 1].setAttributeNS(null, "display", "none");
      }
    },
    // documented in JXG.AbstractRenderer
    updateTouchpoint: function(i2, pos) {
      var x, y, d = 37;
      if (this.touchpoints && i2 >= 0 && 2 * i2 < this.touchpoints.length) {
        x = pos[0];
        y = pos[1];
        this.touchpoints[2 * i2].setAttributeNS(
          null,
          "d",
          "M " + (x - d) + " " + y + " L " + (x + d) + " " + y + " M " + x + " " + (y - d) + " L " + x + " " + (y + d)
        );
        this.updateEllipsePrim(this.touchpoints[2 * i2 + 1], pos[0], pos[1], 25, 25);
      }
    },
    /**
     * Walk recursively through the DOM subtree of a node and collect all
     * value attributes together with the id of that node.
     * <b>Attention:</b> Only values of nodes having a valid id are taken.
     * @param  {Node} node   root node of DOM subtree that will be searched recursively.
     * @return {Array}      Array with entries of the form [id, value]
     * @private
     */
    _getValuesOfDOMElements: function(node2) {
      var values = [];
      if (node2.nodeType === 1) {
        node2 = node2.firstChild;
        while (node2) {
          if (node2.id !== void 0 && node2.value !== void 0) {
            values.push([node2.id, node2.value]);
          }
          values = values.concat(this._getValuesOfDOMElements(node2));
          node2 = node2.nextSibling;
        }
      }
      return values;
    },
    _getDataUri: function(url, callback) {
      var image = new Image();
      image.onload = function() {
        var canvas = document.createElement("canvas");
        canvas.width = this.naturalWidth;
        canvas.height = this.naturalHeight;
        canvas.getContext("2d").drawImage(this, 0, 0);
        callback(canvas.toDataURL("image/png"));
        canvas.remove();
      };
      image.src = url;
    },
    _getImgDataURL: function(svgRoot) {
      var images, len, canvas, ctx, ur, i2;
      images = svgRoot.getElementsByTagName("image");
      len = images.length;
      if (len > 0) {
        canvas = document.createElement("canvas");
        for (i2 = 0; i2 < len; i2++) {
          images[i2].setAttribute("crossorigin", "anonymous");
          ctx = canvas.getContext("2d");
          canvas.width = images[i2].getAttribute("width");
          canvas.height = images[i2].getAttribute("height");
          try {
            ctx.drawImage(images[i2], 0, 0, canvas.width, canvas.height);
            ur = canvas.toDataURL();
            images[i2].setAttribute("xlink:href", ur);
          } catch (err) {
            console.log("CORS problem! Image can not be used", err);
          }
        }
      }
      return true;
    },
    /**
     * Return a data URI of the SVG code representing the construction.
     * The SVG code of the construction is base64 encoded. The return string starts
     * with "data:image/svg+xml;base64,...".
     *
     * @param {Boolean} ignoreTexts If true, the foreignObject tag is set to display=none.
     * This is necessary for older versions of Safari. Default: false
     * @returns {String}  data URI string
     *
     * @example
     * var A = board.create('point', [2, 2]);
     *
     * var txt = board.renderer.dumpToDataURI(false);
     * // txt consists of a string of the form
     * // data:image/svg+xml;base64,PHN2Zy. base64 encoded SVG..+PC9zdmc+
     * // Behind the comma, there is the base64 encoded SVG code
     * // which is decoded with atob().
     * // The call of decodeURIComponent(escape(...)) is necessary
     * // to handle unicode strings correctly.
     * var ar = txt.split(',');
     * document.getElementById('output').value = decodeURIComponent(escape(atob(ar[1])));
     *
     * </pre><div id="JXG1bad4bec-6d08-4ce0-9b7f-d817e8dd762d" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <textarea id="output2023" rows="5" cols="50"></textarea>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG1bad4bec-6d08-4ce0-9b7f-d817e8dd762d',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var A = board.create('point', [2, 2]);
     *
     *     var txt = board.renderer.dumpToDataURI(false);
     *     // txt consists of a string of the form
     *     // data:image/svg+xml;base64,PHN2Zy. base64 encoded SVG..+PC9zdmc+
     *     // Behind the comma, there is the base64 encoded SVG code
     *     // which is decoded with atob().
     *     // The call of decodeURIComponent(escape(...)) is necessary
     *     // to handle unicode strings correctly.
     *     var ar = txt.split(',');
     *     document.getElementById('output2023').value = decodeURIComponent(escape(atob(ar[1])));
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    dumpToDataURI: function(ignoreTexts) {
      var svgRoot = this.svgRoot, btoa = window.btoa || base64_default.encode, svg, i2, len, values = [];
      if (this.container.hasChildNodes() && type_default.exists(this.foreignObjLayer)) {
        if (!ignoreTexts) {
          this.foreignObjLayer.setAttribute("display", "inline");
          while (svgRoot.nextSibling) {
            values = values.concat(this._getValuesOfDOMElements(svgRoot.nextSibling));
            this.foreignObjLayer.appendChild(svgRoot.nextSibling);
          }
        }
      }
      this._getImgDataURL(svgRoot);
      svgRoot.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      svg = new XMLSerializer().serializeToString(svgRoot);
      if (ignoreTexts !== true) {
        len = values.length;
        for (i2 = 0; i2 < len; i2++) {
          svg = svg.replace(
            'id="' + values[i2][0] + '"',
            'id="' + values[i2][0] + '" value="' + values[i2][1] + '"'
          );
        }
      }
      if ((svg.match(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g) || []).length > 1) {
        svg = svg.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, "");
      }
      svg = svg.replace(/&nbsp;/g, " ");
      svg = svg.replace(/url\(&quot;(.*)&quot;\)/g, "url($1)");
      if (type_default.exists(this.foreignObjLayer) && this.foreignObjLayer.hasChildNodes()) {
        while (this.foreignObjLayer.firstChild) {
          this.container.appendChild(this.foreignObjLayer.firstChild);
        }
        this.foreignObjLayer.setAttribute("display", "none");
      }
      return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
    },
    /**
     * Convert the SVG construction into an HTML canvas image.
     * This works for all SVG supporting browsers. Implemented as Promise.
     * <p>
     * Might fail if any text element or foreign object element contains SVG. This
     * is the case e.g. for the default fullscreen symbol.
     * <p>
     * For IE, it is realized as function.
     * It works from version 9, with the exception that HTML texts
     * are ignored on IE. The drawing is done with a delay of
     * 200 ms. Otherwise there would be problems with IE.
     *
     * @param {String} canvasId Id of an HTML canvas element
     * @param {Number} w Width in pixel of the dumped image, i.e. of the canvas tag.
     * @param {Number} h Height in pixel of the dumped image, i.e. of the canvas tag.
     * @param {Boolean} ignoreTexts If true, the foreignObject tag is taken out from the SVG root.
     * This is necessary for older versions of Safari. Default: false
     * @returns {Promise}  Promise object
     *
     * @example
     * 	board.renderer.dumpToCanvas('canvas').then(function() { console.log('done'); });
     *
     * @example
     *  // IE 11 example:
     * 	board.renderer.dumpToCanvas('canvas');
     * 	setTimeout(function() { console.log('done'); }, 400);
     */
    dumpToCanvas: function(canvasId, w, h, ignoreTexts) {
      var svg, tmpImg, cv, ctx, doc = this.container.ownerDocument;
      cv = doc.getElementById(canvasId);
      cv.width = cv.width;
      ctx = cv.getContext("2d");
      if (w !== void 0 && h !== void 0) {
        cv.style.width = parseFloat(w) + "px";
        cv.style.height = parseFloat(h) + "px";
        cv.setAttribute("width", parseFloat(w));
        cv.setAttribute("height", parseFloat(h));
      }
      tmpImg = new Image();
      svg = this.dumpToDataURI(ignoreTexts);
      tmpImg.src = svg;
      if (!("Promise" in window)) {
        tmpImg.onload = function() {
          window.setTimeout(function() {
            try {
              ctx.drawImage(tmpImg, 0, 0, w, h);
            } catch (err) {
              console.log("screenshots not longer supported on IE");
            }
          }, 200);
        };
        return this;
      }
      return new Promise(function(resolve, reject) {
        try {
          tmpImg.onload = function() {
            ctx.drawImage(tmpImg, 0, 0, w, h);
            resolve();
          };
        } catch (e) {
          reject(e);
        }
      });
    },
    /**
     * Display SVG image in html img-tag which enables
     * easy download for the user.
     *
     * Support:
     * <ul>
     * <li> IE: No
     * <li> Edge: full
     * <li> Firefox: full
     * <li> Chrome: full
     * <li> Safari: full (No text support in versions prior to 12).
     * </ul>
     *
     * @param {JXG.Board} board Link to the board.
     * @param {String} imgId Optional id of an img object. If given and different from the empty string,
     * the screenshot is copied to this img object. The width and height will be set to the values of the
     * JSXGraph container.
     * @param {Boolean} ignoreTexts If set to true, the foreignObject is taken out of the
     *  SVGRoot and texts are not displayed. This is mandatory for Safari. Default: false
     * @return {Object}       the svg renderer object
     */
    screenshot: function(board, imgId, ignoreTexts) {
      var node2, doc = this.container.ownerDocument, parent = this.container.parentNode, canvas, id, img, button, buttonText, w, h, bas = board.attr.screenshot, navbar, navbarDisplay, insert, newImg = false, _copyCanvasToImg, isDebug = false;
      if (this.type === "no") {
        return this;
      }
      w = bas.scale * this.container.getBoundingClientRect().width;
      h = bas.scale * this.container.getBoundingClientRect().height;
      if (imgId === void 0 || imgId === "") {
        newImg = true;
        img = new Image();
        img.style.width = w + "px";
        img.style.height = h + "px";
      } else {
        newImg = false;
        img = doc.getElementById(imgId);
      }
      if (newImg) {
        node2 = doc.createElement("div");
        node2.style.cssText = bas.css;
        node2.style.width = w + "px";
        node2.style.height = h + "px";
        node2.style.zIndex = this.container.style.zIndex + 120;
        node2.style.position = "absolute";
        node2.style.top = this.container.offsetTop + "px";
        node2.style.left = this.container.offsetLeft + "px";
      }
      if (!isDebug) {
        canvas = doc.createElement("canvas");
        id = Math.random().toString(36).slice(2, 7);
        canvas.setAttribute("id", id);
        canvas.setAttribute("width", w);
        canvas.setAttribute("height", h);
        canvas.style.width = w + "px";
        canvas.style.height = w + "px";
        canvas.style.display = "none";
        parent.appendChild(canvas);
      } else {
        id = "jxgbox_canvas";
        canvas = doc.getElementById(id);
      }
      if (newImg) {
        button = doc.createElement("span");
        buttonText = doc.createTextNode("\u2716");
        button.style.cssText = bas.cssButton;
        button.appendChild(buttonText);
        button.onclick = function() {
          node2.parentNode.removeChild(node2);
        };
        node2.appendChild(img);
        node2.appendChild(button);
        parent.insertBefore(node2, this.container.nextSibling);
      }
      navbar = doc.getElementById(this.uniqName("navigationbar"));
      if (type_default.exists(navbar)) {
        navbarDisplay = navbar.style.display;
        navbar.style.display = "none";
        insert = this.removeToInsertLater(navbar);
      }
      _copyCanvasToImg = function() {
        img.src = canvas.toDataURL("image/png");
        if (!isDebug) {
          parent.removeChild(canvas);
        }
      };
      if ("Promise" in window) {
        this.dumpToCanvas(id, w, h, ignoreTexts).then(_copyCanvasToImg);
      } else {
        this.dumpToCanvas(id, w, h, ignoreTexts);
        window.setTimeout(_copyCanvasToImg, 200);
      }
      if (type_default.exists(navbar)) {
        navbar.style.display = navbarDisplay;
        insert();
      }
      return this;
    }
  }
);
var svg_default = jxg_default.SVGRenderer;

// node_modules/jsxgraph/src/renderer/vml.js
jxg_default.VMLRenderer = function(container) {
  this.type = "vml";
  this.container = container;
  this.container.style.overflow = "hidden";
  if (this.container.style.position === "") {
    this.container.style.position = "relative";
  }
  this.container.onselectstart = function() {
    return false;
  };
  this.resolution = 10;
  if (!type_default.exists(jxg_default.vmlStylesheet)) {
    container.ownerDocument.namespaces.add("jxgvml", "urn:schemas-microsoft-com:vml");
    jxg_default.vmlStylesheet = this.container.ownerDocument.createStyleSheet();
    jxg_default.vmlStylesheet.addRule(".jxgvml", "behavior:url(#default#VML)");
  }
  try {
    if (!container.ownerDocument.namespaces.jxgvml) {
      container.ownerDocument.namespaces.add("jxgvml", "urn:schemas-microsoft-com:vml");
    }
    this.createNode = function(tagName) {
      return container.ownerDocument.createElement(
        "<jxgvml:" + tagName + ' class="jxgvml">'
      );
    };
  } catch (e) {
    this.createNode = function(tagName) {
      return container.ownerDocument.createElement(
        "<" + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="jxgvml">'
      );
    };
  }
  this.dashArray = [
    "Solid",
    "1 1",
    "ShortDash",
    "Dash",
    "LongDash",
    "ShortDashDot",
    "LongDashDot"
  ];
};
jxg_default.VMLRenderer.prototype = new abstract_default();
jxg_default.extend(
  jxg_default.VMLRenderer.prototype,
  /** @lends JXG.VMLRenderer.prototype */
  {
    /**
     * Sets attribute <tt>key</tt> of node <tt>node</tt> to <tt>value</tt>.
     * @param {Node} node A DOM node.
     * @param {String} key Name of the attribute.
     * @param {String} val New value of the attribute.
     * @param {Boolean} [iFlag=false] If false, the attribute's name is case insensitive.
     */
    _setAttr: function(node2, key, val, iFlag) {
      try {
        if (this.container.ownerDocument.documentMode === 8) {
          node2[key] = val;
        } else {
          node2.setAttribute(key, val, iFlag);
        }
      } catch (e) {
        jxg_default.debug("_setAttr: " + key + " " + val + "<br>\n");
      }
    },
    /* ******************************** *
     *  This renderer does not need to
     *  override draw/update* methods
     *  since it provides draw/update*Prim
     *  methods.
     * ******************************** */
    /* **************************
     *    Lines
     * **************************/
    // documented in AbstractRenderer
    updateTicks: function(ticks) {
      var i2, len, c, x, y, r = this.resolution, tickArr = [];
      len = ticks.ticks.length;
      for (i2 = 0; i2 < len; i2++) {
        c = ticks.ticks[i2];
        x = c[0];
        y = c[1];
        if (type_default.isNumber(x[0]) && type_default.isNumber(x[1])) {
          tickArr.push(
            " m " + Math.round(r * x[0]) + ", " + Math.round(r * y[0]) + " l " + Math.round(r * x[1]) + ", " + Math.round(r * y[1]) + " "
          );
        }
      }
      if (!type_default.exists(ticks.rendNode)) {
        ticks.rendNode = this.createPrim("path", ticks.id);
        this.appendChildPrim(ticks.rendNode, type_default.evaluate(ticks.visProp.layer));
      }
      this._setAttr(ticks.rendNode, "stroked", "true");
      this._setAttr(
        ticks.rendNode,
        "strokecolor",
        type_default.evaluate(ticks.visProp.strokecolor),
        1
      );
      this._setAttr(
        ticks.rendNode,
        "strokeweight",
        type_default.evaluate(ticks.visProp.strokewidth)
      );
      this._setAttr(
        ticks.rendNodeStroke,
        "opacity",
        type_default.evaluate(ticks.visProp.strokeopacity) * 100 + "%"
      );
      this.updatePathPrim(ticks.rendNode, tickArr, ticks.board);
    },
    /* **************************
     *    Text related stuff
     * **************************/
    // Already documented in JXG.AbstractRenderer
    displayCopyright: function(str2, fontsize) {
      var node2, t;
      node2 = this.createNode("textbox");
      node2.style.position = "absolute";
      this._setAttr(node2, "id", this.container.id + "_licenseText");
      node2.style.left = 20;
      node2.style.top = 2;
      node2.style.fontSize = fontsize;
      node2.style.color = "#356AA0";
      node2.style.fontFamily = "Arial,Helvetica,sans-serif";
      this._setAttr(node2, "opacity", "30%");
      node2.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand', enabled = false) progid:DXImageTransform.Microsoft.Alpha(opacity = 30, enabled = true)";
      t = this.container.ownerDocument.createTextNode(str2);
      node2.appendChild(t);
      this.appendChildPrim(node2, 0);
    },
    // documented in AbstractRenderer
    drawInternalText: function(el) {
      var node2;
      node2 = this.createNode("textbox");
      node2.style.position = "absolute";
      el.rendNodeText = this.container.ownerDocument.createTextNode("");
      node2.appendChild(el.rendNodeText);
      this.appendChildPrim(node2, 9);
      node2.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand', enabled = false) progid:DXImageTransform.Microsoft.Alpha(opacity = 100, enabled = false)";
      return node2;
    },
    // documented in AbstractRenderer
    updateInternalText: function(el) {
      var v, content = el.plaintext, m = this.joinTransforms(el, el.transformations), offset = [0, 0], maxX, maxY, minX, minY, i2, node2 = el.rendNode, p = [], ev_ax = el.getAnchorX(), ev_ay = el.getAnchorY();
      if (!isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])) {
        if (ev_ax === "right") {
          offset[0] = 1;
        } else if (ev_ax === "middle") {
          offset[0] = 0.5;
        }
        if (ev_ay === "bottom") {
          offset[1] = 1;
        } else if (ev_ay === "middle") {
          offset[1] = 0.5;
        }
        p[0] = math_default.matVecMult(m, [
          1,
          el.coords.scrCoords[1] - offset[0] * el.size[0],
          el.coords.scrCoords[2] + (1 - offset[1]) * el.size[1] + this.vOffsetText
        ]);
        p[0][1] /= p[0][0];
        p[0][2] /= p[0][0];
        p[1] = math_default.matVecMult(m, [
          1,
          el.coords.scrCoords[1] + (1 - offset[0]) * el.size[0],
          el.coords.scrCoords[2] + (1 - offset[1]) * el.size[1] + this.vOffsetText
        ]);
        p[1][1] /= p[1][0];
        p[1][2] /= p[1][0];
        p[2] = math_default.matVecMult(m, [
          1,
          el.coords.scrCoords[1] + (1 - offset[0]) * el.size[0],
          el.coords.scrCoords[2] - offset[1] * el.size[1] + this.vOffsetText
        ]);
        p[2][1] /= p[2][0];
        p[2][2] /= p[2][0];
        p[3] = math_default.matVecMult(m, [
          1,
          el.coords.scrCoords[1] - offset[0] * el.size[0],
          el.coords.scrCoords[2] - offset[1] * el.size[1] + this.vOffsetText
        ]);
        p[3][1] /= p[3][0];
        p[3][2] /= p[3][0];
        maxX = p[0][1];
        minX = p[0][1];
        maxY = p[0][2];
        minY = p[0][2];
        for (i2 = 1; i2 < 4; i2++) {
          maxX = Math.max(maxX, p[i2][1]);
          minX = Math.min(minX, p[i2][1]);
          maxY = Math.max(maxY, p[i2][2]);
          minY = Math.min(minY, p[i2][2]);
        }
        v = offset[0] === 1 ? Math.floor(el.board.canvasWidth - maxX) : Math.floor(minX);
        if (el.visPropOld.left !== ev_ax + v) {
          if (offset[0] === 1) {
            el.rendNode.style.right = v + "px";
            el.rendNode.style.left = "auto";
          } else {
            el.rendNode.style.left = v + "px";
            el.rendNode.style.right = "auto";
          }
          el.visPropOld.left = ev_ax + v;
        }
        v = offset[1] === 1 ? Math.floor(el.board.canvasHeight - maxY) : Math.floor(minY);
        if (el.visPropOld.top !== ev_ay + v) {
          if (offset[1] === 1) {
            el.rendNode.style.bottom = v + "px";
            el.rendNode.style.top = "auto";
          } else {
            el.rendNode.style.top = v + "px";
            el.rendNode.style.bottom = "auto";
          }
          el.visPropOld.top = ev_ay + v;
        }
      }
      if (el.htmlStr !== content) {
        el.rendNodeText.data = content;
        el.htmlStr = content;
      }
      node2.filters.item(0).M11 = m[1][1];
      node2.filters.item(0).M12 = m[1][2];
      node2.filters.item(0).M21 = m[2][1];
      node2.filters.item(0).M22 = m[2][2];
      node2.filters.item(0).enabled = true;
    },
    /* **************************
     *    Image related stuff
     * **************************/
    // Already documented in JXG.AbstractRenderer
    drawImage: function(el) {
      var node2;
      node2 = this.container.ownerDocument.createElement("img");
      node2.style.position = "absolute";
      this._setAttr(node2, "id", this.container.id + "_" + el.id);
      this.container.appendChild(node2);
      this.appendChildPrim(node2, type_default.evaluate(el.visProp.layer));
      node2.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand') progid:DXImageTransform.Microsoft.Alpha(opacity = 100, enabled = false)";
      el.rendNode = node2;
      this.updateImage(el);
    },
    // Already documented in JXG.AbstractRenderer
    transformImage: function(el, t) {
      var m, maxX, maxY, minX, minY, i2, node2 = el.rendNode, p = [], len = t.length;
      if (len > 0) {
        m = this.joinTransforms(el, t);
        p[0] = math_default.matVecMult(m, el.coords.scrCoords);
        p[0][1] /= p[0][0];
        p[0][2] /= p[0][0];
        p[1] = math_default.matVecMult(m, [
          1,
          el.coords.scrCoords[1] + el.size[0],
          el.coords.scrCoords[2]
        ]);
        p[1][1] /= p[1][0];
        p[1][2] /= p[1][0];
        p[2] = math_default.matVecMult(m, [
          1,
          el.coords.scrCoords[1] + el.size[0],
          el.coords.scrCoords[2] - el.size[1]
        ]);
        p[2][1] /= p[2][0];
        p[2][2] /= p[2][0];
        p[3] = math_default.matVecMult(m, [
          1,
          el.coords.scrCoords[1],
          el.coords.scrCoords[2] - el.size[1]
        ]);
        p[3][1] /= p[3][0];
        p[3][2] /= p[3][0];
        maxX = p[0][1];
        minX = p[0][1];
        maxY = p[0][2];
        minY = p[0][2];
        for (i2 = 1; i2 < 4; i2++) {
          maxX = Math.max(maxX, p[i2][1]);
          minX = Math.min(minX, p[i2][1]);
          maxY = Math.max(maxY, p[i2][2]);
          minY = Math.min(minY, p[i2][2]);
        }
        node2.style.left = Math.floor(minX) + "px";
        node2.style.top = Math.floor(minY) + "px";
        node2.filters.item(0).M11 = m[1][1];
        node2.filters.item(0).M12 = m[1][2];
        node2.filters.item(0).M21 = m[2][1];
        node2.filters.item(0).M22 = m[2][2];
        node2.filters.item(0).enabled = true;
      }
    },
    // Already documented in JXG.AbstractRenderer
    updateImageURL: function(el) {
      var url = type_default.evaluate(el.url);
      this._setAttr(el.rendNode, "src", url);
    },
    /* **************************
     * Render primitive objects
     * **************************/
    // Already documented in JXG.AbstractRenderer
    appendChildPrim: function(node2, level) {
      if (!type_default.exists(level)) {
        level = 0;
      }
      node2.style.zIndex = level;
      this.container.appendChild(node2);
      return node2;
    },
    // Already documented in JXG.AbstractRenderer
    appendNodesToElement: function(el, type) {
      if (type === "shape" || type === "path" || type === "polygon") {
        el.rendNodePath = this.getElementById(el.id + "_path");
      }
      el.rendNodeFill = this.getElementById(el.id + "_fill");
      el.rendNodeStroke = this.getElementById(el.id + "_stroke");
      el.rendNodeShadow = this.getElementById(el.id + "_shadow");
      el.rendNode = this.getElementById(el.id);
    },
    // Already documented in JXG.AbstractRenderer
    createPrim: function(type, id) {
      var node2, pathNode, fillNode = this.createNode("fill"), strokeNode = this.createNode("stroke"), shadowNode = this.createNode("shadow");
      this._setAttr(fillNode, "id", this.container.id + "_" + id + "_fill");
      this._setAttr(strokeNode, "id", this.container.id + "_" + id + "_stroke");
      this._setAttr(shadowNode, "id", this.container.id + "_" + id + "_shadow");
      if (type === "circle" || type === "ellipse") {
        node2 = this.createNode("oval");
        node2.appendChild(fillNode);
        node2.appendChild(strokeNode);
        node2.appendChild(shadowNode);
      } else if (type === "polygon" || type === "path" || type === "shape" || type === "line") {
        node2 = this.createNode("shape");
        node2.appendChild(fillNode);
        node2.appendChild(strokeNode);
        node2.appendChild(shadowNode);
        pathNode = this.createNode("path");
        this._setAttr(pathNode, "id", this.container.id + "_" + id + "_path");
        node2.appendChild(pathNode);
      } else {
        node2 = this.createNode(type);
        node2.appendChild(fillNode);
        node2.appendChild(strokeNode);
        node2.appendChild(shadowNode);
      }
      node2.style.position = "absolute";
      node2.style.left = "0px";
      node2.style.top = "0px";
      this._setAttr(node2, "id", this.container.id + "_" + id);
      return node2;
    },
    // Already documented in JXG.AbstractRenderer
    remove: function(node2) {
      if (type_default.exists(node2)) {
        node2.removeNode(true);
      }
    },
    // Already documented in JXG.AbstractRenderer
    makeArrows: function(el) {
      var nodeStroke, ev_fa = type_default.evaluate(el.visProp.firstarrow), ev_la = type_default.evaluate(el.visProp.lastarrow);
      if (el.visPropOld.firstarrow === ev_fa && el.visPropOld.lastarrow === ev_la) {
        return;
      }
      if (ev_fa) {
        nodeStroke = el.rendNodeStroke;
        this._setAttr(nodeStroke, "startarrow", "block");
        this._setAttr(nodeStroke, "startarrowlength", "long");
      } else {
        nodeStroke = el.rendNodeStroke;
        if (type_default.exists(nodeStroke)) {
          this._setAttr(nodeStroke, "startarrow", "none");
        }
      }
      if (ev_la) {
        nodeStroke = el.rendNodeStroke;
        this._setAttr(nodeStroke, "id", this.container.id + "_" + el.id + "stroke");
        this._setAttr(nodeStroke, "endarrow", "block");
        this._setAttr(nodeStroke, "endarrowlength", "long");
      } else {
        nodeStroke = el.rendNodeStroke;
        if (type_default.exists(nodeStroke)) {
          this._setAttr(nodeStroke, "endarrow", "none");
        }
      }
      el.visPropOld.firstarrow = ev_fa;
      el.visPropOld.lastarrow = ev_la;
    },
    // Already documented in JXG.AbstractRenderer
    updateEllipsePrim: function(node2, x, y, rx, ry) {
      node2.style.left = Math.floor(x - rx) + "px";
      node2.style.top = Math.floor(y - ry) + "px";
      node2.style.width = Math.floor(Math.abs(rx) * 2) + "px";
      node2.style.height = Math.floor(Math.abs(ry) * 2) + "px";
    },
    // Already documented in JXG.AbstractRenderer
    updateLinePrim: function(node2, p1x, p1y, p2x, p2y, board) {
      var s, r = this.resolution;
      if (!isNaN(p1x + p1y + p2x + p2y)) {
        s = [
          "m ",
          Math.floor(r * p1x),
          ", ",
          Math.floor(r * p1y),
          " l ",
          Math.floor(r * p2x),
          ", ",
          Math.floor(r * p2y)
        ];
        this.updatePathPrim(node2, s, board);
      }
    },
    // Already documented in JXG.AbstractRenderer
    updatePathPrim: function(node2, pointString, board) {
      var x = board.canvasWidth, y = board.canvasHeight;
      if (pointString.length <= 0) {
        pointString = ["m 0,0"];
      }
      node2.style.width = x;
      node2.style.height = y;
      this._setAttr(
        node2,
        "coordsize",
        [Math.floor(this.resolution * x), Math.floor(this.resolution * y)].join(",")
      );
      this._setAttr(node2, "path", pointString.join(""));
    },
    // Already documented in JXG.AbstractRenderer
    updatePathStringPoint: function(el, size2, type) {
      var s = [], mround = Math.round, scr = el.coords.scrCoords, sqrt32 = size2 * Math.sqrt(3) * 0.5, s05 = size2 * 0.5, r = this.resolution;
      if (type === "x") {
        s.push(
          [
            " m ",
            mround(r * (scr[1] - size2)),
            ", ",
            mround(r * (scr[2] - size2)),
            " l ",
            mround(r * (scr[1] + size2)),
            ", ",
            mround(r * (scr[2] + size2)),
            " m ",
            mround(r * (scr[1] + size2)),
            ", ",
            mround(r * (scr[2] - size2)),
            " l ",
            mround(r * (scr[1] - size2)),
            ", ",
            mround(r * (scr[2] + size2))
          ].join("")
        );
      } else if (type === "+") {
        s.push(
          [
            " m ",
            mround(r * (scr[1] - size2)),
            ", ",
            mround(r * scr[2]),
            " l ",
            mround(r * (scr[1] + size2)),
            ", ",
            mround(r * scr[2]),
            " m ",
            mround(r * scr[1]),
            ", ",
            mround(r * (scr[2] - size2)),
            " l ",
            mround(r * scr[1]),
            ", ",
            mround(r * (scr[2] + size2))
          ].join("")
        );
      } else if (type === "<>" || type === "<<>>") {
        if (type === "<<>>") {
          size2 *= 1.41;
        }
        s.push(
          [
            " m ",
            mround(r * (scr[1] - size2)),
            ", ",
            mround(r * scr[2]),
            " l ",
            mround(r * scr[1]),
            ", ",
            mround(r * (scr[2] + size2)),
            " l ",
            mround(r * (scr[1] + size2)),
            ", ",
            mround(r * scr[2]),
            " l ",
            mround(r * scr[1]),
            ", ",
            mround(r * (scr[2] - size2)),
            " x e "
          ].join("")
        );
      } else if (type === "^") {
        s.push(
          [
            " m ",
            mround(r * scr[1]),
            ", ",
            mround(r * (scr[2] - size2)),
            " l ",
            mround(r * (scr[1] - sqrt32)),
            ", ",
            mround(r * (scr[2] + s05)),
            " l ",
            mround(r * (scr[1] + sqrt32)),
            ", ",
            mround(r * (scr[2] + s05)),
            " x e "
          ].join("")
        );
      } else if (type === "v") {
        s.push(
          [
            " m ",
            mround(r * scr[1]),
            ", ",
            mround(r * (scr[2] + size2)),
            " l ",
            mround(r * (scr[1] - sqrt32)),
            ", ",
            mround(r * (scr[2] - s05)),
            " l ",
            mround(r * (scr[1] + sqrt32)),
            ", ",
            mround(r * (scr[2] - s05)),
            " x e "
          ].join("")
        );
      } else if (type === ">") {
        s.push(
          [
            " m ",
            mround(r * (scr[1] + size2)),
            ", ",
            mround(r * scr[2]),
            " l ",
            mround(r * (scr[1] - s05)),
            ", ",
            mround(r * (scr[2] - sqrt32)),
            " l ",
            mround(r * (scr[1] - s05)),
            ", ",
            mround(r * (scr[2] + sqrt32)),
            " l ",
            mround(r * (scr[1] + size2)),
            ", ",
            mround(r * scr[2])
          ].join("")
        );
      } else if (type === "<") {
        s.push(
          [
            " m ",
            mround(r * (scr[1] - size2)),
            ", ",
            mround(r * scr[2]),
            " l ",
            mround(r * (scr[1] + s05)),
            ", ",
            mround(r * (scr[2] - sqrt32)),
            " l ",
            mround(r * (scr[1] + s05)),
            ", ",
            mround(r * (scr[2] + sqrt32)),
            " x e "
          ].join("")
        );
      }
      return s;
    },
    // Already documented in JXG.AbstractRenderer
    updatePathStringPrim: function(el) {
      var i2, scr, pStr = [], r = this.resolution, mround = Math.round, symbm = " m ", symbl = " l ", symbc = " c ", nextSymb = symbm, len = Math.min(el.numberPoints, 8192);
      if (el.numberPoints <= 0) {
        return "";
      }
      len = Math.min(len, el.points.length);
      if (el.bezierDegree === 1) {
        for (i2 = 0; i2 < len; i2++) {
          scr = el.points[i2].scrCoords;
          if (isNaN(scr[1]) || isNaN(scr[2])) {
            nextSymb = symbm;
          } else {
            if (scr[1] > 2e4) {
              scr[1] = 2e4;
            } else if (scr[1] < -2e4) {
              scr[1] = -2e4;
            }
            if (scr[2] > 2e4) {
              scr[2] = 2e4;
            } else if (scr[2] < -2e4) {
              scr[2] = -2e4;
            }
            pStr.push(
              [nextSymb, mround(r * scr[1]), ", ", mround(r * scr[2])].join("")
            );
            nextSymb = symbl;
          }
        }
      } else if (el.bezierDegree === 3) {
        i2 = 0;
        while (i2 < len) {
          scr = el.points[i2].scrCoords;
          if (isNaN(scr[1]) || isNaN(scr[2])) {
            nextSymb = symbm;
          } else {
            pStr.push(
              [nextSymb, mround(r * scr[1]), ", ", mround(r * scr[2])].join("")
            );
            if (nextSymb === symbc) {
              i2 += 1;
              scr = el.points[i2].scrCoords;
              pStr.push(
                [" ", mround(r * scr[1]), ", ", mround(r * scr[2])].join("")
              );
              i2 += 1;
              scr = el.points[i2].scrCoords;
              pStr.push(
                [" ", mround(r * scr[1]), ", ", mround(r * scr[2])].join("")
              );
            }
            nextSymb = symbc;
          }
          i2 += 1;
        }
      }
      pStr.push(" e");
      return pStr;
    },
    // Already documented in JXG.AbstractRenderer
    updatePathStringBezierPrim: function(el) {
      var i2, j, k, scr, lx, ly, pStr = [], f = type_default.evaluate(el.visProp.strokewidth), r = this.resolution, mround = Math.round, symbm = " m ", symbl = " c ", nextSymb = symbm, isNoPlot = type_default.evaluate(el.visProp.curvetype) !== "plot", len = Math.min(el.numberPoints, 8192);
      if (el.numberPoints <= 0) {
        return "";
      }
      if (isNoPlot && el.board.options.curve.RDPsmoothing) {
        el.points = numerics_default.RamerDouglasPeucker(el.points, 1);
      }
      len = Math.min(len, el.points.length);
      for (j = 1; j < 3; j++) {
        nextSymb = symbm;
        for (i2 = 0; i2 < len; i2++) {
          scr = el.points[i2].scrCoords;
          if (isNaN(scr[1]) || isNaN(scr[2])) {
            nextSymb = symbm;
          } else {
            if (scr[1] > 2e4) {
              scr[1] = 2e4;
            } else if (scr[1] < -2e4) {
              scr[1] = -2e4;
            }
            if (scr[2] > 2e4) {
              scr[2] = 2e4;
            } else if (scr[2] < -2e4) {
              scr[2] = -2e4;
            }
            if (nextSymb === symbm) {
              pStr.push(
                [nextSymb, mround(r * scr[1]), " ", mround(r * scr[2])].join("")
              );
            } else {
              k = 2 * j;
              pStr.push(
                [
                  nextSymb,
                  mround(
                    r * (lx + (scr[1] - lx) * 0.333 + f * (k * Math.random() - j))
                  ),
                  " ",
                  mround(
                    r * (ly + (scr[2] - ly) * 0.333 + f * (k * Math.random() - j))
                  ),
                  " ",
                  mround(
                    r * (lx + (scr[1] - lx) * 0.666 + f * (k * Math.random() - j))
                  ),
                  " ",
                  mround(
                    r * (ly + (scr[2] - ly) * 0.666 + f * (k * Math.random() - j))
                  ),
                  " ",
                  mround(r * scr[1]),
                  " ",
                  mround(r * scr[2])
                ].join("")
              );
            }
            nextSymb = symbl;
            lx = scr[1];
            ly = scr[2];
          }
        }
      }
      pStr.push(" e");
      return pStr;
    },
    // Already documented in JXG.AbstractRenderer
    updatePolygonPrim: function(node2, el) {
      var i2, len = el.vertices.length, r = this.resolution, scr, pStr = [];
      this._setAttr(node2, "stroked", "false");
      scr = el.vertices[0].coords.scrCoords;
      if (isNaN(scr[1] + scr[2])) {
        return;
      }
      pStr.push(
        ["m ", Math.floor(r * scr[1]), ",", Math.floor(r * scr[2]), " l "].join("")
      );
      for (i2 = 1; i2 < len - 1; i2++) {
        if (el.vertices[i2].isReal) {
          scr = el.vertices[i2].coords.scrCoords;
          if (isNaN(scr[1] + scr[2])) {
            return;
          }
          pStr.push(Math.floor(r * scr[1]) + "," + Math.floor(r * scr[2]));
        } else {
          this.updatePathPrim(node2, "", el.board);
          return;
        }
        if (i2 < len - 2) {
          pStr.push(", ");
        }
      }
      pStr.push(" x e");
      this.updatePathPrim(node2, pStr, el.board);
    },
    // Already documented in JXG.AbstractRenderer
    updateRectPrim: function(node2, x, y, w, h) {
      node2.style.left = Math.floor(x) + "px";
      node2.style.top = Math.floor(y) + "px";
      if (w >= 0) {
        node2.style.width = w + "px";
      }
      if (h >= 0) {
        node2.style.height = h + "px";
      }
    },
    /* **************************
     *  Set Attributes
     * **************************/
    // Already documented in JXG.AbstractRenderer
    setPropertyPrim: function(node2, key, val) {
      var keyVml = "", v;
      switch (key) {
        case "stroke":
          keyVml = "strokecolor";
          break;
        case "stroke-width":
          keyVml = "strokeweight";
          break;
        case "stroke-dasharray":
          keyVml = "dashstyle";
          break;
      }
      if (keyVml !== "") {
        v = type_default.evaluate(val);
        this._setAttr(node2, keyVml, v);
      }
    },
    // Already documented in JXG.AbstractRenderer
    display: function(el, val) {
      if (el && el.rendNode) {
        el.visPropOld.visible = val;
        if (val) {
          el.rendNode.style.visibility = "inherit";
        } else {
          el.rendNode.style.visibility = "hidden";
        }
      }
    },
    // Already documented in JXG.AbstractRenderer
    show: function(el) {
      jxg_default.deprecated("Board.renderer.show()", "Board.renderer.display()");
      if (el && el.rendNode) {
        el.rendNode.style.visibility = "inherit";
      }
    },
    // Already documented in JXG.AbstractRenderer
    hide: function(el) {
      jxg_default.deprecated("Board.renderer.hide()", "Board.renderer.display()");
      if (el && el.rendNode) {
        el.rendNode.style.visibility = "hidden";
      }
    },
    // Already documented in JXG.AbstractRenderer
    setDashStyle: function(el, visProp) {
      var node2;
      if (visProp.dash >= 0) {
        node2 = el.rendNodeStroke;
        this._setAttr(node2, "dashstyle", this.dashArray[visProp.dash]);
      }
    },
    // Already documented in JXG.AbstractRenderer
    setGradient: function(el) {
      var nodeFill = el.rendNodeFill, ev_g = type_default.evaluate(el.visProp.gradient);
      if (ev_g === "linear") {
        this._setAttr(nodeFill, "type", "gradient");
        this._setAttr(
          nodeFill,
          "color2",
          type_default.evaluate(el.visProp.gradientsecondcolor)
        );
        this._setAttr(
          nodeFill,
          "opacity2",
          type_default.evaluate(el.visProp.gradientsecondopacity)
        );
        this._setAttr(nodeFill, "angle", type_default.evaluate(el.visProp.gradientangle));
      } else if (ev_g === "radial") {
        this._setAttr(nodeFill, "type", "gradientradial");
        this._setAttr(
          nodeFill,
          "color2",
          type_default.evaluate(el.visProp.gradientsecondcolor)
        );
        this._setAttr(
          nodeFill,
          "opacity2",
          type_default.evaluate(el.visProp.gradientsecondopacity)
        );
        this._setAttr(
          nodeFill,
          "focusposition",
          type_default.evaluate(el.visProp.gradientpositionx) * 100 + "%," + type_default.evaluate(el.visProp.gradientpositiony) * 100 + "%"
        );
        this._setAttr(nodeFill, "focussize", "0,0");
      } else {
        this._setAttr(nodeFill, "type", "solid");
      }
    },
    // Already documented in JXG.AbstractRenderer
    setObjectFillColor: function(el, color2, opacity) {
      var rgba = type_default.evaluate(color2), c, rgbo, o = type_default.evaluate(opacity), oo, node2 = el.rendNode;
      o = o > 0 ? o : 0;
      if (el.visPropOld.fillcolor === rgba && el.visPropOld.fillopacity === o) {
        return;
      }
      if (type_default.exists(rgba) && rgba !== false) {
        if (rgba.length !== 9) {
          c = rgba;
          oo = o;
        } else {
          rgbo = color_default.rgba2rgbo(rgba);
          c = rgbo[0];
          oo = o * rgbo[1];
        }
        if (c === "none" || c === false) {
          this._setAttr(el.rendNode, "filled", "false");
        } else {
          this._setAttr(el.rendNode, "filled", "true");
          this._setAttr(el.rendNode, "fillcolor", c);
          if (type_default.exists(oo) && el.rendNodeFill) {
            this._setAttr(el.rendNodeFill, "opacity", oo * 100 + "%");
          }
        }
        if (el.type === constants_default.OBJECT_TYPE_IMAGE) {
          if (node2.filters.length > 1) {
            node2.filters.item(1).opacity = Math.round(oo * 100);
            node2.filters.item(1).enabled = true;
          }
        }
      }
      el.visPropOld.fillcolor = rgba;
      el.visPropOld.fillopacity = o;
    },
    // Already documented in JXG.AbstractRenderer
    setObjectStrokeColor: function(el, color2, opacity) {
      var rgba = type_default.evaluate(color2), c, rgbo, o = type_default.evaluate(opacity), oo, node2 = el.rendNode, nodeStroke;
      o = o > 0 ? o : 0;
      if (el.visPropOld.strokecolor === rgba && el.visPropOld.strokeopacity === o) {
        return;
      }
      if (type_default.exists(rgba) && rgba !== false) {
        if (rgba.length !== 9) {
          c = rgba;
          oo = o;
        } else {
          rgbo = color2.rgba2rgbo(rgba);
          c = rgbo[0];
          oo = o * rgbo[1];
        }
        if (el.elementClass === constants_default.OBJECT_CLASS_TEXT) {
          if (node2.filters.length > 1) {
            node2.filters.item(1).opacity = Math.round(oo * 100);
            node2.filters.item(1).enabled = true;
          }
          node2.style.color = c;
        } else {
          if (c !== false) {
            this._setAttr(node2, "stroked", "true");
            this._setAttr(node2, "strokecolor", c);
          }
          nodeStroke = el.rendNodeStroke;
          if (type_default.exists(oo) && el.type !== constants_default.OBJECT_TYPE_IMAGE) {
            this._setAttr(nodeStroke, "opacity", oo * 100 + "%");
          }
        }
      }
      el.visPropOld.strokecolor = rgba;
      el.visPropOld.strokeopacity = o;
    },
    // Already documented in JXG.AbstractRenderer
    setObjectStrokeWidth: function(el, width) {
      var w = type_default.evaluate(width), node2;
      if (isNaN(w) || el.visPropOld.strokewidth === w) {
        return;
      }
      node2 = el.rendNode;
      this.setPropertyPrim(node2, "stroked", "true");
      if (type_default.exists(w)) {
        this.setPropertyPrim(node2, "stroke-width", w);
        if (w === 0 && type_default.exists(el.rendNodeStroke)) {
          this._setAttr(node2, "stroked", "false");
        }
      }
      el.visPropOld.strokewidth = w;
    },
    // Already documented in JXG.AbstractRenderer
    setShadow: function(el) {
      var nodeShadow = el.rendNodeShadow, ev_s = type_default.evaluate(el.visProp.shadow);
      if (!nodeShadow || el.visPropOld.shadow === ev_s) {
        return;
      }
      if (ev_s) {
        this._setAttr(nodeShadow, "On", "True");
        this._setAttr(nodeShadow, "Offset", "3pt,3pt");
        this._setAttr(nodeShadow, "Opacity", "60%");
        this._setAttr(nodeShadow, "Color", "#aaaaaa");
      } else {
        this._setAttr(nodeShadow, "On", "False");
      }
      el.visPropOld.shadow = ev_s;
    },
    /* **************************
     * renderer control
     * **************************/
    // Already documented in JXG.AbstractRenderer
    suspendRedraw: function() {
      this.container.style.display = "none";
    },
    // Already documented in JXG.AbstractRenderer
    unsuspendRedraw: function() {
      this.container.style.display = "";
    }
  }
);
var vml_default = jxg_default.VMLRenderer;

// node_modules/jsxgraph/src/utils/uuid.js
var uuidCharsStr = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
var uuidChars = uuidCharsStr.split("");
jxg_default.Util = jxg_default.Util || {};
jxg_default.Util.genUUID = function(prefix) {
  var r, i2, uuid = [], rnd = 0;
  prefix = prefix || "";
  if (prefix !== "" && prefix.slice(prefix.length - 1) !== "-") {
    prefix = prefix + "-";
  }
  for (i2 = 0; i2 < 36; i2++) {
    if (i2 === 8 || i2 === 13 || i2 === 18 || i2 === 23) {
      uuid[i2] = "-";
    } else if (i2 === 14) {
      uuid[i2] = "4";
    } else {
      if (rnd <= 2) {
        rnd = 33554432 + Math.random() * 16777216 | 0;
      }
      r = rnd & 15;
      rnd = rnd >> 4;
      uuid[i2] = uuidChars[i2 === 19 ? r & 3 | 8 : r];
    }
  }
  return prefix + uuid.join("");
};
var uuid_default = jxg_default.Util;

// node_modules/jsxgraph/src/renderer/canvas.js
jxg_default.CanvasRenderer = function(container, dim) {
  this.type = "canvas";
  this.canvasRoot = null;
  this.suspendHandle = null;
  this.canvasId = uuid_default.genUUID();
  this.canvasNamespace = null;
  if (env_default.isBrowser) {
    this.container = container;
    this.container.style.MozUserSelect = "none";
    this.container.style.userSelect = "none";
    this.container.style.overflow = "hidden";
    if (this.container.style.position === "") {
      this.container.style.position = "relative";
    }
    this.container.innerHTML = [
      '<canvas id="',
      this.canvasId,
      '" width="',
      dim.width,
      'px" height="',
      dim.height,
      'px"></canvas>'
    ].join("");
    this.canvasRoot = this.container.ownerDocument.getElementById(this.canvasId);
    this.canvasRoot.style.display = "block";
    this.context = this.canvasRoot.getContext("2d");
  } else if (env_default.isNode()) {
    try {
      this.canvasRoot = jxg_default.createCanvas(500, 500);
      this.context = this.canvasRoot.getContext("2d");
    } catch (err) {
      throw new Error('JXG.createCanvas not available.\nInstall the npm package `canvas`\nand call:\n    import { createCanvas } from "canvas";\n    JXG.createCanvas = createCanvas;\n');
    }
  }
};
jxg_default.CanvasRenderer.prototype = new abstract_default();
jxg_default.extend(
  jxg_default.CanvasRenderer.prototype,
  /** @lends JXG.CanvasRenderer.prototype */
  {
    /* **************************
     *   private methods only used
     *   in this renderer. Should
     *   not be called from outside.
     * **************************/
    /**
     * Draws a filled polygon.
     * @param {Array} shape A matrix presented by a two dimensional array of numbers.
     * @see JXG.AbstractRenderer#drawArrows
     * @private
     */
    _drawPolygon: function(shape, degree, doFill) {
      var i2, len = shape.length, context = this.context;
      if (len > 0) {
        if (doFill) {
          context.lineWidth = 0;
        }
        context.beginPath();
        context.moveTo(shape[0][0], shape[0][1]);
        if (degree === 1) {
          for (i2 = 1; i2 < len; i2++) {
            context.lineTo(shape[i2][0], shape[i2][1]);
          }
        } else {
          for (i2 = 1; i2 < len; i2 += 3) {
            context.bezierCurveTo(
              shape[i2][0],
              shape[i2][1],
              shape[i2 + 1][0],
              shape[i2 + 1][1],
              shape[i2 + 2][0],
              shape[i2 + 2][1]
            );
          }
        }
        if (doFill) {
          context.lineTo(shape[0][0], shape[0][1]);
          context.closePath();
          context.fill("evenodd");
        } else {
          context.stroke();
        }
      }
    },
    /**
     * Sets the fill color and fills an area.
     * @param {JXG.GeometryElement} el An arbitrary JSXGraph element, preferably one with an area.
     * @private
     */
    _fill: function(el) {
      var context = this.context;
      context.save();
      if (this._setColor(el, "fill")) {
        context.fill("evenodd");
      }
      context.restore();
    },
    /**
     * Rotates a point around <tt>(0, 0)</tt> by a given angle.
     * @param {Number} angle An angle, given in rad.
     * @param {Number} x X coordinate of the point.
     * @param {Number} y Y coordinate of the point.
     * @returns {Array} An array containing the x and y coordinate of the rotated point.
     * @private
     */
    _rotatePoint: function(angle, x, y) {
      return [
        x * Math.cos(angle) - y * Math.sin(angle),
        x * Math.sin(angle) + y * Math.cos(angle)
      ];
    },
    /**
     * Rotates an array of points around <tt>(0, 0)</tt>.
     * @param {Array} shape An array of array of point coordinates.
     * @param {Number} angle The angle in rad the points are rotated by.
     * @returns {Array} Array of array of two dimensional point coordinates.
     * @private
     */
    _rotateShape: function(shape, angle) {
      var i2, rv = [], len = shape.length;
      if (len <= 0) {
        return shape;
      }
      for (i2 = 0; i2 < len; i2++) {
        rv.push(this._rotatePoint(angle, shape[i2][0], shape[i2][1]));
      }
      return rv;
    },
    /**
     * Set the gradient angle for linear color gradients.
     *
     * @private
     * @param {JXG.GeometryElement} node An arbitrary JSXGraph element, preferably one with an area.
     * @param {Number} radians angle value in radians. 0 is horizontal from left to right, Pi/4 is vertical from top to bottom.
     */
    updateGradientAngle: function(el, radians) {
      var f = 1, co = Math.cos(-radians), si = Math.sin(-radians), bb = el.getBoundingBox(), c1, c2, x1, x2, y1, y2, x1s, x2s, y1s, y2s, dx, dy;
      if (Math.abs(co) > Math.abs(si)) {
        f /= Math.abs(co);
      } else {
        f /= Math.abs(si);
      }
      if (co >= 0) {
        x1 = 0;
        x2 = co * f;
      } else {
        x1 = -co * f;
        x2 = 0;
      }
      if (si >= 0) {
        y1 = 0;
        y2 = si * f;
      } else {
        y1 = -si * f;
        y2 = 0;
      }
      c1 = new coords_default(constants_default.COORDS_BY_USER, [bb[0], bb[1]], el.board);
      c2 = new coords_default(constants_default.COORDS_BY_USER, [bb[2], bb[3]], el.board);
      dx = c2.scrCoords[1] - c1.scrCoords[1];
      dy = c2.scrCoords[2] - c1.scrCoords[2];
      x1s = c1.scrCoords[1] + dx * x1;
      y1s = c1.scrCoords[2] + dy * y1;
      x2s = c1.scrCoords[1] + dx * x2;
      y2s = c1.scrCoords[2] + dy * y2;
      return this.context.createLinearGradient(x1s, y1s, x2s, y2s);
    },
    /**
     * Set circles for radial color gradients.
     *
     * @private
     * @param {SVGnode} node SVG gradient node
     * @param {Number} cx Canvas value x1 (but value between 0 and 1)
     * @param {Number} cy  Canvas value y1 (but value between 0 and 1)
     * @param {Number} r  Canvas value r1 (but value between 0 and 1)
     * @param {Number} fx  Canvas value x0 (but value between 0 and 1)
     * @param {Number} fy  Canvas value x1 (but value between 0 and 1)
     * @param {Number} fr  Canvas value r0 (but value between 0 and 1)
     */
    updateGradientCircle: function(el, cx, cy, r, fx, fy, fr) {
      var bb = el.getBoundingBox(), c1, c2, cxs, cys, rs, fxs, fys, frs, dx, dy;
      c1 = new coords_default(constants_default.COORDS_BY_USER, [bb[0], bb[1]], el.board);
      c2 = new coords_default(constants_default.COORDS_BY_USER, [bb[2], bb[3]], el.board);
      dx = c2.scrCoords[1] - c1.scrCoords[1];
      dy = c1.scrCoords[2] - c2.scrCoords[2];
      cxs = c1.scrCoords[1] + dx * cx;
      cys = c2.scrCoords[2] + dy * cy;
      fxs = c1.scrCoords[1] + dx * fx;
      fys = c2.scrCoords[2] + dy * fy;
      rs = r * (dx + dy) * 0.5;
      frs = fr * (dx + dy) * 0.5;
      return this.context.createRadialGradient(fxs, fys, frs, cxs, cys, rs);
    },
    // documented in JXG.AbstractRenderer
    updateGradient: function(el) {
      var col, ev_g = type_default.evaluate(el.visProp.gradient), gradient;
      col = type_default.evaluate(el.visProp.fillcolor);
      if (ev_g === "linear") {
        gradient = this.updateGradientAngle(
          el,
          type_default.evaluate(el.visProp.gradientangle)
        );
      } else if (ev_g === "radial") {
        gradient = this.updateGradientCircle(
          el,
          type_default.evaluate(el.visProp.gradientcx),
          type_default.evaluate(el.visProp.gradientcy),
          type_default.evaluate(el.visProp.gradientr),
          type_default.evaluate(el.visProp.gradientfx),
          type_default.evaluate(el.visProp.gradientfy),
          type_default.evaluate(el.visProp.gradientfr)
        );
      }
      gradient.addColorStop(type_default.evaluate(el.visProp.gradientstartoffset), col);
      gradient.addColorStop(
        type_default.evaluate(el.visProp.gradientendoffset),
        type_default.evaluate(el.visProp.gradientsecondcolor)
      );
      return gradient;
    },
    /**
     * Sets color and opacity for filling and stroking.
     * type is the attribute from visProp and targetType the context[targetTypeStyle].
     * This is necessary, because the fill style of a text is set by the stroke attributes of the text element.
     * @param {JXG.GeometryElement} el Any JSXGraph element.
     * @param {String} [type='stroke'] Either <em>fill</em> or <em>stroke</em>.
     * @param {String} [targetType=type] (optional) Either <em>fill</em> or <em>stroke</em>.
     * @returns {Boolean} If the color could be set, <tt>true</tt> is returned.
     * @private
     */
    _setColor: function(el, type, targetType) {
      var hasColor = true, ev = el.visProp, hl, sw, rgba, rgbo, c, o, oo, grad;
      type = type || "stroke";
      targetType = targetType || type;
      hl = this._getHighlighted(el);
      grad = type_default.evaluate(el.visProp.gradient);
      if (grad === "linear" || grad === "radial") {
        this.context[targetType + "Style"] = this.updateGradient(el);
        return hasColor;
      }
      rgba = type_default.evaluate(ev[hl + type + "color"]);
      if (rgba !== "none" && rgba !== false) {
        o = type_default.evaluate(ev[hl + type + "opacity"]);
        o = o > 0 ? o : 0;
        if (rgba.length !== 9) {
          c = rgba;
          oo = o;
        } else {
          rgbo = color_default.rgba2rgbo(rgba);
          c = rgbo[0];
          oo = o * rgbo[1];
        }
        this.context.globalAlpha = oo;
        this.context[targetType + "Style"] = c;
      } else {
        hasColor = false;
      }
      sw = parseFloat(type_default.evaluate(ev[hl + "strokewidth"]));
      if (type === "stroke" && !isNaN(sw)) {
        if (sw === 0) {
          this.context.globalAlpha = 0;
        } else {
          this.context.lineWidth = sw;
        }
      }
      if (type === "stroke" && ev.linecap !== void 0 && ev.linecap !== "") {
        this.context.lineCap = ev.linecap;
      }
      return hasColor;
    },
    /**
     * Sets color and opacity for drawing paths and lines and draws the paths and lines.
     * @param {JXG.GeometryElement} el An JSXGraph element with a stroke.
     * @private
     */
    _stroke: function(el) {
      var context = this.context, ev_dash = type_default.evaluate(el.visProp.dash), ds = type_default.evaluate(el.visProp.dashscale), sw = ds ? 0.5 * type_default.evaluate(el.visProp.strokewidth) : 1;
      context.save();
      if (ev_dash > 0) {
        if (context.setLineDash) {
          context.setLineDash(
            // sw could distinguish highlighting or not.
            // But it seems to preferable to ignore this.
            this.dashArray[ev_dash - 1].map(function(x) {
              return x * sw;
            })
          );
        }
      } else {
        this.context.lineDashArray = [];
      }
      if (this._setColor(el, "stroke")) {
        context.stroke();
      }
      context.restore();
    },
    /**
     * Translates a set of points.
     * @param {Array} shape An array of point coordinates.
     * @param {Number} x Translation in X direction.
     * @param {Number} y Translation in Y direction.
     * @returns {Array} An array of translated point coordinates.
     * @private
     */
    _translateShape: function(shape, x, y) {
      var i2, rv = [], len = shape.length;
      if (len <= 0) {
        return shape;
      }
      for (i2 = 0; i2 < len; i2++) {
        rv.push([shape[i2][0] + x, shape[i2][1] + y]);
      }
      return rv;
    },
    /* ******************************** *
     *    Point drawing and updating    *
     * ******************************** */
    // documented in AbstractRenderer
    drawPoint: function(el) {
      var f = type_default.evaluate(el.visProp.face), size2 = type_default.evaluate(el.visProp.size), scr = el.coords.scrCoords, sqrt32 = size2 * Math.sqrt(3) * 0.5, s05 = size2 * 0.5, stroke05 = parseFloat(type_default.evaluate(el.visProp.strokewidth)) / 2, context = this.context;
      if (!el.visPropCalc.visible) {
        return;
      }
      switch (f) {
        case "cross":
        case "x":
          context.beginPath();
          context.moveTo(scr[1] - size2, scr[2] - size2);
          context.lineTo(scr[1] + size2, scr[2] + size2);
          context.moveTo(scr[1] + size2, scr[2] - size2);
          context.lineTo(scr[1] - size2, scr[2] + size2);
          context.lineCap = "round";
          context.lineJoin = "round";
          context.closePath();
          this._stroke(el);
          break;
        case "circle":
        case "o":
          context.beginPath();
          context.arc(scr[1], scr[2], size2 + 1 + stroke05, 0, 2 * Math.PI, false);
          context.closePath();
          this._fill(el);
          this._stroke(el);
          break;
        case "square":
        case "[]":
          if (size2 <= 0) {
            break;
          }
          context.save();
          if (this._setColor(el, "stroke", "fill")) {
            context.fillRect(
              scr[1] - size2 - stroke05,
              scr[2] - size2 - stroke05,
              size2 * 2 + 3 * stroke05,
              size2 * 2 + 3 * stroke05
            );
          }
          context.restore();
          context.save();
          this._setColor(el, "fill");
          context.fillRect(
            scr[1] - size2 + stroke05,
            scr[2] - size2 + stroke05,
            size2 * 2 - stroke05,
            size2 * 2 - stroke05
          );
          context.restore();
          break;
        case "plus":
        case "+":
          context.beginPath();
          context.moveTo(scr[1] - size2, scr[2]);
          context.lineTo(scr[1] + size2, scr[2]);
          context.moveTo(scr[1], scr[2] - size2);
          context.lineTo(scr[1], scr[2] + size2);
          context.lineCap = "round";
          context.lineJoin = "round";
          context.closePath();
          this._stroke(el);
          break;
        case "divide":
        case "|":
          context.beginPath();
          context.moveTo(scr[1], scr[2] - size2);
          context.lineTo(scr[1], scr[2] + size2);
          context.lineCap = "round";
          context.lineJoin = "round";
          context.closePath();
          this._stroke(el);
          break;
        case "minus":
        case "-":
          context.beginPath();
          context.moveTo(scr[1] - size2, scr[2]);
          context.lineTo(scr[1] + size2, scr[2]);
          context.lineCap = "round";
          context.lineJoin = "round";
          context.closePath();
          this._stroke(el);
          break;
        case "diamond2":
        case "<<>>":
          size2 *= 1.41;
        case "diamond":
        case "<>":
          context.beginPath();
          context.moveTo(scr[1] - size2, scr[2]);
          context.lineTo(scr[1], scr[2] + size2);
          context.lineTo(scr[1] + size2, scr[2]);
          context.lineTo(scr[1], scr[2] - size2);
          context.closePath();
          this._fill(el);
          this._stroke(el);
          break;
        case "triangleup":
        case "A":
        case "a":
        case "^":
          context.beginPath();
          context.moveTo(scr[1], scr[2] - size2);
          context.lineTo(scr[1] - sqrt32, scr[2] + s05);
          context.lineTo(scr[1] + sqrt32, scr[2] + s05);
          context.closePath();
          this._fill(el);
          this._stroke(el);
          break;
        case "triangledown":
        case "v":
          context.beginPath();
          context.moveTo(scr[1], scr[2] + size2);
          context.lineTo(scr[1] - sqrt32, scr[2] - s05);
          context.lineTo(scr[1] + sqrt32, scr[2] - s05);
          context.closePath();
          this._fill(el);
          this._stroke(el);
          break;
        case "triangleleft":
        case "<":
          context.beginPath();
          context.moveTo(scr[1] - size2, scr[2]);
          context.lineTo(scr[1] + s05, scr[2] - sqrt32);
          context.lineTo(scr[1] + s05, scr[2] + sqrt32);
          context.closePath();
          this._fill(el);
          this._stroke(el);
          break;
        case "triangleright":
        case ">":
          context.beginPath();
          context.moveTo(scr[1] + size2, scr[2]);
          context.lineTo(scr[1] - s05, scr[2] - sqrt32);
          context.lineTo(scr[1] - s05, scr[2] + sqrt32);
          context.closePath();
          this._fill(el);
          this._stroke(el);
          break;
      }
    },
    // documented in AbstractRenderer
    updatePoint: function(el) {
      this.drawPoint(el);
    },
    /* ******************************** *
     *           Lines                  *
     * ******************************** */
    /**
     * Draws arrows of an element (usually a line) in canvas renderer.
     * @param {JXG.GeometryElement} el Line to be drawn.
     * @param {Array} scr1 Screen coordinates of the start position of the line or curve.
     * @param {Array} scr2 Screen coordinates of the end position of the line or curve.
     * @param {String} hl String which carries information if the element is highlighted. Used for getting the correct attribute.
     * @private
     */
    drawArrows: function(el, scr1, scr2, hl, a) {
      var x1, y1, x2, y2, w0, w, arrowHead, arrowTail, context = this.context, size2 = 6, type = 1, type_fa, type_la, degree_fa = 1, degree_la = 1, doFill, i2, len, d1x, d1y, d2x, d2y, last, ang1, ang2, ev_fa = a.evFirst, ev_la = a.evLast;
      if (type_default.evaluate(el.visProp.strokecolor) !== "none" && (ev_fa || ev_la)) {
        if (el.elementClass === constants_default.OBJECT_CLASS_LINE) {
          x1 = scr1.scrCoords[1];
          y1 = scr1.scrCoords[2];
          x2 = scr2.scrCoords[1];
          y2 = scr2.scrCoords[2];
          ang1 = ang2 = Math.atan2(y2 - y1, x2 - x1);
        } else {
          x1 = el.points[0].scrCoords[1];
          y1 = el.points[0].scrCoords[2];
          last = el.points.length - 1;
          if (last < 1) {
            return;
          }
          x2 = el.points[el.points.length - 1].scrCoords[1];
          y2 = el.points[el.points.length - 1].scrCoords[2];
          d1x = el.points[1].scrCoords[1] - el.points[0].scrCoords[1];
          d1y = el.points[1].scrCoords[2] - el.points[0].scrCoords[2];
          d2x = el.points[last].scrCoords[1] - el.points[last - 1].scrCoords[1];
          d2y = el.points[last].scrCoords[2] - el.points[last - 1].scrCoords[2];
          if (ev_fa) {
            ang1 = Math.atan2(d1y, d1x);
          }
          if (ev_la) {
            ang2 = Math.atan2(d2y, d2x);
          }
        }
        w0 = type_default.evaluate(el.visProp[hl + "strokewidth"]);
        if (ev_fa) {
          size2 = a.sizeFirst;
          w = w0 * size2;
          type = a.typeFirst;
          type_fa = type;
          if (type === 2) {
            arrowTail = [
              [w, -w * 0.5],
              [0, 0],
              [w, w * 0.5],
              [w * 0.5, 0]
            ];
          } else if (type === 3) {
            arrowTail = [
              [w / 3, -w * 0.5],
              [0, -w * 0.5],
              [0, w * 0.5],
              [w / 3, w * 0.5]
            ];
          } else if (type === 4) {
            w /= 10;
            degree_fa = 3;
            arrowTail = [
              [10, 3.31],
              [6.47, 3.84],
              [2.87, 4.5],
              [0, 6.63],
              [0.67, 5.52],
              [1.33, 4.42],
              [2, 3.31],
              [1.33, 2.21],
              [0.67, 1.1],
              [0, 0],
              [2.87, 2.13],
              [6.47, 2.79],
              [10, 3.31]
            ];
            len = arrowTail.length;
            for (i2 = 0; i2 < len; i2++) {
              arrowTail[i2][0] *= -w;
              arrowTail[i2][1] *= w;
              arrowTail[i2][0] += 10 * w;
              arrowTail[i2][1] -= 3.31 * w;
            }
          } else if (type === 5) {
            w /= 10;
            degree_fa = 3;
            arrowTail = [
              [10, 3.28],
              [6.61, 4.19],
              [3.19, 5.07],
              [0, 6.55],
              [0.62, 5.56],
              [1, 4.44],
              [1, 3.28],
              [1, 2.11],
              [0.62, 0.99],
              [0, 0],
              [3.19, 1.49],
              [6.61, 2.37],
              [10, 3.28]
            ];
            len = arrowTail.length;
            for (i2 = 0; i2 < len; i2++) {
              arrowTail[i2][0] *= -w;
              arrowTail[i2][1] *= w;
              arrowTail[i2][0] += 10 * w;
              arrowTail[i2][1] -= 3.28 * w;
            }
          } else if (type === 6) {
            w /= 10;
            degree_fa = 3;
            arrowTail = [
              [10, 2.84],
              [6.61, 3.59],
              [3.21, 4.35],
              [0, 5.68],
              [0.33, 4.73],
              [0.67, 3.78],
              [1, 2.84],
              [0.67, 1.89],
              [0.33, 0.95],
              [0, 0],
              [3.21, 1.33],
              [6.61, 2.09],
              [10, 2.84]
            ];
            len = arrowTail.length;
            for (i2 = 0; i2 < len; i2++) {
              arrowTail[i2][0] *= -w;
              arrowTail[i2][1] *= w;
              arrowTail[i2][0] += 10 * w;
              arrowTail[i2][1] -= 2.84 * w;
            }
          } else if (type === 7) {
            w = w0;
            degree_fa = 3;
            arrowTail = [
              [0, 10.39],
              [2.01, 6.92],
              [5.96, 5.2],
              [10, 5.2],
              [5.96, 5.2],
              [2.01, 3.47],
              [0, 0]
            ];
            len = arrowTail.length;
            for (i2 = 0; i2 < len; i2++) {
              arrowTail[i2][0] *= -w;
              arrowTail[i2][1] *= w;
              arrowTail[i2][0] += 10 * w;
              arrowTail[i2][1] -= 5.2 * w;
            }
          } else {
            arrowTail = [
              [w, -w * 0.5],
              [0, 0],
              [w, w * 0.5]
            ];
          }
        }
        if (ev_la) {
          size2 = a.sizeLast;
          w = w0 * size2;
          type = a.typeLast;
          type_la = type;
          if (type === 2) {
            arrowHead = [
              [-w, -w * 0.5],
              [0, 0],
              [-w, w * 0.5],
              [-w * 0.5, 0]
            ];
          } else if (type === 3) {
            arrowHead = [
              [-w / 3, -w * 0.5],
              [0, -w * 0.5],
              [0, w * 0.5],
              [-w / 3, w * 0.5]
            ];
          } else if (type === 4) {
            w /= 10;
            degree_la = 3;
            arrowHead = [
              [10, 3.31],
              [6.47, 3.84],
              [2.87, 4.5],
              [0, 6.63],
              [0.67, 5.52],
              [1.33, 4.42],
              [2, 3.31],
              [1.33, 2.21],
              [0.67, 1.1],
              [0, 0],
              [2.87, 2.13],
              [6.47, 2.79],
              [10, 3.31]
            ];
            len = arrowHead.length;
            for (i2 = 0; i2 < len; i2++) {
              arrowHead[i2][0] *= w;
              arrowHead[i2][1] *= w;
              arrowHead[i2][0] -= 10 * w;
              arrowHead[i2][1] -= 3.31 * w;
            }
          } else if (type === 5) {
            w /= 10;
            degree_la = 3;
            arrowHead = [
              [10, 3.28],
              [6.61, 4.19],
              [3.19, 5.07],
              [0, 6.55],
              [0.62, 5.56],
              [1, 4.44],
              [1, 3.28],
              [1, 2.11],
              [0.62, 0.99],
              [0, 0],
              [3.19, 1.49],
              [6.61, 2.37],
              [10, 3.28]
            ];
            len = arrowHead.length;
            for (i2 = 0; i2 < len; i2++) {
              arrowHead[i2][0] *= w;
              arrowHead[i2][1] *= w;
              arrowHead[i2][0] -= 10 * w;
              arrowHead[i2][1] -= 3.28 * w;
            }
          } else if (type === 6) {
            w /= 10;
            degree_la = 3;
            arrowHead = [
              [10, 2.84],
              [6.61, 3.59],
              [3.21, 4.35],
              [0, 5.68],
              [0.33, 4.73],
              [0.67, 3.78],
              [1, 2.84],
              [0.67, 1.89],
              [0.33, 0.95],
              [0, 0],
              [3.21, 1.33],
              [6.61, 2.09],
              [10, 2.84]
            ];
            len = arrowHead.length;
            for (i2 = 0; i2 < len; i2++) {
              arrowHead[i2][0] *= w;
              arrowHead[i2][1] *= w;
              arrowHead[i2][0] -= 10 * w;
              arrowHead[i2][1] -= 2.84 * w;
            }
          } else if (type === 7) {
            w = w0;
            degree_la = 3;
            arrowHead = [
              [0, 10.39],
              [2.01, 6.92],
              [5.96, 5.2],
              [10, 5.2],
              [5.96, 5.2],
              [2.01, 3.47],
              [0, 0]
            ];
            len = arrowHead.length;
            for (i2 = 0; i2 < len; i2++) {
              arrowHead[i2][0] *= w;
              arrowHead[i2][1] *= w;
              arrowHead[i2][0] -= 10 * w;
              arrowHead[i2][1] -= 5.2 * w;
            }
          } else {
            arrowHead = [
              [-w, -w * 0.5],
              [0, 0],
              [-w, w * 0.5]
            ];
          }
        }
        context.save();
        if (this._setColor(el, "stroke", "fill")) {
          this._setColor(el, "stroke");
          if (ev_fa) {
            if (type_fa === 7) {
              doFill = false;
            } else {
              doFill = true;
            }
            this._drawPolygon(
              this._translateShape(this._rotateShape(arrowTail, ang1), x1, y1),
              degree_fa,
              doFill
            );
          }
          if (ev_la) {
            if (type_la === 7) {
              doFill = false;
            } else {
              doFill = true;
            }
            this._drawPolygon(
              this._translateShape(this._rotateShape(arrowHead, ang2), x2, y2),
              degree_la,
              doFill
            );
          }
        }
        context.restore();
      }
    },
    // documented in AbstractRenderer
    drawLine: function(el) {
      var c1_org, c2_org, c1 = new coords_default(constants_default.COORDS_BY_USER, el.point1.coords.usrCoords, el.board), c2 = new coords_default(constants_default.COORDS_BY_USER, el.point2.coords.usrCoords, el.board), margin = null, hl, w, arrowData;
      if (!el.visPropCalc.visible) {
        return;
      }
      hl = this._getHighlighted(el);
      w = type_default.evaluate(el.visProp[hl + "strokewidth"]);
      arrowData = this.getArrowHeadData(el, w, hl);
      if (arrowData.evFirst || arrowData.evLast) {
        margin = -4;
      }
      geometry_default.calcStraight(el, c1, c2, margin);
      this.handleTouchpoints(el, c1, c2, arrowData);
      c1_org = new coords_default(constants_default.COORDS_BY_USER, c1.usrCoords, el.board);
      c2_org = new coords_default(constants_default.COORDS_BY_USER, c2.usrCoords, el.board);
      this.getPositionArrowHead(el, c1, c2, arrowData);
      this.context.beginPath();
      this.context.moveTo(c1.scrCoords[1], c1.scrCoords[2]);
      this.context.lineTo(c2.scrCoords[1], c2.scrCoords[2]);
      this._stroke(el);
      if (arrowData.evFirst || arrowData.evLast) {
        this.drawArrows(el, c1_org, c2_org, hl, arrowData);
      }
    },
    // documented in AbstractRenderer
    updateLine: function(el) {
      this.drawLine(el);
    },
    // documented in AbstractRenderer
    drawTicks: function() {
    },
    // documented in AbstractRenderer
    updateTicks: function(ticks) {
      var i2, c, x, y, len = ticks.ticks.length, len2, j, context = this.context;
      context.beginPath();
      for (i2 = 0; i2 < len; i2++) {
        c = ticks.ticks[i2];
        x = c[0];
        y = c[1];
        len2 = x.length;
        context.moveTo(x[0], y[0]);
        for (j = 1; j < len2; ++j) {
          context.lineTo(x[j], y[j]);
        }
      }
      context.lineCap = "round";
      this._stroke(ticks);
    },
    /* **************************
     *    Curves
     * **************************/
    // documented in AbstractRenderer
    drawCurve: function(el) {
      var hl, w, arrowData;
      if (type_default.evaluate(el.visProp.handdrawing)) {
        this.updatePathStringBezierPrim(el);
      } else {
        this.updatePathStringPrim(el);
      }
      if (el.numberPoints > 1) {
        hl = this._getHighlighted(el);
        w = type_default.evaluate(el.visProp[hl + "strokewidth"]);
        arrowData = this.getArrowHeadData(el, w, hl);
        if (arrowData.evFirst || arrowData.evLast) {
          this.drawArrows(el, null, null, hl, arrowData);
        }
      }
    },
    // documented in AbstractRenderer
    updateCurve: function(el) {
      this.drawCurve(el);
    },
    /* **************************
     *    Circle related stuff
     * **************************/
    // documented in AbstractRenderer
    drawEllipse: function(el) {
      var m1 = el.center.coords.scrCoords[1], m2 = el.center.coords.scrCoords[2], sX = el.board.unitX, sY = el.board.unitY, rX = 2 * el.Radius(), rY = 2 * el.Radius(), aWidth = rX * sX, aHeight = rY * sY, aX = m1 - aWidth / 2, aY = m2 - aHeight / 2, hB = aWidth / 2 * 0.5522848, vB = aHeight / 2 * 0.5522848, eX = aX + aWidth, eY = aY + aHeight, mX = aX + aWidth / 2, mY = aY + aHeight / 2, context = this.context;
      if (rX > 0 && rY > 0 && !isNaN(m1 + m2)) {
        context.beginPath();
        context.moveTo(aX, mY);
        context.bezierCurveTo(aX, mY - vB, mX - hB, aY, mX, aY);
        context.bezierCurveTo(mX + hB, aY, eX, mY - vB, eX, mY);
        context.bezierCurveTo(eX, mY + vB, mX + hB, eY, mX, eY);
        context.bezierCurveTo(mX - hB, eY, aX, mY + vB, aX, mY);
        context.closePath();
        this._fill(el);
        this._stroke(el);
      }
    },
    // documented in AbstractRenderer
    updateEllipse: function(el) {
      return this.drawEllipse(el);
    },
    /* **************************
     *    Polygon
     * **************************/
    // nothing here, using AbstractRenderer implementations
    /* **************************
     *    Text related stuff
     * **************************/
    // Already documented in JXG.AbstractRenderer
    displayCopyright: function(str2, fontSize) {
      var context = this.context;
      context.save();
      context.font = fontSize + "px Arial";
      context.fillStyle = "#aaa";
      context.lineWidth = 0.5;
      context.fillText(str2, 10, 2 + fontSize);
      context.restore();
    },
    // Already documented in JXG.AbstractRenderer
    drawInternalText: function(el) {
      var ev_fs = type_default.evaluate(el.visProp.fontsize), fontUnit = type_default.evaluate(el.visProp.fontunit), ev_ax = el.getAnchorX(), ev_ay = el.getAnchorY(), context = this.context;
      context.save();
      if (this._setColor(el, "stroke", "fill") && !isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])) {
        context.font = (ev_fs > 0 ? ev_fs : 0) + fontUnit + " Arial";
        this.transformImage(el, el.transformations);
        if (ev_ax === "left") {
          context.textAlign = "left";
        } else if (ev_ax === "right") {
          context.textAlign = "right";
        } else if (ev_ax === "middle") {
          context.textAlign = "center";
        }
        if (ev_ay === "bottom") {
          context.textBaseline = "bottom";
        } else if (ev_ay === "top") {
          context.textBaseline = "top";
        } else if (ev_ay === "middle") {
          context.textBaseline = "middle";
        }
        context.fillText(el.plaintext, el.coords.scrCoords[1], el.coords.scrCoords[2]);
      }
      context.restore();
      return null;
    },
    // Already documented in JXG.AbstractRenderer
    updateInternalText: function(el) {
      this.drawInternalText(el);
    },
    // documented in JXG.AbstractRenderer
    // Only necessary for texts
    setObjectStrokeColor: function(el, color2, opacity) {
      var rgba = type_default.evaluate(color2), c, rgbo, o = type_default.evaluate(opacity), oo, node2;
      o = o > 0 ? o : 0;
      if (el.visPropOld.strokecolor === rgba && el.visPropOld.strokeopacity === o) {
        return;
      }
      if (type_default.exists(rgba) && rgba !== false) {
        if (rgba.length !== 9) {
          c = rgba;
          oo = o;
        } else {
          rgbo = color_default.rgba2rgbo(rgba);
          c = rgbo[0];
          oo = o * rgbo[1];
        }
        node2 = el.rendNode;
        if (el.elementClass === constants_default.OBJECT_CLASS_TEXT && type_default.evaluate(el.visProp.display) === "html") {
          node2.style.color = c;
          node2.style.opacity = oo;
        }
      }
      el.visPropOld.strokecolor = rgba;
      el.visPropOld.strokeopacity = o;
    },
    /* **************************
     *    Image related stuff
     * **************************/
    // Already documented in JXG.AbstractRenderer
    drawImage: function(el) {
      el.rendNode = new Image();
      el._src = "";
      this.updateImage(el);
    },
    // Already documented in JXG.AbstractRenderer
    updateImage: function(el) {
      var context = this.context, o = type_default.evaluate(el.visProp.fillopacity), paintImg = type_default.bind(function() {
        el.imgIsLoaded = true;
        if (el.size[0] <= 0 || el.size[1] <= 0) {
          return;
        }
        context.save();
        context.globalAlpha = o;
        this.transformImage(el, el.transformations);
        context.drawImage(
          el.rendNode,
          el.coords.scrCoords[1],
          el.coords.scrCoords[2] - el.size[1],
          el.size[0],
          el.size[1]
        );
        context.restore();
      }, this);
      if (this.updateImageURL(el)) {
        el.rendNode.onload = paintImg;
      } else {
        if (el.imgIsLoaded) {
          paintImg();
        }
      }
    },
    // Already documented in JXG.AbstractRenderer
    transformImage: function(el, t) {
      var m, s, cx, cy, node2, len = t.length, ctx = this.context;
      if (len > 0) {
        m = this.joinTransforms(el, t);
        if (el.elementClass === constants_default.OBJECT_CLASS_TEXT && el.visProp.display === "html") {
          s = " matrix(" + [m[1][1], m[2][1], m[1][2], m[2][2], m[1][0], m[2][0]].join(",") + ") ";
          if (s.indexOf("NaN") === -1) {
            node2 = el.rendNode;
            node2.style.transform = s;
            cx = -el.coords.scrCoords[1];
            cy = -el.coords.scrCoords[2];
            switch (type_default.evaluate(el.visProp.anchorx)) {
              case "right":
                cx += el.size[0];
                break;
              case "middle":
                cx += el.size[0] * 0.5;
                break;
            }
            switch (type_default.evaluate(el.visProp.anchory)) {
              case "bottom":
                cy += el.size[1];
                break;
              case "middle":
                cy += el.size[1] * 0.5;
                break;
            }
            node2.style["transform-origin"] = cx + "px " + cy + "px";
          }
        } else {
          if (Math.abs(numerics_default.det(m)) >= math_default.eps) {
            ctx.transform(m[1][1], m[2][1], m[1][2], m[2][2], m[1][0], m[2][0]);
          }
        }
      }
    },
    // Already documented in JXG.AbstractRenderer
    updateImageURL: function(el) {
      var url;
      url = type_default.evaluate(el.url);
      if (el._src !== url) {
        el.imgIsLoaded = false;
        el.rendNode.src = url;
        el._src = url;
        return true;
      }
      return false;
    },
    /* **************************
     * Render primitive objects
     * **************************/
    // documented in AbstractRenderer
    remove: function(shape) {
      if (type_default.exists(shape) && type_default.exists(shape.parentNode)) {
        shape.parentNode.removeChild(shape);
      }
    },
    // documented in AbstractRenderer
    updatePathStringPrim: function(el) {
      var i2, scr, scr1, scr2, len, symbm = "M", symbl = "L", symbc = "C", nextSymb = symbm, maxSize = 5e3, context = this.context;
      if (el.numberPoints <= 0) {
        return;
      }
      len = Math.min(el.points.length, el.numberPoints);
      context.beginPath();
      if (el.bezierDegree === 1) {
        for (i2 = 0; i2 < len; i2++) {
          scr = el.points[i2].scrCoords;
          if (isNaN(scr[1]) || isNaN(scr[2])) {
            nextSymb = symbm;
          } else {
            if (scr[1] > maxSize) {
              scr[1] = maxSize;
            } else if (scr[1] < -maxSize) {
              scr[1] = -maxSize;
            }
            if (scr[2] > maxSize) {
              scr[2] = maxSize;
            } else if (scr[2] < -maxSize) {
              scr[2] = -maxSize;
            }
            if (nextSymb === symbm) {
              context.moveTo(scr[1], scr[2]);
            } else {
              context.lineTo(scr[1], scr[2]);
            }
            nextSymb = symbl;
          }
        }
      } else if (el.bezierDegree === 3) {
        i2 = 0;
        while (i2 < len) {
          scr = el.points[i2].scrCoords;
          if (isNaN(scr[1]) || isNaN(scr[2])) {
            nextSymb = symbm;
          } else {
            if (nextSymb === symbm) {
              context.moveTo(scr[1], scr[2]);
            } else {
              i2 += 1;
              scr1 = el.points[i2].scrCoords;
              i2 += 1;
              scr2 = el.points[i2].scrCoords;
              context.bezierCurveTo(
                scr[1],
                scr[2],
                scr1[1],
                scr1[2],
                scr2[1],
                scr2[2]
              );
            }
            nextSymb = symbc;
          }
          i2 += 1;
        }
      }
      context.lineCap = "round";
      this._fill(el);
      this._stroke(el);
    },
    // Already documented in JXG.AbstractRenderer
    updatePathStringBezierPrim: function(el) {
      var i2, j, k, scr, lx, ly, len, symbm = "M", symbl = "C", nextSymb = symbm, maxSize = 5e3, f = type_default.evaluate(el.visProp.strokewidth), isNoPlot = type_default.evaluate(el.visProp.curvetype) !== "plot", context = this.context;
      if (el.numberPoints <= 0) {
        return;
      }
      if (isNoPlot && el.board.options.curve.RDPsmoothing) {
        el.points = numerics_default.RamerDouglasPeucker(el.points, 0.5);
      }
      len = Math.min(el.points.length, el.numberPoints);
      context.beginPath();
      for (j = 1; j < 3; j++) {
        nextSymb = symbm;
        for (i2 = 0; i2 < len; i2++) {
          scr = el.points[i2].scrCoords;
          if (isNaN(scr[1]) || isNaN(scr[2])) {
            nextSymb = symbm;
          } else {
            if (scr[1] > maxSize) {
              scr[1] = maxSize;
            } else if (scr[1] < -maxSize) {
              scr[1] = -maxSize;
            }
            if (scr[2] > maxSize) {
              scr[2] = maxSize;
            } else if (scr[2] < -maxSize) {
              scr[2] = -maxSize;
            }
            if (nextSymb === symbm) {
              context.moveTo(scr[1], scr[2]);
            } else {
              k = 2 * j;
              context.bezierCurveTo(
                lx + (scr[1] - lx) * 0.333 + f * (k * Math.random() - j),
                ly + (scr[2] - ly) * 0.333 + f * (k * Math.random() - j),
                lx + (scr[1] - lx) * 0.666 + f * (k * Math.random() - j),
                ly + (scr[2] - ly) * 0.666 + f * (k * Math.random() - j),
                scr[1],
                scr[2]
              );
            }
            nextSymb = symbl;
            lx = scr[1];
            ly = scr[2];
          }
        }
      }
      context.lineCap = "round";
      this._fill(el);
      this._stroke(el);
    },
    // documented in AbstractRenderer
    updatePolygonPrim: function(node2, el) {
      var scrCoords, i2, j, len = el.vertices.length, context = this.context, isReal = true;
      if (len <= 0 || !el.visPropCalc.visible) {
        return;
      }
      if (el.elType === "polygonalchain") {
        len++;
      }
      context.beginPath();
      i2 = 0;
      while (!el.vertices[i2].isReal && i2 < len - 1) {
        i2++;
        isReal = false;
      }
      scrCoords = el.vertices[i2].coords.scrCoords;
      context.moveTo(scrCoords[1], scrCoords[2]);
      for (j = i2; j < len - 1; j++) {
        if (!el.vertices[j].isReal) {
          isReal = false;
        }
        scrCoords = el.vertices[j].coords.scrCoords;
        context.lineTo(scrCoords[1], scrCoords[2]);
      }
      context.closePath();
      if (isReal) {
        this._fill(el);
      }
    },
    // **************************  Set Attributes *************************
    // Already documented in JXG.AbstractRenderer
    display: function(el, val) {
      if (el && el.rendNode) {
        el.visPropOld.visible = val;
        if (val) {
          el.rendNode.style.visibility = "inherit";
        } else {
          el.rendNode.style.visibility = "hidden";
        }
      }
    },
    // documented in AbstractRenderer
    show: function(el) {
      jxg_default.deprecated("Board.renderer.show()", "Board.renderer.display()");
      if (type_default.exists(el.rendNode)) {
        el.rendNode.style.visibility = "inherit";
      }
    },
    // documented in AbstractRenderer
    hide: function(el) {
      jxg_default.deprecated("Board.renderer.hide()", "Board.renderer.display()");
      if (type_default.exists(el.rendNode)) {
        el.rendNode.style.visibility = "hidden";
      }
    },
    // documented in AbstractRenderer
    setGradient: function(el) {
    },
    // documented in AbstractRenderer
    setShadow: function(el) {
      if (el.visPropOld.shadow === el.visProp.shadow) {
        return;
      }
      el.visPropOld.shadow = el.visProp.shadow;
    },
    // documented in AbstractRenderer
    highlight: function(obj) {
      if (obj.elementClass === constants_default.OBJECT_CLASS_TEXT && type_default.evaluate(obj.visProp.display) === "html") {
        this.updateTextStyle(obj, true);
      } else {
        obj.board.prepareUpdate();
        obj.board.renderer.suspendRedraw(obj.board);
        obj.board.updateRenderer();
        obj.board.renderer.unsuspendRedraw();
      }
      return this;
    },
    // documented in AbstractRenderer
    noHighlight: function(obj) {
      if (obj.elementClass === constants_default.OBJECT_CLASS_TEXT && type_default.evaluate(obj.visProp.display) === "html") {
        this.updateTextStyle(obj, false);
      } else {
        obj.board.prepareUpdate();
        obj.board.renderer.suspendRedraw(obj.board);
        obj.board.updateRenderer();
        obj.board.renderer.unsuspendRedraw();
      }
      return this;
    },
    /* **************************
     * renderer control
     * **************************/
    // documented in AbstractRenderer
    suspendRedraw: function(board) {
      this.context.save();
      this.context.clearRect(0, 0, this.canvasRoot.width, this.canvasRoot.height);
      if (board && board.attr.showcopyright) {
        this.displayCopyright(jxg_default.licenseText, 12);
      }
    },
    // documented in AbstractRenderer
    unsuspendRedraw: function() {
      this.context.restore();
    },
    // document in AbstractRenderer
    resize: function(w, h) {
      if (this.container) {
        this.canvasRoot.style.width = parseFloat(w) + "px";
        this.canvasRoot.style.height = parseFloat(h) + "px";
        this.canvasRoot.setAttribute("width", 2 * parseFloat(w) + "px");
        this.canvasRoot.setAttribute("height", 2 * parseFloat(h) + "px");
      } else {
        this.canvasRoot.width = 2 * parseFloat(w);
        this.canvasRoot.height = 2 * parseFloat(h);
      }
      this.context = this.canvasRoot.getContext("2d");
      this.context.scale(2, 2);
    },
    removeToInsertLater: function() {
      return function() {
      };
    }
  }
);
var canvas_default = jxg_default.CanvasRenderer;

// node_modules/jsxgraph/src/renderer/no.js
jxg_default.NoRenderer = function() {
  this.enhancedRendering = false;
  this.type = "no";
};
jxg_default.extend(
  jxg_default.NoRenderer.prototype,
  /** @lends JXG.NoRenderer.prototype */
  {
    /* ******************************** *
     *    Point drawing and updating    *
     * ******************************** */
    /**
     * Draws a point on the {@link JXG.Board}.
     * @param {JXG.Point} element Reference to a {@link JXG.Point} object that has to be drawn.
     * @see Point
     * @see JXG.Point
     * @see JXG.AbstractRenderer#updatePoint
     * @see JXG.AbstractRenderer#changePointStyle
     */
    drawPoint: function(element) {
    },
    /**
     * Updates visual appearance of the renderer element assigned to the given {@link JXG.Point}.
     * @param {JXG.Point} element Reference to a {@link JXG.Point} object, that has to be updated.
     * @see Point
     * @see JXG.Point
     * @see JXG.AbstractRenderer#drawPoint
     * @see JXG.AbstractRenderer#changePointStyle
     */
    updatePoint: function(element) {
    },
    /**
     * Changes the style of a {@link JXG.Point}. This is required because the point styles differ in what
     * elements have to be drawn, e.g. if the point is marked by a "x" or a "+" two lines are drawn, if
     * it's marked by spot a circle is drawn. This method removes the old renderer element(s) and creates
     * the new one(s).
     * @param {JXG.Point} element Reference to a {@link JXG.Point} object, that's style is changed.
     * @see Point
     * @see JXG.Point
     * @see JXG.AbstractRenderer#updatePoint
     * @see JXG.AbstractRenderer#drawPoint
     */
    changePointStyle: function(element) {
    },
    /* ******************************** *
     *           Lines                  *
     * ******************************** */
    /**
     * Draws a line on the {@link JXG.Board}.
     * @param {JXG.Line} element Reference to a line object, that has to be drawn.
     * @see Line
     * @see JXG.Line
     * @see JXG.AbstractRenderer#updateLine
     */
    drawLine: function(element) {
    },
    /**
     * Updates visual appearance of the renderer element assigned to the given {@link JXG.Line}.
     * @param {JXG.Line} element Reference to the {@link JXG.Line} object that has to be updated.
     * @see Line
     * @see JXG.Line
     * @see JXG.AbstractRenderer#drawLine
     */
    updateLine: function(element) {
    },
    /**
     * Creates a rendering node for ticks added to a line.
     * @param {JXG.Line} element A arbitrary line.
     * @see Line
     * @see Ticks
     * @see JXG.Line
     * @see JXG.Ticks
     * @see JXG.AbstractRenderer#updateTicks
     */
    drawTicks: function(element) {
    },
    /**
     * Update {@link Ticks} on a {@link JXG.Line}. This method is only a stub and has to be implemented
     * in any descendant renderer class.
     * @param {JXG.Line} element Reference of an line object, thats ticks have to be updated.
     * @see Line
     * @see Ticks
     * @see JXG.Line
     * @see JXG.Ticks
     * @see JXG.AbstractRenderer#drawTicks
     */
    updateTicks: function(element) {
    },
    /* **************************
     *    Curves
     * **************************/
    /**
     * Draws a {@link JXG.Curve} on the {@link JXG.Board}.
     * @param {JXG.Curve} element Reference to a graph object, that has to be plotted.
     * @see Curve
     * @see JXG.Curve
     * @see JXG.AbstractRenderer#updateCurve
     */
    drawCurve: function(element) {
    },
    /**
     * Updates visual appearance of the renderer element assigned to the given {@link JXG.Curve}.
     * @param {JXG.Curve} element Reference to a {@link JXG.Curve} object, that has to be updated.
     * @see Curve
     * @see JXG.Curve
     * @see JXG.AbstractRenderer#drawCurve
     */
    updateCurve: function(element) {
    },
    /* **************************
     *    Circle related stuff
     * **************************/
    /**
     * Draws a {@link JXG.Circle}
     * @param {JXG.Circle} element Reference to a {@link JXG.Circle} object that has to be drawn.
     * @see Circle
     * @see JXG.Circle
     * @see JXG.AbstractRenderer#updateEllipse
     */
    drawEllipse: function(element) {
    },
    /**
     * Updates visual appearance of a given {@link JXG.Circle} on the {@link JXG.Board}.
     * @param {JXG.Circle} element Reference to a {@link JXG.Circle} object, that has to be updated.
     * @see Circle
     * @see JXG.Circle
     * @see JXG.AbstractRenderer#drawEllipse
     */
    updateEllipse: function(element) {
    },
    /* **************************
     *   Polygon related stuff
     * **************************/
    /**
     * Draws a {@link JXG.Polygon} on the {@link JXG.Board}.
     * @param {JXG.Polygon} element Reference to a Polygon object, that is to be drawn.
     * @see Polygon
     * @see JXG.Polygon
     * @see JXG.AbstractRenderer#updatePolygon
     */
    drawPolygon: function(element) {
    },
    /**
     * Updates properties of a {@link JXG.Polygon}'s rendering node.
     * @param {JXG.Polygon} element Reference to a {@link JXG.Polygon} object, that has to be updated.
     * @see Polygon
     * @see JXG.Polygon
     * @see JXG.AbstractRenderer#drawPolygon
     */
    updatePolygon: function(element) {
    },
    /* **************************
     *    Text related stuff
     * **************************/
    /**
     * Shows a small copyright notice in the top left corner of the board.
     * @param {String} str The copyright notice itself
     * @param {Number} fontsize Size of the font the copyright notice is written in
     */
    displayCopyright: function(str2, fontsize) {
    },
    /**
     * An internal text is a {@link JXG.Text} element which is drawn using only
     * the given renderer but no HTML. This method is only a stub, the drawing
     * is done in the special renderers.
     * @param {JXG.Text} element Reference to a {@link JXG.Text} object
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#updateInternalText
     * @see JXG.AbstractRenderer#drawText
     * @see JXG.AbstractRenderer#updateText
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    drawInternalText: function(element) {
    },
    /**
     * Updates visual properties of an already existing {@link JXG.Text} element.
     * @param {JXG.Text} element Reference to an {@link JXG.Text} object, that has to be updated.
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#drawInternalText
     * @see JXG.AbstractRenderer#drawText
     * @see JXG.AbstractRenderer#updateText
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    updateInternalText: function(element) {
    },
    /**
     * Displays a {@link JXG.Text} on the {@link JXG.Board} by putting a HTML div over it.
     * @param {JXG.Text} element Reference to an {@link JXG.Text} object, that has to be displayed
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#drawInternalText
     * @see JXG.AbstractRenderer#updateText
     * @see JXG.AbstractRenderer#updateInternalText
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    drawText: function(element) {
    },
    /**
     * Updates visual properties of an already existing {@link JXG.Text} element.
     * @param {JXG.Text} element Reference to an {@link JXG.Text} object, that has to be updated.
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#drawText
     * @see JXG.AbstractRenderer#drawInternalText
     * @see JXG.AbstractRenderer#updateInternalText
     * @see JXG.AbstractRenderer#updateTextStyle
     */
    updateText: function(element) {
    },
    /**
     * Updates CSS style properties of a {@link JXG.Text} node.
     * @param {JXG.Text} element Reference to the {@link JXG.Text} object, that has to be updated.
     * @param {Boolean} doHighlight
     * @see Text
     * @see JXG.Text
     * @see JXG.AbstractRenderer#drawText
     * @see JXG.AbstractRenderer#drawInternalText
     * @see JXG.AbstractRenderer#updateText
     * @see JXG.AbstractRenderer#updateInternalText
     */
    updateTextStyle: function(element, doHighlight) {
    },
    /**
     * Set color and opacity of internal texts.
     * SVG needs its own version.
     * @private
     * @see JXG.AbstractRenderer#updateTextStyle
     * @see JXG.AbstractRenderer#updateInternalTextStyle
     */
    updateInternalTextStyle: function(element, strokeColor, strokeOpacity) {
    },
    /* **************************
     *    Image related stuff
     * **************************/
    /**
     * Draws an {@link JXG.Image} on a board; This is just a template that has to be implemented by special renderers.
     * @param {JXG.Image} element Reference to the image object that is to be drawn
     * @see Image
     * @see JXG.Image
     * @see JXG.AbstractRenderer#updateImage
     */
    drawImage: function(element) {
    },
    /**
     * Updates the properties of an {@link JXG.Image} element.
     * @param {JXG.Image} element Reference to an {@link JXG.Image} object, that has to be updated.
     * @see Image
     * @see JXG.Image
     * @see JXG.AbstractRenderer#drawImage
     */
    updateImage: function(element) {
    },
    /**
     * Applies transformations on images and text elements. This method is just a stub and has to be implemented in all
     * descendant classes where text and image transformations are to be supported.
     * @param {JXG.Image|JXG.Text} element A {@link JXG.Image} or {@link JXG.Text} object.
     * @param {Array} transformations An array of {@link JXG.Transformation} objects. This is usually the transformations property
     * of the given element <tt>el</tt>.
     */
    transformImage: function(element, transformations) {
    },
    /**
     * If the URL of the image is provided by a function the URL has to be updated during updateImage()
     * @param {JXG.Image} element Reference to an image object.
     * @see JXG.AbstractRenderer#updateImage
     */
    updateImageURL: function(element) {
    },
    /* **************************
     * Render primitive objects
     * **************************/
    /**
     * Appends a node to a specific layer level. This is just an abstract method and has to be implemented
     * in all renderers that want to use the <tt>createPrim</tt> model to draw.
     * @param {Node} node A DOM tree node.
     * @param {Number} level The layer the node is attached to. This is the index of the layer in
     * {@link JXG.SVGRenderer#layer} or the <tt>z-index</tt> style property of the node in VMLRenderer.
     */
    appendChildPrim: function(node2, level) {
    },
    /**
     * Stores the rendering nodes. This is an abstract method which has to be implemented in all renderers that use
     * the <tt>createPrim</tt> method.
     * @param {JXG.GeometryElement} element A JSXGraph element.
     * @param {String} type The XML node name. Only used in VMLRenderer.
     */
    appendNodesToElement: function(element, type) {
    },
    /**
     * Creates a node of a given type with a given id.
     * @param {String} type The type of the node to create.
     * @param {String} id Set the id attribute to this.
     * @returns {Node} Reference to the created node.
     */
    createPrim: function(type, id) {
      return null;
    },
    /**
     * Removes an element node. Just a stub.
     * @param {Node} node The node to remove.
     */
    remove: function(node2) {
    },
    /**
     * Can be used to create the nodes to display arrows. This is an abstract method which has to be implemented
     * in any descendant renderer.
     * @param {JXG.GeometryElement} element The element the arrows are to be attached to.
     */
    makeArrows: function(element) {
    },
    /**
     * Updates an ellipse node primitive. This is an abstract method which has to be implemented in all renderers
     * that use the <tt>createPrim</tt> method.
     * @param {Node} node Reference to the node.
     * @param {Number} x Centre X coordinate
     * @param {Number} y Centre Y coordinate
     * @param {Number} rx The x-axis radius.
     * @param {Number} ry The y-axis radius.
     */
    updateEllipsePrim: function(node2, x, y, rx, ry) {
    },
    /**
     * Refreshes a line node. This is an abstract method which has to be implemented in all renderers that use
     * the <tt>createPrim</tt> method.
     * @param {Node} node The node to be refreshed.
     * @param {Number} p1x The first point's x coordinate.
     * @param {Number} p1y The first point's y coordinate.
     * @param {Number} p2x The second point's x coordinate.
     * @param {Number} p2y The second point's y coordinate.
     * @param {JXG.Board} board
     */
    updateLinePrim: function(node2, p1x, p1y, p2x, p2y, board) {
    },
    /**
     * Updates a path element. This is an abstract method which has to be implemented in all renderers that use
     * the <tt>createPrim</tt> method.
     * @param {Node} node The path node.
     * @param {String} pathString A string formatted like e.g. <em>'M 1,2 L 3,1 L5,5'</em>. The format of the string
     * depends on the rendering engine.
     * @param {JXG.Board} board Reference to the element's board.
     */
    updatePathPrim: function(node2, pathString, board) {
    },
    /**
     * Builds a path data string to draw a point with a face other than <em>rect</em> and <em>circle</em>. Since
     * the format of such a string usually depends on the renderer this method
     * is only an abstract method. Therefore, it has to be implemented in the descendant renderer itself unless
     * the renderer does not use the createPrim interface but the draw* interfaces to paint.
     * @param {JXG.Point} element The point element
     * @param {Number} size A positive number describing the size. Usually the half of the width and height of
     * the drawn point.
     * @param {String} type A string describing the point's face. This method only accepts the shortcut version of
     * each possible face: <tt>x, +, |, -, [], <>, <<>>, ^, v, >, <
     */
    updatePathStringPoint: function(element, size2, type) {
    },
    /**
     * Builds a path data string from a {@link JXG.Curve} element. Since the path data strings heavily depend on the
     * underlying rendering technique this method is just a stub. Although such a path string is of no use for the
     * CanvasRenderer, this method is used there to draw a path directly.
     * @param element
     */
    updatePathStringPrim: function(element) {
    },
    /**
     * Builds a path data string from a {@link JXG.Curve} element such that the curve looks like
     * hand drawn.
     * Since the path data strings heavily depend on the
     * underlying rendering technique this method is just a stub. Although such a path string is of no use for the
     * CanvasRenderer, this method is used there to draw a path directly.
     * @param element
     */
    updatePathStringBezierPrim: function(element) {
    },
    /**
     * Update a polygon primitive.
     * @param {Node} node
     * @param {JXG.Polygon} element A JSXGraph element of type {@link JXG.Polygon}
     */
    updatePolygonPrim: function(node2, element) {
    },
    /**
     * Update a rectangle primitive. This is used only for points with face of type 'rect'.
     * @param {Node} node The node yearning to be updated.
     * @param {Number} x x coordinate of the top left vertex.
     * @param {Number} y y coordinate of the top left vertex.
     * @param {Number} w Width of the rectangle.
     * @param {Number} h The rectangle's height.
     */
    updateRectPrim: function(node2, x, y, w, h) {
    },
    /* **************************
     *  Set Attributes
     * **************************/
    /**
     * Sets a node's attribute.
     * @param {Node} node The node that is to be updated.
     * @param {String} key Name of the attribute.
     * @param {String} val New value for the attribute.
     */
    setPropertyPrim: function(node2, key, val) {
    },
    /**
     * Shows or hides an element on the canvas; Only a stub, requires implementation in the derived renderer.
     * @param {JXG.GeometryElement} element Reference to the object that has to appear.
     * @param {Boolean} value true to show the element, false to hide the element.
     */
    display: function(element, value) {
      if (element) {
        element.visPropOld.visible = value;
      }
    },
    /**
     * Shows a hidden element on the canvas; Only a stub, requires implementation in the derived renderer.
     *
     * Please use JXG.AbstractRenderer#display instead
     * @param {JXG.GeometryElement} element Reference to the object that has to appear.
     * @see JXG.AbstractRenderer#hide
     * @deprecated
     */
    show: function(element) {
    },
    /**
     * Hides an element on the canvas; Only a stub, requires implementation in the derived renderer.
     *
     * Please use JXG.AbstractRenderer#display instead
     * @param {JXG.GeometryElement} element Reference to the geometry element that has to disappear.
     * @see JXG.AbstractRenderer#show
     * @deprecated
     */
    hide: function(element) {
    },
    /**
     * Sets the buffering as recommended by SVGWG. Until now only Opera supports this and will be ignored by
     * other browsers. Although this feature is only supported by SVG we have this method in {@link JXG.AbstractRenderer}
     * because it is called from outside the renderer.
     * @param {Node} node The SVG DOM Node which buffering type to update.
     * @param {String} type Either 'auto', 'dynamic', or 'static'. For an explanation see
     *   {@link https://www.w3.org/TR/SVGTiny12/painting.html#BufferedRenderingProperty}.
     */
    setBuffering: function(node2, type) {
    },
    /**
     * Sets an element's dash style.
     * @param {JXG.GeometryElement} element An JSXGraph element.
     */
    setDashStyle: function(element) {
    },
    /**
     * Puts an object into draft mode, i.e. it's visual appearance will be changed. For GEONE<sub>x</sub>T backwards compatibility.
     * @param {JXG.GeometryElement} element Reference of the object that is in draft mode.
     */
    setDraft: function(element) {
    },
    /**
     * Puts an object from draft mode back into normal mode.
     * @param {JXG.GeometryElement} element Reference of the object that no longer is in draft mode.
     */
    removeDraft: function(element) {
    },
    /**
     * Sets up nodes for rendering a gradient fill.
     * @param element
     */
    setGradient: function(element) {
    },
    /**
     * Updates the gradient fill.
     * @param {JXG.GeometryElement} element An JSXGraph element with an area that can be filled.
     */
    updateGradient: function(element) {
    },
    /**
     * Sets the transition duration (in milliseconds) for fill color and stroke
     * color and opacity.
     * @param {JXG.GeometryElement} element Reference of the object that wants a
     *         new transition duration.
     * @param {Number} duration (Optional) duration in milliseconds. If not given,
     *        element.visProp.transitionDuration is taken. This is the default.
     */
    setObjectTransition: function(element, duration) {
    },
    /**
     * Sets an objects fill color.
     * @param {JXG.GeometryElement} element Reference of the object that wants a new fill color.
     * @param {String} color Color in a HTML/CSS compatible format. If you don't want any fill color at all, choose 'none'.
     * @param {Number} opacity Opacity of the fill color. Must be between 0 and 1.
     */
    setObjectFillColor: function(element, color2, opacity) {
    },
    /**
     * Changes an objects stroke color to the given color.
     * @param {JXG.GeometryElement} element Reference of the {@link JXG.GeometryElement} that gets a new stroke color.
     * @param {String} color Color value in a HTML compatible format, e.g. <strong>#00ff00</strong> or <strong>green</strong> for green.
     * @param {Number} opacity Opacity of the fill color. Must be between 0 and 1.
     */
    setObjectStrokeColor: function(element, color2, opacity) {
    },
    /**
     * Sets an element's stroke width.
     * @param {JXG.GeometryElement} element Reference to the geometry element.
     * @param {Number} width The new stroke width to be assigned to the element.
     */
    setObjectStrokeWidth: function(element, width) {
    },
    /**
     * Sets the shadow properties to a geometry element. This method is only a stub, it is implemented in the actual renderers.
     * @param {JXG.GeometryElement} element Reference to a geometry object, that should get a shadow
     */
    setShadow: function(element) {
    },
    /**
     * Highlights an object, i.e. changes the current colors of the object to its highlighting colors
     * @param {JXG.GeometryElement} element Reference of the object that will be highlighted.
     * @returns {JXG.AbstractRenderer} Reference to the renderer
     */
    highlight: function(element) {
    },
    /**
     * Uses the normal colors of an object, i.e. the opposite of {@link JXG.AbstractRenderer#highlight}.
     * @param {JXG.GeometryElement} element Reference of the object that will get its normal colors.
     * @returns {JXG.AbstractRenderer} Reference to the renderer
     */
    noHighlight: function(element) {
    },
    /* **************************
     * renderer control
     * **************************/
    /**
     * Stop redraw. This method is called before every update, so a non-vector-graphics based renderer
     * can use this method to delete the contents of the drawing panel. This is an abstract method every
     * descendant renderer should implement, if appropriate.
     * @see JXG.AbstractRenderer#unsuspendRedraw
     */
    suspendRedraw: function() {
    },
    /**
     * Restart redraw. This method is called after updating all the rendering node attributes.
     * @see JXG.AbstractRenderer#suspendRedraw
     */
    unsuspendRedraw: function() {
    },
    /**
     * The tiny zoom bar shown on the bottom of a board (if showNavigation on board creation is true).
     * @param {JXG.Board} board Reference to a JSXGraph board.
     */
    drawNavigationBar: function(board) {
    },
    /**
     * Wrapper for getElementById for maybe other renderers which elements are not directly accessible by DOM methods like document.getElementById().
     * @param {String} id Unique identifier for element.
     * @returns {Object} Reference to a JavaScript object. In case of SVG/VMLRenderer it's a reference to a SVG/VML node.
     */
    getElementById: function(id) {
      return null;
    },
    /**
     * Resizes the rendering element
     * @param {Number} w New width
     * @param {Number} h New height
     */
    resize: function(w, h) {
    },
    removeToInsertLater: function() {
      return function() {
      };
    }
  }
);
jxg_default.NoRenderer.prototype = new abstract_default();
var no_default = jxg_default.NoRenderer;

// node_modules/jsxgraph/src/jsxgraph.js
jxg_default.JSXGraph = {
  /**
   * Stores the renderer that is used to draw the boards.
   * @type String
   */
  rendererType: function() {
    options_default.board.renderer = "no";
    if (env_default.supportsVML()) {
      options_default.board.renderer = "vml";
      document.onmousemove = function() {
        var t;
        if (document.body) {
          t = document.body.scrollLeft;
          t += document.body.scrollTop;
        }
        return t;
      };
    }
    if (env_default.supportsCanvas()) {
      options_default.board.renderer = "canvas";
    }
    if (env_default.supportsSVG()) {
      options_default.board.renderer = "svg";
    }
    if (env_default.isNode() && env_default.supportsCanvas()) {
      options_default.board.renderer = "canvas";
    }
    if (env_default.isNode() || options_default.renderer === "no") {
      options_default.text.display = "internal";
      options_default.infobox.display = "internal";
    }
    return options_default.board.renderer;
  }(),
  /**
   * Initialize the rendering engine
   *
   * @param  {String} box        id of or reference to the div element which hosts the JSXGraph construction
   * @param  {Object} dim        The dimensions of the board
   * @param  {Object} doc        Usually, this is document object of the browser window.  If false or null, this defaults
   * to the document object of the browser.
   * @param  {Object} attrRenderer Attribute 'renderer', specifies the rendering engine. Possible values are 'auto', 'svg',
   *  'canvas', 'no', and 'vml'.
   * @returns {Object}           Reference to the rendering engine object.
   * @private
   */
  initRenderer: function(box, dim, doc, attrRenderer) {
    var boxid, renderer;
    if ((!type_default.exists(doc) || doc === false) && typeof document === "object") {
      doc = document;
    }
    if (typeof doc === "object" && box !== null) {
      boxid = type_default.isString(box) ? doc.getElementById(box) : box;
      while (boxid.firstChild) {
        boxid.removeChild(boxid.firstChild);
      }
    } else {
      boxid = box;
    }
    if (attrRenderer === void 0 || attrRenderer === "auto") {
      attrRenderer = this.rendererType;
    }
    if (attrRenderer === "svg") {
      renderer = new svg_default(boxid, dim);
    } else if (attrRenderer === "vml") {
      renderer = new vml_default(boxid);
    } else if (attrRenderer === "canvas") {
      renderer = new canvas_default(boxid, dim);
    } else {
      renderer = new no_default();
    }
    return renderer;
  },
  /**
   * Merge the user supplied attributes with the attributes in options.js
   *
   * @param {Object} attributes User supplied attributes
   * @returns {Object} Merged attributes for the board
   *
   * @private
   */
  _setAttributes: function(attributes, options) {
    var attr = type_default.copyAttributes(attributes, options, "board"), list2 = [
      "drag",
      "fullscreen",
      "intl",
      "keyboard",
      "logging",
      "navbar",
      "pan",
      "resize",
      "screenshot",
      "selection",
      "zoom"
    ], len = list2.length, i2, key;
    for (i2 = 0; i2 < len; i2++) {
      key = list2[i2];
      attr[key] = type_default.copyAttributes(attr, options, "board", key);
    }
    attr.movetarget = attributes.moveTarget || attributes.movetarget || options.board.moveTarget;
    return attr;
  },
  /**
   * Further initialization of the board. Set some properties from attribute values.
   *
   * @param {JXG.Board} board
   * @param {Object} attr attributes object
   * @param {Object} dimensions Object containing dimensions of the canvas
   *
   * @private
   */
  _fillBoard: function(board, attr, dimensions) {
    board.initInfobox(attr.infobox);
    board.maxboundingbox = attr.maxboundingbox;
    board.resizeContainer(dimensions.width, dimensions.height, true, true);
    board._createSelectionPolygon(attr);
    board.renderer.drawNavigationBar(board, attr.navbar);
    jxg_default.boards[board.id] = board;
  },
  /**
   *
   * @param {String|Object} container id of or reference to the HTML element in which the board is painted.
   * @param {Object} attr An object that sets some of the board properties.
   *
   * @private
   */
  _setARIA: function(container, attr) {
    var doc = attr.document, doc_glob, node_jsx, newNode, parent, id_label, id_description;
    if (typeof doc !== "object") {
      if (!env_default.isBrowser) {
        return;
      }
      doc = document;
    }
    node_jsx = type_default.isString(container) ? doc.getElementById(container) : container;
    doc_glob = node_jsx.ownerDocument;
    parent = node_jsx.parentNode;
    id_label = container + "_ARIAlabel";
    id_description = container + "_ARIAdescription";
    newNode = doc_glob.createElement("div");
    newNode.innerHTML = attr.title;
    newNode.setAttribute("id", id_label);
    newNode.style.display = "none";
    parent.insertBefore(newNode, node_jsx);
    newNode = doc_glob.createElement("div");
    newNode.innerHTML = attr.description;
    newNode.setAttribute("id", id_description);
    newNode.style.display = "none";
    parent.insertBefore(newNode, node_jsx);
    node_jsx.setAttribute("aria-labelledby", id_label);
    node_jsx.setAttribute("aria-describedby", id_description);
  },
  /**
   * Remove the two corresponding ARIA divs when freeing a board
   *
   * @param {JXG.Board} board
   *
   * @private
   */
  _removeARIANodes: function(board) {
    var node2, id, doc;
    doc = board.document || document;
    if (typeof doc !== "object") {
      return;
    }
    id = board.containerObj.getAttribute("aria-labelledby");
    node2 = doc.getElementById(id);
    if (node2 && node2.parentNode) {
      node2.parentNode.removeChild(node2);
    }
    id = board.containerObj.getAttribute("aria-describedby");
    node2 = doc.getElementById(id);
    if (node2 && node2.parentNode) {
      node2.parentNode.removeChild(node2);
    }
  },
  /**
   * Initialize a new board.
   * @param {String|Object} box id of or reference to the HTML element in which the board is painted.
   * @param {Object} attributes An object that sets some of the board properties. Most of these properties can be set via JXG.Options.
   * @param {Array} [attributes.boundingbox=[-5, 5, 5, -5]] An array containing four numbers describing the left, top, right and bottom boundary of the board in user coordinates
   * @param {Boolean} [attributes.keepaspectratio=false] If <tt>true</tt>, the bounding box is adjusted to the same aspect ratio as the aspect ratio of the div containing the board.
   * @param {Boolean} [attributes.showCopyright=false] Show the copyright string in the top left corner.
   * @param {Boolean} [attributes.showNavigation=false] Show the navigation buttons in the bottom right corner.
   * @param {Object} [attributes.zoom] Allow the user to zoom with the mouse wheel or the two-fingers-zoom gesture.
   * @param {Object} [attributes.pan] Allow the user to pan with shift+drag mouse or two-fingers-pan gesture.
   * @param {Object} [attributes.drag] Allow the user to drag objects with a pointer device.
   * @param {Object} [attributes.keyboard] Allow the user to drag objects with arrow keys on keyboard.
   * @param {Boolean} [attributes.axis=false] If set to true, show the axis. Can also be set to an object that is given to both axes as an attribute object.
   * @param {Boolean|Object} [attributes.grid] If set to true, shows the grid. Can also be set to an object that is given to the grid as its attribute object.
   * @param {Boolean} [attributes.registerEvents=true] Register mouse / touch events.
   * @returns {JXG.Board} Reference to the created board.
   *
   * @see JXG.AbstractRenderer#drawNavigationBar
   */
  initBoard: function(box, attributes) {
    var originX, originY, unitX, unitY, w, h, offX = 0, offY = 0, renderer, dimensions, bbox, attr, axattr, axattr_x, axattr_y, options, theme = {}, board;
    attributes = attributes || {};
    if (attributes.theme !== "default" && type_default.exists(jxg_default.themes[attributes.theme])) {
      theme = jxg_default.themes[attributes.theme];
    }
    options = type_default.deepCopy(options_default, theme, true);
    attr = this._setAttributes(attributes, options);
    dimensions = env_default.getDimensions(box, attr.document);
    if (attr.unitx || attr.unity) {
      originX = type_default.def(attr.originx, 150);
      originY = type_default.def(attr.originy, 150);
      unitX = type_default.def(attr.unitx, 50);
      unitY = type_default.def(attr.unity, 50);
    } else {
      bbox = attr.boundingbox;
      if (bbox[0] < attr.maxboundingbox[0]) {
        bbox[0] = attr.maxboundingbox[0];
      }
      if (bbox[1] > attr.maxboundingbox[1]) {
        bbox[1] = attr.maxboundingbox[1];
      }
      if (bbox[2] > attr.maxboundingbox[2]) {
        bbox[2] = attr.maxboundingbox[2];
      }
      if (bbox[3] < attr.maxboundingbox[3]) {
        bbox[3] = attr.maxboundingbox[3];
      }
      dimensions.width = "1";
      dimensions.height = "1";
      w = Math.max(parseInt(dimensions.width, 10), math_default.eps);
      h = Math.max(parseInt(dimensions.height, 10), math_default.eps);
      if (type_default.exists(bbox) && attr.keepaspectratio) {
        unitX = w / (bbox[2] - bbox[0]);
        unitY = h / (bbox[1] - bbox[3]);
        if (Math.abs(unitX) < Math.abs(unitY)) {
          unitY = Math.abs(unitX) * unitY / Math.abs(unitY);
          offY = (h / unitY - (bbox[1] - bbox[3])) * 0.5;
        } else {
          unitX = Math.abs(unitY) * unitX / Math.abs(unitX);
          offX = (w / unitX - (bbox[2] - bbox[0])) * 0.5;
        }
      } else {
        unitX = w / (bbox[2] - bbox[0]);
        unitY = h / (bbox[1] - bbox[3]);
      }
      originX = -unitX * (bbox[0] - offX);
      originY = unitY * (bbox[1] + offY);
    }
    renderer = this.initRenderer(box, dimensions, attr.document, attr.renderer);
    this._setARIA(box, attr);
    board = new board_default(
      box,
      renderer,
      attr.id,
      [originX, originY],
      /*attr.zoomfactor * */
      attr.zoomx,
      /*attr.zoomfactor * */
      attr.zoomy,
      unitX,
      unitY,
      dimensions.width,
      dimensions.height,
      attr
    );
    board.keepaspectratio = attr.keepaspectratio;
    this._fillBoard(board, attr, dimensions);
    board.suspendUpdate();
    attr = board.attr;
    if (attr.axis) {
      axattr = typeof attr.axis === "object" ? attr.axis : {};
      axattr_x = type_default.deepCopy(options.board.defaultaxes.x, axattr);
      axattr_y = type_default.deepCopy(options.board.defaultaxes.y, axattr);
      if (attr.defaultaxes.x) {
        axattr_x = type_default.deepCopy(axattr_x, attr.defaultaxes.x);
      }
      if (attr.defaultaxes.y) {
        axattr_y = type_default.deepCopy(axattr_y, attr.defaultaxes.y);
      }
      board.defaultAxes = {};
      board.defaultAxes.x = board.create("axis", [[0, 0], [1, 0]], axattr_x);
      board.defaultAxes.y = board.create("axis", [[0, 0], [0, 1]], axattr_y);
    }
    if (attr.grid) {
      board.create("grid", [], typeof attr.grid === "object" ? attr.grid : {});
    }
    board.unsuspendUpdate();
    return board;
  },
  /**
   * Load a board from a file containing a construction made with either GEONExT,
   * Intergeo, Geogebra, or Cinderella.
   * @param {String|Object} box id of or reference to the HTML element in which the board is painted.
   * @param {String} file base64 encoded string.
   * @param {String} format containing the file format: 'Geonext' or 'Intergeo'.
   * @param {Object} attributes Attributes for the board and 'encoding'.
   *  Compressed files need encoding 'iso-8859-1'. Otherwise it probably is 'utf-8'.
   * @param {Function} callback
   * @returns {JXG.Board} Reference to the created board.
   * @see JXG.FileReader
   * @see JXG.GeonextReader
   * @see JXG.GeogebraReader
   * @see JXG.IntergeoReader
   * @see JXG.CinderellaReader
   *
   * @example
   * // Uncompressed file
   * var board = JXG.JSXGraph.loadBoardFromFile('jxgbox', 'filename', 'geonext',
   *      {encoding: 'utf-8'},
   *      function (board) { console.log("Done loading"); }
   * );
   * // Compressed file
   * var board = JXG.JSXGraph.loadBoardFromFile('jxgbox', 'filename', 'geonext',
   *      {encoding: 'iso-8859-1'},
   *      function (board) { console.log("Done loading"); }
   * );
   *
   * @example
   * // From <input type="file" id="localfile" />
   * var file = document.getElementById('localfile').files[0];
   * JXG.JSXGraph.loadBoardFromFile('jxgbox', file, 'geonext',
   *      {encoding: 'utf-8'},
   *      function (board) { console.log("Done loading"); }
   * );
   */
  loadBoardFromFile: function(box, file, format, attributes, callback) {
    var attr, renderer, board, dimensions, encoding;
    attributes = attributes || {};
    attr = this._setAttributes(attributes);
    dimensions = env_default.getDimensions(box, attr.document);
    renderer = this.initRenderer(box, dimensions, attr.document, attr.renderer);
    this._setARIA(box, attr);
    board = new board_default(
      box,
      renderer,
      "",
      [150, 150],
      1,
      1,
      50,
      50,
      dimensions.width,
      dimensions.height,
      attr
    );
    this._fillBoard(board, attr, dimensions);
    encoding = attr.encoding || "iso-8859-1";
    file_default.parseFileContent(file, board, format, true, encoding, callback);
    return board;
  },
  /**
   * Load a board from a base64 encoded string containing a construction made with either GEONExT,
   * Intergeo, Geogebra, or Cinderella.
   * @param {String|Object} box id of or reference to the HTML element in which the board is painted.
   * @param {String} string base64 encoded string.
   * @param {String} format containing the file format: 'Geonext', 'Intergeo', 'Geogebra'.
   * @param {Object} attributes Attributes for the board and 'encoding'.
   *  Compressed files need encoding 'iso-8859-1'. Otherwise it probably is 'utf-8'.
   * @param {Function} callback
   * @returns {JXG.Board} Reference to the created board.
   * @see JXG.FileReader
   * @see JXG.GeonextReader
   * @see JXG.GeogebraReader
   * @see JXG.IntergeoReader
   * @see JXG.CinderellaReader
   */
  loadBoardFromString: function(box, string, format, attributes, callback) {
    var attr, renderer, board, dimensions;
    attributes = attributes || {};
    attr = this._setAttributes(attributes);
    dimensions = env_default.getDimensions(box, attr.document);
    renderer = this.initRenderer(box, dimensions, attr.document, attr.renderer);
    this._setARIA(box, attr);
    board = new board_default(
      box,
      renderer,
      "",
      [150, 150],
      1,
      1,
      50,
      50,
      dimensions.width,
      dimensions.height,
      attr
    );
    this._fillBoard(board, attr, dimensions);
    file_default.parseString(string, board, format, true, callback);
    return board;
  },
  /**
   * Delete a board and all its contents.
   * @param {JXG.Board|String} board id of or reference to the DOM element in which the board is drawn.
   *
   */
  freeBoard: function(board) {
    var el;
    if (typeof board === "string") {
      board = jxg_default.boards[board];
    }
    this._removeARIANodes(board);
    board.removeEventHandlers();
    board.suspendUpdate();
    for (el in board.objects) {
      if (board.objects.hasOwnProperty(el)) {
        board.objects[el].remove();
      }
    }
    while (board.containerObj.firstChild) {
      board.containerObj.removeChild(board.containerObj.firstChild);
    }
    for (el in board.objects) {
      if (board.objects.hasOwnProperty(el)) {
        delete board.objects[el];
      }
    }
    delete board.renderer;
    board.jc.creator.clearCache();
    delete board.jc;
    delete jxg_default.boards[board.id];
  },
  /**
   * @deprecated Use JXG#registerElement
   * @param element
   * @param creator
   */
  registerElement: function(element, creator) {
    jxg_default.deprecated("JXG.JSXGraph.registerElement()", "JXG.registerElement()");
    jxg_default.registerElement(element, creator);
  }
};
if (env_default.isBrowser && typeof window === "object" && typeof document === "object") {
  env_default.addEvent(
    window,
    "load",
    function() {
      var type, i2, j, div, id, board, txt, width, height, maxWidth, aspectRatio, cssClasses, bbox, axis, grid, code, src, request, postpone = false, scripts = document.getElementsByTagName("script"), init2 = function(code2, type2, bbox2) {
        var board2 = jxg_default.JSXGraph.initBoard(id, {
          boundingbox: bbox2,
          keepaspectratio: true,
          grid,
          axis,
          showReload: true
        });
        if (type2.toLowerCase().indexOf("script") > -1) {
          board2.construct(code2);
        } else {
          try {
            board2.jc.parse(code2);
          } catch (e2) {
            jxg_default.debug(e2);
          }
        }
        return board2;
      }, makeReload = function(board2, code2, type2, bbox2) {
        return function() {
          var newBoard;
          jxg_default.JSXGraph.freeBoard(board2);
          newBoard = init2(code2, type2, bbox2);
          newBoard.reload = makeReload(newBoard, code2, type2, bbox2);
        };
      };
      for (i2 = 0; i2 < scripts.length; i2++) {
        type = scripts[i2].getAttribute("type", false);
        if (type_default.exists(type) && (type.toLowerCase() === "text/jessiescript" || type.toLowerCase() === "jessiescript" || type.toLowerCase() === "text/jessiecode" || type.toLowerCase() === "jessiecode")) {
          cssClasses = scripts[i2].getAttribute("class", false) || "";
          width = scripts[i2].getAttribute("width", false) || "";
          height = scripts[i2].getAttribute("height", false) || "";
          maxWidth = scripts[i2].getAttribute("maxwidth", false) || "100%";
          aspectRatio = scripts[i2].getAttribute("aspectratio", false) || "1/1";
          bbox = scripts[i2].getAttribute("boundingbox", false) || "-5, 5, 5, -5";
          id = scripts[i2].getAttribute("container", false);
          src = scripts[i2].getAttribute("src", false);
          bbox = bbox.split(",");
          if (bbox.length !== 4) {
            bbox = [-5, 5, 5, -5];
          } else {
            for (j = 0; j < bbox.length; j++) {
              bbox[j] = parseFloat(bbox[j]);
            }
          }
          axis = type_default.str2Bool(scripts[i2].getAttribute("axis", false) || "false");
          grid = type_default.str2Bool(scripts[i2].getAttribute("grid", false) || "false");
          if (!type_default.exists(id)) {
            id = "jessiescript_autgen_jxg_" + i2;
            div = document.createElement("div");
            div.setAttribute("id", id);
            txt = width !== "" ? "width:" + width + ";" : "";
            txt += height !== "" ? "height:" + height + ";" : "";
            txt += maxWidth !== "" ? "max-width:" + maxWidth + ";" : "";
            txt += aspectRatio !== "" ? "aspect-ratio:" + aspectRatio + ";" : "";
            div.setAttribute("style", txt);
            div.setAttribute("class", "jxgbox " + cssClasses);
            try {
              document.body.insertBefore(div, scripts[i2]);
            } catch (e) {
              if (typeof jQuery === "object") {
                jQuery(div).insertBefore(scripts[i2]);
              }
            }
          } else {
            div = document.getElementById(id);
          }
          code = "";
          if (type_default.exists(src)) {
            postpone = true;
            request = new XMLHttpRequest();
            request.open("GET", src);
            request.overrideMimeType("text/plain; charset=x-user-defined");
            request.addEventListener("load", function() {
              if (this.status < 400) {
                code = this.responseText + "\n" + code;
                board = init2(code, type, bbox);
                board.reload = makeReload(board, code, type, bbox);
              } else {
                throw new Error(
                  "\nJSXGraph: failed to load file",
                  src,
                  ":",
                  this.responseText
                );
              }
            });
            request.addEventListener("error", function(e) {
              throw new Error("\nJSXGraph: failed to load file", src, ":", e);
            });
            request.send();
          } else {
            postpone = false;
          }
          if (document.getElementById(id)) {
            code = scripts[i2].innerHTML;
            code = code.replace(/<!\[CDATA\[/g, "").replace(/\]\]>/g, "");
            scripts[i2].innerHTML = code;
            if (!postpone) {
              board = init2(code, type, bbox);
              board.reload = makeReload(board, code, type, bbox);
            }
          } else {
            jxg_default.debug(
              "JSXGraph: Apparently the div injection failed. Can't create a board, sorry."
            );
          }
        }
      }
    },
    window
  );
}
var jsxgraph_default = jxg_default.JSXGraph;

// node_modules/jsxgraph/src/base/point.js
jxg_default.Point = function(board, coordinates, attributes) {
  this.constructor(board, attributes, constants_default.OBJECT_TYPE_POINT, constants_default.OBJECT_CLASS_POINT);
  this.element = this.board.select(attributes.anchor);
  this.coordsConstructor(coordinates);
  this.elType = "point";
  this.id = this.board.setId(this, "P");
  this.board.renderer.drawPoint(this);
  this.board.finalizeAdding(this);
  this.createGradient();
  this.createLabel();
};
jxg_default.Point.prototype = new element_default();
type_default.copyPrototypeMethods(jxg_default.Point, coordselement_default, "coordsConstructor");
jxg_default.extend(
  jxg_default.Point.prototype,
  /** @lends JXG.Point.prototype */
  {
    /**
     * Checks whether (x,y) is near the point.
     * @param {Number} x Coordinate in x direction, screen coordinates.
     * @param {Number} y Coordinate in y direction, screen coordinates.
     * @returns {Boolean} True if (x,y) is near the point, False otherwise.
     * @private
     */
    hasPoint: function(x, y) {
      var coordsScr = this.coords.scrCoords, r, prec, type, unit = type_default.evaluate(this.visProp.sizeunit);
      if (type_default.isObject(type_default.evaluate(this.visProp.precision))) {
        type = this.board._inputDevice;
        prec = type_default.evaluate(this.visProp.precision[type]);
      } else {
        prec = this.board.options.precision.hasPoint;
      }
      r = parseFloat(type_default.evaluate(this.visProp.size));
      if (unit === "user") {
        r *= Math.sqrt(Math.abs(this.board.unitX * this.board.unitY));
      }
      r += parseFloat(type_default.evaluate(this.visProp.strokewidth)) * 0.5;
      if (r < prec) {
        r = prec;
      }
      return Math.abs(coordsScr[1] - x) < r + 2 && Math.abs(coordsScr[2] - y) < r + 2;
    },
    /**
     * Updates the position of the point.
     */
    update: function(fromParent) {
      if (!this.needsUpdate) {
        return this;
      }
      this.updateCoords(fromParent);
      if (type_default.evaluate(this.visProp.trace)) {
        this.cloneToBackground(true);
      }
      return this;
    },
    /**
     * Applies the transformations of the element to {@link JXG.Point#baseElement}.
     * Point transformations are relative to a base element.
     * @param {Boolean} fromParent True if the drag comes from a child element. This is the case if a line
     *    through two points is dragged. Otherwise, the element is the drag element and we apply the
     *    the inverse transformation to the baseElement if is different from the element.
     * @returns {JXG.CoordsElement} Reference to this object.
     */
    updateTransform: function(fromParent) {
      var c, i2;
      if (this.transformations.length === 0 || this.baseElement === null) {
        return this;
      }
      if (this === this.baseElement) {
        c = this.transformations[0].apply(this.baseElement, "self");
        this.coords.setCoordinates(constants_default.COORDS_BY_USER, c);
      } else {
        c = this.transformations[0].apply(this.baseElement);
      }
      this.coords.setCoordinates(constants_default.COORDS_BY_USER, c);
      for (i2 = 1; i2 < this.transformations.length; i2++) {
        this.coords.setCoordinates(
          constants_default.COORDS_BY_USER,
          this.transformations[i2].apply(this)
        );
      }
      return this;
    },
    /**
     * Calls the renderer to update the drawing.
     * @private
     */
    updateRenderer: function() {
      this.updateRendererGeneric("updatePoint");
      return this;
    },
    // documented in JXG.GeometryElement
    bounds: function() {
      return this.coords.usrCoords.slice(1).concat(this.coords.usrCoords.slice(1));
    },
    /**
     * Convert the point to intersection point and update the construction.
     * To move the point visual onto the intersection, a call of board update is necessary.
     *
     * @param {String|Object} el1, el2, i, j The intersecting objects and the numbers.
     **/
    makeIntersection: function(el1, el2, i2, j) {
      var func;
      el1 = this.board.select(el1);
      el2 = this.board.select(el2);
      func = geometry_default.intersectionFunction(
        this.board,
        el1,
        el2,
        i2,
        j,
        this.visProp.alwaysintersect
      );
      this.addConstraint([func]);
      try {
        el1.addChild(this);
        el2.addChild(this);
      } catch (e) {
        throw new Error(
          "JSXGraph: Can't create 'intersection' with parent types '" + typeof el1 + "' and '" + typeof el2 + "'."
        );
      }
      this.type = constants_default.OBJECT_TYPE_INTERSECTION;
      this.elType = "intersection";
      this.parents = [el1.id, el2.id, i2, j];
      this.generatePolynomial = function() {
        var poly1 = el1.generatePolynomial(this), poly2 = el2.generatePolynomial(this);
        if (poly1.length === 0 || poly2.length === 0) {
          return [];
        }
        return [poly1[0], poly2[0]];
      };
      this.prepareUpdate().update();
    },
    /**
     * Set the style of a point.
     * Used for GEONExT import and should not be used to set the point's face and size.
     * @param {Number} i Integer to determine the style.
     * @private
     */
    setStyle: function(i2) {
      var facemap = [
        // 0-2
        "cross",
        "cross",
        "cross",
        // 3-6
        "circle",
        "circle",
        "circle",
        "circle",
        // 7-9
        "square",
        "square",
        "square",
        // 10-12
        "plus",
        "plus",
        "plus"
      ], sizemap = [
        // 0-2
        2,
        3,
        4,
        // 3-6
        1,
        2,
        3,
        4,
        // 7-9
        2,
        3,
        4,
        // 10-12
        2,
        3,
        4
      ];
      this.visProp.face = facemap[i2];
      this.visProp.size = sizemap[i2];
      this.board.renderer.changePointStyle(this);
      return this;
    },
    /**
     * @deprecated Use JXG#normalizePointFace instead
     * @param s
     * @returns {*}
     */
    normalizeFace: function(s) {
      jxg_default.deprecated("Point.normalizeFace()", "JXG.normalizePointFace()");
      return options_default.normalizePointFace(s);
    },
    /**
     * Set the face of a point element.
     * @param {String} f String which determines the face of the point. See {@link JXG.GeometryElement#face} for a list of available faces.
     * @see JXG.GeometryElement#face
     * @deprecated Use setAttribute()
     */
    face: function(f) {
      jxg_default.deprecated("Point.face()", "Point.setAttribute()");
      this.setAttribute({ face: f });
    },
    /**
     * Set the size of a point element
     * @param {Number} s Integer which determines the size of the point.
     * @see JXG.GeometryElement#size
     * @deprecated Use setAttribute()
     */
    size: function(s) {
      jxg_default.deprecated("Point.size()", "Point.setAttribute()");
      this.setAttribute({ size: s });
    },
    /**
     * Test if the point is on (is incident with) element "el".
     *
     * @param {JXG.GeometryElement} el
     * @param {Number} tol
     * @returns {Boolean}
     *
     * @example
     * var circ = board.create('circle', [[-2, -2], 1]);
     * var seg = board.create('segment', [[-1, -3], [0,0]]);
     * var line = board.create('line', [[1, 3], [2, -2]]);
     * var po = board.create('point', [-1, 0], {color: 'blue'});
     * var curve = board.create('functiongraph', ['sin(x)'], {strokeColor: 'blue'});
     * var pol = board.create('polygon', [[2,2], [4,2], [4,3]], {strokeColor: 'blue'});
     *
     * var point = board.create('point', [-1, 1], {
     *               attractors: [line, seg, circ, po, curve, pol],
     *               attractorDistance: 0.2
     *             });
     *
     * var txt = board.create('text', [-4, 3, function() {
     *              return 'point on line: ' + point.isOn(line) + '<br>' +
     *                 'point on seg: ' + point.isOn(seg) + '<br>' +
     *                 'point on circ = ' + point.isOn(circ) + '<br>' +
     *                 'point on point = ' + point.isOn(po) + '<br>' +
     *                 'point on curve = ' + point.isOn(curve) + '<br>' +
     *                 'point on polygon = ' + point.isOn(pol) + '<br>';
     * }]);
     *
     * </pre><div id="JXG6c7d7404-758a-44eb-802c-e9644b9fab71" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG6c7d7404-758a-44eb-802c-e9644b9fab71',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var circ = board.create('circle', [[-2, -2], 1]);
     *     var seg = board.create('segment', [[-1, -3], [0,0]]);
     *     var line = board.create('line', [[1, 3], [2, -2]]);
     *     var po = board.create('point', [-1, 0], {color: 'blue'});
     *     var curve = board.create('functiongraph', ['sin(x)'], {strokeColor: 'blue'});
     *     var pol = board.create('polygon', [[2,2], [4,2], [4,3]], {strokeColor: 'blue'});
     *
     *     var point = board.create('point', [-1, 1], {
     *                   attractors: [line, seg, circ, po, curve, pol],
     *                   attractorDistance: 0.2
     *                 });
     *
     *     var txt = board.create('text', [-4, 3, function() {
     *             return 'point on line: ' + point.isOn(line) + '<br>' +
     *                     'point on seg: ' + point.isOn(seg) + '<br>' +
     *                     'point on circ = ' + point.isOn(circ) + '<br>' +
     *                     'point on point = ' + point.isOn(po) + '<br>' +
     *                     'point on curve = ' + point.isOn(curve) + '<br>' +
     *                     'point on polygon = ' + point.isOn(pol) + '<br>';
     *     }]);
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    isOn: function(el, tol) {
      var arr, crds;
      tol = tol || math_default.eps;
      if (type_default.isPoint(el)) {
        return this.Dist(el) < tol;
      } else if (el.elementClass === constants_default.OBJECT_CLASS_LINE) {
        if (el.elType === "segment" && !type_default.evaluate(this.visProp.alwaysintersect)) {
          arr = jxg_default.Math.Geometry.projectCoordsToSegment(
            this.coords.usrCoords,
            el.point1.coords.usrCoords,
            el.point2.coords.usrCoords
          );
          if (arr[1] >= 0 && arr[1] <= 1 && geometry_default.distPointLine(this.coords.usrCoords, el.stdform) < tol) {
            return true;
          } else {
            return false;
          }
        } else {
          return geometry_default.distPointLine(this.coords.usrCoords, el.stdform) < tol;
        }
      } else if (el.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
        if (type_default.evaluate(el.visProp.hasinnerpoints)) {
          return this.Dist(el.center) < el.Radius() + tol;
        }
        return Math.abs(this.Dist(el.center) - el.Radius()) < tol;
      } else if (el.elementClass === constants_default.OBJECT_CLASS_CURVE) {
        crds = geometry_default.projectPointToCurve(this, el, this.board)[0];
        return geometry_default.distance(this.coords.usrCoords, crds.usrCoords, 3) < tol;
      } else if (el.type === constants_default.OBJECT_TYPE_POLYGON) {
        if (type_default.evaluate(el.visProp.hasinnerpoints)) {
          if (el.pnpoly(
            this.coords.usrCoords[1],
            this.coords.usrCoords[2],
            jxg_default.COORDS_BY_USER
          )) {
            return true;
          }
        }
        arr = geometry_default.projectCoordsToPolygon(this.coords.usrCoords, el);
        return geometry_default.distance(this.coords.usrCoords, arr, 3) < tol;
      } else if (el.type === constants_default.OBJECT_TYPE_TURTLE) {
        crds = geometry_default.projectPointToTurtle(this, el, this.board);
        return geometry_default.distance(this.coords.usrCoords, crds.usrCoords, 3) < tol;
      }
      return false;
    },
    // Already documented in GeometryElement
    cloneToBackground: function() {
      var copy = {};
      copy.id = this.id + "T" + this.numTraces;
      this.numTraces += 1;
      copy.coords = this.coords;
      copy.visProp = type_default.deepCopy(this.visProp, this.visProp.traceattributes, true);
      copy.visProp.layer = this.board.options.layer.trace;
      copy.elementClass = constants_default.OBJECT_CLASS_POINT;
      copy.board = this.board;
      type_default.clearVisPropOld(copy);
      copy.visPropCalc = {
        visible: type_default.evaluate(copy.visProp.visible)
      };
      this.board.renderer.drawPoint(copy);
      this.traces[copy.id] = copy.rendNode;
      return this;
    }
  }
);
jxg_default.createPoint = function(board, parents, attributes) {
  var el, attr;
  attr = type_default.copyAttributes(attributes, board.options, "point");
  el = coordselement_default.create(jxg_default.Point, board, parents, attr);
  if (!el) {
    throw new Error(
      "JSXGraph: Can't create point with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [x,y], [z,x,y], [element,transformation]"
    );
  }
  return el;
};
jxg_default.createGlider = function(board, parents, attributes) {
  var el, coords, attr = type_default.copyAttributes(attributes, board.options, "glider");
  if (parents.length === 1) {
    coords = [0, 0];
  } else {
    coords = parents.slice(0, 2);
  }
  el = board.create("point", coords, attr);
  el.makeGlider(parents[parents.length - 1]);
  return el;
};
jxg_default.createIntersectionPoint = function(board, parents, attributes) {
  var el, el1, el2, func, i2, j, attr = type_default.copyAttributes(attributes, board.options, "intersection");
  parents.push(0, 0);
  el1 = board.select(parents[0]);
  el2 = board.select(parents[1]);
  i2 = parents[2] || 0;
  j = parents[3] || 0;
  el = board.create("point", [0, 0, 0], attr);
  func = geometry_default.intersectionFunction(board, el1, el2, i2, j, el.visProp.alwaysintersect);
  el.addConstraint([func]);
  try {
    el1.addChild(el);
    el2.addChild(el);
  } catch (e) {
    throw new Error(
      "JSXGraph: Can't create 'intersection' with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'."
    );
  }
  el.type = constants_default.OBJECT_TYPE_INTERSECTION;
  el.elType = "intersection";
  el.setParents([el1.id, el2.id]);
  el.intersectionNumbers = [i2, j];
  el.getParents = function() {
    return this.parents.concat(this.intersectionNumbers);
  };
  el.generatePolynomial = function() {
    var poly1 = el1.generatePolynomial(el), poly2 = el2.generatePolynomial(el);
    if (poly1.length === 0 || poly2.length === 0) {
      return [];
    }
    return [poly1[0], poly2[0]];
  };
  return el;
};
jxg_default.createOtherIntersectionPoint = function(board, parents, attributes) {
  var el, el1, el2, other;
  if (parents.length !== 3 || !type_default.isPoint(parents[2]) || parents[0].elementClass !== constants_default.OBJECT_CLASS_LINE && parents[0].elementClass !== constants_default.OBJECT_CLASS_CIRCLE || parents[1].elementClass !== constants_default.OBJECT_CLASS_LINE && parents[1].elementClass !== constants_default.OBJECT_CLASS_CIRCLE) {
    throw new Error(
      "JSXGraph: Can't create 'other intersection point' with parent types '" + typeof parents[0] + "',  '" + typeof parents[1] + "'and  '" + typeof parents[2] + "'.\nPossible parent types: [circle|line,circle|line,point]"
    );
  }
  el1 = board.select(parents[0]);
  el2 = board.select(parents[1]);
  other = board.select(parents[2]);
  el = board.create(
    "point",
    [
      function() {
        var c = geometry_default.meet(el1.stdform, el2.stdform, 0, el1.board);
        if (Math.abs(other.X() - c.usrCoords[1]) > math_default.eps || Math.abs(other.Y() - c.usrCoords[2]) > math_default.eps || Math.abs(other.Z() - c.usrCoords[0]) > math_default.eps) {
          return c;
        }
        return geometry_default.meet(el1.stdform, el2.stdform, 1, el1.board);
      }
    ],
    attributes
  );
  el.type = constants_default.OBJECT_TYPE_INTERSECTION;
  el.elType = "otherintersection";
  el.setParents([el1.id, el2.id, other]);
  el1.addChild(el);
  el2.addChild(el);
  el.generatePolynomial = function() {
    var poly1 = el1.generatePolynomial(el), poly2 = el2.generatePolynomial(el);
    if (poly1.length === 0 || poly2.length === 0) {
      return [];
    }
    return [poly1[0], poly2[0]];
  };
  return el;
};
jxg_default.createPolePoint = function(board, parents, attributes) {
  var el, el1, el2, firstParentIsConic, secondParentIsConic, firstParentIsLine, secondParentIsLine;
  if (parents.length > 1) {
    firstParentIsConic = parents[0].type === constants_default.OBJECT_TYPE_CONIC || parents[0].elementClass === constants_default.OBJECT_CLASS_CIRCLE;
    secondParentIsConic = parents[1].type === constants_default.OBJECT_TYPE_CONIC || parents[1].elementClass === constants_default.OBJECT_CLASS_CIRCLE;
    firstParentIsLine = parents[0].elementClass === constants_default.OBJECT_CLASS_LINE;
    secondParentIsLine = parents[1].elementClass === constants_default.OBJECT_CLASS_LINE;
  }
  if (parents.length !== 2 || !(firstParentIsConic && secondParentIsLine || firstParentIsLine && secondParentIsConic)) {
    throw new Error(
      "JSXGraph: Can't create 'pole point' with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent type: [conic|circle,line], [line,conic|circle]"
    );
  }
  if (secondParentIsLine) {
    el1 = board.select(parents[0]);
    el2 = board.select(parents[1]);
  } else {
    el1 = board.select(parents[1]);
    el2 = board.select(parents[0]);
  }
  el = board.create(
    "point",
    [
      function() {
        var q = el1.quadraticform, s = el2.stdform.slice(0, 3);
        return [
          jxg_default.Math.Numerics.det([s, q[1], q[2]]),
          jxg_default.Math.Numerics.det([q[0], s, q[2]]),
          jxg_default.Math.Numerics.det([q[0], q[1], s])
        ];
      }
    ],
    attributes
  );
  el.elType = "polepoint";
  el.setParents([el1.id, el2.id]);
  el1.addChild(el);
  el2.addChild(el);
  return el;
};
jxg_default.registerElement("point", jxg_default.createPoint);
jxg_default.registerElement("glider", jxg_default.createGlider);
jxg_default.registerElement("intersection", jxg_default.createIntersectionPoint);
jxg_default.registerElement("otherintersection", jxg_default.createOtherIntersectionPoint);
jxg_default.registerElement("polepoint", jxg_default.createPolePoint);
var point_default = jxg_default.Point;

// node_modules/jsxgraph/src/base/line.js
jxg_default.Line = function(board, p1, p2, attributes) {
  this.constructor(board, attributes, constants_default.OBJECT_TYPE_LINE, constants_default.OBJECT_CLASS_LINE);
  this.point1 = this.board.select(p1);
  this.point2 = this.board.select(p2);
  this.ticks = [];
  this.defaultTicks = null;
  this.parentPolygon = null;
  this.id = this.board.setId(this, "L");
  this.board.renderer.drawLine(this);
  this.board.finalizeAdding(this);
  this.elType = "line";
  if (this.point1._is_new) {
    this.addChild(this.point1);
    delete this.point1._is_new;
  } else {
    this.point1.addChild(this);
  }
  if (this.point2._is_new) {
    this.addChild(this.point2);
    delete this.point2._is_new;
  } else {
    this.point2.addChild(this);
  }
  this.inherits.push(this.point1, this.point2);
  this.updateStdform();
  this.createLabel();
  this.methodMap = jxg_default.deepCopy(this.methodMap, {
    point1: "point1",
    point2: "point2",
    getSlope: "Slope",
    Slope: "Slope",
    Direction: "Direction",
    getRise: "getRise",
    Rise: "getRise",
    getYIntersect: "getRise",
    YIntersect: "getRise",
    getAngle: "getAngle",
    Angle: "getAngle",
    L: "L",
    length: "L",
    setFixedLength: "setFixedLength",
    setStraight: "setStraight"
  });
};
jxg_default.Line.prototype = new element_default();
jxg_default.extend(
  jxg_default.Line.prototype,
  /** @lends JXG.Line.prototype */
  {
    /**
     * Checks whether (x,y) is near the line.
     * @param {Number} x Coordinate in x direction, screen coordinates.
     * @param {Number} y Coordinate in y direction, screen coordinates.
     * @returns {Boolean} True if (x,y) is near the line, False otherwise.
     */
    hasPoint: function(x, y) {
      var c = [], v = [1, x, y], s, vnew, p1c, p2c, d, pos, i2, prec, type, sw = type_default.evaluate(this.visProp.strokewidth);
      if (type_default.isObject(type_default.evaluate(this.visProp.precision))) {
        type = this.board._inputDevice;
        prec = type_default.evaluate(this.visProp.precision[type]);
      } else {
        prec = this.board.options.precision.hasPoint;
      }
      prec += sw * 0.5;
      c[0] = this.stdform[0] - this.stdform[1] * this.board.origin.scrCoords[1] / this.board.unitX + this.stdform[2] * this.board.origin.scrCoords[2] / this.board.unitY;
      c[1] = this.stdform[1] / this.board.unitX;
      c[2] = this.stdform[2] / -this.board.unitY;
      s = geometry_default.distPointLine(v, c);
      if (isNaN(s) || s > prec) {
        return false;
      }
      if (type_default.evaluate(this.visProp.straightfirst) && type_default.evaluate(this.visProp.straightlast)) {
        return true;
      }
      p1c = this.point1.coords;
      p2c = this.point2.coords;
      vnew = [0, c[1], c[2]];
      vnew = math_default.crossProduct(vnew, v);
      vnew = math_default.crossProduct(vnew, c);
      vnew[1] /= vnew[0];
      vnew[2] /= vnew[0];
      vnew[0] = 1;
      vnew = new coords_default(constants_default.COORDS_BY_SCREEN, vnew.slice(1), this.board).usrCoords;
      d = p1c.distance(constants_default.COORDS_BY_USER, p2c);
      p1c = p1c.usrCoords.slice(0);
      p2c = p2c.usrCoords.slice(0);
      if (d < math_default.eps) {
        pos = 0;
      } else {
        if (d === Number.POSITIVE_INFINITY) {
          d = 1 / math_default.eps;
          if (Math.abs(p2c[0]) < math_default.eps) {
            d /= geometry_default.distance([0, 0, 0], p2c);
            p2c = [1, p1c[1] + p2c[1] * d, p1c[2] + p2c[2] * d];
          } else {
            d /= geometry_default.distance([0, 0, 0], p1c);
            p1c = [1, p2c[1] + p1c[1] * d, p2c[2] + p1c[2] * d];
          }
        }
        i2 = 1;
        d = p2c[i2] - p1c[i2];
        if (Math.abs(d) < math_default.eps) {
          i2 = 2;
          d = p2c[i2] - p1c[i2];
        }
        pos = (vnew[i2] - p1c[i2]) / d;
      }
      if (!type_default.evaluate(this.visProp.straightfirst) && pos < 0) {
        return false;
      }
      return !(!type_default.evaluate(this.visProp.straightlast) && pos > 1);
    },
    // documented in base/element
    update: function() {
      var funps;
      if (!this.needsUpdate) {
        return this;
      }
      if (this.constrained) {
        if (type_default.isFunction(this.funps)) {
          funps = this.funps();
          if (funps && funps.length && funps.length === 2) {
            this.point1 = funps[0];
            this.point2 = funps[1];
          }
        } else {
          if (type_default.isFunction(this.funp1)) {
            funps = this.funp1();
            if (type_default.isPoint(funps)) {
              this.point1 = funps;
            } else if (funps && funps.length && funps.length === 2) {
              this.point1.setPositionDirectly(constants_default.COORDS_BY_USER, funps);
            }
          }
          if (type_default.isFunction(this.funp2)) {
            funps = this.funp2();
            if (type_default.isPoint(funps)) {
              this.point2 = funps;
            } else if (funps && funps.length && funps.length === 2) {
              this.point2.setPositionDirectly(constants_default.COORDS_BY_USER, funps);
            }
          }
        }
      }
      this.updateSegmentFixedLength();
      this.updateStdform();
      if (type_default.evaluate(this.visProp.trace)) {
        this.cloneToBackground(true);
      }
      return this;
    },
    /**
     * Update segments with fixed length and at least one movable point.
     * @private
     */
    updateSegmentFixedLength: function() {
      var d, d_new, d1, d2, drag1, drag2, x, y;
      if (!this.hasFixedLength) {
        return this;
      }
      d = this.point1.Dist(this.point2);
      d_new = Math.abs(this.fixedLength());
      d1 = this.fixedLengthOldCoords[0].distance(
        constants_default.COORDS_BY_USER,
        this.point1.coords
      );
      d2 = this.fixedLengthOldCoords[1].distance(
        constants_default.COORDS_BY_USER,
        this.point2.coords
      );
      if (d1 > math_default.eps || d2 > math_default.eps || d !== d_new) {
        drag1 = this.point1.isDraggable && this.point1.type !== constants_default.OBJECT_TYPE_GLIDER && !type_default.evaluate(this.point1.visProp.fixed);
        drag2 = this.point2.isDraggable && this.point2.type !== constants_default.OBJECT_TYPE_GLIDER && !type_default.evaluate(this.point2.visProp.fixed);
        if (d > math_default.eps) {
          if (d1 > d2 && drag2 || d1 <= d2 && drag2 && !drag1) {
            this.point2.setPositionDirectly(constants_default.COORDS_BY_USER, [
              this.point1.X() + (this.point2.X() - this.point1.X()) * d_new / d,
              this.point1.Y() + (this.point2.Y() - this.point1.Y()) * d_new / d
            ]);
            this.point2.fullUpdate();
          } else if (d1 <= d2 && drag1 || d1 > d2 && drag1 && !drag2) {
            this.point1.setPositionDirectly(constants_default.COORDS_BY_USER, [
              this.point2.X() + (this.point1.X() - this.point2.X()) * d_new / d,
              this.point2.Y() + (this.point1.Y() - this.point2.Y()) * d_new / d
            ]);
            this.point1.fullUpdate();
          }
        } else {
          x = Math.random() - 0.5;
          y = Math.random() - 0.5;
          d = math_default.hypot(x, y);
          if (drag2) {
            this.point2.setPositionDirectly(constants_default.COORDS_BY_USER, [
              this.point1.X() + x * d_new / d,
              this.point1.Y() + y * d_new / d
            ]);
            this.point2.fullUpdate();
          } else if (drag1) {
            this.point1.setPositionDirectly(constants_default.COORDS_BY_USER, [
              this.point2.X() + x * d_new / d,
              this.point2.Y() + y * d_new / d
            ]);
            this.point1.fullUpdate();
          }
        }
        this.fixedLengthOldCoords[0].setCoordinates(
          constants_default.COORDS_BY_USER,
          this.point1.coords.usrCoords
        );
        this.fixedLengthOldCoords[1].setCoordinates(
          constants_default.COORDS_BY_USER,
          this.point2.coords.usrCoords
        );
      }
      return this;
    },
    /**
     * Updates the stdform derived from the parent point positions.
     * @private
     */
    updateStdform: function() {
      var v = math_default.crossProduct(
        this.point1.coords.usrCoords,
        this.point2.coords.usrCoords
      );
      this.stdform[0] = v[0];
      this.stdform[1] = v[1];
      this.stdform[2] = v[2];
      this.stdform[3] = 0;
      this.normalize();
    },
    /**
     * Uses the boards renderer to update the line.
     * @private
     */
    updateRenderer: function() {
      if (!this.needsUpdate) {
        return this;
      }
      if (this.visPropCalc.visible) {
        this.isReal = !isNaN(
          this.point1.coords.usrCoords[1] + this.point1.coords.usrCoords[2] + this.point2.coords.usrCoords[1] + this.point2.coords.usrCoords[2]
        ) && math_default.innerProduct(this.stdform, this.stdform, 3) >= math_default.eps * math_default.eps;
        if (
          //wasReal &&
          !this.isReal
        ) {
          this.updateVisibility(false);
        }
      }
      if (this.visPropCalc.visible) {
        this.board.renderer.updateLine(this);
      }
      if (this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal) {
        this.label.update();
        this.board.renderer.updateText(this.label);
      }
      this.setDisplayRendNode();
      this.needsUpdate = false;
      return this;
    },
    // /**
    //  * Used to generate a polynomial for a point p that lies on this line, i.e. p is collinear to
    //  * {@link JXG.Line#point1} and {@link JXG.Line#point2}.
    //  *
    //  * @param {JXG.Point} p The point for that the polynomial is generated.
    //  * @returns {Array} An array containing the generated polynomial.
    //  * @private
    //  */
    generatePolynomial: function(p) {
      var u1 = this.point1.symbolic.x, u2 = this.point1.symbolic.y, v1 = this.point2.symbolic.x, v2 = this.point2.symbolic.y, w1 = p.symbolic.x, w2 = p.symbolic.y;
      return [
        [
          "(",
          u2,
          ")*(",
          w1,
          ")-(",
          u2,
          ")*(",
          v1,
          ")+(",
          w2,
          ")*(",
          v1,
          ")-(",
          u1,
          ")*(",
          w2,
          ")+(",
          u1,
          ")*(",
          v2,
          ")-(",
          w1,
          ")*(",
          v2,
          ")"
        ].join("")
      ];
    },
    /**
     * Calculates the y intersect of the line.
     * @returns {Number} The y intersect.
     */
    getRise: function() {
      if (Math.abs(this.stdform[2]) >= math_default.eps) {
        return -this.stdform[0] / this.stdform[2];
      }
      return Infinity;
    },
    /**
     * Calculates the slope of the line.
     * @returns {Number} The slope of the line or Infinity if the line is parallel to the y-axis.
     */
    Slope: function() {
      if (Math.abs(this.stdform[2]) >= math_default.eps) {
        return -this.stdform[1] / this.stdform[2];
      }
      return Infinity;
    },
    /**
     * Alias for line.Slope
     * @returns {Number} The slope of the line or Infinity if the line is parallel to the y-axis.
     * @deprecated
     * @see #Slope
     */
    getSlope: function() {
      return this.Slope();
    },
    /**
     * Determines the angle between the positive x axis and the line.
     * @returns {Number}
     */
    getAngle: function() {
      return Math.atan2(-this.stdform[1], this.stdform[2]);
    },
    /**
     * Returns the direction vector of the line. This is an array of length two
     * containing the direction vector as [x, y]. It is defined as
     *  <li> the difference of the x- and y-coordinate of the second and first point, in case both points are finite or both points are infinite.
     *  <li> [x, y] coordinates of point2, in case only point2 is infinite.
     *  <li> [-x, -y] coordinates of point1, in case only point1 is infinite.
     * @function
     * @returns {Array} of length 2.
     */
    Direction: function() {
      var coords1 = this.point1.coords.usrCoords, coords2 = this.point2.coords.usrCoords;
      if (coords2[0] === 0 && coords1[0] !== 0) {
        return coords2.slice(1);
      }
      if (coords1[0] === 0 && coords2[0] !== 0) {
        return [-coords1[1], -coords1[2]];
      }
      return [
        coords2[1] - coords1[1],
        coords2[2] - coords1[2]
      ];
    },
    /**
     * Returns true, if the line is vertical (if the x coordinate of the direction vector is 0).
     * @function
     * @returns {Boolean}
     */
    isVertical: function() {
      var dir = this.Direction();
      return dir[0] === 0 && dir[1] !== 0;
    },
    /**
     * Returns true, if the line is horizontal (if the y coordinate of the direction vector is 0).
     * @function
     * @returns {Boolean}
     */
    isHorizontal: function() {
      var dir = this.Direction();
      return dir[1] === 0 && dir[0] !== 0;
    },
    /**
     * Determines whether the line is drawn beyond {@link JXG.Line#point1} and
     * {@link JXG.Line#point2} and updates the line.
     * @param {Boolean} straightFirst True if the Line shall be drawn beyond
     * {@link JXG.Line#point1}, false otherwise.
     * @param {Boolean} straightLast True if the Line shall be drawn beyond
     * {@link JXG.Line#point2}, false otherwise.
     * @see #straightFirst
     * @see #straightLast
     * @private
     */
    setStraight: function(straightFirst, straightLast) {
      this.visProp.straightfirst = straightFirst;
      this.visProp.straightlast = straightLast;
      this.board.renderer.updateLine(this);
      return this;
    },
    // documented in geometry element
    getTextAnchor: function() {
      return new coords_default(
        constants_default.COORDS_BY_USER,
        [
          0.5 * (this.point2.X() + this.point1.X()),
          0.5 * (this.point2.Y() + this.point1.Y())
        ],
        this.board
      );
    },
    /**
     * Adjusts Label coords relative to Anchor. DESCRIPTION
     * @private
     */
    setLabelRelativeCoords: function(relCoords) {
      if (type_default.exists(this.label)) {
        this.label.relativeCoords = new coords_default(
          constants_default.COORDS_BY_SCREEN,
          [relCoords[0], -relCoords[1]],
          this.board
        );
      }
    },
    // documented in geometry element
    getLabelAnchor: function() {
      var x, y, fs = 0, c1 = new coords_default(constants_default.COORDS_BY_USER, this.point1.coords.usrCoords, this.board), c2 = new coords_default(constants_default.COORDS_BY_USER, this.point2.coords.usrCoords, this.board), ev_sf = type_default.evaluate(this.visProp.straightfirst), ev_sl = type_default.evaluate(this.visProp.straightlast);
      if (ev_sf || ev_sl) {
        geometry_default.calcStraight(this, c1, c2, 0);
      }
      c1 = c1.scrCoords;
      c2 = c2.scrCoords;
      if (!type_default.exists(this.label)) {
        return new coords_default(constants_default.COORDS_BY_SCREEN, [NaN, NaN], this.board);
      }
      switch (type_default.evaluate(this.label.visProp.position)) {
        case "last":
          x = c2[1];
          y = c2[2];
          break;
        case "first":
          x = c1[1];
          y = c1[2];
          break;
        case "lft":
        case "llft":
        case "ulft":
          if (c1[1] <= c2[1]) {
            x = c1[1];
            y = c1[2];
          } else {
            x = c2[1];
            y = c2[2];
          }
          break;
        case "rt":
        case "lrt":
        case "urt":
          if (c1[1] > c2[1]) {
            x = c1[1];
            y = c1[2];
          } else {
            x = c2[1];
            y = c2[2];
          }
          break;
        default:
          x = 0.5 * (c1[1] + c2[1]);
          y = 0.5 * (c1[2] + c2[2]);
      }
      if (ev_sf || ev_sl) {
        if (type_default.exists(this.label)) {
          fs = type_default.evaluate(this.label.visProp.fontsize);
        }
        if (Math.abs(x) < math_default.eps) {
          x = fs;
        } else if (this.board.canvasWidth + math_default.eps > x && x > this.board.canvasWidth - fs - math_default.eps) {
          x = this.board.canvasWidth - fs;
        }
        if (math_default.eps + fs > y && y > -math_default.eps) {
          y = fs;
        } else if (this.board.canvasHeight + math_default.eps > y && y > this.board.canvasHeight - fs - math_default.eps) {
          y = this.board.canvasHeight - fs;
        }
      }
      return new coords_default(constants_default.COORDS_BY_SCREEN, [x, y], this.board);
    },
    // documented in geometry element
    cloneToBackground: function() {
      var copy = {}, r, s, er;
      copy.id = this.id + "T" + this.numTraces;
      copy.elementClass = constants_default.OBJECT_CLASS_LINE;
      this.numTraces++;
      copy.point1 = this.point1;
      copy.point2 = this.point2;
      copy.stdform = this.stdform;
      copy.board = this.board;
      copy.visProp = type_default.deepCopy(this.visProp, this.visProp.traceattributes, true);
      copy.visProp.layer = this.board.options.layer.trace;
      type_default.clearVisPropOld(copy);
      copy.visPropCalc = {
        visible: type_default.evaluate(copy.visProp.visible)
      };
      s = this.getSlope();
      r = this.getRise();
      copy.getSlope = function() {
        return s;
      };
      copy.getRise = function() {
        return r;
      };
      er = this.board.renderer.enhancedRendering;
      this.board.renderer.enhancedRendering = true;
      this.board.renderer.drawLine(copy);
      this.board.renderer.enhancedRendering = er;
      this.traces[copy.id] = copy.rendNode;
      return this;
    },
    /**
     * Add transformations to this line.
     * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation} or an array of
     * {@link JXG.Transformation}s.
     * @returns {JXG.Line} Reference to this line object.
     */
    addTransform: function(transform) {
      var i2, list2 = type_default.isArray(transform) ? transform : [transform], len = list2.length;
      for (i2 = 0; i2 < len; i2++) {
        this.point1.transformations.push(list2[i2]);
        this.point2.transformations.push(list2[i2]);
      }
      return this;
    },
    // see GeometryElement.js
    snapToGrid: function(pos) {
      var c1, c2, dc, t, ticks, x, y, sX, sY;
      if (type_default.evaluate(this.visProp.snaptogrid)) {
        if (this.parents.length < 3) {
          this.point1.handleSnapToGrid(true, true);
          this.point2.handleSnapToGrid(true, true);
        } else if (type_default.exists(pos)) {
          sX = type_default.evaluate(this.visProp.snapsizex);
          sY = type_default.evaluate(this.visProp.snapsizey);
          c1 = new coords_default(constants_default.COORDS_BY_SCREEN, [pos.Xprev, pos.Yprev], this.board);
          x = c1.usrCoords[1];
          y = c1.usrCoords[2];
          if (sX <= 0 && this.board.defaultAxes && this.board.defaultAxes.x.defaultTicks) {
            ticks = this.board.defaultAxes.x.defaultTicks;
            sX = ticks.ticksDelta * (type_default.evaluate(ticks.visProp.minorticks) + 1);
          }
          if (sY <= 0 && this.board.defaultAxes && this.board.defaultAxes.y.defaultTicks) {
            ticks = this.board.defaultAxes.y.defaultTicks;
            sY = ticks.ticksDelta * (type_default.evaluate(ticks.visProp.minorticks) + 1);
          }
          if (sX > 0 && sY > 0) {
            c2 = geometry_default.projectPointToLine({ coords: c1 }, this, this.board);
            dc = statistics_default.subtract(
              [1, Math.round(x / sX) * sX, Math.round(y / sY) * sY],
              c2.usrCoords
            );
            t = this.board.create("transform", dc.slice(1), {
              type: "translate"
            });
            t.applyOnce([this.point1, this.point2]);
          }
        }
      } else {
        this.point1.handleSnapToGrid(false, true);
        this.point2.handleSnapToGrid(false, true);
      }
      return this;
    },
    // see element.js
    snapToPoints: function() {
      var forceIt = type_default.evaluate(this.visProp.snaptopoints);
      if (this.parents.length < 3) {
        this.point1.handleSnapToPoints(forceIt);
        this.point2.handleSnapToPoints(forceIt);
      }
      return this;
    },
    /**
     * Treat the line as parametric curve in homogeneous coordinates, where the parameter t runs from 0 to 1.
     * First we transform the interval [0,1] to [-1,1].
     * If the line has homogeneous coordinates [c, a, b] = stdform[] then the direction of the line is [b, -a].
     * Now, we take one finite point that defines the line, i.e. we take either point1 or point2
     * (in case the line is not the ideal line).
     * Let the coordinates of that point be [z, x, y].
     * Then, the curve runs linearly from
     * [0, b, -a] (t=-1) to [z, x, y] (t=0)
     * and
     * [z, x, y] (t=0) to [0, -b, a] (t=1)
     *
     * @param {Number} t Parameter running from 0 to 1.
     * @returns {Number} X(t) x-coordinate of the line treated as parametric curve.
     * */
    X: function(t) {
      var x, b = this.stdform[2];
      x = Math.abs(this.point1.coords.usrCoords[0]) > math_default.eps ? this.point1.coords.usrCoords[1] : this.point2.coords.usrCoords[1];
      t = (t - 0.5) * 2;
      return (1 - Math.abs(t)) * x - t * b;
    },
    /**
     * Treat the line as parametric curve in homogeneous coordinates.
     * See {@link JXG.Line#X} for a detailed description.
     * @param {Number} t Parameter running from 0 to 1.
     * @returns {Number} Y(t) y-coordinate of the line treated as parametric curve.
     */
    Y: function(t) {
      var y, a = this.stdform[1];
      y = Math.abs(this.point1.coords.usrCoords[0]) > math_default.eps ? this.point1.coords.usrCoords[2] : this.point2.coords.usrCoords[2];
      t = (t - 0.5) * 2;
      return (1 - Math.abs(t)) * y + t * a;
    },
    /**
     * Treat the line as parametric curve in homogeneous coordinates.
     * See {@link JXG.Line#X} for a detailed description.
     *
     * @param {Number} t Parameter running from 0 to 1.
     * @returns {Number} Z(t) z-coordinate of the line treated as parametric curve.
     */
    Z: function(t) {
      var z = Math.abs(this.point1.coords.usrCoords[0]) > math_default.eps ? this.point1.coords.usrCoords[0] : this.point2.coords.usrCoords[0];
      t = (t - 0.5) * 2;
      return (1 - Math.abs(t)) * z;
    },
    /**
     * The distance between the two points defining the line.
     * @returns {Number}
     */
    L: function() {
      return this.point1.Dist(this.point2);
    },
    /**
     * Set a new fixed length, then update the board.
     * @param {String|Number|function} l A string, function or number describing the new length.
     * @returns {JXG.Line} Reference to this line
     */
    setFixedLength: function(l) {
      if (!this.hasFixedLength) {
        return this;
      }
      this.fixedLength = type_default.createFunction(l, this.board);
      this.board.update();
      return this;
    },
    /**
     * Treat the element  as a parametric curve
     * @private
     */
    minX: function() {
      return 0;
    },
    /**
     * Treat the element as parametric curve
     * @private
     */
    maxX: function() {
      return 1;
    },
    // documented in geometry element
    bounds: function() {
      var p1c = this.point1.coords.usrCoords, p2c = this.point2.coords.usrCoords;
      return [
        Math.min(p1c[1], p2c[1]),
        Math.max(p1c[2], p2c[2]),
        Math.max(p1c[1], p2c[1]),
        Math.min(p1c[2], p2c[2])
      ];
    },
    // documented in GeometryElement.js
    remove: function() {
      this.removeAllTicks();
      element_default.prototype.remove.call(this);
    }
    // hideElement: function () {
    //     var i;
    //
    //     GeometryElement.prototype.hideElement.call(this);
    //
    //     for (i = 0; i < this.ticks.length; i++) {
    //         this.ticks[i].hideElement();
    //     }
    // },
    //
    // showElement: function () {
    //     var i;
    //     GeometryElement.prototype.showElement.call(this);
    //
    //     for (i = 0; i < this.ticks.length; i++) {
    //         this.ticks[i].showElement();
    //     }
    // }
  }
);
jxg_default.createLine = function(board, parents, attributes) {
  var ps, el, p1, p2, i2, attr, c = [], doTransform = false, constrained = false, isDraggable;
  if (parents.length === 2) {
    attr = type_default.copyAttributes(attributes, board.options, "line", "point1");
    if (type_default.isArray(parents[0]) && parents[0].length > 1) {
      p1 = board.create("point", parents[0], attr);
    } else if (type_default.isString(parents[0]) || type_default.isPoint(parents[0])) {
      p1 = board.select(parents[0]);
    } else if (type_default.isFunction(parents[0]) && type_default.isPoint(parents[0]())) {
      p1 = parents[0]();
      constrained = true;
    } else if (type_default.isFunction(parents[0]) && parents[0]().length && parents[0]().length >= 2) {
      p1 = jxg_default.createPoint(board, parents[0](), attr);
      constrained = true;
    } else if (type_default.isObject(parents[0]) && type_default.isTransformationOrArray(parents[1])) {
      doTransform = true;
      p1 = board.create("point", [parents[0].point1, parents[1]], attr);
    } else {
      throw new Error(
        "JSXGraph: Can't create line with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]"
      );
    }
    attr = type_default.copyAttributes(attributes, board.options, "line", "point2");
    if (doTransform) {
      p2 = board.create("point", [parents[0].point2, parents[1]], attr);
    } else if (type_default.isArray(parents[1]) && parents[1].length > 1) {
      p2 = board.create("point", parents[1], attr);
    } else if (type_default.isString(parents[1]) || type_default.isPoint(parents[1])) {
      p2 = board.select(parents[1]);
    } else if (type_default.isFunction(parents[1]) && type_default.isPoint(parents[1]())) {
      p2 = parents[1]();
      constrained = true;
    } else if (type_default.isFunction(parents[1]) && parents[1]().length && parents[1]().length >= 2) {
      p2 = jxg_default.createPoint(board, parents[1](), attr);
      constrained = true;
    } else {
      throw new Error(
        "JSXGraph: Can't create line with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]"
      );
    }
    attr = type_default.copyAttributes(attributes, board.options, "line");
    el = new jxg_default.Line(board, p1, p2, attr);
    if (constrained) {
      el.constrained = true;
      el.funp1 = parents[0];
      el.funp2 = parents[1];
    } else if (!doTransform) {
      el.isDraggable = true;
    }
    el.setParents([p1.id, p2.id]);
  } else if (parents.length === 3) {
    isDraggable = true;
    for (i2 = 0; i2 < 3; i2++) {
      if (type_default.isNumber(parents[i2])) {
        c[i2] = type_default.createFunction(parents[i2]);
      } else if (type_default.isFunction(parents[i2])) {
        c[i2] = parents[i2];
        isDraggable = false;
      } else {
        throw new Error(
          "JSXGraph: Can't create line with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "' and '" + typeof parents[2] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]"
        );
      }
    }
    attr = type_default.copyAttributes(attributes, board.options, "line", "point1");
    if (isDraggable) {
      p1 = board.create("point", [
        c[2]() * c[2]() + c[1]() * c[1](),
        c[2]() - c[1]() * c[0]() + c[2](),
        -c[1]() - c[2]() * c[0]() - c[1]()
      ], attr);
    } else {
      p1 = board.create("point", [
        function() {
          return (c[2]() * c[2]() + c[1]() * c[1]()) * 0.5;
        },
        function() {
          return (c[2]() - c[1]() * c[0]() + c[2]()) * 0.5;
        },
        function() {
          return (-c[1]() - c[2]() * c[0]() - c[1]()) * 0.5;
        }
      ], attr);
    }
    attr = type_default.copyAttributes(attributes, board.options, "line", "point2");
    if (isDraggable) {
      p2 = board.create("point", [
        c[2]() * c[2]() + c[1]() * c[1](),
        -c[1]() * c[0]() + c[2](),
        -c[2]() * c[0]() - c[1]()
      ], attr);
    } else {
      p2 = board.create("point", [
        function() {
          return c[2]() * c[2]() + c[1]() * c[1]();
        },
        function() {
          return -c[1]() * c[0]() + c[2]();
        },
        function() {
          return -c[2]() * c[0]() - c[1]();
        }
      ], attr);
    }
    p1.prepareUpdate().update();
    p2.prepareUpdate().update();
    attr = type_default.copyAttributes(attributes, board.options, "line");
    el = new jxg_default.Line(board, p1, p2, attr);
    el.isDraggable = isDraggable;
    el.setParents([p1, p2]);
  } else if (
    // The parent array contains a function which returns two points.
    parents.length === 1 && type_default.isFunction(parents[0]) && parents[0]().length === 2 && type_default.isPoint(parents[0]()[0]) && type_default.isPoint(parents[0]()[1])
  ) {
    ps = parents[0]();
    attr = type_default.copyAttributes(attributes, board.options, "line");
    el = new jxg_default.Line(board, ps[0], ps[1], attr);
    el.constrained = true;
    el.funps = parents[0];
    el.setParents(ps);
  } else if (parents.length === 1 && type_default.isFunction(parents[0]) && parents[0]().length === 3 && type_default.isNumber(parents[0]()[0]) && type_default.isNumber(parents[0]()[1]) && type_default.isNumber(parents[0]()[2])) {
    ps = parents[0];
    attr = type_default.copyAttributes(attributes, board.options, "line", "point1");
    p1 = board.create("point", [
      function() {
        var c2 = ps();
        return [
          (c2[2] * c2[2] + c2[1] * c2[1]) * 0.5,
          (c2[2] - c2[1] * c2[0] + c2[2]) * 0.5,
          (-c2[1] - c2[2] * c2[0] - c2[1]) * 0.5
        ];
      }
    ], attr);
    attr = type_default.copyAttributes(attributes, board.options, "line", "point2");
    p2 = board.create("point", [
      function() {
        var c2 = ps();
        return [
          c2[2] * c2[2] + c2[1] * c2[1],
          -c2[1] * c2[0] + c2[2],
          -c2[2] * c2[0] - c2[1]
        ];
      }
    ], attr);
    attr = type_default.copyAttributes(attributes, board.options, "line");
    el = new jxg_default.Line(board, p1, p2, attr);
    el.constrained = true;
    el.funps = parents[0];
    el.setParents([p1, p2]);
  } else {
    throw new Error(
      "JSXGraph: Can't create line with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]"
    );
  }
  return el;
};
jxg_default.registerElement("line", jxg_default.createLine);
jxg_default.createSegment = function(board, parents, attributes) {
  var el, attr;
  attributes.straightFirst = false;
  attributes.straightLast = false;
  attr = type_default.copyAttributes(attributes, board.options, "segment");
  el = board.create("line", parents.slice(0, 2), attr);
  if (parents.length === 3) {
    el.hasFixedLength = true;
    if (type_default.isNumber(parents[2])) {
      el.fixedLength = function() {
        return parents[2];
      };
    } else if (type_default.isFunction(parents[2])) {
      el.fixedLength = type_default.createFunction(parents[2], this.board);
    } else {
      throw new Error(
        "JSXGraph: Can't create segment with third parent type '" + typeof parents[2] + "'.\nPossible third parent types: number or function"
      );
    }
    el.getParents = function() {
      return this.parents.concat(this.fixedLength());
    };
    el.fixedLengthOldCoords = [];
    el.fixedLengthOldCoords[0] = new coords_default(
      constants_default.COORDS_BY_USER,
      el.point1.coords.usrCoords.slice(1, 3),
      board
    );
    el.fixedLengthOldCoords[1] = new coords_default(
      constants_default.COORDS_BY_USER,
      el.point2.coords.usrCoords.slice(1, 3),
      board
    );
  }
  el.elType = "segment";
  return el;
};
jxg_default.registerElement("segment", jxg_default.createSegment);
jxg_default.createArrow = function(board, parents, attributes) {
  var el, attr;
  attributes.straightFirst = false;
  attributes.straightLast = false;
  attr = type_default.copyAttributes(attributes, board.options, "arrow");
  el = board.create("line", parents, attr);
  el.type = constants_default.OBJECT_TYPE_VECTOR;
  el.elType = "arrow";
  return el;
};
jxg_default.registerElement("arrow", jxg_default.createArrow);
jxg_default.createAxis = function(board, parents, attributes) {
  var axis, attr, ancestor, ticksDist;
  attr = type_default.copyAttributes(attributes, board.options, "axis");
  try {
    axis = board.create("line", parents, attr);
  } catch (err) {
    throw new Error(
      "JSXGraph: Can't create axis with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]"
    );
  }
  axis.type = constants_default.OBJECT_TYPE_AXIS;
  axis.isDraggable = false;
  axis.point1.isDraggable = false;
  axis.point2.isDraggable = false;
  axis._point1UsrCoordsOrg = axis.point1.coords.usrCoords.slice();
  axis._point2UsrCoordsOrg = axis.point2.coords.usrCoords.slice();
  for (ancestor in axis.ancestors) {
    if (axis.ancestors.hasOwnProperty(ancestor)) {
      axis.ancestors[ancestor].type = constants_default.OBJECT_TYPE_AXISPOINT;
    }
  }
  if (type_default.exists(attr.ticks.ticksdistance)) {
    ticksDist = attr.ticks.ticksdistance;
  } else if (type_default.isArray(attr.ticks.ticks)) {
    ticksDist = attr.ticks.ticks;
  } else {
    ticksDist = 1;
  }
  axis.defaultTicks = board.create("ticks", [axis, ticksDist], attr.ticks);
  axis.defaultTicks.dump = false;
  axis.elType = "axis";
  axis.subs = {
    ticks: axis.defaultTicks
  };
  axis.inherits.push(axis.defaultTicks);
  axis.update = function() {
    var bbox, position, i2, direction, horizontal, vertical, ticksAutoPos, ticksAutoPosThres, dist, anchor, left, right, distUsr, newPosP1, newPosP2, locationOrg, visLabel, anchr, off;
    bbox = this.board.getBoundingBox();
    position = type_default.evaluate(this.visProp.position);
    direction = this.Direction();
    horizontal = this.isHorizontal();
    vertical = this.isVertical();
    ticksAutoPos = type_default.evaluate(this.visProp.ticksautopos);
    ticksAutoPosThres = type_default.evaluate(this.visProp.ticksautoposthreshold);
    if (horizontal) {
      ticksAutoPosThres = type_default.parseNumber(ticksAutoPosThres, Math.abs(bbox[1] - bbox[3]), 1 / this.board.unitX) * this.board.unitX;
    } else if (vertical) {
      ticksAutoPosThres = type_default.parseNumber(ticksAutoPosThres, Math.abs(bbox[1] - bbox[3]), 1 / this.board.unitY) * this.board.unitY;
    } else {
      ticksAutoPosThres = type_default.parseNumber(ticksAutoPosThres, 1, 1);
    }
    anchor = type_default.evaluate(this.visProp.anchor);
    left = anchor.indexOf("left") > -1;
    right = anchor.indexOf("right") > -1;
    distUsr = type_default.evaluate(this.visProp.anchordist);
    if (horizontal) {
      distUsr = type_default.parseNumber(distUsr, Math.abs(bbox[1] - bbox[3]), 1 / this.board.unitX);
    } else if (vertical) {
      distUsr = type_default.parseNumber(distUsr, Math.abs(bbox[0] - bbox[2]), 1 / this.board.unitY);
    } else {
      distUsr = 0;
    }
    locationOrg = this.board.getPointLoc(this._point1UsrCoordsOrg, distUsr);
    newPosP1 = this.point1.coords.usrCoords.slice();
    newPosP2 = this.point2.coords.usrCoords.slice();
    if (position === "static" || !vertical && !horizontal) {
    } else if (position === "fixed") {
      if (horizontal) {
        if (direction[0] > 0 && right || direction[0] < 0 && left) {
          newPosP1[2] = bbox[3] + distUsr;
          newPosP2[2] = bbox[3] + distUsr;
        } else if (direction[0] > 0 && left || direction[0] < 0 && right) {
          newPosP1[2] = bbox[1] - distUsr;
          newPosP2[2] = bbox[1] - distUsr;
        } else {
          newPosP1 = this._point1UsrCoordsOrg.slice();
          newPosP2 = this._point2UsrCoordsOrg.slice();
        }
      }
      if (vertical) {
        if (direction[1] > 0 && left || direction[1] < 0 && right) {
          newPosP1[1] = bbox[0] + distUsr;
          newPosP2[1] = bbox[0] + distUsr;
        } else if (direction[1] > 0 && right || direction[1] < 0 && left) {
          newPosP1[1] = bbox[2] - distUsr;
          newPosP2[1] = bbox[2] - distUsr;
        } else {
          newPosP1 = this._point1UsrCoordsOrg.slice();
          newPosP2 = this._point2UsrCoordsOrg.slice();
        }
      }
    } else if (position === "sticky") {
      if (horizontal) {
        if (locationOrg[1] < 0 && (direction[0] > 0 && right || direction[0] < 0 && left)) {
          newPosP1[2] = bbox[3] + distUsr;
          newPosP2[2] = bbox[3] + distUsr;
        } else if (locationOrg[1] > 0 && (direction[0] > 0 && left || direction[0] < 0 && right)) {
          newPosP1[2] = bbox[1] - distUsr;
          newPosP2[2] = bbox[1] - distUsr;
        } else {
          newPosP1 = this._point1UsrCoordsOrg.slice();
          newPosP2 = this._point2UsrCoordsOrg.slice();
        }
      }
      if (vertical) {
        if (locationOrg[0] < 0 && (direction[1] > 0 && left || direction[1] < 0 && right)) {
          newPosP1[1] = bbox[0] + distUsr;
          newPosP2[1] = bbox[0] + distUsr;
        } else if (locationOrg[0] > 0 && (direction[1] > 0 && right || direction[1] < 0 && left)) {
          newPosP1[1] = bbox[2] - distUsr;
          newPosP2[1] = bbox[2] - distUsr;
        } else {
          newPosP1 = this._point1UsrCoordsOrg.slice();
          newPosP2 = this._point2UsrCoordsOrg.slice();
        }
      }
    }
    this.point1.setPositionDirectly(jxg_default.COORDS_BY_USER, newPosP1);
    this.point2.setPositionDirectly(jxg_default.COORDS_BY_USER, newPosP2);
    visLabel = this.defaultTicks.visProp.label;
    if (ticksAutoPos && (horizontal || vertical)) {
      if (!type_default.exists(visLabel._anchorx_org)) {
        visLabel._anchorx_org = type_default.def(visLabel.anchorx, this.board.options.text.anchorX);
      }
      if (!type_default.exists(visLabel._anchory_org)) {
        visLabel._anchory_org = type_default.def(visLabel.anchory, this.board.options.text.anchorY);
      }
      if (!type_default.exists(visLabel._offset_org)) {
        visLabel._offset_org = visLabel.offset.slice();
      }
      off = visLabel.offset;
      if (horizontal) {
        dist = axis.point1.coords.scrCoords[2] - this.board.canvasHeight * 0.5;
        anchr = visLabel.anchory;
        if (dist < 0 && Math.abs(dist) > ticksAutoPosThres) {
          if (visLabel._side === "bottom") {
            if (visLabel.anchory === "top") {
              anchr = "bottom";
            }
            off[1] *= -1;
            visLabel._side = "top";
          }
        } else if (dist > 0 && Math.abs(dist) > ticksAutoPosThres) {
          if (visLabel._side === "top") {
            if (visLabel.anchory === "bottom") {
              anchr = "top";
            }
            off[1] *= -1;
            visLabel._side = "bottom";
          }
        } else {
          anchr = visLabel._anchory_org;
          off = visLabel._offset_org.slice();
          if (anchr === "top") {
            visLabel._side = "bottom";
          } else if (anchr === "bottom") {
            visLabel._side = "top";
          } else if (off[1] < 0) {
            visLabel._side = "bottom";
          } else {
            visLabel._side = "top";
          }
        }
        for (i2 = 0; i2 < axis.defaultTicks.labels.length; i2++) {
          this.defaultTicks.labels[i2].visProp.anchory = anchr;
        }
        visLabel.anchory = anchr;
      } else if (vertical) {
        dist = axis.point1.coords.scrCoords[1] - this.board.canvasWidth * 0.5;
        if (dist < 0 && Math.abs(dist) > ticksAutoPosThres) {
          if (visLabel._side === "right") {
            if (visLabel.anchorx === "left") {
              anchr = "right";
            }
            off[0] *= -1;
            visLabel._side = "left";
          }
        } else if (dist > 0 && Math.abs(dist) > ticksAutoPosThres) {
          if (visLabel._side === "left") {
            if (visLabel.anchorx === "right") {
              anchr = "left";
            }
            off[0] *= -1;
            visLabel._side = "right";
          }
        } else {
          anchr = visLabel._anchorx_org;
          off = visLabel._offset_org.slice();
          if (anchr === "left") {
            visLabel._side = "right";
          } else if (anchr === "right") {
            visLabel._side = "left";
          } else if (off[0] < 0) {
            visLabel._side = "left";
          } else {
            visLabel._side = "right";
          }
        }
        for (i2 = 0; i2 < axis.defaultTicks.labels.length; i2++) {
          this.defaultTicks.labels[i2].visProp.anchorx = anchr;
        }
        visLabel.anchorx = anchr;
      }
      visLabel.offset = off;
    } else {
      delete visLabel._anchorx_org;
      delete visLabel._anchory_org;
      delete visLabel._offset_org;
    }
    jxg_default.Line.prototype.update.call(this);
    this.defaultTicks.needsUpdate = true;
    return this;
  };
  return axis;
};
jxg_default.registerElement("axis", jxg_default.createAxis);
jxg_default.createTangent = function(board, parents, attributes) {
  var p, c, j, el, tangent, attr, getCurveTangentDir;
  if (parents.length === 1) {
    p = parents[0];
    c = p.slideObject;
  } else if (parents.length === 2) {
    if (type_default.isPoint(parents[0])) {
      p = parents[0];
      c = parents[1];
    } else if (type_default.isPoint(parents[1])) {
      c = parents[0];
      p = parents[1];
    } else {
      throw new Error(
        "JSXGraph: Can't create tangent with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [glider], [point,line|curve|circle|conic]"
      );
    }
  } else {
    throw new Error(
      "JSXGraph: Can't create tangent with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [glider], [point,line|curve|circle|conic]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "tangent");
  if (c.elementClass === constants_default.OBJECT_CLASS_LINE) {
    tangent = board.create("line", [c.point1, c.point2], attr);
    tangent.glider = p;
  } else if (c.elementClass === constants_default.OBJECT_CLASS_CURVE && c.type !== constants_default.OBJECT_TYPE_CONIC) {
    if (type_default.evaluate(c.visProp.curvetype) !== "plot") {
      tangent = board.create(
        "line",
        [
          function() {
            var g = c.X, f = c.Y;
            return -p.X() * numerics_default.D(f)(p.position) + p.Y() * numerics_default.D(g)(p.position);
          },
          function() {
            return numerics_default.D(c.Y)(p.position);
          },
          function() {
            return -numerics_default.D(c.X)(p.position);
          }
        ],
        attr
      );
      p.addChild(tangent);
      tangent.glider = p;
    } else {
      getCurveTangentDir = function(position, curve, num) {
        var i2 = Math.floor(position), p1, p2, t, A, B, C, D, dx, dy, d, points, le;
        if (curve.bezierDegree === 1) {
          if (i2 === curve.numberPoints - 1) {
            i2--;
          }
        } else if (curve.bezierDegree === 3) {
          if (curve.elType === "sector") {
            points = curve.points.slice(3, curve.numberPoints - 3);
            le = points.length;
          } else {
            points = curve.points;
            le = points.length;
          }
          i2 = Math.floor(position * (le - 1) / 3) * 3;
          t = (position * (le - 1) - i2) / 3;
          if (i2 >= le - 1) {
            i2 = le - 4;
            t = 1;
          }
        } else {
          return 0;
        }
        if (i2 < 0) {
          return 1;
        }
        if (curve.bezierDegree === 1) {
          p1 = curve.points[i2].usrCoords;
          p2 = curve.points[i2 + 1].usrCoords;
        } else {
          A = points[i2].usrCoords;
          B = points[i2 + 1].usrCoords;
          C = points[i2 + 2].usrCoords;
          D = points[i2 + 3].usrCoords;
          dx = (1 - t) * (1 - t) * (B[1] - A[1]) + 2 * (1 - t) * t * (C[1] - B[1]) + t * t * (D[1] - C[1]);
          dy = (1 - t) * (1 - t) * (B[2] - A[2]) + 2 * (1 - t) * t * (C[2] - B[2]) + t * t * (D[2] - C[2]);
          d = math_default.hypot(dx, dy);
          dx /= d;
          dy /= d;
          p1 = p.coords.usrCoords;
          p2 = [1, p1[1] + dx, p1[2] + dy];
        }
        switch (num) {
          case 0:
            return p1[2] * p2[1] - p1[1] * p2[2];
          case 1:
            return p2[2] - p1[2];
          case 2:
            return p1[1] - p2[1];
        }
        return 0;
      };
      tangent = board.create(
        "line",
        [
          function() {
            return getCurveTangentDir(p.position, c, 0);
          },
          function() {
            return getCurveTangentDir(p.position, c, 1);
          },
          function() {
            return getCurveTangentDir(p.position, c, 2);
          }
        ],
        attr
      );
      p.addChild(tangent);
      tangent.glider = p;
    }
  } else if (c.type === constants_default.OBJECT_TYPE_TURTLE) {
    tangent = board.create(
      "line",
      [
        function() {
          var i2 = Math.floor(p.position);
          for (j = 0; j < c.objects.length; j++) {
            el = c.objects[j];
            if (el.type === constants_default.OBJECT_TYPE_CURVE) {
              if (i2 < el.numberPoints) {
                break;
              }
              i2 -= el.numberPoints;
            }
          }
          if (i2 === el.numberPoints - 1) {
            i2--;
          }
          if (i2 < 0) {
            return 1;
          }
          return el.Y(i2) * el.X(i2 + 1) - el.X(i2) * el.Y(i2 + 1);
        },
        function() {
          var i2 = Math.floor(p.position);
          for (j = 0; j < c.objects.length; j++) {
            el = c.objects[j];
            if (el.type === constants_default.OBJECT_TYPE_CURVE) {
              if (i2 < el.numberPoints) {
                break;
              }
              i2 -= el.numberPoints;
            }
          }
          if (i2 === el.numberPoints - 1) {
            i2--;
          }
          if (i2 < 0) {
            return 0;
          }
          return el.Y(i2 + 1) - el.Y(i2);
        },
        function() {
          var i2 = Math.floor(p.position);
          for (j = 0; j < c.objects.length; j++) {
            el = c.objects[j];
            if (el.type === constants_default.OBJECT_TYPE_CURVE) {
              if (i2 < el.numberPoints) {
                break;
              }
              i2 -= el.numberPoints;
            }
          }
          if (i2 === el.numberPoints - 1) {
            i2--;
          }
          if (i2 < 0) {
            return 0;
          }
          return el.X(i2) - el.X(i2 + 1);
        }
      ],
      attr
    );
    p.addChild(tangent);
    tangent.glider = p;
  } else if (c.elementClass === constants_default.OBJECT_CLASS_CIRCLE || c.type === constants_default.OBJECT_TYPE_CONIC) {
    tangent = board.create(
      "line",
      [
        function() {
          return math_default.matVecMult(c.quadraticform, p.coords.usrCoords)[0];
        },
        function() {
          return math_default.matVecMult(c.quadraticform, p.coords.usrCoords)[1];
        },
        function() {
          return math_default.matVecMult(c.quadraticform, p.coords.usrCoords)[2];
        }
      ],
      attr
    );
    p.addChild(tangent);
    tangent.glider = p;
  }
  if (!type_default.exists(tangent)) {
    throw new Error("JSXGraph: Couldn't create tangent with the given parents.");
  }
  tangent.elType = "tangent";
  tangent.type = constants_default.OBJECT_TYPE_TANGENT;
  tangent.setParents(parents);
  return tangent;
};
jxg_default.createRadicalAxis = function(board, parents, attributes) {
  var el, el1, el2;
  if (parents.length !== 2 || parents[0].elementClass !== constants_default.OBJECT_CLASS_CIRCLE || parents[1].elementClass !== constants_default.OBJECT_CLASS_CIRCLE) {
    throw new Error(
      "JSXGraph: Can't create 'radical axis' with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent type: [circle,circle]"
    );
  }
  el1 = board.select(parents[0]);
  el2 = board.select(parents[1]);
  el = board.create(
    "line",
    [
      function() {
        var a = el1.stdform, b = el2.stdform;
        return math_default.matVecMult(math_default.transpose([a.slice(0, 3), b.slice(0, 3)]), [
          b[3],
          -a[3]
        ]);
      }
    ],
    attributes
  );
  el.elType = "radicalaxis";
  el.setParents([el1.id, el2.id]);
  el1.addChild(el);
  el2.addChild(el);
  return el;
};
jxg_default.createPolarLine = function(board, parents, attributes) {
  var el, el1, el2, firstParentIsConic, secondParentIsConic, firstParentIsPoint, secondParentIsPoint;
  if (parents.length > 1) {
    firstParentIsConic = parents[0].type === constants_default.OBJECT_TYPE_CONIC || parents[0].elementClass === constants_default.OBJECT_CLASS_CIRCLE;
    secondParentIsConic = parents[1].type === constants_default.OBJECT_TYPE_CONIC || parents[1].elementClass === constants_default.OBJECT_CLASS_CIRCLE;
    firstParentIsPoint = type_default.isPoint(parents[0]);
    secondParentIsPoint = type_default.isPoint(parents[1]);
  }
  if (parents.length !== 2 || !(firstParentIsConic && secondParentIsPoint || firstParentIsPoint && secondParentIsConic)) {
    throw new Error(
      "JSXGraph: Can't create 'polar line' with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent type: [conic|circle,point], [point,conic|circle]"
    );
  }
  if (secondParentIsPoint) {
    el1 = board.select(parents[0]);
    el2 = board.select(parents[1]);
  } else {
    el1 = board.select(parents[1]);
    el2 = board.select(parents[0]);
  }
  el = board.create("tangent", [el1, el2], attributes);
  el.elType = "polarline";
  return el;
};
jxg_default.registerElement("tangent", jxg_default.createTangent);
jxg_default.registerElement("polar", jxg_default.createTangent);
jxg_default.registerElement("radicalaxis", jxg_default.createRadicalAxis);
jxg_default.registerElement("polarline", jxg_default.createPolarLine);
var line_default = jxg_default.Line;

// node_modules/jsxgraph/src/base/group.js
jxg_default.Group = function(board, id, name, objects, attributes) {
  var number, objArray, i2, obj;
  this.board = board;
  this.objects = {};
  number = this.board.numObjects;
  this.board.numObjects += 1;
  if (id === "" || !type_default.exists(id)) {
    this.id = this.board.id + "Group" + number;
  } else {
    this.id = id;
  }
  this.board.groups[this.id] = this;
  this.type = constants_default.OBJECT_TYPE_POINT;
  this.elementClass = constants_default.OBJECT_CLASS_POINT;
  if (name === "" || !type_default.exists(name)) {
    this.name = "group_" + this.board.generateName(this);
  } else {
    this.name = name;
  }
  delete this.type;
  this.coords = {};
  this.needsRegularUpdate = attributes.needsregularupdate;
  this.rotationCenter = "centroid";
  this.scaleCenter = null;
  this.rotationPoints = [];
  this.translationPoints = [];
  this.scalePoints = [];
  this.scaleDirections = {};
  this.parents = [];
  if (type_default.isArray(objects)) {
    objArray = objects;
  } else {
    objArray = Array.prototype.slice.call(arguments, 3);
  }
  for (i2 = 0; i2 < objArray.length; i2++) {
    obj = this.board.select(objArray[i2]);
    if (!type_default.evaluate(obj.visProp.fixed) && type_default.exists(obj.coords)) {
      this.addPoint(obj);
    }
  }
  this.methodMap = {
    ungroup: "ungroup",
    add: "addPoint",
    addPoint: "addPoint",
    addPoints: "addPoints",
    addGroup: "addGroup",
    remove: "removePoint",
    removePoint: "removePoint",
    setAttribute: "setAttribute",
    setProperty: "setAttribute"
  };
};
jxg_default.extend(
  jxg_default.Group.prototype,
  /** @lends JXG.Group.prototype */
  {
    /**
     * Releases all elements of this group.
     * @returns {JXG.Group} returns this (empty) group
     */
    ungroup: function() {
      var el, p, i2;
      for (el in this.objects) {
        if (this.objects.hasOwnProperty(el)) {
          p = this.objects[el].point;
          if (type_default.isArray(p.groups)) {
            i2 = type_default.indexOf(p.groups, this.id);
            if (i2 >= 0) {
              delete p.groups[i2];
            }
          }
        }
      }
      this.objects = {};
      return this;
    },
    /**
     * Adds ids of elements to the array this.parents. This is a copy
     * of {@link Element.addParents}.
     * @param {Array} parents Array of elements or ids of elements.
     * Alternatively, one can give a list of objects as parameters.
     * @returns {JXG.Object} reference to the object itself.
     **/
    addParents: function(parents) {
      var i2, len, par;
      if (type_default.isArray(parents)) {
        par = parents;
      } else {
        par = arguments;
      }
      len = par.length;
      for (i2 = 0; i2 < len; ++i2) {
        if (type_default.isId(this.board, par[i2])) {
          this.parents.push(par[i2]);
        } else if (type_default.exists(par[i2].id)) {
          this.parents.push(par[i2].id);
        }
      }
      this.parents = type_default.uniqueArray(this.parents);
    },
    /**
     * Sets ids of elements to the array this.parents. This is a copy
     * of {@link Element.setParents}
     * First, this.parents is cleared. See {@link Group#addParents}.
     * @param {Array} parents Array of elements or ids of elements.
     * Alternatively, one can give a list of objects as parameters.
     * @returns {JXG.Object} reference to the object itself.
     **/
    setParents: function(parents) {
      this.parents = [];
      this.addParents(parents);
      return this;
    },
    /**
     * List of the element ids resp. values used as parents in {@link JXG.Board#create}.
     * @returns {Array}
     */
    getParents: function() {
      return type_default.isArray(this.parents) ? this.parents : [];
    },
    /**
     * Update the cached coordinates of a group element.
     * @param  {String} el element id of the group element whose cached coordinates
     * are going to be updated.
     * @return null
     */
    _updateCoordsCache: function(el) {
      var obj;
      if (el !== "" && type_default.exists(this.objects[el])) {
        obj = this.objects[el].point;
        this.coords[obj.id] = { usrCoords: obj.coords.usrCoords.slice(0) };
      }
    },
    /**
     * Sends an update to all group members.
     * This method is called from the points' coords object event listeners
     * and not by the board.
     * @returns {JXG.Group} returns this group
     */
    update: function() {
      var drag, el, actionCenter, desc, s, sx, sy, alpha, t, center, obj = null;
      if (!this.needsUpdate) {
        return this;
      }
      drag = this._update_find_drag_type();
      if (drag.action === "nothing") {
        this._updateCoordsCache(drag.id);
        return this;
      }
      obj = this.objects[drag.id].point;
      if (drag.action === "translation") {
        t = [
          obj.coords.usrCoords[1] - this.coords[drag.id].usrCoords[1],
          obj.coords.usrCoords[2] - this.coords[drag.id].usrCoords[2]
        ];
      } else if (drag.action === "rotation" || drag.action === "scaling") {
        if (drag.action === "rotation") {
          actionCenter = "rotationCenter";
        } else {
          actionCenter = "scaleCenter";
        }
        if (type_default.isPoint(this[actionCenter])) {
          center = this[actionCenter].coords.usrCoords.slice(1);
        } else if (this[actionCenter] === "centroid") {
          center = this._update_centroid_center();
        } else if (type_default.isArray(this[actionCenter])) {
          center = this[actionCenter];
        } else if (type_default.isFunction(this[actionCenter])) {
          center = this[actionCenter]();
        } else {
          return this;
        }
        if (drag.action === "rotation") {
          alpha = geometry_default.rad(
            this.coords[drag.id].usrCoords.slice(1),
            center,
            this.objects[drag.id].point
          );
          t = this.board.create("transform", [alpha, center[0], center[1]], {
            type: "rotate"
          });
          t.update();
        } else if (drag.action === "scaling") {
          s = geometry_default.distance(this.coords[drag.id].usrCoords.slice(1), center);
          if (Math.abs(s) < math_default.eps) {
            return this;
          }
          s = geometry_default.distance(obj.coords.usrCoords.slice(1), center) / s;
          sx = this.scaleDirections[drag.id].indexOf("x") >= 0 ? s : 1;
          sy = this.scaleDirections[drag.id].indexOf("y") >= 0 ? s : 1;
          t = this.board.create(
            "transform",
            [1, 0, 0, center[0] * (1 - sx), sx, 0, center[1] * (1 - sy), 0, sy],
            { type: "generic" }
          );
          t.update();
        } else {
          return this;
        }
      }
      this._update_apply_transformation(drag, t);
      this.needsUpdate = false;
      for (el in this.objects) {
        if (this.objects.hasOwnProperty(el)) {
          for (desc in this.objects[el].descendants) {
            if (this.objects[el].descendants.hasOwnProperty(desc)) {
              this.objects[el].descendants.needsUpdate = this.objects[el].descendants.needsRegularUpdate || this.board.needsFullUpdate;
            }
          }
        }
      }
      this.board.updateElements(drag);
      for (el in this.objects) {
        if (this.objects.hasOwnProperty(el)) {
          this._updateCoordsCache(el);
        }
      }
      return this;
    },
    /**
     * @private
    */
    //  Determine what the dragging of a group element should do:
    //  rotation, translation, scaling or nothing.
    _update_find_drag_type: function() {
      var el, obj, action = "nothing", changed = [], dragObjId;
      for (el in this.objects) {
        if (this.objects.hasOwnProperty(el)) {
          obj = this.objects[el].point;
          if (obj.coords.distance(constants_default.COORDS_BY_USER, this.coords[el]) > math_default.eps) {
            changed.push(obj.id);
          }
        }
      }
      if (changed.length === 0) {
        return {
          action,
          id: "",
          changed
        };
      }
      dragObjId = changed[0];
      obj = this.objects[dragObjId].point;
      if (changed.length > 1) {
        action = "translation";
      } else {
        if (type_default.isInArray(this.rotationPoints, obj) && type_default.exists(this.rotationCenter)) {
          action = "rotation";
        } else if (type_default.isInArray(this.scalePoints, obj) && type_default.exists(this.scaleCenter)) {
          action = "scaling";
        } else if (type_default.isInArray(this.translationPoints, obj)) {
          action = "translation";
        }
      }
      return {
        action,
        id: dragObjId,
        changed
      };
    },
    /**
     * @private
     * @returns {Array} array of length two,
    */
    // Determine the Euclidean coordinates of the centroid of the group.
    _update_centroid_center: function() {
      var center, len, el;
      center = [0, 0];
      len = 0;
      for (el in this.coords) {
        if (this.coords.hasOwnProperty(el)) {
          center[0] += this.coords[el].usrCoords[1];
          center[1] += this.coords[el].usrCoords[2];
          ++len;
        }
      }
      if (len > 0) {
        center[0] /= len;
        center[1] /= len;
      }
      return center;
    },
    /**
     * @private
    */
    // Apply the transformation to all elements of the group
    _update_apply_transformation: function(drag, t) {
      var el, obj;
      for (el in this.objects) {
        if (this.objects.hasOwnProperty(el)) {
          if (type_default.exists(this.board.objects[el])) {
            obj = this.objects[el].point;
            if (obj.id !== drag.id) {
              if (drag.action === "translation") {
                if (!type_default.isInArray(drag.changed, obj.id)) {
                  obj.coords.setCoordinates(constants_default.COORDS_BY_USER, [
                    this.coords[el].usrCoords[1] + t[0],
                    this.coords[el].usrCoords[2] + t[1]
                  ]);
                }
              } else if (drag.action === "rotation" || drag.action === "scaling") {
                t.applyOnce([obj]);
              }
            } else {
              if (drag.action === "rotation" || drag.action === "scaling") {
                obj.coords.setCoordinates(
                  constants_default.COORDS_BY_USER,
                  math_default.matVecMult(t.matrix, this.coords[obj.id].usrCoords)
                );
              }
            }
          } else {
            delete this.objects[el];
          }
        }
      }
    },
    /**
     * Adds an Point to this group.
     * @param {JXG.Point} object The point added to the group.
     * @returns {JXG.Group} returns this group
     */
    addPoint: function(object) {
      this.objects[object.id] = { point: this.board.select(object) };
      this._updateCoordsCache(object.id);
      this.translationPoints.push(object);
      object.groups.push(this.id);
      object.groups = type_default.uniqueArray(object.groups);
      return this;
    },
    /**
     * Adds multiple points to this group.
     * @param {Array} objects An array of points to add to the group.
     * @returns {JXG.Group} returns this group
     */
    addPoints: function(objects) {
      var p;
      for (p = 0; p < objects.length; p++) {
        this.addPoint(objects[p]);
      }
      return this;
    },
    /**
     * Adds all points in a group to this group.
     * @param {JXG.Group} group The group added to this group.
     * @returns {JXG.Group} returns this group
     */
    addGroup: function(group) {
      var el;
      for (el in group.objects) {
        if (group.objects.hasOwnProperty(el)) {
          this.addPoint(group.objects[el].point);
        }
      }
      return this;
    },
    /**
     * Removes a point from the group.
     * @param {JXG.Point} point
     * @returns {JXG.Group} returns this group
     */
    removePoint: function(point) {
      delete this.objects[point.id];
      return this;
    },
    /**
     * Sets the center of rotation for the group. This is either a point or the centroid of the group.
     * @param {JXG.Point|String} object A point which will be the center of rotation, the string "centroid", or
     * an array of length two, or a function returning an array of length two.
     * @default 'centroid'
     * @returns {JXG.Group} returns this group
     */
    setRotationCenter: function(object) {
      this.rotationCenter = object;
      return this;
    },
    /**
     * Sets the rotation points of the group. Dragging at one of these points results into a rotation of the whole group around
     * the rotation center of the group {@see JXG.Group#setRotationCenter}.
     * @param {Array|JXG.Point} objects Array of {@link JXG.Point} or arbitrary number of {@link JXG.Point} elements.
     * @returns {JXG.Group} returns this group
     */
    setRotationPoints: function(objects) {
      return this._setActionPoints("rotation", objects);
    },
    /**
     * Adds a point to the set of rotation points of the group. Dragging at one of these points results into a rotation of the whole group around
     * the rotation center of the group {@see JXG.Group#setRotationCenter}.
     * @param {JXG.Point} point {@link JXG.Point} element.
     * @returns {JXG.Group} returns this group
     */
    addRotationPoint: function(point) {
      return this._addActionPoint("rotation", point);
    },
    /**
     * Removes the rotation property from a point of the group.
     * @param {JXG.Point} point {@link JXG.Point} element.
     * @returns {JXG.Group} returns this group
     */
    removeRotationPoint: function(point) {
      return this._removeActionPoint("rotation", point);
    },
    /**
     * Sets the translation points of the group. Dragging at one of these points results into a translation of the whole group.
     * @param {Array|JXG.Point} objects Array of {@link JXG.Point} or arbitrary number of {@link JXG.Point} elements.
     *
     * By default, all points of the group are translation points.
     * @returns {JXG.Group} returns this group
     */
    setTranslationPoints: function(objects) {
      return this._setActionPoints("translation", objects);
    },
    /**
     * Adds a point to the set of the translation points of the group.
     * Dragging one of these points results into a translation of the whole group.
     * @param {JXG.Point} point {@link JXG.Point} element.
     * @returns {JXG.Group} returns this group
     */
    addTranslationPoint: function(point) {
      return this._addActionPoint("translation", point);
    },
    /**
     * Removes the translation property from a point of the group.
     * @param {JXG.Point} point {@link JXG.Point} element.
     * @returns {JXG.Group} returns this group
     */
    removeTranslationPoint: function(point) {
      return this._removeActionPoint("translation", point);
    },
    /**
     * Sets the center of scaling for the group. This is either a point or the centroid of the group.
     * @param {JXG.Point|String} object A point which will be the center of scaling, the string "centroid", or
     * an array of length two, or a function returning an array of length two.
     * @returns {JXG.Group} returns this group
     */
    setScaleCenter: function(object) {
      this.scaleCenter = object;
      return this;
    },
    /**
     * Sets the scale points of the group. Dragging at one of these points results into a scaling of the whole group.
     * @param {Array|JXG.Point} objects Array of {@link JXG.Point} or arbitrary number of {@link JXG.Point} elements.
     * @param {String} direction Restricts the directions to be scaled. Possible values are 'x', 'y', 'xy'. Default value is 'xy'.
     *
     * By default, all points of the group are translation points.
     * @returns {JXG.Group} returns this group
     */
    setScalePoints: function(objects, direction) {
      var objs, i2, len;
      if (type_default.isArray(objects)) {
        objs = objects;
      } else {
        objs = arguments;
      }
      len = objs.length;
      for (i2 = 0; i2 < len; ++i2) {
        this.scaleDirections[this.board.select(objs[i2]).id] = direction || "xy";
      }
      return this._setActionPoints("scale", objects);
    },
    /**
     * Adds a point to the set of the scale points of the group. Dragging at one of these points results into a scaling of the whole group.
     * @param {JXG.Point} point {@link JXG.Point} element.
     * @param {String} direction Restricts the directions to be scaled. Possible values are 'x', 'y', 'xy'. Default value is 'xy'.
     * @returns {JXG.Group} returns this group
     */
    addScalePoint: function(point, direction) {
      this._addActionPoint("scale", point);
      this.scaleDirections[this.board.select(point).id] = direction || "xy";
      return this;
    },
    /**
     * Removes the scaling property from a point of the group.
     * @param {JXG.Point} point {@link JXG.Point} element.
     * @returns {JXG.Group} returns this group
     */
    removeScalePoint: function(point) {
      return this._removeActionPoint("scale", point);
    },
    /**
     * Generic method for {@link JXG.Group@setTranslationPoints} and {@link JXG.Group@setRotationPoints}
     * @private
     */
    _setActionPoints: function(action, objects) {
      var objs, i2, len;
      if (type_default.isArray(objects)) {
        objs = objects;
      } else {
        objs = arguments;
      }
      len = objs.length;
      this[action + "Points"] = [];
      for (i2 = 0; i2 < len; ++i2) {
        this._addActionPoint(action, objs[i2]);
      }
      return this;
    },
    /**
     * Generic method for {@link JXG.Group@addTranslationPoint} and {@link JXG.Group@addRotationPoint}
     * @private
     */
    _addActionPoint: function(action, point) {
      this[action + "Points"].push(this.board.select(point));
      return this;
    },
    /**
     * Generic method for {@link JXG.Group@removeTranslationPoint} and {@link JXG.Group@removeRotationPoint}
     * @private
     */
    _removeActionPoint: function(action, point) {
      var idx = this[action + "Points"].indexOf(this.board.select(point));
      if (idx > -1) {
        this[action + "Points"].splice(idx, 1);
      }
      return this;
    },
    /**
     * @deprecated
     * Use setAttribute
     */
    setProperty: function() {
      jxg_default.deprecated("Group.setProperty", "Group.setAttribute()");
      this.setAttribute.apply(this, arguments);
    },
    setAttribute: function() {
      var el;
      for (el in this.objects) {
        if (this.objects.hasOwnProperty(el)) {
          this.objects[el].point.setAttribute.apply(
            this.objects[el].point,
            arguments
          );
        }
      }
      return this;
    }
  }
);
jxg_default.createGroup = function(board, parents, attributes) {
  var attr = type_default.copyAttributes(attributes, board.options, "group"), g = new jxg_default.Group(board, attr.id, attr.name, parents, attr);
  g.elType = "group";
  g.setParents(parents);
  return g;
};
jxg_default.registerElement("group", jxg_default.createGroup);
var group_default = jxg_default.Group;

// node_modules/jsxgraph/src/base/circle.js
jxg_default.Circle = function(board, method, par1, par2, attributes) {
  this.constructor(board, attributes, constants_default.OBJECT_TYPE_CIRCLE, constants_default.OBJECT_CLASS_CIRCLE);
  this.method = method;
  this.midpoint = this.board.select(par1);
  this.center = this.board.select(par1);
  this.point2 = null;
  this.radius = 0;
  this.line = null;
  this.circle = null;
  this.points = [];
  if (method === "twoPoints") {
    this.point2 = board.select(par2);
    this.radius = this.Radius();
  } else if (method === "pointRadius") {
    this.gxtterm = par2;
    this.updateRadius = type_default.createFunction(par2, this.board);
    this.updateRadius();
    this.addParentsFromJCFunctions([this.updateRadius]);
  } else if (method === "pointLine") {
    this.line = board.select(par2);
    this.radius = this.line.point1.coords.distance(
      constants_default.COORDS_BY_USER,
      this.line.point2.coords
    );
  } else if (method === "pointCircle") {
    this.circle = board.select(par2);
    this.radius = this.circle.Radius();
  }
  this.id = this.board.setId(this, "C");
  this.board.renderer.drawEllipse(this);
  this.board.finalizeAdding(this);
  this.createGradient();
  this.elType = "circle";
  this.createLabel();
  if (type_default.exists(this.center._is_new)) {
    this.addChild(this.center);
    delete this.center._is_new;
  } else {
    this.center.addChild(this);
  }
  if (method === "pointRadius") {
    this.notifyParents(par2);
  } else if (method === "pointLine") {
    this.line.addChild(this);
  } else if (method === "pointCircle") {
    this.circle.addChild(this);
  } else if (method === "twoPoints") {
    if (type_default.exists(this.point2._is_new)) {
      this.addChild(this.point2);
      delete this.point2._is_new;
    } else {
      this.point2.addChild(this);
    }
  }
  this.methodMap = type_default.deepCopy(this.methodMap, {
    setRadius: "setRadius",
    getRadius: "getRadius",
    Area: "Area",
    area: "Area",
    Perimeter: "Perimeter",
    Circumference: "Perimeter",
    radius: "Radius",
    Radius: "Radius",
    Diameter: "Diameter",
    center: "center",
    line: "line",
    point2: "point2"
  });
};
jxg_default.Circle.prototype = new element_default();
jxg_default.extend(
  jxg_default.Circle.prototype,
  /** @lends JXG.Circle.prototype */
  {
    /**
     * Checks whether (x,y) is near the circle line or inside of the ellipse
     * (in case JXG.Options.conic#hasInnerPoints is true).
     * @param {Number} x Coordinate in x direction, screen coordinates.
     * @param {Number} y Coordinate in y direction, screen coordinates.
     * @returns {Boolean} True if (x,y) is near the circle, False otherwise.
     * @private
     */
    hasPoint: function(x, y) {
      var prec, type, mp = this.center.coords.usrCoords, p = new coords_default(constants_default.COORDS_BY_SCREEN, [x, y], this.board), r = this.Radius(), dx, dy, dist;
      if (type_default.isObject(type_default.evaluate(this.visProp.precision))) {
        type = this.board._inputDevice;
        prec = type_default.evaluate(this.visProp.precision[type]);
      } else {
        prec = this.board.options.precision.hasPoint;
      }
      dx = mp[1] - p.usrCoords[1];
      dy = mp[2] - p.usrCoords[2];
      dist = math_default.hypot(dx, dy);
      prec += type_default.evaluate(this.visProp.strokewidth) * 0.5;
      prec /= Math.sqrt(Math.abs(this.board.unitX * this.board.unitY));
      if (type_default.evaluate(this.visProp.hasinnerpoints)) {
        return dist < r + prec;
      }
      return Math.abs(dist - r) < prec;
    },
    // /**
    //  * Used to generate a polynomial for a point p that lies on this circle.
    //  * @param {JXG.Point} p The point for which the polynomial is generated.
    //  * @returns {Array} An array containing the generated polynomial.
    //  * @private
    //  */
    generatePolynomial: function(p) {
      var m1 = this.center.symbolic.x, m2 = this.center.symbolic.y, g1 = p.symbolic.x, g2 = p.symbolic.y, rsq = this.generateRadiusSquared();
      if (rsq === "") {
        return [];
      }
      return [
        "((" + g1 + ")-(" + m1 + "))^2 + ((" + g2 + ")-(" + m2 + "))^2 - (" + rsq + ")"
      ];
    },
    /**
     * Generate symbolic radius calculation for loci determination with Groebner-Basis algorithm.
     * @returns {String} String containing symbolic calculation of the circle's radius or an empty string
     * if the radius can't be expressed in a polynomial equation.
     * @private
     */
    generateRadiusSquared: function() {
      var m1, m2, p1, p2, q1, q2, rsq = "";
      if (this.method === "twoPoints") {
        m1 = this.center.symbolic.x;
        m2 = this.center.symbolic.y;
        p1 = this.point2.symbolic.x;
        p2 = this.point2.symbolic.y;
        rsq = "((" + p1 + ")-(" + m1 + "))^2 + ((" + p2 + ")-(" + m2 + "))^2";
      } else if (this.method === "pointRadius") {
        if (type_default.isNumber(this.radius)) {
          rsq = (this.radius * this.radius).toString();
        }
      } else if (this.method === "pointLine") {
        p1 = this.line.point1.symbolic.x;
        p2 = this.line.point1.symbolic.y;
        q1 = this.line.point2.symbolic.x;
        q2 = this.line.point2.symbolic.y;
        rsq = "((" + p1 + ")-(" + q1 + "))^2 + ((" + p2 + ")-(" + q2 + "))^2";
      } else if (this.method === "pointCircle") {
        rsq = this.circle.Radius();
      }
      return rsq;
    },
    /**
     * Uses the boards renderer to update the circle.
     */
    update: function() {
      var x, y, z, r, c, i2;
      if (this.needsUpdate) {
        if (type_default.evaluate(this.visProp.trace)) {
          this.cloneToBackground(true);
        }
        if (this.method === "pointLine") {
          this.radius = this.line.point1.coords.distance(
            constants_default.COORDS_BY_USER,
            this.line.point2.coords
          );
        } else if (this.method === "pointCircle") {
          this.radius = this.circle.Radius();
        } else if (this.method === "pointRadius") {
          this.radius = this.updateRadius();
        }
        this.radius = Math.abs(this.radius);
        this.updateStdform();
        this.updateQuadraticform();
        z = this.center.coords.usrCoords[0];
        x = this.center.coords.usrCoords[1] / z;
        y = this.center.coords.usrCoords[2] / z;
        z /= z;
        r = this.Radius();
        c = 0.551915024494;
        this.numberPoints = 13;
        this.dataX = [
          x + r,
          x + r,
          x + r * c,
          x,
          x - r * c,
          x - r,
          x - r,
          x - r,
          x - r * c,
          x,
          x + r * c,
          x + r,
          x + r
        ];
        this.dataY = [
          y,
          y + r * c,
          y + r,
          y + r,
          y + r,
          y + r * c,
          y,
          y - r * c,
          y - r,
          y - r,
          y - r,
          y - r * c,
          y
        ];
        this.bezierDegree = 3;
        for (i2 = 0; i2 < this.numberPoints; i2++) {
          this.points[i2] = new coords_default(
            constants_default.COORDS_BY_USER,
            [this.dataX[i2], this.dataY[i2]],
            this.board
          );
        }
      }
      return this;
    },
    /**
     * Updates this circle's {@link JXG.Circle#quadraticform}.
     * @private
     */
    updateQuadraticform: function() {
      var m = this.center, mX = m.X(), mY = m.Y(), r = this.Radius();
      this.quadraticform = [
        [mX * mX + mY * mY - r * r, -mX, -mY],
        [-mX, 1, 0],
        [-mY, 0, 1]
      ];
    },
    /**
     * Updates the stdform derived from the position of the center and the circle's radius.
     * @private
     */
    updateStdform: function() {
      this.stdform[3] = 0.5;
      this.stdform[4] = this.Radius();
      this.stdform[1] = -this.center.coords.usrCoords[1];
      this.stdform[2] = -this.center.coords.usrCoords[2];
      if (!isFinite(this.stdform[4])) {
        this.stdform[0] = type_default.exists(this.point2) ? -(this.stdform[1] * this.point2.coords.usrCoords[1] + this.stdform[2] * this.point2.coords.usrCoords[2]) : 0;
      }
      this.normalize();
    },
    /**
     * Uses the boards renderer to update the circle.
     * @private
     */
    updateRenderer: function() {
      if (!this.needsUpdate) {
        return this;
      }
      if (this.visPropCalc.visible) {
        this.isReal = !isNaN(
          this.center.coords.usrCoords[1] + this.center.coords.usrCoords[2] + this.Radius()
        ) && this.center.isReal;
        if (
          //wasReal &&
          !this.isReal
        ) {
          this.updateVisibility(false);
        }
      }
      if (this.visPropCalc.visible) {
        this.board.renderer.updateEllipse(this);
      }
      if (this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal) {
        this.label.update();
        this.board.renderer.updateText(this.label);
      }
      this.setDisplayRendNode();
      this.needsUpdate = false;
      return this;
    },
    /**
     * Finds dependencies in a given term and resolves them by adding the elements referenced in this
     * string to the circle's list of ancestors.
     * @param {String} contentStr
     * @private
     */
    notifyParents: function(contentStr) {
      if (type_default.isString(contentStr)) {
        geonext_default.findDependencies(this, contentStr, this.board);
      }
    },
    /**
     * Set a new radius, then update the board.
     * @param {String|Number|function} r A string, function or number describing the new radius.
     * @returns {JXG.Circle} Reference to this circle
     */
    setRadius: function(r) {
      this.updateRadius = type_default.createFunction(r, this.board);
      this.addParentsFromJCFunctions([this.updateRadius]);
      this.board.update();
      return this;
    },
    /**
     * Calculates the radius of the circle.
     * @param {String|Number|function} [value] Set new radius
     * @returns {Number} The radius of the circle
     */
    Radius: function(value) {
      if (type_default.exists(value)) {
        this.setRadius(value);
        return this.Radius();
      }
      if (this.method === "twoPoints") {
        if (type_default.cmpArrays(this.point2.coords.usrCoords, [0, 0, 0]) || type_default.cmpArrays(this.center.coords.usrCoords, [0, 0, 0])) {
          return NaN;
        }
        return this.center.Dist(this.point2);
      }
      if (this.method === "pointLine" || this.method === "pointCircle") {
        return this.radius;
      }
      if (this.method === "pointRadius") {
        return Math.abs(this.updateRadius());
      }
      return NaN;
    },
    /**
     * Calculates the diameter of the circle.
     * @returns {Number} The Diameter of the circle
     */
    Diameter: function() {
      return 2 * this.Radius();
    },
    /**
     * Use {@link JXG.Circle#Radius}.
     * @deprecated
     */
    getRadius: function() {
      jxg_default.deprecated("Circle.getRadius()", "Circle.Radius()");
      return this.Radius();
    },
    // documented in geometry element
    getTextAnchor: function() {
      return this.center.coords;
    },
    // documented in geometry element
    getLabelAnchor: function() {
      var x, y, r = this.Radius(), c = this.center.coords.usrCoords, SQRTH = 0.7071067811865;
      switch (type_default.evaluate(this.visProp.label.position)) {
        case "lft":
          x = c[1] - r;
          y = c[2];
          break;
        case "llft":
          x = c[1] - SQRTH * r;
          y = c[2] - SQRTH * r;
          break;
        case "rt":
          x = c[1] + r;
          y = c[2];
          break;
        case "lrt":
          x = c[1] + SQRTH * r;
          y = c[2] - SQRTH * r;
          break;
        case "urt":
          x = c[1] + SQRTH * r;
          y = c[2] + SQRTH * r;
          break;
        case "top":
          x = c[1];
          y = c[2] + r;
          break;
        case "bot":
          x = c[1];
          y = c[2] - r;
          break;
        default:
          x = c[1] - SQRTH * r;
          y = c[2] + SQRTH * r;
          break;
      }
      return new coords_default(constants_default.COORDS_BY_USER, [x, y], this.board);
    },
    // documented in geometry element
    cloneToBackground: function() {
      var er, r = this.Radius(), copy = {
        id: this.id + "T" + this.numTraces,
        elementClass: constants_default.OBJECT_CLASS_CIRCLE,
        center: {
          coords: this.center.coords
        },
        Radius: function() {
          return r;
        },
        getRadius: function() {
          return r;
        },
        board: this.board,
        visProp: type_default.deepCopy(this.visProp, this.visProp.traceattributes, true)
      };
      copy.visProp.layer = this.board.options.layer.trace;
      this.numTraces++;
      type_default.clearVisPropOld(copy);
      copy.visPropCalc = {
        visible: type_default.evaluate(copy.visProp.visible)
      };
      er = this.board.renderer.enhancedRendering;
      this.board.renderer.enhancedRendering = true;
      this.board.renderer.drawEllipse(copy);
      this.board.renderer.enhancedRendering = er;
      this.traces[copy.id] = copy.rendNode;
      return this;
    },
    /**
     * Add transformations to this circle.
     * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation} or an array of {@link JXG.Transformation}s.
     * @returns {JXG.Circle} Reference to this circle object.
     */
    addTransform: function(transform) {
      var i2, list2 = type_default.isArray(transform) ? transform : [transform], len = list2.length;
      for (i2 = 0; i2 < len; i2++) {
        this.center.transformations.push(list2[i2]);
        if (this.method === "twoPoints") {
          this.point2.transformations.push(list2[i2]);
        }
      }
      return this;
    },
    // see element.js
    snapToGrid: function() {
      var forceIt = type_default.evaluate(this.visProp.snaptogrid);
      this.center.handleSnapToGrid(forceIt, true);
      if (this.method === "twoPoints") {
        this.point2.handleSnapToGrid(forceIt, true);
      }
      return this;
    },
    // see element.js
    snapToPoints: function() {
      var forceIt = type_default.evaluate(this.visProp.snaptopoints);
      this.center.handleSnapToPoints(forceIt);
      if (this.method === "twoPoints") {
        this.point2.handleSnapToPoints(forceIt);
      }
      return this;
    },
    /**
     * Treats the circle as parametric curve and calculates its X coordinate.
     * @param {Number} t Number between 0 and 1.
     * @returns {Number} <tt>X(t)= radius*cos(t)+centerX</tt>.
     */
    X: function(t) {
      return this.Radius() * Math.cos(t * 2 * Math.PI) + this.center.coords.usrCoords[1];
    },
    /**
     * Treats the circle as parametric curve and calculates its Y coordinate.
     * @param {Number} t Number between 0 and 1.
     * @returns {Number} <tt>X(t)= radius*sin(t)+centerY</tt>.
     */
    Y: function(t) {
      return this.Radius() * Math.sin(t * 2 * Math.PI) + this.center.coords.usrCoords[2];
    },
    /**
     * Treat the circle as parametric curve and calculates its Z coordinate.
     * @param {Number} t ignored
     * @returns {Number} 1.0
     */
    Z: function(t) {
      return 1;
    },
    /**
     * Returns 0.
     * @private
     */
    minX: function() {
      return 0;
    },
    /**
     * Returns 1.
     * @private
     */
    maxX: function() {
      return 1;
    },
    /**
     * Circle area
     * @returns {Number} area of the circle.
     */
    Area: function() {
      var r = this.Radius();
      return r * r * Math.PI;
    },
    /**
     * Perimeter (circumference) of circle.
     * @returns {Number} Perimeter of circle in user units.
     */
    Perimeter: function() {
      return 2 * this.Radius() * Math.PI;
    },
    /**
     * Get bounding box of the circle.
     * @returns {Array} [x1, y1, x2, y2]
     */
    bounds: function() {
      var uc = this.center.coords.usrCoords, r = this.Radius();
      return [uc[1] - r, uc[2] + r, uc[1] + r, uc[2] - r];
    },
    /**
     * Get data to construct this element. Data consists of the parent elements
     * and static data like radius.
     * @returns {Array} data necessary to construct this element
     */
    getParents: function() {
      if (this.parents.length === 1) {
        return this.parents.concat(this.radius);
      }
      return this.parents;
    }
  }
);
jxg_default.createCircle = function(board, parents, attributes) {
  var el, p, i2, attr, obj, isDraggable = true, point_style = ["center", "point2"];
  p = [];
  obj = board.select(parents[0]);
  if (type_default.isObject(obj) && obj.elementClass === constants_default.OBJECT_CLASS_CIRCLE && type_default.isTransformationOrArray(parents[1])) {
    attr = type_default.copyAttributes(attributes, board.options, "circle");
    el = jxg_default.createEllipse(
      board,
      [
        obj.center,
        obj.center,
        function() {
          return 2 * obj.Radius();
        }
      ],
      attr
    );
    el.addTransform(parents[1]);
    return el;
  }
  for (i2 = 0; i2 < parents.length; i2++) {
    if (type_default.isPointType(board, parents[i2])) {
      if (parents.length < 3) {
        p = p.concat(
          type_default.providePoints(board, [parents[i2]], attributes, "circle", [point_style[i2]])
        );
      } else {
        p = p.concat(
          type_default.providePoints(board, [parents[i2]], attributes, "point")
        );
      }
      if (p[p.length - 1] === false) {
        throw new Error(
          "JSXGraph: Can't create circle from this type. Please provide a point type."
        );
      }
    } else {
      p.push(parents[i2]);
    }
  }
  attr = type_default.copyAttributes(attributes, board.options, "circle");
  if (p.length === 2 && type_default.isPoint(p[0]) && type_default.isPoint(p[1])) {
    el = new jxg_default.Circle(board, "twoPoints", p[0], p[1], attr);
  } else if ((type_default.isNumber(p[0]) || type_default.isFunction(p[0]) || type_default.isString(p[0])) && type_default.isPoint(p[1])) {
    el = new jxg_default.Circle(board, "pointRadius", p[1], p[0], attr);
  } else if ((type_default.isNumber(p[1]) || type_default.isFunction(p[1]) || type_default.isString(p[1])) && type_default.isPoint(p[0])) {
    el = new jxg_default.Circle(board, "pointRadius", p[0], p[1], attr);
  } else if (p[0].elementClass === constants_default.OBJECT_CLASS_CIRCLE && type_default.isPoint(p[1])) {
    el = new jxg_default.Circle(board, "pointCircle", p[1], p[0], attr);
  } else if (p[1].elementClass === constants_default.OBJECT_CLASS_CIRCLE && type_default.isPoint(p[0])) {
    el = new jxg_default.Circle(board, "pointCircle", p[0], p[1], attr);
  } else if (p[0].elementClass === constants_default.OBJECT_CLASS_LINE && type_default.isPoint(p[1])) {
    el = new jxg_default.Circle(board, "pointLine", p[1], p[0], attr);
  } else if (p[1].elementClass === constants_default.OBJECT_CLASS_LINE && type_default.isPoint(p[0])) {
    el = new jxg_default.Circle(board, "pointLine", p[0], p[1], attr);
  } else if (parents.length === 3 && type_default.isPoint(p[0]) && type_default.isPoint(p[1]) && type_default.isPoint(p[2])) {
    if (jxg_default.elements.circumcircle) {
      el = jxg_default.elements.circumcircle(board, p, attr);
    } else {
      throw new Error(
        "JSXGraph: Can't create circle with three points. Please include the circumcircle element (element/composition)."
      );
    }
  } else {
    throw new Error(
      "JSXGraph: Can't create circle with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,point], [point,number], [point,function], [point,circle], [point,point,point], [circle,transformation]"
    );
  }
  el.isDraggable = isDraggable;
  el.setParents(p);
  el.elType = "circle";
  for (i2 = 0; i2 < p.length; i2++) {
    if (type_default.isPoint(p[i2])) {
      el.inherits.push(p[i2]);
    }
  }
  return el;
};
jxg_default.registerElement("circle", jxg_default.createCircle);
var circle_default = jxg_default.Circle;

// node_modules/jsxgraph/src/element/conic.js
jxg_default.createEllipse = function(board, parents, attributes) {
  var polarForm, curve, M, C, majorAxis, i2, hasPointOrg, F = [], attr_foci = type_default.copyAttributes(attributes, board.options, "conic", "foci"), attr_center = type_default.copyAttributes(attributes, board.options, "conic", "center"), attr_curve = type_default.copyAttributes(attributes, board.options, "conic");
  for (i2 = 0; i2 < 2; i2++) {
    if (parents[i2].length > 1) {
      F[i2] = board.create("point", parents[i2], attr_foci);
    } else if (type_default.isPoint(parents[i2])) {
      F[i2] = board.select(parents[i2]);
    } else if (type_default.isFunction(parents[i2]) && type_default.isPoint(parents[i2]())) {
      F[i2] = parents[i2]();
    } else if (type_default.isString(parents[i2])) {
      F[i2] = board.select(parents[i2]);
    } else {
      throw new Error(
        "JSXGraph: Can't create Ellipse with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,point,point], [point,point,number|function]"
      );
    }
  }
  if (type_default.isNumber(parents[2])) {
    majorAxis = type_default.createFunction(parents[2], board);
  } else if (type_default.isFunction(parents[2]) && type_default.isNumber(parents[2]())) {
    majorAxis = parents[2];
  } else {
    if (type_default.isPoint(parents[2])) {
      C = board.select(parents[2]);
    } else if (parents[2].length > 1) {
      C = board.create("point", parents[2], attr_foci);
    } else if (type_default.isFunction(parents[2]) && type_default.isPoint(parents[2]())) {
      C = parents[2]();
    } else if (type_default.isString(parents[2])) {
      C = board.select(parents[2]);
    } else {
      throw new Error(
        "JSXGraph: Can't create Ellipse with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "' and '" + typeof parents[2] + "'.\nPossible parent types: [point,point,point], [point,point,number|function]"
      );
    }
    majorAxis = function() {
      return C.Dist(F[0]) + C.Dist(F[1]);
    };
  }
  if (!type_default.exists(parents[4])) {
    parents[4] = 2 * Math.PI;
  }
  if (!type_default.exists(parents[3])) {
    parents[3] = 0;
  }
  M = board.create(
    "point",
    [
      function() {
        return (F[0].X() + F[1].X()) * 0.5;
      },
      function() {
        return (F[0].Y() + F[1].Y()) * 0.5;
      }
    ],
    attr_center
  );
  curve = board.create(
    "curve",
    [
      function(x) {
        return 0;
      },
      function(x) {
        return 0;
      },
      parents[3],
      parents[4]
    ],
    attr_curve
  );
  curve.majorAxis = majorAxis;
  hasPointOrg = curve.hasPoint;
  polarForm = function(phi, suspendUpdate) {
    var r, rr, ax, ay, bx, by, axbx, ayby, f;
    if (!suspendUpdate) {
      r = majorAxis();
      rr = r * r;
      ax = F[0].X();
      ay = F[0].Y();
      bx = F[1].X();
      by = F[1].Y();
      axbx = ax - bx;
      ayby = ay - by;
      f = (rr - ax * ax - ay * ay + bx * bx + by * by) / (2 * r);
      curve.quadraticform = [
        [f * f - bx * bx - by * by, f * axbx / r + bx, f * ayby / r + by],
        [f * axbx / r + bx, axbx * axbx / rr - 1, axbx * ayby / rr],
        [f * ayby / r + by, axbx * ayby / rr, ayby * ayby / rr - 1]
      ];
    }
  };
  curve.X = function(phi, suspendUpdate) {
    var r = majorAxis(), c = F[1].Dist(F[0]), b = 0.5 * (c * c - r * r) / (c * Math.cos(phi) - r), beta = Math.atan2(F[1].Y() - F[0].Y(), F[1].X() - F[0].X());
    if (!suspendUpdate) {
      polarForm(phi, suspendUpdate);
    }
    return F[0].X() + Math.cos(beta + phi) * b;
  };
  curve.Y = function(phi, suspendUpdate) {
    var r = majorAxis(), c = F[1].Dist(F[0]), b = 0.5 * (c * c - r * r) / (c * Math.cos(phi) - r), beta = Math.atan2(F[1].Y() - F[0].Y(), F[1].X() - F[0].X());
    return F[0].Y() + Math.sin(beta + phi) * b;
  };
  curve.midpoint = curve.center = M;
  curve.type = constants_default.OBJECT_TYPE_CONIC;
  curve.subs = {
    center: curve.center
  };
  curve.inherits.push(curve.center, F[0], F[1]);
  if (type_default.isPoint(C)) {
    curve.inherits.push(C);
  }
  curve.hasPoint = function(x, y) {
    var ac, bc, r, p, dist;
    if (type_default.evaluate(this.visProp.hasinnerpoints)) {
      ac = F[0].coords;
      bc = F[1].coords;
      r = this.majorAxis();
      p = new coords_default(constants_default.COORDS_BY_SCREEN, [x, y], this.board);
      dist = p.distance(constants_default.COORDS_BY_USER, ac) + p.distance(constants_default.COORDS_BY_USER, bc);
      return dist <= r;
    }
    return hasPointOrg.apply(this, arguments);
  };
  M.addChild(curve);
  for (i2 = 0; i2 < 2; i2++) {
    if (type_default.isPoint(F[i2])) {
      F[i2].addChild(curve);
    }
  }
  if (type_default.isPoint(C)) {
    C.addChild(curve);
  }
  curve.setParents(parents);
  return curve;
};
jxg_default.createHyperbola = function(board, parents, attributes) {
  var polarForm, curve, M, C, majorAxis, i2, F = [], attr_foci = type_default.copyAttributes(attributes, board.options, "conic", "foci"), attr_center = type_default.copyAttributes(attributes, board.options, "conic", "center"), attr_curve = type_default.copyAttributes(attributes, board.options, "conic");
  for (i2 = 0; i2 < 2; i2++) {
    if (parents[i2].length > 1) {
      F[i2] = board.create("point", parents[i2], attr_foci);
    } else if (type_default.isPoint(parents[i2])) {
      F[i2] = board.select(parents[i2]);
    } else if (type_default.isFunction(parents[i2]) && type_default.isPoint(parents[i2]())) {
      F[i2] = parents[i2]();
    } else if (type_default.isString(parents[i2])) {
      F[i2] = board.select(parents[i2]);
    } else {
      throw new Error(
        "JSXGraph: Can't create Hyperbola with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,point,point], [point,point,number|function]"
      );
    }
  }
  if (type_default.isNumber(parents[2])) {
    majorAxis = type_default.createFunction(parents[2], board);
  } else if (type_default.isFunction(parents[2]) && type_default.isNumber(parents[2]())) {
    majorAxis = parents[2];
  } else {
    if (type_default.isPoint(parents[2])) {
      C = board.select(parents[2]);
    } else if (parents[2].length > 1) {
      C = board.create("point", parents[2], attr_foci);
    } else if (type_default.isFunction(parents[2]) && type_default.isPoint(parents[2]())) {
      C = parents[2]();
    } else if (type_default.isString(parents[2])) {
      C = board.select(parents[2]);
    } else {
      throw new Error(
        "JSXGraph: Can't create Hyperbola with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "' and '" + typeof parents[2] + "'.\nPossible parent types: [point,point,point], [point,point,number|function]"
      );
    }
    majorAxis = function() {
      return C.Dist(F[0]) - C.Dist(F[1]);
    };
  }
  if (!type_default.exists(parents[4])) {
    parents[4] = 1.0001 * Math.PI;
  }
  if (!type_default.exists(parents[3])) {
    parents[3] = -1.0001 * Math.PI;
  }
  M = board.create(
    "point",
    [
      function() {
        return (F[0].X() + F[1].X()) * 0.5;
      },
      function() {
        return (F[0].Y() + F[1].Y()) * 0.5;
      }
    ],
    attr_center
  );
  curve = board.create(
    "curve",
    [
      function(x) {
        return 0;
      },
      function(x) {
        return 0;
      },
      parents[3],
      parents[4]
    ],
    attr_curve
  );
  curve.majorAxis = majorAxis;
  polarForm = function(phi, suspendUpdate) {
    var r, rr, ax, ay, bx, by, axbx, ayby, f;
    if (!suspendUpdate) {
      r = majorAxis();
      rr = r * r;
      ax = F[0].X();
      ay = F[0].Y();
      bx = F[1].X();
      by = F[1].Y();
      axbx = ax - bx;
      ayby = ay - by;
      f = (rr - ax * ax - ay * ay + bx * bx + by * by) / (2 * r);
      curve.quadraticform = [
        [f * f - bx * bx - by * by, f * axbx / r + bx, f * ayby / r + by],
        [f * axbx / r + bx, axbx * axbx / rr - 1, axbx * ayby / rr],
        [f * ayby / r + by, axbx * ayby / rr, ayby * ayby / rr - 1]
      ];
    }
  };
  curve.X = function(phi, suspendUpdate) {
    var r = majorAxis(), c = F[1].Dist(F[0]), b = 0.5 * (c * c - r * r) / (c * Math.cos(phi) + r), beta = Math.atan2(F[1].Y() - F[0].Y(), F[1].X() - F[0].X());
    if (!suspendUpdate) {
      polarForm(phi, suspendUpdate);
    }
    return F[0].X() + Math.cos(beta + phi) * b;
  };
  curve.Y = function(phi, suspendUpdate) {
    var r = majorAxis(), c = F[1].Dist(F[0]), b = 0.5 * (c * c - r * r) / (c * Math.cos(phi) + r), beta = Math.atan2(F[1].Y() - F[0].Y(), F[1].X() - F[0].X());
    return F[0].Y() + Math.sin(beta + phi) * b;
  };
  curve.midpoint = curve.center = M;
  curve.subs = {
    center: curve.center
  };
  curve.inherits.push(curve.center, F[0], F[1]);
  if (type_default.isPoint(C)) {
    curve.inherits.push(C);
  }
  curve.type = constants_default.OBJECT_TYPE_CONIC;
  M.addChild(curve);
  for (i2 = 0; i2 < 2; i2++) {
    if (type_default.isPoint(F[i2])) {
      F[i2].addChild(curve);
    }
  }
  if (type_default.isPoint(C)) {
    C.addChild(curve);
  }
  curve.setParents(parents);
  return curve;
};
jxg_default.createParabola = function(board, parents, attributes) {
  var polarForm, curve, M, F1 = parents[0], l = parents[1], attr_foci = type_default.copyAttributes(attributes, board.options, "conic", "foci"), attr_center = type_default.copyAttributes(attributes, board.options, "conic", "center"), attr_curve = type_default.copyAttributes(attributes, board.options, "conic"), attr_line;
  if (parents[0].length > 1) {
    F1 = board.create("point", parents[0], attr_foci);
  } else if (type_default.isPoint(parents[0])) {
    F1 = board.select(parents[0]);
  } else if (type_default.isFunction(parents[0]) && type_default.isPoint(parents[0]())) {
    F1 = parents[0]();
  } else if (type_default.isString(parents[0])) {
    F1 = board.select(parents[0]);
  } else {
    throw new Error(
      "JSXGraph: Can't create Parabola with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,line]"
    );
  }
  if (type_default.isArray(l) && l.length === 2) {
    attr_line = type_default.copyAttributes(attributes, board.options, "conic", "line");
    l = board.create("line", l, attr_line);
  }
  if (!type_default.exists(parents[3])) {
    parents[3] = 2 * Math.PI;
  }
  if (!type_default.exists(parents[2])) {
    parents[2] = 0;
  }
  M = board.create(
    "point",
    [
      function() {
        return geometry_default.projectPointToLine(F1, l, board).usrCoords;
      }
    ],
    attr_center
  );
  curve = board.create(
    "curve",
    [
      function(x) {
        return 0;
      },
      function(x) {
        return 0;
      },
      parents[2],
      parents[3]
    ],
    attr_curve
  );
  curve.midpoint = curve.center = M;
  curve.subs = {
    center: curve.center
  };
  curve.inherits.push(curve.center);
  polarForm = function(t, suspendUpdate) {
    var a, b, c, ab, px, py;
    if (!suspendUpdate) {
      a = l.stdform[1];
      b = l.stdform[2];
      c = l.stdform[0];
      ab = a * a + b * b;
      px = F1.X();
      py = F1.Y();
      curve.quadraticform = [
        [c * c - ab * (px * px + py * py), c * a + ab * px, c * b + ab * py],
        [c * a + ab * px, -b * b, a * b],
        [c * b + ab * py, a * b, -a * a]
      ];
    }
  };
  curve.X = function(phi, suspendUpdate) {
    var a, det, beta = l.getAngle(), d = geometry_default.distPointLine(F1.coords.usrCoords, l.stdform), A = l.point1.coords.usrCoords, B = l.point2.coords.usrCoords, M2 = F1.coords.usrCoords;
    if (A[0] === 0) {
      A = [1, B[1] + l.stdform[2], B[2] - l.stdform[1]];
    } else if (B[0] === 0) {
      B = [1, A[1] + l.stdform[2], A[2] - l.stdform[1]];
    }
    det = (B[1] - A[1]) * (M2[2] - A[2]) - (B[2] - A[2]) * (M2[1] - A[1]) >= 0 ? 1 : -1;
    a = det * d / (1 - Math.sin(phi));
    if (!suspendUpdate) {
      polarForm(phi, suspendUpdate);
    }
    return F1.X() + Math.cos(phi + beta) * a;
  };
  curve.Y = function(phi, suspendUpdate) {
    var a, det, beta = l.getAngle(), d = geometry_default.distPointLine(F1.coords.usrCoords, l.stdform), A = l.point1.coords.usrCoords, B = l.point2.coords.usrCoords, M2 = F1.coords.usrCoords;
    if (A[0] === 0) {
      A = [1, B[1] + l.stdform[2], B[2] - l.stdform[1]];
    } else if (B[0] === 0) {
      B = [1, A[1] + l.stdform[2], A[2] - l.stdform[1]];
    }
    det = (B[1] - A[1]) * (M2[2] - A[2]) - (B[2] - A[2]) * (M2[1] - A[1]) >= 0 ? 1 : -1;
    a = det * d / (1 - Math.sin(phi));
    return F1.Y() + Math.sin(phi + beta) * a;
  };
  curve.type = constants_default.OBJECT_TYPE_CONIC;
  M.addChild(curve);
  if (type_default.isPoint(F1)) {
    F1.addChild(curve);
    curve.inherits.push(F1);
  }
  l.addChild(curve);
  curve.setParents(parents);
  return curve;
};
jxg_default.createConic = function(board, parents, attributes) {
  var polarForm, curve, fitConic, degconic, sym, eigen, a, b, c, c1, c2, i2, definingMat, givenByPoints, rotationMatrix = [
    [1, 0, 0],
    [0, 1, 0],
    [0, 0, 1]
  ], M = [
    [1, 0, 0],
    [0, 1, 0],
    [0, 0, 1]
  ], points = [], p = [], attr_point = type_default.copyAttributes(attributes, board.options, "conic", "point"), attr_center = type_default.copyAttributes(attributes, board.options, "conic", "center"), attr_curve = type_default.copyAttributes(attributes, board.options, "conic");
  if (parents.length === 5) {
    givenByPoints = true;
  } else if (parents.length === 6) {
    givenByPoints = false;
  } else {
    throw new Error(
      "JSXGraph: Can't create generic Conic with " + parents.length + " parameters."
    );
  }
  if (givenByPoints) {
    for (i2 = 0; i2 < 5; i2++) {
      if (parents[i2].length > 1) {
        points[i2] = board.create("point", parents[i2], attr_point);
      } else if (type_default.isPoint(parents[i2])) {
        points[i2] = board.select(parents[i2]);
      } else if (type_default.isFunction(parents[i2]) && type_default.isPoint(parents[i2]())) {
        points[i2] = parents[i2]();
      } else if (type_default.isString(parents[i2])) {
        points[i2] = board.select(parents[i2]);
      } else {
        throw new Error(
          "JSXGraph: Can't create Conic section with parent types '" + typeof parents[i2] + "'.\nPossible parent types: [point,point,point,point,point], [a00,a11,a22,a01,a02,a12]"
        );
      }
    }
  } else {
    definingMat = [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0]
    ];
    definingMat[0][0] = type_default.isFunction(parents[2]) ? function() {
      return parents[2]();
    } : function() {
      return parents[2];
    };
    definingMat[0][1] = type_default.isFunction(parents[4]) ? function() {
      return parents[4]();
    } : function() {
      return parents[4];
    };
    definingMat[0][2] = type_default.isFunction(parents[5]) ? function() {
      return parents[5]();
    } : function() {
      return parents[5];
    };
    definingMat[1][1] = type_default.isFunction(parents[0]) ? function() {
      return parents[0]();
    } : function() {
      return parents[0];
    };
    definingMat[1][2] = type_default.isFunction(parents[3]) ? function() {
      return parents[3]();
    } : function() {
      return parents[3];
    };
    definingMat[2][2] = type_default.isFunction(parents[1]) ? function() {
      return parents[1]();
    } : function() {
      return parents[1];
    };
  }
  sym = function(A) {
    var i3, j;
    for (i3 = 0; i3 < 3; i3++) {
      for (j = i3; j < 3; j++) {
        A[i3][j] += A[j][i3];
      }
    }
    for (i3 = 0; i3 < 3; i3++) {
      for (j = 0; j < i3; j++) {
        A[i3][j] = A[j][i3];
      }
    }
    return A;
  };
  degconic = function(v, w) {
    var i3, j, mat = [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0]
    ];
    for (i3 = 0; i3 < 3; i3++) {
      for (j = 0; j < 3; j++) {
        mat[i3][j] = v[i3] * w[j];
      }
    }
    return sym(mat);
  };
  fitConic = function(A, B, p2) {
    var i3, j, pBp, pAp, Mv, mat = [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0]
    ];
    Mv = math_default.matVecMult(B, p2);
    pBp = math_default.innerProduct(p2, Mv);
    Mv = math_default.matVecMult(A, p2);
    pAp = math_default.innerProduct(p2, Mv);
    for (i3 = 0; i3 < 3; i3++) {
      for (j = 0; j < 3; j++) {
        mat[i3][j] = pBp * A[i3][j] - pAp * B[i3][j];
      }
    }
    return mat;
  };
  curve = board.create(
    "curve",
    [
      function(x) {
        return 0;
      },
      function(x) {
        return 0;
      },
      0,
      2 * Math.PI
    ],
    attr_curve
  );
  polarForm = function(phi, suspendUpdate) {
    var i3, j, v;
    if (!suspendUpdate) {
      if (givenByPoints) {
        for (i3 = 0; i3 < 5; i3++) {
          p[i3] = points[i3].coords.usrCoords;
        }
        c1 = degconic(math_default.crossProduct(p[0], p[1]), math_default.crossProduct(p[2], p[3]));
        c2 = degconic(math_default.crossProduct(p[0], p[2]), math_default.crossProduct(p[1], p[3]));
        M = fitConic(c1, c2, p[4]);
      } else {
        for (i3 = 0; i3 < 3; i3++) {
          for (j = i3; j < 3; j++) {
            M[i3][j] = definingMat[i3][j]();
            if (j > i3) {
              M[j][i3] = M[i3][j];
            }
          }
        }
      }
      curve.quadraticform = M;
      eigen = numerics_default.Jacobi(M);
      if (eigen[0][0][0] < 0) {
        eigen[0][0][0] *= -1;
        eigen[0][1][1] *= -1;
        eigen[0][2][2] *= -1;
      }
      rotationMatrix = eigen[1];
      c = Math.sqrt(Math.abs(eigen[0][0][0]));
      a = Math.sqrt(Math.abs(eigen[0][1][1]));
      b = Math.sqrt(Math.abs(eigen[0][2][2]));
    }
    if (eigen[0][1][1] <= 0 && eigen[0][2][2] <= 0) {
      v = math_default.matVecMult(rotationMatrix, [1 / c, Math.cos(phi) / a, Math.sin(phi) / b]);
    } else if (eigen[0][1][1] <= 0 && eigen[0][2][2] > 0) {
      v = math_default.matVecMult(rotationMatrix, [Math.cos(phi) / c, 1 / a, Math.sin(phi) / b]);
    } else if (eigen[0][2][2] < 0) {
      v = math_default.matVecMult(rotationMatrix, [Math.sin(phi) / c, Math.cos(phi) / a, 1 / b]);
    }
    if (type_default.exists(v)) {
      v[1] /= v[0];
      v[2] /= v[0];
      v[0] = 1;
    } else {
      v = [1, NaN, NaN];
    }
    return v;
  };
  curve.X = function(phi, suspendUpdate) {
    return polarForm(phi, suspendUpdate)[1];
  };
  curve.Y = function(phi, suspendUpdate) {
    return polarForm(phi, suspendUpdate)[2];
  };
  curve.midpoint = board.create(
    "point",
    [
      function() {
        var m = curve.quadraticform;
        return [
          m[1][1] * m[2][2] - m[1][2] * m[1][2],
          m[1][2] * m[0][2] - m[2][2] * m[0][1],
          m[0][1] * m[1][2] - m[1][1] * m[0][2]
        ];
      }
    ],
    attr_center
  );
  curve.type = constants_default.OBJECT_TYPE_CONIC;
  curve.center = curve.midpoint;
  curve.subs = {
    center: curve.center
  };
  curve.inherits.push(curve.center);
  curve.inherits = curve.inherits.concat(points);
  if (givenByPoints) {
    for (i2 = 0; i2 < 5; i2++) {
      if (type_default.isPoint(points[i2])) {
        points[i2].addChild(curve);
      }
    }
    curve.setParents(parents);
  }
  curve.addChild(curve.center);
  return curve;
};
jxg_default.registerElement("ellipse", jxg_default.createEllipse);
jxg_default.registerElement("hyperbola", jxg_default.createHyperbola);
jxg_default.registerElement("parabola", jxg_default.createParabola);
jxg_default.registerElement("conic", jxg_default.createConic);

// node_modules/jsxgraph/src/base/polygon.js
jxg_default.Polygon = function(board, vertices, attributes) {
  this.constructor(board, attributes, constants_default.OBJECT_TYPE_POLYGON, constants_default.OBJECT_CLASS_AREA);
  var i2, l, len, j, p, attr_line = type_default.copyAttributes(attributes, board.options, "polygon", "borders");
  this.withLines = attributes.withlines;
  this.attr_line = attr_line;
  this.vertices = [];
  for (i2 = 0; i2 < vertices.length; i2++) {
    this.vertices[i2] = this.board.select(vertices[i2]);
    if (this.vertices[i2]._is_new) {
      delete this.vertices[i2]._is_new;
      this.vertices[i2]._is_new_pol = true;
    }
  }
  if (this.vertices.length > 0 && this.vertices[this.vertices.length - 1].id !== this.vertices[0].id) {
    this.vertices.push(this.vertices[0]);
  }
  this.borders = [];
  if (this.withLines) {
    len = this.vertices.length - 1;
    for (j = 0; j < len; j++) {
      i2 = (j + 1) % len;
      attr_line.id = attr_line.ids && attr_line.ids[i2];
      attr_line.name = attr_line.names && attr_line.names[i2];
      attr_line.strokecolor = type_default.isArray(attr_line.colors) && attr_line.colors[i2 % attr_line.colors.length] || attr_line.strokecolor;
      attr_line.visible = type_default.exists(attributes.borders.visible) ? attributes.borders.visible : attributes.visible;
      if (attr_line.strokecolor === false) {
        attr_line.strokecolor = "none";
      }
      l = board.create("segment", [this.vertices[i2], this.vertices[i2 + 1]], attr_line);
      l.dump = false;
      this.borders[i2] = l;
      l.parentPolygon = this;
      this.addChild(l);
    }
  }
  this.inherits.push(this.vertices, this.borders);
  this.id = this.board.setId(this, "Py");
  for (i2 = 0; i2 < this.vertices.length - 1; i2++) {
    p = this.board.select(this.vertices[i2]);
    if (type_default.exists(p._is_new_pol)) {
      this.addChild(p);
      delete p._is_new_pol;
    } else {
      p.addChild(this);
    }
  }
  this.board.renderer.drawPolygon(this);
  this.board.finalizeAdding(this);
  this.createGradient();
  this.elType = "polygon";
  this.createLabel();
  this.methodMap = jxg_default.deepCopy(this.methodMap, {
    borders: "borders",
    vertices: "vertices",
    A: "Area",
    Area: "Area",
    Perimeter: "Perimeter",
    L: "Perimeter",
    boundingBox: "bounds",
    BoundingBox: "bounds",
    addPoints: "addPoints",
    insertPoints: "insertPoints",
    removePoints: "removePoints",
    Intersect: "intersect"
  });
};
jxg_default.Polygon.prototype = new element_default();
jxg_default.extend(
  jxg_default.Polygon.prototype,
  /** @lends JXG.Polygon.prototype */
  {
    /**
     * Wrapper for JXG.Math.Geometry.pnpoly.
     *
     * @param {Number} x_in x-coordinate (screen or user coordinates)
     * @param {Number} y_in y-coordinate (screen or user coordinates)
     * @param {Number} coord_type (Optional) the type of coordinates used here.
     *   Possible values are <b>JXG.COORDS_BY_USER</b> and <b>JXG.COORDS_BY_SCREEN</b>.
     *   Default value is JXG.COORDS_BY_SCREEN
     *
     * @returns {Boolean} if (x_in, y_in) is inside of the polygon.
     * @see JXG.Math.Geometry#pnpoly
     *
     * @example
     * var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);
     * var p = board.create('point', [4, 3]);
     * var txt = board.create('text', [-1, 0.5, function() {
     *   return 'Point A is inside of the polygon = ' +
     *     pol.pnpoly(p.X(), p.Y(), JXG.COORDS_BY_USER);
     * }]);
     *
     * </pre><div id="JXG7f96aec7-4e3d-4ffc-a3f5-d3f967b6691c" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG7f96aec7-4e3d-4ffc-a3f5-d3f967b6691c',
     *             {boundingbox: [-2, 5, 5,-2], axis: true, showcopyright: false, shownavigation: false});
     *     var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);
     *     var p = board.create('point', [4, 3]);
     *     var txt = board.create('text', [-1, 0.5, function() {
     *     		return 'Point A is inside of the polygon = ' + pol.pnpoly(p.X(), p.Y(), JXG.COORDS_BY_USER);
     *     }]);
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    pnpoly: function(x_in, y_in, coord_type) {
      return geometry_default.pnpoly(x_in, y_in, this.vertices, coord_type);
    },
    /**
     * Checks whether (x,y) is near the polygon.
     * @param {Number} x Coordinate in x direction, screen coordinates.
     * @param {Number} y Coordinate in y direction, screen coordinates.
     * @returns {Boolean} Returns true, if (x,y) is inside or at the boundary the polygon, otherwise false.
     */
    hasPoint: function(x, y) {
      var i2, len;
      if (type_default.evaluate(this.visProp.hasinnerpoints)) {
        if (this.pnpoly(x, y)) {
          return true;
        }
      }
      len = this.borders.length;
      for (i2 = 0; i2 < len; i2++) {
        if (this.borders[i2].hasPoint(x, y)) {
          return true;
        }
      }
      return false;
    },
    /**
     * Uses the boards renderer to update the polygon.
     */
    updateRenderer: function() {
      var i2, len;
      if (!this.needsUpdate) {
        return this;
      }
      if (this.visPropCalc.visible) {
        len = this.vertices.length - (this.elType === "polygonalchain" ? 0 : 1);
        this.isReal = true;
        for (i2 = 0; i2 < len; ++i2) {
          if (!this.vertices[i2].isReal) {
            this.isReal = false;
            break;
          }
        }
        if (!this.isReal) {
          this.updateVisibility(false);
          for (i2 in this.childElements) {
            if (this.childElements.hasOwnProperty(i2)) {
              this.childElements[i2].setDisplayRendNode(false);
            }
          }
        }
      }
      if (this.visPropCalc.visible) {
        this.board.renderer.updatePolygon(this);
      }
      if (this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal) {
        this.label.update();
        this.board.renderer.updateText(this.label);
      }
      this.setDisplayRendNode();
      this.needsUpdate = false;
      return this;
    },
    /**
     * return TextAnchor
     */
    getTextAnchor: function() {
      var a, b, x, y, i2;
      if (this.vertices.length === 0) {
        return new coords_default(constants_default.COORDS_BY_USER, [1, 0, 0], this.board);
      }
      a = this.vertices[0].X();
      b = this.vertices[0].Y();
      x = a;
      y = b;
      for (i2 = 0; i2 < this.vertices.length; i2++) {
        if (this.vertices[i2].X() < a) {
          a = this.vertices[i2].X();
        }
        if (this.vertices[i2].X() > x) {
          x = this.vertices[i2].X();
        }
        if (this.vertices[i2].Y() > b) {
          b = this.vertices[i2].Y();
        }
        if (this.vertices[i2].Y() < y) {
          y = this.vertices[i2].Y();
        }
      }
      return new coords_default(constants_default.COORDS_BY_USER, [(a + x) * 0.5, (b + y) * 0.5], this.board);
    },
    getLabelAnchor: jxg_default.shortcut(jxg_default.Polygon.prototype, "getTextAnchor"),
    // documented in geometry element
    cloneToBackground: function() {
      var copy = {}, er;
      copy.id = this.id + "T" + this.numTraces;
      this.numTraces++;
      copy.vertices = this.vertices;
      copy.visProp = type_default.deepCopy(this.visProp, this.visProp.traceattributes, true);
      copy.visProp.layer = this.board.options.layer.trace;
      copy.board = this.board;
      type_default.clearVisPropOld(copy);
      copy.visPropCalc = {
        visible: type_default.evaluate(copy.visProp.visible)
      };
      er = this.board.renderer.enhancedRendering;
      this.board.renderer.enhancedRendering = true;
      this.board.renderer.drawPolygon(copy);
      this.board.renderer.enhancedRendering = er;
      this.traces[copy.id] = copy.rendNode;
      return this;
    },
    /**
     * Hide the polygon including its border lines. It will still exist but not visible on the board.
     * @param {Boolean} [borderless=false] If set to true, the polygon is treated as a polygon without
     * borders, i.e. the borders will not be hidden.
     */
    hideElement: function(borderless) {
      var i2;
      jxg_default.deprecated("Element.hideElement()", "Element.setDisplayRendNode()");
      this.visPropCalc.visible = false;
      this.board.renderer.display(this, false);
      if (!borderless) {
        for (i2 = 0; i2 < this.borders.length; i2++) {
          this.borders[i2].hideElement();
        }
      }
      if (this.hasLabel && type_default.exists(this.label)) {
        this.label.hiddenByParent = true;
        if (this.label.visPropCalc.visible) {
          this.label.hideElement();
        }
      }
    },
    /**
     * Make the element visible.
     * @param {Boolean} [borderless=false] If set to true, the polygon is treated as a polygon without
     * borders, i.e. the borders will not be shown.
     */
    showElement: function(borderless) {
      var i2;
      jxg_default.deprecated("Element.showElement()", "Element.setDisplayRendNode()");
      this.visPropCalc.visible = true;
      this.board.renderer.display(this, true);
      if (!borderless) {
        for (i2 = 0; i2 < this.borders.length; i2++) {
          this.borders[i2].showElement().updateRenderer();
        }
      }
      if (type_default.exists(this.label) && this.hasLabel && this.label.hiddenByParent) {
        this.label.hiddenByParent = false;
        if (!this.label.visPropCalc.visible) {
          this.label.showElement().updateRenderer();
        }
      }
      return this;
    },
    /**
     * Area of (not self-intersecting) polygon
     * @returns {Number} Area of (not self-intersecting) polygon
     */
    Area: function() {
      return Math.abs(geometry_default.signedPolygon(this.vertices, true));
    },
    /**
     * Perimeter of polygon. For a polygonal chain, this method returns its length.
     *
     * @returns {Number} Perimeter of polygon in user units.
     * @see JXG.Polygon#L
     *
     * @example
     * var p = [[0.0, 2.0], [2.0, 1.0], [4.0, 6.0], [1.0, 3.0]];
     *
     * var pol = board.create('polygon', p, {hasInnerPoints: true});
     * var t = board.create('text', [5, 5, function() { return pol.Perimeter(); }]);
     * </pre><div class="jxgbox" id="JXGb10b734d-89fc-4b9d-b4a7-e3f0c1c6bf77" style="width: 400px; height: 400px;"></div>
     * <script type="text/javascript">
     *  (function () {
     *   var board = JXG.JSXGraph.initBoard('JXGb10b734d-89fc-4b9d-b4a7-e3f0c1c6bf77', {boundingbox: [-1, 9, 9, -1], axis: false, showcopyright: false, shownavigation: false}),
     *       p = [[0.0, 2.0], [2.0, 1.0], [4.0, 6.0], [1.0, 4.0]],
     *       cc1 = board.create('polygon', p, {hasInnerPoints: true}),
     *       t = board.create('text', [5, 5, function() { return cc1.Perimeter(); }]);
     *  })();
     * <\/script><pre>
     *
     */
    Perimeter: function() {
      var i2, len = this.vertices.length, val = 0;
      for (i2 = 1; i2 < len; ++i2) {
        val += this.vertices[i2].Dist(this.vertices[i2 - 1]);
      }
      return val;
    },
    /**
     * Alias for Perimeter. For polygons, the perimeter is returned. For polygonal chains the length is returned.
     *
     * @returns Number
     * @see JXG.Polygon#Perimeter
     */
    L: function() {
      return this.Perimeter();
    },
    /**
     * Bounding box of a polygon. The bounding box is an array of four numbers: the first two numbers
     * determine the upper left corner, the last two number determine the lower right corner of the bounding box.
     *
     * The width and height of a polygon can then determined like this:
     * @example
     * var box = polygon.boundingBox();
     * var width = box[2] - box[0];
     * var height = box[1] - box[3];
     *
     * @returns {Array} Array containing four numbers: [minX, maxY, maxX, minY]
     */
    boundingBox: function() {
      var box = [0, 0, 0, 0], i2, v, le = this.vertices.length - 1;
      if (le === 0) {
        return box;
      }
      box[0] = this.vertices[0].X();
      box[2] = box[0];
      box[1] = this.vertices[0].Y();
      box[3] = box[1];
      for (i2 = 1; i2 < le; ++i2) {
        v = this.vertices[i2].X();
        if (v < box[0]) {
          box[0] = v;
        } else if (v > box[2]) {
          box[2] = v;
        }
        v = this.vertices[i2].Y();
        if (v > box[1]) {
          box[1] = v;
        } else if (v < box[3]) {
          box[3] = v;
        }
      }
      return box;
    },
    // Already documented in GeometryElement
    bounds: function() {
      return this.boundingBox();
    },
    /**
     * This method removes the SVG or VML nodes of the lines and the filled area from the renderer, to remove
     * the object completely you should use {@link JXG.Board#removeObject}.
     *
     * @private
     */
    remove: function() {
      var i2;
      for (i2 = 0; i2 < this.borders.length; i2++) {
        this.board.removeObject(this.borders[i2]);
      }
      element_default.prototype.remove.call(this);
    },
    /**
     * Finds the index to a given point reference.
     * @param {JXG.Point} p Reference to an element of type {@link JXG.Point}
     * @returns {Number} Index of the point or -1.
     */
    findPoint: function(p) {
      var i2;
      if (!type_default.isPoint(p)) {
        return -1;
      }
      for (i2 = 0; i2 < this.vertices.length; i2++) {
        if (this.vertices[i2].id === p.id) {
          return i2;
        }
      }
      return -1;
    },
    /**
     * Add more points to the polygon. The new points will be inserted at the end.
     * The attributes of new border segments are set to the same values
     * as those used when the polygon was created.
     * If new vertices are supplied by coordinates, the default attributes of polygon
     * vertices are taken as their attributes. Therefore, the visual attributes of
     * new vertices and borders may have to be adapted afterwards.
     * @param {JXG.Point} p Arbitrary number of points or coordinate arrays
     * @returns {JXG.Polygon} Reference to the polygon
     * @example
     * var pg = board.create('polygon', [[1,2], [3,4], [-3,1]], {hasInnerPoints: true});
     * var newPoint = board.create('point', [-1, -1]);
     * var newPoint2 = board.create('point', [-1, -2]);
     * pg.addPoints(newPoint, newPoint2, [1, -2]);
     *
     * </pre><div id="JXG70eb0fd2-d20f-4ba9-9ab6-0eac92aabfa5" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG70eb0fd2-d20f-4ba9-9ab6-0eac92aabfa5',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var pg = board.create('polygon', [[1,2], [3,4], [-3,1]], {hasInnerPoints: true});
     *     var newPoint = board.create('point', [-1, -1]);
     *     var newPoint2 = board.create('point', [-1, -2]);
     *     pg.addPoints(newPoint, newPoint2, [1, -2]);
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    addPoints: function(p) {
      var idx, args2 = Array.prototype.slice.call(arguments);
      if (this.elType === "polygonalchain") {
        idx = this.vertices.length - 1;
      } else {
        idx = this.vertices.length - 2;
      }
      return this.insertPoints.apply(this, [idx].concat(args2));
    },
    /**
     * Insert points to the vertex list of the polygon after index <tt>idx</tt>.
     * The attributes of new border segments are set to the same values
     * as those used when the polygon was created.
     * If new vertices are supplied by coordinates, the default attributes of polygon
     * vertices are taken as their attributes. Therefore, the visual attributes of
     * new vertices and borders may have to be adapted afterwards.
     *
     * @param {Number} idx The position after which the new vertices are inserted.
     * Setting idx to -1 inserts the new points at the front, i.e. at position 0.
     * @param {JXG.Point} p Arbitrary number of points or coordinate arrays to insert.
     * @returns {JXG.Polygon} Reference to the polygon object
     *
     * @example
     * var pg = board.create('polygon', [[1,2], [3,4], [-3,1]], {hasInnerPoints: true});
     * var newPoint = board.create('point', [-1, -1]);
     * pg.insertPoints(0, newPoint, newPoint, [1, -2]);
     *
     * </pre><div id="JXG17b84b2a-a851-4e3f-824f-7f6a60f166ca" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG17b84b2a-a851-4e3f-824f-7f6a60f166ca',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var pg = board.create('polygon', [[1,2], [3,4], [-3,1]], {hasInnerPoints: true});
     *     var newPoint = board.create('point', [-1, -1]);
     *     pg.insertPoints(0, newPoint, newPoint, [1, -2]);
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    insertPoints: function(idx, p) {
      var i2, le, last, start, q;
      if (arguments.length === 0) {
        return this;
      }
      last = this.vertices.length - 1;
      if (this.elType === "polygon") {
        last--;
      }
      if (idx < -1 || idx > last) {
        return this;
      }
      le = arguments.length - 1;
      for (i2 = 1; i2 < le + 1; i2++) {
        q = type_default.providePoints(this.board, [arguments[i2]], {}, "polygon", [
          "vertices"
        ])[0];
        if (q._is_new) {
          this.addChild(q);
          delete q._is_new;
        }
        this.vertices.splice(idx + i2, 0, q);
      }
      if (this.withLines) {
        start = idx + 1;
        if (this.elType === "polygon") {
          if (idx < 0) {
            this.vertices[this.vertices.length - 1] = this.vertices[0];
            this.borders[this.borders.length - 1].point2 = this.vertices[this.vertices.length - 1];
          } else {
            this.borders[idx].point2 = this.vertices[start];
          }
        } else {
          if (idx >= 0) {
            if (idx < this.borders.length) {
              this.borders[idx].point2 = this.vertices[start];
            } else {
              start = idx;
            }
          }
        }
        for (i2 = start; i2 < start + le; i2++) {
          this.borders.splice(
            i2,
            0,
            this.board.create(
              "segment",
              [this.vertices[i2], this.vertices[i2 + 1]],
              this.attr_line
            )
          );
        }
      }
      this.inherits = [];
      this.inherits.push(this.vertices, this.borders);
      this.board.update();
      return this;
    },
    /**
     * Removes given set of vertices from the polygon
     * @param {JXG.Point} p Arbitrary number of vertices as {@link JXG.Point} elements or index numbers
     * @returns {JXG.Polygon} Reference to the polygon
     */
    removePoints: function(p) {
      var i2, j, idx, firstPoint, nvertices = [], nborders = [], nidx = [], partition = [];
      if (this.elType === "polygon") {
        firstPoint = this.vertices.pop();
      }
      for (i2 = 0; i2 < arguments.length; i2++) {
        idx = arguments[i2];
        if (type_default.isPoint(idx)) {
          idx = this.findPoint(idx);
        }
        if (type_default.isNumber(idx) && idx > -1 && idx < this.vertices.length && type_default.indexOf(nidx, idx) === -1) {
          nidx.push(idx);
        }
      }
      if (nidx.length === 0) {
        if (this.elType === "polygon") {
          this.vertices.push(firstPoint);
        }
        return this;
      }
      for (i2 = 0; i2 < nidx.length; i2++) {
        this.vertices[nidx[i2]].removeChild(this);
      }
      nidx = nidx.sort();
      nvertices = this.vertices.slice();
      nborders = this.borders.slice();
      if (this.withLines) {
        partition.push([nidx[nidx.length - 1]]);
      }
      for (i2 = nidx.length - 1; i2 > -1; i2--) {
        nvertices[nidx[i2]] = -1;
        if (this.withLines && nidx.length > 1 && nidx[i2] - 1 > nidx[i2 - 1]) {
          partition[partition.length - 1][1] = nidx[i2];
          partition.push([nidx[i2 - 1]]);
        }
      }
      if (this.withLines) {
        partition[partition.length - 1][1] = nidx[0];
      }
      this.vertices = [];
      for (i2 = 0; i2 < nvertices.length; i2++) {
        if (type_default.isPoint(nvertices[i2])) {
          this.vertices.push(nvertices[i2]);
        }
      }
      if (this.elType === "polygon" && this.vertices.length > 1 && this.vertices[this.vertices.length - 1].id !== this.vertices[0].id) {
        this.vertices.push(this.vertices[0]);
      }
      if (this.withLines) {
        for (i2 = 0; i2 < partition.length; i2++) {
          for (j = partition[i2][1] - 1; j < partition[i2][0] + 1; j++) {
            if (j < 0) {
              if (this.elType === "polygon") {
                this.board.removeObject(this.borders[nborders.length - 1]);
                nborders[nborders.length - 1] = -1;
              }
            } else if (j < nborders.length) {
              this.board.removeObject(this.borders[j]);
              nborders[j] = -1;
            }
          }
          if (partition[i2][1] !== 0 && partition[i2][0] !== nvertices.length - 1) {
            nborders[partition[i2][0] - 1] = this.board.create(
              "segment",
              [nvertices[partition[i2][1] - 1], nvertices[partition[i2][0] + 1]],
              this.attr_line
            );
          }
        }
        this.borders = [];
        for (i2 = 0; i2 < nborders.length; i2++) {
          if (nborders[i2] !== -1) {
            this.borders.push(nborders[i2]);
          }
        }
        if (this.elType === "polygon" && this.vertices.length > 2 && // Avoid trivial case of polygon with 1 vertex
        (partition[0][1] === this.vertices.length - 1 || partition[partition.length - 1][1] === 0)) {
          this.borders.push(
            this.board.create(
              "segment",
              [this.vertices[this.vertices.length - 2], this.vertices[0]],
              this.attr_line
            )
          );
        }
      }
      this.inherits = [];
      this.inherits.push(this.vertices, this.borders);
      this.board.update();
      return this;
    },
    // documented in element.js
    getParents: function() {
      this.setParents(this.vertices);
      return this.parents;
    },
    getAttributes: function() {
      var attr = element_default.prototype.getAttributes.call(this), i2;
      if (this.withLines) {
        attr.lines = attr.lines || {};
        attr.lines.ids = [];
        attr.lines.colors = [];
        for (i2 = 0; i2 < this.borders.length; i2++) {
          attr.lines.ids.push(this.borders[i2].id);
          attr.lines.colors.push(this.borders[i2].visProp.strokecolor);
        }
      }
      return attr;
    },
    snapToGrid: function() {
      var i2, force;
      if (type_default.evaluate(this.visProp.snaptogrid)) {
        force = true;
      } else {
        force = false;
      }
      for (i2 = 0; i2 < this.vertices.length; i2++) {
        this.vertices[i2].handleSnapToGrid(force, true);
      }
    },
    /**
     * Moves the polygon by the difference of two coordinates.
     * @param {Number} method The type of coordinates used here. Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.
     * @param {Array} coords coordinates in screen/user units
     * @param {Array} oldcoords previous coordinates in screen/user units
     * @returns {JXG.Polygon} this element
     */
    setPositionDirectly: function(method, coords, oldcoords) {
      var dc, t, i2, len, c = new coords_default(method, coords, this.board), oldc = new coords_default(method, oldcoords, this.board);
      len = this.vertices.length - 1;
      for (i2 = 0; i2 < len; i2++) {
        if (!this.vertices[i2].draggable()) {
          return this;
        }
      }
      dc = statistics_default.subtract(c.usrCoords, oldc.usrCoords);
      t = this.board.create("transform", dc.slice(1), { type: "translate" });
      t.applyOnce(this.vertices.slice(0, -1));
      return this;
    },
    /**
     * Algorithm by Sutherland and Hodgman to compute the intersection of two convex polygons.
     * The polygon itself is the clipping polygon, it expects as parameter a polygon to be clipped.
     * See <a href="https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm">wikipedia entry</a>.
     * Called by {@link JXG.Polygon#intersect}.
     *
     * @private
     *
     * @param {JXG.Polygon} polygon Polygon which will be clipped.
     *
     * @returns {Array} of (normalized homogeneous user) coordinates (i.e. [z, x, y], where z==1 in most cases,
     *   representing the vertices of the intersection polygon.
     *
     */
    sutherlandHodgman: function(polygon) {
      var clip = jxg_default.Math.Geometry.sortVertices(this.vertices), subject = jxg_default.Math.Geometry.sortVertices(polygon.vertices), lenClip = clip.length - 1, lenSubject = subject.length - 1, lenIn, outputList = [], inputList, i2, j, S, E, cross, isInside = function(c1, c2, c3) {
        return (c2[1] - c1[1]) * (c3[2] - c1[2]) - (c2[2] - c1[2]) * (c3[1] - c1[1]) >= 0;
      };
      for (i2 = 0; i2 < lenSubject; i2++) {
        outputList.push(subject[i2]);
      }
      for (i2 = 0; i2 < lenClip; i2++) {
        inputList = outputList.slice(0);
        lenIn = inputList.length;
        outputList = [];
        S = inputList[lenIn - 1];
        for (j = 0; j < lenIn; j++) {
          E = inputList[j];
          if (isInside(clip[i2], clip[i2 + 1], E)) {
            if (!isInside(clip[i2], clip[i2 + 1], S)) {
              cross = jxg_default.Math.Geometry.meetSegmentSegment(
                S,
                E,
                clip[i2],
                clip[i2 + 1]
              );
              cross[0][1] /= cross[0][0];
              cross[0][2] /= cross[0][0];
              cross[0][0] = 1;
              outputList.push(cross[0]);
            }
            outputList.push(E);
          } else if (isInside(clip[i2], clip[i2 + 1], S)) {
            cross = jxg_default.Math.Geometry.meetSegmentSegment(
              S,
              E,
              clip[i2],
              clip[i2 + 1]
            );
            cross[0][1] /= cross[0][0];
            cross[0][2] /= cross[0][0];
            cross[0][0] = 1;
            outputList.push(cross[0]);
          }
          S = E;
        }
      }
      return outputList;
    },
    /**
     * Generic method for the intersection of this polygon with another polygon.
     * The parent object is the clipping polygon, it expects as parameter a polygon to be clipped.
     * Both polygons have to be convex.
     * Calls the algorithm by Sutherland, Hodgman, {@link JXG.Polygon#sutherlandHodgman}.
     * <p>
     * An alternative is to use the methods from {@link JXG.Math.Clip}, where the algorithm by Greiner and Hormann
     * is used.
     *
     * @param {JXG.Polygon} polygon Polygon which will be clipped.
     *
     * @returns {Array} of (normalized homogeneous user) coordinates (i.e. [z, x, y], where z==1 in most cases,
     *   representing the vertices of the intersection polygon.
     *
     * @example
     *  // Static intersection of two polygons pol1 and pol2
     *  var pol1 = board.create('polygon', [[-2, 3], [-4, -3], [2, 0], [4, 4]], {
     *                name:'pol1', withLabel: true,
     *                fillColor: 'yellow'
     *             });
     *  var pol2 = board.create('polygon', [[-2, -3], [-4, 1], [0, 4], [5, 1]], {
     *                name:'pol2', withLabel: true
     *             });
     *
     *  // Static version:
     *  // the intersection polygon does not adapt to changes of pol1 or pol2.
     *  var pol3 = board.create('polygon', pol1.intersect(pol2), {fillColor: 'blue'});
     * </pre><div class="jxgbox" id="JXGd1fe5ea9-309f-494a-af07-ee3d033acb7c" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *   (function() {
     *       var board = JXG.JSXGraph.initBoard('JXGd1fe5ea9-309f-494a-af07-ee3d033acb7c', {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *       // Intersect two polygons pol1 and pol2
     *       var pol1 = board.create('polygon', [[-2, 3], [-4, -3], [2, 0], [4, 4]], {
     *                name:'pol1', withLabel: true,
     *                fillColor: 'yellow'
     *             });
     *       var pol2 = board.create('polygon', [[-2, -3], [-4, 1], [0, 4], [5, 1]], {
     *                name:'pol2', withLabel: true
     *             });
     *
     *       // Static version: the intersection polygon does not adapt to changes of pol1 or pol2.
     *       var pol3 = board.create('polygon', pol1.intersect(pol2), {fillColor: 'blue'});
     *   })();
     * <\/script><pre>
     *
     * @example
     *  // Dynamic intersection of two polygons pol1 and pol2
     *  var pol1 = board.create('polygon', [[-2, 3], [-4, -3], [2, 0], [4, 4]], {
     *                name:'pol1', withLabel: true,
     *                fillColor: 'yellow'
     *             });
     *  var pol2 = board.create('polygon', [[-2, -3], [-4, 1], [0, 4], [5, 1]], {
     *                name:'pol2', withLabel: true
     *             });
     *
     *  // Dynamic version:
     *  // the intersection polygon does adapt to changes of pol1 or pol2.
     *  // For this a curve element is used.
     *  var curve = board.create('curve', [[],[]], {fillColor: 'blue', fillOpacity: 0.4});
     *  curve.updateDataArray = function() {
     *      var mat = JXG.Math.transpose(pol1.intersect(pol2));
     *
     *      if (mat.length == 3) {
     *          this.dataX = mat[1];
     *          this.dataY = mat[2];
     *      } else {
     *          this.dataX = [];
     *          this.dataY = [];
     *      }
     *  };
     *  board.update();
     * </pre><div class="jxgbox" id="JXGf870d516-ca1a-4140-8fe3-5d64fb42e5f2" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *   (function() {
     *       var board = JXG.JSXGraph.initBoard('JXGf870d516-ca1a-4140-8fe3-5d64fb42e5f2', {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *       // Intersect two polygons pol1 and pol2
     *       var pol1 = board.create('polygon', [[-2, 3], [-4, -3], [2, 0], [4, 4]], {
     *                name:'pol1', withLabel: true,
     *                fillColor: 'yellow'
     *             });
     *       var pol2 = board.create('polygon', [[-2, -3], [-4, 1], [0, 4], [5, 1]], {
     *                name:'pol2', withLabel: true
     *             });
     *
     *  // Dynamic version:
     *  // the intersection polygon does  adapt to changes of pol1 or pol2.
     *  // For this a curve element is used.
     *    var curve = board.create('curve', [[],[]], {fillColor: 'blue', fillOpacity: 0.4});
     *    curve.updateDataArray = function() {
     *        var mat = JXG.Math.transpose(pol1.intersect(pol2));
     *
     *        if (mat.length == 3) {
     *            this.dataX = mat[1];
     *            this.dataY = mat[2];
     *        } else {
     *            this.dataX = [];
     *            this.dataY = [];
     *        }
     *    };
     *    board.update();
     *   })();
     * <\/script><pre>
     *
     */
    intersect: function(polygon) {
      return this.sutherlandHodgman(polygon);
    }
  }
);
jxg_default.createPolygon = function(board, parents, attributes) {
  var el, i2, le, obj, points = [], attr, attr_points, is_transform = false;
  attr = type_default.copyAttributes(attributes, board.options, "polygon");
  obj = board.select(parents[0]);
  if (obj === null) {
    obj = parents[0];
  }
  if (type_default.isObject(obj) && obj.type === constants_default.OBJECT_TYPE_POLYGON && type_default.isTransformationOrArray(parents[1])) {
    is_transform = true;
    le = obj.vertices.length - 1;
    attr_points = type_default.copyAttributes(attributes, board.options, "polygon", "vertices");
    for (i2 = 0; i2 < le; i2++) {
      if (attr_points.withlabel) {
        attr_points.name = obj.vertices[i2].name === "" ? "" : obj.vertices[i2].name + "'";
      }
      points.push(board.create("point", [obj.vertices[i2], parents[1]], attr_points));
    }
  } else {
    points = type_default.providePoints(board, parents, attributes, "polygon", ["vertices"]);
    if (points === false) {
      throw new Error(
        "JSXGraph: Can't create polygon / polygonalchain with parent types other than 'point' and 'coordinate arrays' or a function returning an array of coordinates. Alternatively, a polygon and a transformation can be supplied"
      );
    }
  }
  attr = type_default.copyAttributes(attributes, board.options, "polygon");
  el = new jxg_default.Polygon(board, points, attr);
  el.isDraggable = true;
  if (is_transform) {
    el.prepareUpdate().update().updateVisibility().updateRenderer();
    le = obj.vertices.length - 1;
    for (i2 = 0; i2 < le; i2++) {
      points[i2].prepareUpdate().update().updateVisibility().updateRenderer();
    }
  }
  return el;
};
jxg_default.createRegularPolygon = function(board, parents, attributes) {
  var el, i2, n, p = [], rot, len, pointsExist, attr;
  len = parents.length;
  n = parents[len - 1];
  if (type_default.isNumber(n) && (parents.length !== 3 || n < 3)) {
    throw new Error(
      "JSXGraph: A regular polygon needs two point types and a number > 2 as input."
    );
  }
  if (type_default.isNumber(board.select(n))) {
    len--;
    pointsExist = false;
  } else {
    n = len;
    pointsExist = true;
  }
  p = type_default.providePoints(board, parents.slice(0, len), attributes, "regularpolygon", [
    "vertices"
  ]);
  if (p === false) {
    throw new Error(
      "JSXGraph: Can't create regular polygon with parent types other than 'point' and 'coordinate arrays' or a function returning an array of coordinates"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "regularpolygon", "vertices");
  for (i2 = 2; i2 < n; i2++) {
    rot = board.create("transform", [Math.PI * (2 - (n - 2) / n), p[i2 - 1]], {
      type: "rotate"
    });
    if (pointsExist) {
      p[i2].addTransform(p[i2 - 2], rot);
      p[i2].fullUpdate();
    } else {
      if (type_default.isArray(attr.ids) && attr.ids.length >= n - 2) {
        attr.id = attr.ids[i2 - 2];
      }
      p[i2] = board.create("point", [p[i2 - 2], rot], attr);
      p[i2].type = constants_default.OBJECT_TYPE_CAS;
      p[i2].isDraggable = true;
      p[i2].visProp.fixed = false;
    }
  }
  attr = type_default.copyAttributes(attributes, board.options, "regularpolygon");
  el = board.create("polygon", p, attr);
  el.elType = "regularpolygon";
  return el;
};
jxg_default.createPolygonalChain = function(board, parents, attributes) {
  var attr, el;
  attr = type_default.copyAttributes(attributes, board.options, "polygonalchain");
  el = board.create("polygon", parents, attr);
  el.elType = "polygonalchain";
  el.vertices.pop();
  board.removeObject(el.borders[el.borders.length - 1]);
  el.borders.pop();
  return el;
};
jxg_default.createParallelogram = function(board, parents, attributes) {
  var el, pp, points = [], attr, attr_pp;
  points = type_default.providePoints(board, parents, attributes, "polygon", ["vertices"]);
  if (points === false || points.length < 3) {
    throw new Error(
      "JSXGraph: Can't create parallelogram with parent types other than 'point' and 'coordinate arrays' or a function returning an array of coordinates."
    );
  }
  attr_pp = type_default.copyAttributes(attributes, board.options, "parallelogram", ["parallelpoint"]);
  pp = board.create("parallelpoint", points, attr_pp);
  attr = type_default.copyAttributes(attributes, board.options, "parallelogram");
  el = board.create("polygon", [points[0], points[1], pp, points[2]], attr);
  el.elType = "parallelogram";
  el.parallelPoint = pp;
  el.isDraggable = true;
  pp.isDraggable = true;
  pp.visProp.fixed = false;
  return el;
};
jxg_default.registerElement("polygon", jxg_default.createPolygon);
jxg_default.registerElement("regularpolygon", jxg_default.createRegularPolygon);
jxg_default.registerElement("polygonalchain", jxg_default.createPolygonalChain);
jxg_default.registerElement("parallelogram", jxg_default.createParallelogram);
var polygon_default = jxg_default.Polygon;

// node_modules/jsxgraph/src/base/curve.js
jxg_default.Curve = function(board, parents, attributes) {
  this.constructor(board, attributes, constants_default.OBJECT_TYPE_CURVE, constants_default.OBJECT_CLASS_CURVE);
  this.points = [];
  this.numberPoints = type_default.evaluate(this.visProp.numberpointshigh);
  this.bezierDegree = 1;
  this.dataX = null;
  this.dataY = null;
  this.ticks = [];
  this.qdt = null;
  if (type_default.exists(parents[0])) {
    this.varname = parents[0];
  } else {
    this.varname = "x";
  }
  this.xterm = parents[1];
  this.yterm = parents[2];
  this.generateTerm(this.varname, this.xterm, this.yterm, parents[3], parents[4]);
  this.updateCurve();
  this.id = this.board.setId(this, "G");
  this.board.renderer.drawCurve(this);
  this.board.finalizeAdding(this);
  this.createGradient();
  this.elType = "curve";
  this.createLabel();
  if (type_default.isString(this.xterm)) {
    this.notifyParents(this.xterm);
  }
  if (type_default.isString(this.yterm)) {
    this.notifyParents(this.yterm);
  }
  this.methodMap = type_default.deepCopy(this.methodMap, {
    generateTerm: "generateTerm",
    setTerm: "generateTerm",
    move: "moveTo",
    moveTo: "moveTo",
    MinX: "minX",
    MaxX: "maxX"
  });
};
jxg_default.Curve.prototype = new element_default();
jxg_default.extend(
  jxg_default.Curve.prototype,
  /** @lends JXG.Curve.prototype */
  {
    /**
     * Gives the default value of the left bound for the curve.
     * May be overwritten in {@link JXG.Curve#generateTerm}.
     * @returns {Number} Left bound for the curve.
     */
    minX: function() {
      var leftCoords;
      if (type_default.evaluate(this.visProp.curvetype) === "polar") {
        return 0;
      }
      leftCoords = new coords_default(
        constants_default.COORDS_BY_SCREEN,
        [-this.board.canvasWidth * 0.1, 0],
        this.board,
        false
      );
      return leftCoords.usrCoords[1];
    },
    /**
     * Gives the default value of the right bound for the curve.
     * May be overwritten in {@link JXG.Curve#generateTerm}.
     * @returns {Number} Right bound for the curve.
     */
    maxX: function() {
      var rightCoords;
      if (type_default.evaluate(this.visProp.curvetype) === "polar") {
        return 2 * Math.PI;
      }
      rightCoords = new coords_default(
        constants_default.COORDS_BY_SCREEN,
        [this.board.canvasWidth * 1.1, 0],
        this.board,
        false
      );
      return rightCoords.usrCoords[1];
    },
    /**
     * The parametric function which defines the x-coordinate of the curve.
     * @param {Number} t A number between {@link JXG.Curve#minX} and {@link JXG.Curve#maxX}.
     * @param {Boolean} suspendUpdate A boolean flag which is false for the
     * first call of the function during a fresh plot of the curve and true
     * for all subsequent calls of the function. This may be used to speed up the
     * plotting of the curve, if the e.g. the curve depends on some input elements.
     * @returns {Number} x-coordinate of the curve at t.
     */
    X: function(t) {
      return NaN;
    },
    /**
     * The parametric function which defines the y-coordinate of the curve.
     * @param {Number} t A number between {@link JXG.Curve#minX} and {@link JXG.Curve#maxX}.
     * @param {Boolean} suspendUpdate A boolean flag which is false for the
     * first call of the function during a fresh plot of the curve and true
     * for all subsequent calls of the function. This may be used to speed up the
     * plotting of the curve, if the e.g. the curve depends on some input elements.
     * @returns {Number} y-coordinate of the curve at t.
     */
    Y: function(t) {
      return NaN;
    },
    /**
     * Treat the curve as curve with homogeneous coordinates.
     * @param {Number} t A number between {@link JXG.Curve#minX} and {@link JXG.Curve#maxX}.
     * @returns {Number} Always 1.0
     */
    Z: function(t) {
      return 1;
    },
    /**
     * Checks whether (x,y) is near the curve.
     * @param {Number} x Coordinate in x direction, screen coordinates.
     * @param {Number} y Coordinate in y direction, screen coordinates.
     * @param {Number} start Optional start index for search on data plots.
     * @returns {Boolean} True if (x,y) is near the curve, False otherwise.
     */
    hasPoint: function(x, y, start) {
      var t, c, i2, tX, tY, checkPoint, len, invMat, isIn, res = [], points, qdt, steps = type_default.evaluate(this.visProp.numberpointslow), d = (this.maxX() - this.minX()) / steps, prec, type, dist = Infinity, ux2, uy2, ev_ct, mi, ma, suspendUpdate = true;
      if (type_default.isObject(type_default.evaluate(this.visProp.precision))) {
        type = this.board._inputDevice;
        prec = type_default.evaluate(this.visProp.precision[type]);
      } else {
        prec = this.board.options.precision.hasPoint;
      }
      checkPoint = new coords_default(constants_default.COORDS_BY_SCREEN, [x, y], this.board, false);
      x = checkPoint.usrCoords[1];
      y = checkPoint.usrCoords[2];
      if (this.bezierDegree === 1 && type_default.evaluate(this.visProp.hasinnerpoints)) {
        isIn = geometry_default.windingNumber([1, x, y], this.points, true);
        if (isIn !== 0) {
          return true;
        }
      }
      prec += type_default.evaluate(this.visProp.strokewidth) * 0.5;
      prec *= prec;
      ux2 = this.board.unitX * this.board.unitX;
      uy2 = this.board.unitY * this.board.unitY;
      mi = this.minX();
      ma = this.maxX();
      if (type_default.exists(this._visibleArea)) {
        mi = this._visibleArea[0];
        ma = this._visibleArea[1];
        d = (ma - mi) / steps;
      }
      ev_ct = type_default.evaluate(this.visProp.curvetype);
      if (ev_ct === "parameter" || ev_ct === "polar") {
        if (this.transformations.length > 0) {
          this.updateTransformMatrix();
          invMat = math_default.inverse(this.transformMat);
          c = math_default.matVecMult(invMat, [1, x, y]);
          x = c[1];
          y = c[2];
        }
        for (i2 = 0, t = mi; i2 < steps; i2++) {
          tX = this.X(t, suspendUpdate);
          tY = this.Y(t, suspendUpdate);
          dist = (x - tX) * (x - tX) * ux2 + (y - tY) * (y - tY) * uy2;
          if (dist <= prec) {
            return true;
          }
          t += d;
        }
      } else if (ev_ct === "plot" || ev_ct === "functiongraph") {
        if (!type_default.exists(start) || start < 0) {
          start = 0;
        }
        if (type_default.exists(this.qdt) && type_default.evaluate(this.visProp.useqdt) && this.bezierDegree !== 3) {
          qdt = this.qdt.query(new coords_default(constants_default.COORDS_BY_USER, [x, y], this.board));
          points = qdt.points;
          len = points.length;
        } else {
          points = this.points;
          len = this.numberPoints - 1;
        }
        for (i2 = start; i2 < len; i2++) {
          if (this.bezierDegree === 3) {
            res = geometry_default.projectCoordsToBeziersegment([1, x, y], this, i2);
          } else {
            if (qdt) {
              if (points[i2].prev) {
                res = geometry_default.projectCoordsToSegment(
                  [1, x, y],
                  points[i2].prev.usrCoords,
                  points[i2].usrCoords
                );
              }
              if (points[i2].next && points[i2 + 1] !== points[i2].next) {
                res = geometry_default.projectCoordsToSegment(
                  [1, x, y],
                  points[i2].usrCoords,
                  points[i2].next.usrCoords
                );
              }
            } else {
              res = geometry_default.projectCoordsToSegment(
                [1, x, y],
                points[i2].usrCoords,
                points[i2 + 1].usrCoords
              );
            }
          }
          if (res[1] >= 0 && res[1] <= 1 && (x - res[0][1]) * (x - res[0][1]) * ux2 + (y - res[0][2]) * (y - res[0][2]) * uy2 <= prec) {
            return true;
          }
        }
        return false;
      }
      return dist < prec;
    },
    /**
     * Allocate points in the Coords array this.points
     */
    allocatePoints: function() {
      var i2, len;
      len = this.numberPoints;
      if (this.points.length < this.numberPoints) {
        for (i2 = this.points.length; i2 < len; i2++) {
          this.points[i2] = new coords_default(
            constants_default.COORDS_BY_USER,
            [0, 0],
            this.board,
            false
          );
        }
      }
    },
    /**
     * Computes for equidistant points on the x-axis the values of the function
     * @returns {JXG.Curve} Reference to the curve object.
     * @see JXG.Curve#updateCurve
     */
    update: function() {
      if (this.needsUpdate) {
        if (type_default.evaluate(this.visProp.trace)) {
          this.cloneToBackground(true);
        }
        this.updateCurve();
      }
      return this;
    },
    /**
     * Updates the visual contents of the curve.
     * @returns {JXG.Curve} Reference to the curve object.
     */
    updateRenderer: function() {
      if (!this.needsUpdate) {
        return this;
      }
      if (this.visPropCalc.visible) {
        this.isReal = plot_default.checkReal(this.points);
        if (
          //wasReal &&
          !this.isReal
        ) {
          this.updateVisibility(false);
        }
      }
      if (this.visPropCalc.visible) {
        this.board.renderer.updateCurve(this);
      }
      if (this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal) {
        this.label.update();
        this.board.renderer.updateText(this.label);
      }
      this.setDisplayRendNode();
      this.needsUpdate = false;
      return this;
    },
    /**
     * For dynamic dataplots updateCurve can be used to compute new entries
     * for the arrays {@link JXG.Curve#dataX} and {@link JXG.Curve#dataY}. It
     * is used in {@link JXG.Curve#updateCurve}. Default is an empty method, can
     * be overwritten by the user.
     *
     *
     * @example
     * // This example overwrites the updateDataArray method.
     * // There, new values for the arrays JXG.Curve.dataX and JXG.Curve.dataY
     * // are computed from the value of the slider N
     *
     * var N = board.create('slider', [[0,1.5],[3,1.5],[1,3,40]], {name:'n',snapWidth:1});
     * var circ = board.create('circle',[[4,-1.5],1],{strokeWidth:1, strokecolor:'black', strokeWidth:2,
     * 		fillColor:'#0055ff13'});
     *
     * var c = board.create('curve', [[0],[0]],{strokecolor:'red', strokeWidth:2});
     * c.updateDataArray = function() {
     *         var r = 1, n = Math.floor(N.Value()),
     *             x = [0], y = [0],
     *             phi = Math.PI/n,
     *             h = r*Math.cos(phi),
     *             s = r*Math.sin(phi),
     *             i, j,
     *             px = 0, py = 0, sgn = 1,
     *             d = 16,
     *             dt = phi/d,
     *             pt;
     *
     *         for (i = 0; i < n; i++) {
     *             for (j = -d; j <= d; j++) {
     *                 pt = dt*j;
     *                 x.push(px + r*Math.sin(pt));
     *                 y.push(sgn*r*Math.cos(pt) - (sgn-1)*h*0.5);
     *             }
     *             px += s;
     *             sgn *= (-1);
     *         }
     *         x.push((n - 1)*s);
     *         y.push(h + (sgn - 1)*h*0.5);
     *         this.dataX = x;
     *         this.dataY = y;
     *     }
     *
     * var c2 = board.create('curve', [[0],[0]],{strokecolor:'red', strokeWidth:1});
     * c2.updateDataArray = function() {
     *         var r = 1, n = Math.floor(N.Value()),
     *             px = circ.midpoint.X(), py = circ.midpoint.Y(),
     *             x = [px], y = [py],
     *             phi = Math.PI/n,
     *             s = r*Math.sin(phi),
     *             i, j,
     *             d = 16,
     *             dt = phi/d,
     *             pt = Math.PI*0.5+phi;
     *
     *         for (i = 0; i < n; i++) {
     *             for (j= -d; j <= d; j++) {
     *                 x.push(px + r*Math.cos(pt));
     *                 y.push(py + r*Math.sin(pt));
     *                 pt -= dt;
     *             }
     *             x.push(px);
     *             y.push(py);
     *             pt += dt;
     *         }
     *         this.dataX = x;
     *         this.dataY = y;
     *     }
     *     board.update();
     *
     * </pre><div id="JXG20bc7802-e69e-11e5-b1bf-901b0e1b8723" class="jxgbox" style="width: 600px; height: 400px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG20bc7802-e69e-11e5-b1bf-901b0e1b8723',
     *             {boundingbox: [-1.5,2,8,-3], keepaspectratio: true, axis: true, showcopyright: false, shownavigation: false});
     *             var N = board.create('slider', [[0,1.5],[3,1.5],[1,3,40]], {name:'n',snapWidth:1});
     *             var circ = board.create('circle',[[4,-1.5],1],{strokeWidth:1, strokecolor:'black',
     *             strokeWidth:2, fillColor:'#0055ff13'});
     *
     *             var c = board.create('curve', [[0],[0]],{strokecolor:'red', strokeWidth:2});
     *             c.updateDataArray = function() {
     *                     var r = 1, n = Math.floor(N.Value()),
     *                         x = [0], y = [0],
     *                         phi = Math.PI/n,
     *                         h = r*Math.cos(phi),
     *                         s = r*Math.sin(phi),
     *                         i, j,
     *                         px = 0, py = 0, sgn = 1,
     *                         d = 16,
     *                         dt = phi/d,
     *                         pt;
     *
     *                     for (i=0;i<n;i++) {
     *                         for (j=-d;j<=d;j++) {
     *                             pt = dt*j;
     *                             x.push(px+r*Math.sin(pt));
     *                             y.push(sgn*r*Math.cos(pt)-(sgn-1)*h*0.5);
     *                         }
     *                         px += s;
     *                         sgn *= (-1);
     *                     }
     *                     x.push((n-1)*s);
     *                     y.push(h+(sgn-1)*h*0.5);
     *                     this.dataX = x;
     *                     this.dataY = y;
     *                 }
     *
     *             var c2 = board.create('curve', [[0],[0]],{strokecolor:'red', strokeWidth:1});
     *             c2.updateDataArray = function() {
     *                     var r = 1, n = Math.floor(N.Value()),
     *                         px = circ.midpoint.X(), py = circ.midpoint.Y(),
     *                         x = [px], y = [py],
     *                         phi = Math.PI/n,
     *                         s = r*Math.sin(phi),
     *                         i, j,
     *                         d = 16,
     *                         dt = phi/d,
     *                         pt = Math.PI*0.5+phi;
     *
     *                     for (i=0;i<n;i++) {
     *                         for (j=-d;j<=d;j++) {
     *                             x.push(px+r*Math.cos(pt));
     *                             y.push(py+r*Math.sin(pt));
     *                             pt -= dt;
     *                         }
     *                         x.push(px);
     *                         y.push(py);
     *                         pt += dt;
     *                     }
     *                     this.dataX = x;
     *                     this.dataY = y;
     *                 }
     *                 board.update();
     *
     *     })();
     *
     * <\/script><pre>
     *
     * @example
     * // This is an example which overwrites updateDataArray and produces
     * // a Bezier curve of degree three.
     * var A = board.create('point', [-3,3]);
     * var B = board.create('point', [3,-2]);
     * var line = board.create('segment', [A,B]);
     *
     * var height = 0.5; // height of the curly brace
     *
     * // Curly brace
     * var crl = board.create('curve', [[0],[0]], {strokeWidth:1, strokeColor:'black'});
     * crl.bezierDegree = 3;
     * crl.updateDataArray = function() {
     *     var d = [B.X()-A.X(), B.Y()-A.Y()],
     *         dl = Math.sqrt(d[0]*d[0]+d[1]*d[1]),
     *         mid = [(A.X()+B.X())*0.5, (A.Y()+B.Y())*0.5];
     *
     *     d[0] *= height/dl;
     *     d[1] *= height/dl;
     *
     *     this.dataX = [ A.X(), A.X()-d[1], mid[0], mid[0]-d[1], mid[0], B.X()-d[1], B.X() ];
     *     this.dataY = [ A.Y(), A.Y()+d[0], mid[1], mid[1]+d[0], mid[1], B.Y()+d[0], B.Y() ];
     * };
     *
     * // Text
     * var txt = board.create('text', [
     *                     function() {
     *                         var d = [B.X()-A.X(), B.Y()-A.Y()],
     *                             dl = Math.sqrt(d[0]*d[0]+d[1]*d[1]),
     *                             mid = (A.X()+B.X())*0.5;
     *
     *                         d[1] *= height/dl;
     *                         return mid-d[1]+0.1;
     *                     },
     *                     function() {
     *                         var d = [B.X()-A.X(), B.Y()-A.Y()],
     *                             dl = Math.sqrt(d[0]*d[0]+d[1]*d[1]),
     *                             mid = (A.Y()+B.Y())*0.5;
     *
     *                         d[0] *= height/dl;
     *                         return mid+d[0]+0.1;
     *                     },
     *                     function() { return "length=" + JXG.toFixed(B.Dist(A), 2); }
     *                 ]);
     *
     *
     * board.update(); // This update is necessary to call updateDataArray the first time.
     *
     * </pre><div id="JXGa61a4d66-e69f-11e5-b1bf-901b0e1b8723"  class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *      var board = JXG.JSXGraph.initBoard('JXGa61a4d66-e69f-11e5-b1bf-901b0e1b8723',
     *             {boundingbox: [-4, 4, 4,-4], axis: true, showcopyright: false, shownavigation: false});
     *     var A = board.create('point', [-3,3]);
     *     var B = board.create('point', [3,-2]);
     *     var line = board.create('segment', [A,B]);
     *
     *     var height = 0.5; // height of the curly brace
     *
     *     // Curly brace
     *     var crl = board.create('curve', [[0],[0]], {strokeWidth:1, strokeColor:'black'});
     *     crl.bezierDegree = 3;
     *     crl.updateDataArray = function() {
     *         var d = [B.X()-A.X(), B.Y()-A.Y()],
     *             dl = Math.sqrt(d[0]*d[0]+d[1]*d[1]),
     *             mid = [(A.X()+B.X())*0.5, (A.Y()+B.Y())*0.5];
     *
     *         d[0] *= height/dl;
     *         d[1] *= height/dl;
     *
     *         this.dataX = [ A.X(), A.X()-d[1], mid[0], mid[0]-d[1], mid[0], B.X()-d[1], B.X() ];
     *         this.dataY = [ A.Y(), A.Y()+d[0], mid[1], mid[1]+d[0], mid[1], B.Y()+d[0], B.Y() ];
     *     };
     *
     *     // Text
     *     var txt = board.create('text', [
     *                         function() {
     *                             var d = [B.X()-A.X(), B.Y()-A.Y()],
     *                                 dl = Math.sqrt(d[0]*d[0]+d[1]*d[1]),
     *                                 mid = (A.X()+B.X())*0.5;
     *
     *                             d[1] *= height/dl;
     *                             return mid-d[1]+0.1;
     *                         },
     *                         function() {
     *                             var d = [B.X()-A.X(), B.Y()-A.Y()],
     *                                 dl = Math.sqrt(d[0]*d[0]+d[1]*d[1]),
     *                                 mid = (A.Y()+B.Y())*0.5;
     *
     *                             d[0] *= height/dl;
     *                             return mid+d[0]+0.1;
     *                         },
     *                         function() { return "length="+JXG.toFixed(B.Dist(A), 2); }
     *                     ]);
     *
     *
     *     board.update(); // This update is necessary to call updateDataArray the first time.
     *
     *     })();
     *
     * <\/script><pre>
     *
     *
     */
    updateDataArray: function() {
    },
    /**
     * Computes the curve path
     * @see JXG.Curve#update
     * @returns {JXG.Curve} Reference to the curve object.
     */
    updateCurve: function() {
      var i2, len, mi, ma, x, y, version2 = this.visProp.plotversion, suspendUpdate = false;
      this.updateTransformMatrix();
      this.updateDataArray();
      mi = this.minX();
      ma = this.maxX();
      if (type_default.exists(this.dataX)) {
        this.numberPoints = this.dataX.length;
        len = this.numberPoints;
        this.allocatePoints();
        for (i2 = 0; i2 < len; i2++) {
          x = i2;
          if (type_default.exists(this.dataY)) {
            y = i2;
            this.points[i2].setCoordinates(
              constants_default.COORDS_BY_USER,
              [this.dataX[i2], this.dataY[i2]],
              false
            );
          } else {
            y = this.X(x);
            this.points[i2].setCoordinates(
              constants_default.COORDS_BY_USER,
              [this.dataX[i2], this.Y(y, suspendUpdate)],
              false
            );
          }
          this.points[i2]._t = i2;
          suspendUpdate = true;
        }
      } else {
        if (type_default.evaluate(this.visProp.doadvancedplot)) {
          if (version2 === 1 || type_default.evaluate(this.visProp.doadvancedplotold)) {
            plot_default.updateParametricCurveOld(this, mi, ma);
          } else if (version2 === 2) {
            plot_default.updateParametricCurve_v2(this, mi, ma);
          } else if (version2 === 3) {
            plot_default.updateParametricCurve_v3(this, mi, ma);
          } else if (version2 === 4) {
            plot_default.updateParametricCurve_v4(this, mi, ma);
          } else {
            plot_default.updateParametricCurve_v2(this, mi, ma);
          }
        } else {
          if (this.board.updateQuality === this.board.BOARD_QUALITY_HIGH) {
            this.numberPoints = type_default.evaluate(this.visProp.numberpointshigh);
          } else {
            this.numberPoints = type_default.evaluate(this.visProp.numberpointslow);
          }
          this.allocatePoints();
          plot_default.updateParametricCurveNaive(this, mi, ma, this.numberPoints);
        }
        len = this.numberPoints;
        if (type_default.evaluate(this.visProp.useqdt) && this.board.updateQuality === this.board.BOARD_QUALITY_HIGH) {
          this.qdt = new qdt_default(this.board.getBoundingBox());
          for (i2 = 0; i2 < this.points.length; i2++) {
            this.qdt.insert(this.points[i2]);
            if (i2 > 0) {
              this.points[i2].prev = this.points[i2 - 1];
            }
            if (i2 < len - 1) {
              this.points[i2].next = this.points[i2 + 1];
            }
          }
        }
      }
      if (type_default.evaluate(this.visProp.curvetype) !== "plot" && type_default.evaluate(this.visProp.rdpsmoothing)) {
        this.points = numerics_default.RamerDouglasPeucker(this.points, 0.2);
        this.numberPoints = this.points.length;
      }
      len = this.numberPoints;
      for (i2 = 0; i2 < len; i2++) {
        this.updateTransform(this.points[i2]);
      }
      return this;
    },
    updateTransformMatrix: function() {
      var t, i2, len = this.transformations.length;
      this.transformMat = [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]
      ];
      for (i2 = 0; i2 < len; i2++) {
        t = this.transformations[i2];
        t.update();
        this.transformMat = math_default.matMatMult(t.matrix, this.transformMat);
      }
      return this;
    },
    /**
     * Applies the transformations of the curve to the given point <tt>p</tt>.
     * Before using it, {@link JXG.Curve#updateTransformMatrix} has to be called.
     * @param {JXG.Point} p
     * @returns {JXG.Point} The given point.
     */
    updateTransform: function(p) {
      var c, len = this.transformations.length;
      if (len > 0) {
        c = math_default.matVecMult(this.transformMat, p.usrCoords);
        p.setCoordinates(constants_default.COORDS_BY_USER, c, false, true);
      }
      return p;
    },
    /**
     * Add transformations to this curve.
     * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation} or an array of {@link JXG.Transformation}s.
     * @returns {JXG.Curve} Reference to the curve object.
     */
    addTransform: function(transform) {
      var i2, list2 = type_default.isArray(transform) ? transform : [transform], len = list2.length;
      for (i2 = 0; i2 < len; i2++) {
        this.transformations.push(list2[i2]);
      }
      return this;
    },
    /**
     * Generate the method curve.X() in case curve.dataX is an array
     * and generate the method curve.Y() in case curve.dataY is an array.
     * @private
     * @param {String} which Either 'X' or 'Y'
     * @returns {function}
     **/
    interpolationFunctionFromArray: function(which) {
      var data = "data" + which, that2 = this;
      return function(t, suspendedUpdate) {
        var i2, j, t0, t1, arr = that2[data], len = arr.length, last, f = [];
        if (isNaN(t)) {
          return NaN;
        }
        if (t < 0) {
          if (type_default.isFunction(arr[0])) {
            return arr[0]();
          }
          return arr[0];
        }
        if (that2.bezierDegree === 3) {
          last = (len - 1) / 3;
          if (t >= last) {
            if (type_default.isFunction(arr[arr.length - 1])) {
              return arr[arr.length - 1]();
            }
            return arr[arr.length - 1];
          }
          i2 = Math.floor(t) * 3;
          t0 = t % 1;
          t1 = 1 - t0;
          for (j = 0; j < 4; j++) {
            if (type_default.isFunction(arr[i2 + j])) {
              f[j] = arr[i2 + j]();
            } else {
              f[j] = arr[i2 + j];
            }
          }
          return t1 * t1 * (t1 * f[0] + 3 * t0 * f[1]) + (3 * t1 * f[2] + t0 * f[3]) * t0 * t0;
        }
        if (t > len - 2) {
          i2 = len - 2;
        } else {
          i2 = parseInt(Math.floor(t), 10);
        }
        if (i2 === t) {
          if (type_default.isFunction(arr[i2])) {
            return arr[i2]();
          }
          return arr[i2];
        }
        for (j = 0; j < 2; j++) {
          if (type_default.isFunction(arr[i2 + j])) {
            f[j] = arr[i2 + j]();
          } else {
            f[j] = arr[i2 + j];
          }
        }
        return f[0] + (f[1] - f[0]) * (t - i2);
      };
    },
    /**
     * Converts the JavaScript/JessieCode/GEONExT syntax of the defining function term into JavaScript.
     * New methods X() and Y() for the Curve object are generated, further
     * new methods for minX() and maxX().
     * If mi or ma are not supplied, default functions are set.
     *
     * @param {String} varname Name of the parameter in xterm and yterm, e.g. 'x' or 't'
     * @param {String|Number|Function|Array} xterm Term for the x coordinate. Can also be an array consisting of discrete values.
     * @param {String|Number|Function|Array} yterm Term for the y coordinate. Can also be an array consisting of discrete values.
     * @param {String|Number|Function} [mi] Lower bound on the parameter
     * @param {String|Number|Function} [ma] Upper bound on the parameter
     * @see JXG.GeonextParser.geonext2JS
     */
    generateTerm: function(varname, xterm, yterm, mi, ma) {
      var fx, fy;
      if (type_default.isArray(xterm)) {
        this.dataX = xterm;
        this.numberPoints = this.dataX.length;
        this.X = this.interpolationFunctionFromArray.apply(this, ["X"]);
        this.visProp.curvetype = "plot";
        this.isDraggable = true;
      } else {
        this.X = type_default.createFunction(xterm, this.board, varname);
        if (type_default.isString(xterm)) {
          this.visProp.curvetype = "functiongraph";
        } else if (type_default.isFunction(xterm) || type_default.isNumber(xterm)) {
          this.visProp.curvetype = "parameter";
        }
        this.isDraggable = true;
      }
      if (type_default.isArray(yterm)) {
        this.dataY = yterm;
        this.Y = this.interpolationFunctionFromArray.apply(this, ["Y"]);
      } else {
        this.Y = type_default.createFunction(yterm, this.board, varname);
      }
      if (type_default.isFunction(xterm) && type_default.isArray(yterm)) {
        fx = type_default.createFunction(yterm[0], this.board, "");
        fy = type_default.createFunction(yterm[1], this.board, "");
        this.X = function(phi) {
          return xterm(phi) * Math.cos(phi) + fx();
        };
        this.X.deps = fx.deps;
        this.Y = function(phi) {
          return xterm(phi) * Math.sin(phi) + fy();
        };
        this.Y.deps = fy.deps;
        this.visProp.curvetype = "polar";
      }
      if (type_default.exists(mi)) {
        this.minX = type_default.createFunction(mi, this.board, "");
      } else {
        delete this.minX;
      }
      if (type_default.exists(ma)) {
        this.maxX = type_default.createFunction(ma, this.board, "");
      } else {
        delete this.maxX;
      }
      this.addParentsFromJCFunctions([this.X, this.Y, this.minX, this.maxX]);
    },
    /**
     * Finds dependencies in a given term and notifies the parents by adding the
     * dependent object to the found objects child elements.
     * @param {String} contentStr String containing dependencies for the given object.
     */
    notifyParents: function(contentStr) {
      var fstr, dep, isJessieCode = false, obj;
      obj = { xterm: 1, yterm: 1 };
      for (fstr in obj) {
        if (obj.hasOwnProperty(fstr) && this.hasOwnProperty(fstr) && this[fstr].origin) {
          isJessieCode = true;
          for (dep in this[fstr].origin.deps) {
            if (this[fstr].origin.deps.hasOwnProperty(dep)) {
              this[fstr].origin.deps[dep].addChild(this);
            }
          }
        }
      }
      if (!isJessieCode) {
        geonext_default.findDependencies(this, contentStr, this.board);
      }
    },
    // documented in geometry element
    getLabelAnchor: function() {
      var c, x, y, ax = 0.05 * this.board.canvasWidth, ay = 0.05 * this.board.canvasHeight, bx = 0.95 * this.board.canvasWidth, by = 0.95 * this.board.canvasHeight;
      switch (type_default.evaluate(this.visProp.label.position)) {
        case "ulft":
          x = ax;
          y = ay;
          break;
        case "llft":
          x = ax;
          y = by;
          break;
        case "rt":
          x = bx;
          y = 0.5 * by;
          break;
        case "lrt":
          x = bx;
          y = by;
          break;
        case "urt":
          x = bx;
          y = ay;
          break;
        case "top":
          x = 0.5 * bx;
          y = ay;
          break;
        case "bot":
          x = 0.5 * bx;
          y = by;
          break;
        default:
          x = ax;
          y = 0.5 * by;
      }
      c = new coords_default(constants_default.COORDS_BY_SCREEN, [x, y], this.board, false);
      return geometry_default.projectCoordsToCurve(
        c.usrCoords[1],
        c.usrCoords[2],
        0,
        this,
        this.board
      )[0];
    },
    // documented in geometry element
    cloneToBackground: function() {
      var er, copy = {
        id: this.id + "T" + this.numTraces,
        elementClass: constants_default.OBJECT_CLASS_CURVE,
        points: this.points.slice(0),
        bezierDegree: this.bezierDegree,
        numberPoints: this.numberPoints,
        board: this.board,
        visProp: type_default.deepCopy(this.visProp, this.visProp.traceattributes, true)
      };
      copy.visProp.layer = this.board.options.layer.trace;
      copy.visProp.curvetype = this.visProp.curvetype;
      this.numTraces++;
      type_default.clearVisPropOld(copy);
      copy.visPropCalc = {
        visible: type_default.evaluate(copy.visProp.visible)
      };
      er = this.board.renderer.enhancedRendering;
      this.board.renderer.enhancedRendering = true;
      this.board.renderer.drawCurve(copy);
      this.board.renderer.enhancedRendering = er;
      this.traces[copy.id] = copy.rendNode;
      return this;
    },
    // Already documented in GeometryElement
    bounds: function() {
      var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, l = this.points.length, i2, bezier, up;
      if (this.bezierDegree === 3) {
        for (i2 = 0; i2 < l; i2++) {
          this.points[i2].X = type_default.bind(function() {
            return this.usrCoords[1];
          }, this.points[i2]);
          this.points[i2].Y = type_default.bind(function() {
            return this.usrCoords[2];
          }, this.points[i2]);
        }
        bezier = numerics_default.bezier(this.points);
        up = bezier[3]();
        minX = numerics_default.fminbr(
          function(t) {
            return bezier[0](t);
          },
          [0, up]
        );
        maxX = numerics_default.fminbr(
          function(t) {
            return -bezier[0](t);
          },
          [0, up]
        );
        minY = numerics_default.fminbr(
          function(t) {
            return bezier[1](t);
          },
          [0, up]
        );
        maxY = numerics_default.fminbr(
          function(t) {
            return -bezier[1](t);
          },
          [0, up]
        );
        minX = bezier[0](minX);
        maxX = bezier[0](maxX);
        minY = bezier[1](minY);
        maxY = bezier[1](maxY);
        return [minX, maxY, maxX, minY];
      }
      for (i2 = 0; i2 < l; i2++) {
        if (minX > this.points[i2].usrCoords[1]) {
          minX = this.points[i2].usrCoords[1];
        }
        if (maxX < this.points[i2].usrCoords[1]) {
          maxX = this.points[i2].usrCoords[1];
        }
        if (minY > this.points[i2].usrCoords[2]) {
          minY = this.points[i2].usrCoords[2];
        }
        if (maxY < this.points[i2].usrCoords[2]) {
          maxY = this.points[i2].usrCoords[2];
        }
      }
      return [minX, maxY, maxX, minY];
    },
    // documented in element.js
    getParents: function() {
      var p = [this.xterm, this.yterm, this.minX(), this.maxX()];
      if (this.parents.length !== 0) {
        p = this.parents;
      }
      return p;
    },
    /**
     * Shift the curve by the vector 'where'.
     *
     * @param {Array} where Array containing the x and y coordinate of the target location.
     * @returns {JXG.Curve} Reference to itself.
     */
    moveTo: function(where) {
      var delta = [], p;
      if (this.points.length > 0 && !type_default.evaluate(this.visProp.fixed)) {
        p = this.points[0];
        if (where.length === 3) {
          delta = [
            where[0] - p.usrCoords[0],
            where[1] - p.usrCoords[1],
            where[2] - p.usrCoords[2]
          ];
        } else {
          delta = [where[0] - p.usrCoords[1], where[1] - p.usrCoords[2]];
        }
        this.setPosition(constants_default.COORDS_BY_USER, delta);
      }
      return this;
    },
    /**
     * If the curve is the result of a transformation applied
     * to a continuous curve, the glider projection has to be done
     * on the original curve. Otherwise there will be problems
     * when changing between high and low precision plotting,
     * since there number of points changes.
     *
     * @private
     * @returns {Array} [Boolean, curve]: Array contining 'true' if curve is result of a transformation,
     *   and the source curve of the transformation.
     */
    getTransformationSource: function() {
      var isTransformed, curve_org;
      if (type_default.exists(this._transformationSource)) {
        curve_org = this._transformationSource;
        if (curve_org.elementClass === constants_default.OBJECT_CLASS_CURVE) {
          isTransformed = true;
        }
      }
      return [isTransformed, curve_org];
    }
    // See JXG.Math.Geometry.pnpoly
    // pnpoly: function (x_in, y_in, coord_type) {
    //     var i,
    //         j,
    //         len,
    //         x,
    //         y,
    //         crds,
    //         v = this.points,
    //         isIn = false;
    //     if (coord_type === Const.COORDS_BY_USER) {
    //         crds = new Coords(Const.COORDS_BY_USER, [x_in, y_in], this.board);
    //         x = crds.scrCoords[1];
    //         y = crds.scrCoords[2];
    //     } else {
    //         x = x_in;
    //         y = y_in;
    //     }
    //     len = this.points.length;
    //     for (i = 0, j = len - 2; i < len - 1; j = i++) {
    //         if (
    //             v[i].scrCoords[2] > y !== v[j].scrCoords[2] > y &&
    //             x <
    //                 ((v[j].scrCoords[1] - v[i].scrCoords[1]) * (y - v[i].scrCoords[2])) /
    //                     (v[j].scrCoords[2] - v[i].scrCoords[2]) +
    //                     v[i].scrCoords[1]
    //         ) {
    //             isIn = !isIn;
    //         }
    //     }
    //     return isIn;
    // }
  }
);
jxg_default.createCurve = function(board, parents, attributes) {
  var obj, cu, attr = type_default.copyAttributes(attributes, board.options, "curve");
  obj = board.select(parents[0], true);
  if (type_default.isTransformationOrArray(parents[1]) && type_default.isObject(obj) && (obj.type === constants_default.OBJECT_TYPE_CURVE || obj.type === constants_default.OBJECT_TYPE_ANGLE || obj.type === constants_default.OBJECT_TYPE_ARC || obj.type === constants_default.OBJECT_TYPE_CONIC || obj.type === constants_default.OBJECT_TYPE_SECTOR)) {
    if (obj.type === constants_default.OBJECT_TYPE_SECTOR) {
      attr = type_default.copyAttributes(attributes, board.options, "sector");
    } else if (obj.type === constants_default.OBJECT_TYPE_ARC) {
      attr = type_default.copyAttributes(attributes, board.options, "arc");
    } else if (obj.type === constants_default.OBJECT_TYPE_ANGLE) {
      if (!type_default.exists(attributes.withLabel)) {
        attributes.withLabel = false;
      }
      attr = type_default.copyAttributes(attributes, board.options, "angle");
    } else {
      attr = type_default.copyAttributes(attributes, board.options, "curve");
    }
    attr = type_default.copyAttributes(attr, board.options, "curve");
    cu = new jxg_default.Curve(board, ["x", [], []], attr);
    cu.updateDataArray = function() {
      var i2, le = obj.numberPoints;
      this.bezierDegree = obj.bezierDegree;
      this.dataX = [];
      this.dataY = [];
      for (i2 = 0; i2 < le; i2++) {
        this.dataX.push(obj.points[i2].usrCoords[1]);
        this.dataY.push(obj.points[i2].usrCoords[2]);
      }
      return this;
    };
    cu.addTransform(parents[1]);
    obj.addChild(cu);
    cu.setParents([obj]);
    cu._transformationSource = obj;
    return cu;
  }
  attr = type_default.copyAttributes(attributes, board.options, "curve");
  return new jxg_default.Curve(board, ["x"].concat(parents), attr);
};
jxg_default.registerElement("curve", jxg_default.createCurve);
jxg_default.createFunctiongraph = function(board, parents, attributes) {
  var attr, par = ["x", "x"].concat(parents);
  attr = type_default.copyAttributes(attributes, board.options, "functiongraph");
  attr = type_default.copyAttributes(attr, board.options, "curve");
  attr.curvetype = "functiongraph";
  return new jxg_default.Curve(board, par, attr);
};
jxg_default.registerElement("functiongraph", jxg_default.createFunctiongraph);
jxg_default.registerElement("plot", jxg_default.createFunctiongraph);
jxg_default.createSpline = function(board, parents, attributes) {
  var el, funcs, ret;
  funcs = function() {
    var D, x = [], y = [];
    return [
      function(t, suspended) {
        var i2, j, c;
        if (!suspended) {
          x = [];
          y = [];
          if (parents.length === 2 && type_default.isArray(parents[0]) && type_default.isArray(parents[1]) && parents[0].length === parents[1].length) {
            for (i2 = 0; i2 < parents[0].length; i2++) {
              if (type_default.isFunction(parents[0][i2])) {
                x.push(parents[0][i2]());
              } else {
                x.push(parents[0][i2]);
              }
              if (type_default.isFunction(parents[1][i2])) {
                y.push(parents[1][i2]());
              } else {
                y.push(parents[1][i2]);
              }
            }
          } else {
            for (i2 = 0; i2 < parents.length; i2++) {
              if (type_default.isPoint(parents[i2])) {
                x.push(parents[i2].X());
                y.push(parents[i2].Y());
              } else if (type_default.isArray(parents[i2]) && parents[i2].length === 2) {
                for (j = 0; j < parents.length; j++) {
                  if (type_default.isFunction(parents[j][0])) {
                    x.push(parents[j][0]());
                  } else {
                    x.push(parents[j][0]);
                  }
                  if (type_default.isFunction(parents[j][1])) {
                    y.push(parents[j][1]());
                  } else {
                    y.push(parents[j][1]);
                  }
                }
              } else if (type_default.isFunction(parents[i2]) && parents[i2]().length === 2) {
                c = parents[i2]();
                x.push(c[0]);
                y.push(c[1]);
              }
            }
          }
          D = numerics_default.splineDef(x, y);
        }
        return numerics_default.splineEval(t, x, y, D);
      },
      // minX()
      function() {
        return x[0];
      },
      //maxX()
      function() {
        return x[x.length - 1];
      }
    ];
  };
  attributes = type_default.copyAttributes(attributes, board.options, "curve");
  attributes.curvetype = "functiongraph";
  ret = funcs();
  el = new jxg_default.Curve(board, ["x", "x", ret[0], ret[1], ret[2]], attributes);
  el.setParents(parents);
  el.elType = "spline";
  return el;
};
jxg_default.registerElement("spline", jxg_default.createSpline);
jxg_default.createCardinalSpline = function(board, parents, attributes) {
  var el, getPointLike, points, tau, type, p, q, i2, le, splineArr, errStr = "\nPossible parent types: [points:array, tau:number|function, type:string]";
  if (!type_default.exists(parents[0]) || !type_default.isArray(parents[0])) {
    throw new Error(
      "JSXGraph: JXG.createCardinalSpline: argument 1 'points' has to be array of points or coordinate pairs" + errStr
    );
  }
  if (!type_default.exists(parents[1]) || !type_default.isNumber(parents[1]) && !type_default.isFunction(parents[1])) {
    throw new Error(
      "JSXGraph: JXG.createCardinalSpline: argument 2 'tau' has to be number between [0,1] or function'" + errStr
    );
  }
  if (!type_default.exists(parents[2]) || !type_default.isString(parents[2])) {
    throw new Error(
      "JSXGraph: JXG.createCardinalSpline: argument 3 'type' has to be string 'uniform' or 'centripetal'" + errStr
    );
  }
  attributes = type_default.copyAttributes(attributes, board.options, "curve");
  attributes = type_default.copyAttributes(attributes, board.options, "cardinalspline");
  attributes.curvetype = "parameter";
  p = parents[0];
  q = [];
  if (!attributes.isarrayofcoordinates && p.length === 2 && type_default.isArray(p[0]) && type_default.isArray(p[1]) && p[0].length === p[1].length) {
    for (i2 = 0; i2 < p[0].length; i2++) {
      q[i2] = [];
      if (type_default.isFunction(p[0][i2])) {
        q[i2].push(p[0][i2]());
      } else {
        q[i2].push(p[0][i2]);
      }
      if (type_default.isFunction(p[1][i2])) {
        q[i2].push(p[1][i2]());
      } else {
        q[i2].push(p[1][i2]);
      }
    }
  } else {
    for (i2 = 0; i2 < p.length; i2++) {
      if (type_default.isString(p[i2])) {
        q.push(board.select(p[i2]));
      } else if (type_default.isPoint(p[i2])) {
        q.push(p[i2]);
      } else if (type_default.isArray(p[i2]) && p[i2].length === 2) {
        q[i2] = [];
        if (type_default.isFunction(p[i2][0])) {
          q[i2].push(p[i2][0]());
        } else {
          q[i2].push(p[i2][0]);
        }
        if (type_default.isFunction(p[i2][1])) {
          q[i2].push(p[i2][1]());
        } else {
          q[i2].push(p[i2][1]);
        }
      } else if (type_default.isFunction(p[i2]) && p[i2]().length === 2) {
        q.push(parents[i2]());
      }
    }
  }
  if (attributes.createpoints === true) {
    points = type_default.providePoints(board, q, attributes, "cardinalspline", ["points"]);
  } else {
    points = [];
    getPointLike = function(ii) {
      return {
        X: function() {
          return q[ii][0];
        },
        Y: function() {
          return q[ii][1];
        },
        Dist: function(p2) {
          var dx = this.X() - p2.X(), dy = this.Y() - p2.Y();
          return math_default.hypot(dx, dy);
        }
      };
    };
    for (i2 = 0; i2 < q.length; i2++) {
      if (type_default.isPoint(q[i2])) {
        points.push(q[i2]);
      } else {
        points.push(getPointLike(i2));
      }
    }
  }
  tau = parents[1];
  type = parents[2];
  splineArr = ["x"].concat(numerics_default.CardinalSpline(points, tau, type));
  el = new jxg_default.Curve(board, splineArr, attributes);
  le = points.length;
  el.setParents(points);
  for (i2 = 0; i2 < le; i2++) {
    p = points[i2];
    if (type_default.isPoint(p)) {
      if (type_default.exists(p._is_new)) {
        el.addChild(p);
        delete p._is_new;
      } else {
        p.addChild(el);
      }
    }
  }
  el.elType = "cardinalspline";
  return el;
};
jxg_default.registerElement("cardinalspline", jxg_default.createCardinalSpline);
jxg_default.createMetapostSpline = function(board, parents, attributes) {
  var el, getPointLike, points, controls, p, q, i2, le, errStr = "\nPossible parent types: [points:array, controls:object";
  if (!type_default.exists(parents[0]) || !type_default.isArray(parents[0])) {
    throw new Error(
      "JSXGraph: JXG.createMetapostSpline: argument 1 'points' has to be array of points or coordinate pairs" + errStr
    );
  }
  if (!type_default.exists(parents[1]) || !type_default.isObject(parents[1])) {
    throw new Error(
      "JSXGraph: JXG.createMetapostSpline: argument 2 'controls' has to be a JavaScript object'" + errStr
    );
  }
  attributes = type_default.copyAttributes(attributes, board.options, "curve");
  attributes = type_default.copyAttributes(attributes, board.options, "metapostspline");
  attributes.curvetype = "parameter";
  p = parents[0];
  q = [];
  if (!attributes.isarrayofcoordinates && p.length === 2 && type_default.isArray(p[0]) && type_default.isArray(p[1]) && p[0].length === p[1].length) {
    for (i2 = 0; i2 < p[0].length; i2++) {
      q[i2] = [];
      if (type_default.isFunction(p[0][i2])) {
        q[i2].push(p[0][i2]());
      } else {
        q[i2].push(p[0][i2]);
      }
      if (type_default.isFunction(p[1][i2])) {
        q[i2].push(p[1][i2]());
      } else {
        q[i2].push(p[1][i2]);
      }
    }
  } else {
    for (i2 = 0; i2 < p.length; i2++) {
      if (type_default.isString(p[i2])) {
        q.push(board.select(p[i2]));
      } else if (type_default.isPoint(p[i2])) {
        q.push(p[i2]);
      } else if (type_default.isArray(p[i2]) && p[i2].length === 2) {
        q[i2] = [];
        if (type_default.isFunction(p[i2][0])) {
          q[i2].push(p[i2][0]());
        } else {
          q[i2].push(p[i2][0]);
        }
        if (type_default.isFunction(p[i2][1])) {
          q[i2].push(p[i2][1]());
        } else {
          q[i2].push(p[i2][1]);
        }
      } else if (type_default.isFunction(p[i2]) && p[i2]().length === 2) {
        q.push(parents[i2]());
      }
    }
  }
  if (attributes.createpoints === true) {
    points = type_default.providePoints(board, q, attributes, "metapostspline", ["points"]);
  } else {
    points = [];
    getPointLike = function(ii) {
      return {
        X: function() {
          return q[ii][0];
        },
        Y: function() {
          return q[ii][1];
        }
      };
    };
    for (i2 = 0; i2 < q.length; i2++) {
      if (type_default.isPoint(q[i2])) {
        points.push(q[i2]);
      } else {
        points.push(getPointLike);
      }
    }
  }
  controls = parents[1];
  el = new jxg_default.Curve(board, ["t", [], [], 0, p.length - 1], attributes);
  el.updateDataArray = function() {
    var res, i3, len = points.length, p2 = [];
    for (i3 = 0; i3 < len; i3++) {
      p2.push([points[i3].X(), points[i3].Y()]);
    }
    res = metapost_default.curve(p2, controls);
    this.dataX = res[0];
    this.dataY = res[1];
  };
  el.bezierDegree = 3;
  le = points.length;
  el.setParents(points);
  for (i2 = 0; i2 < le; i2++) {
    if (type_default.isPoint(points[i2])) {
      points[i2].addChild(el);
    }
  }
  el.elType = "metapostspline";
  return el;
};
jxg_default.registerElement("metapostspline", jxg_default.createMetapostSpline);
jxg_default.createRiemannsum = function(board, parents, attributes) {
  var n, type, f, par, c, attr;
  attr = type_default.copyAttributes(attributes, board.options, "riemannsum");
  attr.curvetype = "plot";
  f = parents[0];
  n = type_default.createFunction(parents[1], board, "");
  if (!type_default.exists(n)) {
    throw new Error(
      "JSXGraph: JXG.createRiemannsum: argument '2' n has to be number or function.\nPossible parent types: [function,n:number|function,type,start:number|function,end:number|function]"
    );
  }
  type = type_default.createFunction(parents[2], board, "");
  if (!type_default.exists(type)) {
    throw new Error(
      "JSXGraph: JXG.createRiemannsum: argument 3 'type' has to be string or function.\nPossible parent types: [function,n:number|function,type,start:number|function,end:number|function]"
    );
  }
  par = [[0], [0]].concat(parents.slice(3));
  c = board.create("curve", par, attr);
  c.sum = 0;
  c.Value = function() {
    return this.sum;
  };
  c.updateDataArray = function() {
    var u = numerics_default.riemann(f, n(), type(), this.minX(), this.maxX());
    this.dataX = u[0];
    this.dataY = u[1];
    this.sum = u[2];
  };
  c.addParentsFromJCFunctions([n, type]);
  return c;
};
jxg_default.registerElement("riemannsum", jxg_default.createRiemannsum);
jxg_default.createTracecurve = function(board, parents, attributes) {
  var c, glider, tracepoint, attr;
  if (parents.length !== 2) {
    throw new Error(
      "JSXGraph: Can't create trace curve with given parent'\nPossible parent types: [glider, point]"
    );
  }
  glider = board.select(parents[0]);
  tracepoint = board.select(parents[1]);
  if (glider.type !== constants_default.OBJECT_TYPE_GLIDER || !type_default.isPoint(tracepoint)) {
    throw new Error(
      "JSXGraph: Can't create trace curve with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [glider, point]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "tracecurve");
  attr.curvetype = "plot";
  c = board.create("curve", [[0], [0]], attr);
  c.updateDataArray = function() {
    var i2, step, t, el, pEl, x, y, from, savetrace, le = attr.numberpoints, savePos = glider.position, slideObj = glider.slideObject, mi = slideObj.minX(), ma = slideObj.maxX();
    step = (ma - mi) / le;
    this.dataX = [];
    this.dataY = [];
    if (slideObj.elementClass !== constants_default.OBJECT_CLASS_CURVE) {
      le++;
    }
    for (i2 = 0; i2 < le; i2++) {
      t = mi + i2 * step;
      x = slideObj.X(t) / slideObj.Z(t);
      y = slideObj.Y(t) / slideObj.Z(t);
      glider.setPositionDirectly(constants_default.COORDS_BY_USER, [x, y]);
      from = false;
      for (el in this.board.objects) {
        if (this.board.objects.hasOwnProperty(el)) {
          pEl = this.board.objects[el];
          if (pEl === glider) {
            from = true;
          }
          if (from && pEl.needsRegularUpdate) {
            savetrace = pEl.visProp.trace;
            pEl.visProp.trace = false;
            pEl.needsUpdate = true;
            pEl.update(true);
            pEl.visProp.trace = savetrace;
            if (pEl === tracepoint) {
              break;
            }
          }
        }
      }
      this.dataX[i2] = tracepoint.X();
      this.dataY[i2] = tracepoint.Y();
    }
    glider.position = savePos;
    from = false;
    for (el in this.board.objects) {
      if (this.board.objects.hasOwnProperty(el)) {
        pEl = this.board.objects[el];
        if (pEl === glider) {
          from = true;
        }
        if (from && pEl.needsRegularUpdate) {
          savetrace = pEl.visProp.trace;
          pEl.visProp.trace = false;
          pEl.needsUpdate = true;
          pEl.update(true);
          pEl.visProp.trace = savetrace;
          if (pEl === tracepoint) {
            break;
          }
        }
      }
    }
  };
  return c;
};
jxg_default.registerElement("tracecurve", jxg_default.createTracecurve);
jxg_default.createStepfunction = function(board, parents, attributes) {
  var c, attr;
  if (parents.length !== 2) {
    throw new Error(
      "JSXGraph: Can't create step function with given parent'\nPossible parent types: [array, array|function]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "stepfunction");
  c = board.create("curve", parents, attr);
  c.updateDataArray = function() {
    var i2, j = 0, len = this.xterm.length;
    this.dataX = [];
    this.dataY = [];
    if (len === 0) {
      return;
    }
    this.dataX[j] = this.xterm[0];
    this.dataY[j] = this.yterm[0];
    ++j;
    for (i2 = 1; i2 < len; ++i2) {
      this.dataX[j] = this.xterm[i2];
      this.dataY[j] = this.dataY[j - 1];
      ++j;
      this.dataX[j] = this.xterm[i2];
      this.dataY[j] = this.yterm[i2];
      ++j;
    }
  };
  return c;
};
jxg_default.registerElement("stepfunction", jxg_default.createStepfunction);
jxg_default.createDerivative = function(board, parents, attributes) {
  var c, curve, dx, dy, attr;
  if (parents.length !== 1 && parents[0].class !== constants_default.OBJECT_CLASS_CURVE) {
    throw new Error(
      "JSXGraph: Can't create derivative curve with given parent'\nPossible parent types: [curve]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "curve");
  curve = parents[0];
  dx = numerics_default.D(curve.X);
  dy = numerics_default.D(curve.Y);
  c = board.create(
    "curve",
    [
      function(t) {
        return curve.X(t);
      },
      function(t) {
        return dy(t) / dx(t);
      },
      curve.minX(),
      curve.maxX()
    ],
    attr
  );
  c.setParents(curve);
  return c;
};
jxg_default.registerElement("derivative", jxg_default.createDerivative);
jxg_default.createCurveIntersection = function(board, parents, attributes) {
  var c;
  if (parents.length !== 2) {
    throw new Error(
      "JSXGraph: Can't create curve intersection with given parent'\nPossible parent types: [array, array|function]"
    );
  }
  c = board.create("curve", [[], []], attributes);
  c.updateDataArray = function() {
    var a = clip_default.intersection(parents[0], parents[1], this.board);
    this.dataX = a[0];
    this.dataY = a[1];
  };
  return c;
};
jxg_default.createCurveUnion = function(board, parents, attributes) {
  var c;
  if (parents.length !== 2) {
    throw new Error(
      "JSXGraph: Can't create curve union with given parent'\nPossible parent types: [array, array|function]"
    );
  }
  c = board.create("curve", [[], []], attributes);
  c.updateDataArray = function() {
    var a = clip_default.union(parents[0], parents[1], this.board);
    this.dataX = a[0];
    this.dataY = a[1];
  };
  return c;
};
jxg_default.createCurveDifference = function(board, parents, attributes) {
  var c;
  if (parents.length !== 2) {
    throw new Error(
      "JSXGraph: Can't create curve difference with given parent'\nPossible parent types: [array, array|function]"
    );
  }
  c = board.create("curve", [[], []], attributes);
  c.updateDataArray = function() {
    var a = clip_default.difference(parents[0], parents[1], this.board);
    this.dataX = a[0];
    this.dataY = a[1];
  };
  return c;
};
jxg_default.registerElement("curvedifference", jxg_default.createCurveDifference);
jxg_default.registerElement("curveintersection", jxg_default.createCurveIntersection);
jxg_default.registerElement("curveunion", jxg_default.createCurveUnion);
jxg_default.createBoxPlot = function(board, parents, attributes) {
  var box, i2, len, attr = type_default.copyAttributes(attributes, board.options, "boxplot");
  if (parents.length !== 3) {
    throw new Error(
      "JSXGraph: Can't create box plot with given parent'\nPossible parent types: [array, number|function, number|function] containing quantiles, axis, width"
    );
  }
  if (parents[0].length < 5) {
    throw new Error(
      "JSXGraph: Can't create box plot with given parent[0]'\nparent[0] has to contain at least 5 quantiles."
    );
  }
  box = board.create("curve", [[], []], attr);
  len = parents[0].length;
  box.Q = [];
  for (i2 = 0; i2 < len; i2++) {
    box.Q[i2] = type_default.createFunction(parents[0][i2], board);
  }
  box.x = type_default.createFunction(parents[1], board);
  box.w = type_default.createFunction(parents[2], board);
  box.updateDataArray = function() {
    var v1, v2, l1, l2, r1, r2, w2, dir, x;
    w2 = type_default.evaluate(this.visProp.smallwidth);
    dir = type_default.evaluate(this.visProp.dir);
    x = this.x();
    l1 = x - this.w() * 0.5;
    l2 = x - this.w() * 0.5 * w2;
    r1 = x + this.w() * 0.5;
    r2 = x + this.w() * 0.5 * w2;
    v1 = [x, l2, r2, x, x, l1, l1, r1, r1, x, NaN, l1, r1, NaN, x, x, l2, r2, x];
    v2 = [
      this.Q[0](),
      this.Q[0](),
      this.Q[0](),
      this.Q[0](),
      this.Q[1](),
      this.Q[1](),
      this.Q[3](),
      this.Q[3](),
      this.Q[1](),
      this.Q[1](),
      NaN,
      this.Q[2](),
      this.Q[2](),
      NaN,
      this.Q[3](),
      this.Q[4](),
      this.Q[4](),
      this.Q[4](),
      this.Q[4]()
    ];
    if (dir === "vertical") {
      this.dataX = v1;
      this.dataY = v2;
    } else {
      this.dataX = v2;
      this.dataY = v1;
    }
  };
  box.addParentsFromJCFunctions([box.Q, box.x, box.w]);
  return box;
};
jxg_default.registerElement("boxplot", jxg_default.createBoxPlot);
jxg_default.createImplicitCurve = function(board, parents, attributes) {
  var c, attr;
  if (parents.length !== 1 && parents.length !== 3) {
    throw new Error(
      "JSXGraph: Can't create curve implicitCurve with given parent'\nPossible parent types: [f] or [f, dfx, dfy]\nwith functions f, dfx, dfy"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "implicitcurve");
  c = board.create("curve", [[], []], attr);
  c.f = type_default.createFunction(parents[0], board, "x, y");
  c.dfx = type_default.createFunction(parents[1], board, "x, y");
  c.dfy = type_default.createFunction(parents[2], board, "x, y");
  c.updateDataArray = function() {
    var bbox = this.board.getBoundingBox(), ip, cfg, ret = [], mgn = type_default.evaluate(this.visProp.margin);
    bbox[0] -= mgn;
    bbox[1] += mgn;
    bbox[2] += mgn;
    bbox[3] -= mgn;
    cfg = {
      resolution_out: Math.max(0.01, type_default.evaluate(this.visProp.resolution_outer)),
      resolution_in: Math.max(0.01, type_default.evaluate(this.visProp.resolution_inner)),
      max_steps: type_default.evaluate(this.visProp.max_steps),
      alpha_0: type_default.evaluate(this.visProp.alpha_0),
      tol_u0: type_default.evaluate(this.visProp.tol_u0),
      tol_newton: type_default.evaluate(this.visProp.tol_newton),
      tol_cusp: type_default.evaluate(this.visProp.tol_cusp),
      tol_progress: type_default.evaluate(this.visProp.tol_progress),
      qdt_box: type_default.evaluate(this.visProp.qdt_box),
      kappa_0: type_default.evaluate(this.visProp.kappa_0),
      delta_0: type_default.evaluate(this.visProp.delta_0),
      h_initial: type_default.evaluate(this.visProp.h_initial),
      h_critical: type_default.evaluate(this.visProp.h_critical),
      h_max: type_default.evaluate(this.visProp.h_max),
      loop_dist: type_default.evaluate(this.visProp.loop_dist),
      loop_dir: type_default.evaluate(this.visProp.loop_dir),
      loop_detection: type_default.evaluate(this.visProp.loop_detection),
      unitX: this.board.unitX,
      unitY: this.board.unitY
    };
    this.dataX = [];
    this.dataY = [];
    ip = new implicitplot_default(bbox, cfg, this.f, this.dfx, this.dfy);
    this.qdt = ip.qdt;
    ret = ip.plot();
    this.dataX = ret[0];
    this.dataY = ret[1];
  };
  c.elType = "implicitcurve";
  return c;
};
jxg_default.registerElement("implicitcurve", jxg_default.createImplicitCurve);
var curve_default = jxg_default.Curve;

// node_modules/jsxgraph/src/element/arc.js
jxg_default.createArc = function(board, parents, attributes) {
  var el, attr, points;
  points = type_default.providePoints(board, parents, attributes, "arc", [
    "center",
    "radiuspoint",
    "anglepoint"
  ]);
  if (points === false || points.length < 3) {
    throw new Error(
      "JSXGraph: Can't create Arc with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "' and '" + typeof parents[2] + "'.\nPossible parent types: [point,point,point], [arc, transformation]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "arc");
  el = board.create("curve", [[0], [0]], attr);
  el.elType = "arc";
  el.setParents(points);
  el.type = constants_default.OBJECT_TYPE_ARC;
  el.center = points[0];
  el.radiuspoint = points[1];
  el.point2 = el.radiuspoint;
  el.anglepoint = points[2];
  el.point3 = el.anglepoint;
  if (type_default.exists(el.center._is_new)) {
    el.addChild(el.center);
    delete el.center._is_new;
  } else {
    el.center.addChild(el);
  }
  if (type_default.exists(el.radiuspoint._is_new)) {
    el.addChild(el.radiuspoint);
    delete el.radiuspoint._is_new;
  } else {
    el.radiuspoint.addChild(el);
  }
  if (type_default.exists(el.anglepoint._is_new)) {
    el.addChild(el.anglepoint);
    delete el.anglepoint._is_new;
  } else {
    el.anglepoint.addChild(el);
  }
  el.useDirection = attr.usedirection;
  el.updateDataArray = function() {
    var ar, phi, det, p0c, p1c, p2c, sgn = 1, A = this.radiuspoint, B = this.center, C = this.anglepoint, ev_s = type_default.evaluate(this.visProp.selection);
    phi = geometry_default.rad(A, B, C);
    if (ev_s === "minor" && phi > Math.PI || ev_s === "major" && phi < Math.PI) {
      sgn = -1;
    }
    if (this.useDirection) {
      p0c = points[1].coords.usrCoords;
      p1c = points[3].coords.usrCoords;
      p2c = points[2].coords.usrCoords;
      det = (p0c[1] - p2c[1]) * (p0c[2] - p1c[2]) - (p0c[2] - p2c[2]) * (p0c[1] - p1c[1]);
      if (det < 0) {
        this.radiuspoint = points[1];
        this.anglepoint = points[2];
      } else {
        this.radiuspoint = points[2];
        this.anglepoint = points[1];
      }
    }
    A = A.coords.usrCoords;
    B = B.coords.usrCoords;
    C = C.coords.usrCoords;
    ar = geometry_default.bezierArc(A, B, C, false, sgn);
    this.dataX = ar[0];
    this.dataY = ar[1];
    this.bezierDegree = 3;
    this.updateStdform();
    this.updateQuadraticform();
  };
  el.Radius = function() {
    return this.radiuspoint.Dist(this.center);
  };
  el.getRadius = function() {
    jxg_default.deprecated("Arc.getRadius()", "Arc.Radius()");
    return this.Radius();
  };
  el.Value = function(unit, rad) {
    var val;
    rad = rad || geometry_default.rad(this.radiuspoint, this.center, this.anglepoint);
    unit = unit || "length";
    unit = unit.toLocaleLowerCase();
    if (unit === "" || unit.indexOf("len") === 0) {
      val = rad * this.Radius();
    } else if (unit.indexOf("rad") === 0) {
      val = rad;
    } else if (unit.indexOf("deg") === 0) {
      val = rad * 180 / Math.PI;
    } else if (unit.indexOf("sem") === 0) {
      val = rad / Math.PI;
    } else if (unit.indexOf("cir") === 0) {
      val = rad * 0.5 / Math.PI;
    }
    return val;
  };
  el.L = function() {
    return this.Value("length");
  };
  el.hasPoint = function(x, y) {
    var dist, checkPoint, has, invMat, c, prec, type, r = this.Radius();
    if (type_default.evaluate(this.visProp.hasinnerpoints)) {
      return this.hasPointSector(x, y);
    }
    if (type_default.isObject(type_default.evaluate(this.visProp.precision))) {
      type = this.board._inputDevice;
      prec = type_default.evaluate(this.visProp.precision[type]);
    } else {
      prec = this.board.options.precision.hasPoint;
    }
    prec /= Math.min(Math.abs(this.board.unitX), Math.abs(this.board.unitY));
    checkPoint = new coords_default(constants_default.COORDS_BY_SCREEN, [x, y], this.board);
    if (this.transformations.length > 0) {
      this.updateTransformMatrix();
      invMat = math_default.inverse(this.transformMat);
      c = math_default.matVecMult(invMat, checkPoint.usrCoords);
      checkPoint = new coords_default(constants_default.COORDS_BY_USER, c, this.board);
    }
    dist = this.center.coords.distance(constants_default.COORDS_BY_USER, checkPoint);
    has = Math.abs(dist - r) < prec;
    if (has) {
      has = geometry_default.coordsOnArc(this, checkPoint);
    }
    return has;
  };
  el.hasPointSector = function(x, y) {
    var checkPoint = new coords_default(constants_default.COORDS_BY_SCREEN, [x, y], this.board), r = this.Radius(), dist = this.center.coords.distance(constants_default.COORDS_BY_USER, checkPoint), has = dist < r;
    if (has) {
      has = geometry_default.coordsOnArc(this, checkPoint);
    }
    return has;
  };
  el.getTextAnchor = function() {
    return this.center.coords;
  };
  el.getLabelAnchor = function() {
    var coords, vec, vecx, vecy, len, angle = geometry_default.rad(this.radiuspoint, this.center, this.anglepoint), dx = 10 / this.board.unitX, dy = 10 / this.board.unitY, p2c = this.point2.coords.usrCoords, pmc = this.center.coords.usrCoords, bxminusax = p2c[1] - pmc[1], byminusay = p2c[2] - pmc[2], ev_s = type_default.evaluate(this.visProp.selection), l_vp = this.label ? this.label.visProp : this.visProp.label;
    if (ev_s === "minor" && angle > Math.PI || ev_s === "major" && angle < Math.PI) {
      angle = -(2 * Math.PI - angle);
    }
    coords = new coords_default(
      constants_default.COORDS_BY_USER,
      [
        pmc[1] + Math.cos(angle * 0.5) * bxminusax - Math.sin(angle * 0.5) * byminusay,
        pmc[2] + Math.sin(angle * 0.5) * bxminusax + Math.cos(angle * 0.5) * byminusay
      ],
      this.board
    );
    vecx = coords.usrCoords[1] - pmc[1];
    vecy = coords.usrCoords[2] - pmc[2];
    len = math_default.hypot(vecx, vecy);
    vecx = vecx * (len + dx) / len;
    vecy = vecy * (len + dy) / len;
    vec = [pmc[1] + vecx, pmc[2] + vecy];
    l_vp.position = geometry_default.calcLabelQuadrant(geometry_default.rad([1, 0], [0, 0], vec));
    return new coords_default(constants_default.COORDS_BY_USER, vec, this.board);
  };
  el.updateQuadraticform = circle_default.prototype.updateQuadraticform;
  el.updateStdform = circle_default.prototype.updateStdform;
  el.methodMap = jxg_default.deepCopy(el.methodMap, {
    getRadius: "getRadius",
    radius: "Radius",
    Radius: "Radius",
    center: "center",
    radiuspoint: "radiuspoint",
    anglepoint: "anglepoint",
    Value: "Value",
    L: "L"
  });
  el.prepareUpdate().update();
  return el;
};
jxg_default.registerElement("arc", jxg_default.createArc);
jxg_default.createSemicircle = function(board, parents, attributes) {
  var el, mp, attr, points;
  points = type_default.providePoints(board, parents, attributes, "point");
  if (points === false || points.length !== 2) {
    throw new Error(
      "JSXGraph: Can't create Semicircle with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,point]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "semicircle", "center");
  mp = board.create("midpoint", points, attr);
  mp.dump = false;
  attr = type_default.copyAttributes(attributes, board.options, "semicircle");
  el = board.create("arc", [mp, points[1], points[0]], attr);
  el.elType = "semicircle";
  el.setParents([points[0].id, points[1].id]);
  el.subs = {
    midpoint: mp
  };
  el.inherits.push(mp);
  el.midpoint = el.center = mp;
  return el;
};
jxg_default.registerElement("semicircle", jxg_default.createSemicircle);
jxg_default.createCircumcircleArc = function(board, parents, attributes) {
  var el, mp, attr, points;
  points = type_default.providePoints(board, parents, attributes, "point");
  if (points === false || points.length !== 3) {
    throw new Error(
      "JSXGraph: create Circumcircle Arc with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "' and '" + typeof parents[2] + "'.\nPossible parent types: [point,point,point]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "circumcirclearc", "center");
  mp = board.create("circumcenter", points, attr);
  mp.dump = false;
  attr = type_default.copyAttributes(attributes, board.options, "circumcirclearc");
  attr.usedirection = true;
  el = board.create("arc", [mp, points[0], points[2], points[1]], attr);
  el.elType = "circumcirclearc";
  el.setParents([points[0].id, points[1].id, points[2].id]);
  el.subs = {
    center: mp
  };
  el.inherits.push(mp);
  el.center = mp;
  return el;
};
jxg_default.registerElement("circumcirclearc", jxg_default.createCircumcircleArc);
jxg_default.createMinorArc = function(board, parents, attributes) {
  attributes.selection = "minor";
  return jxg_default.createArc(board, parents, attributes);
};
jxg_default.registerElement("minorarc", jxg_default.createMinorArc);
jxg_default.createMajorArc = function(board, parents, attributes) {
  attributes.selection = "major";
  return jxg_default.createArc(board, parents, attributes);
};
jxg_default.registerElement("majorarc", jxg_default.createMajorArc);

// node_modules/jsxgraph/src/element/sector.js
jxg_default.createSector = function(board, parents, attributes) {
  var el, attr, i2, type = "invalid", s, v, attrPoints = ["center", "radiusPoint", "anglePoint"], points;
  if (parents[0].elementClass === constants_default.OBJECT_CLASS_LINE && parents[1].elementClass === constants_default.OBJECT_CLASS_LINE && (type_default.isArray(parents[2]) || type_default.isNumber(parents[2])) && (type_default.isArray(parents[3]) || type_default.isNumber(parents[3])) && (type_default.isNumber(parents[4]) || type_default.isFunction(parents[4]) || type_default.isString(parents[4]))) {
    type = "2lines";
  } else {
    points = type_default.providePoints(board, parents, attributes, "sector", attrPoints);
    if (points === false) {
      throw new Error(
        "JSXGraph: Can't create Sector with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "' and '" + typeof parents[2] + "'."
      );
    }
    type = "3points";
  }
  attr = type_default.copyAttributes(attributes, board.options, "sector");
  el = board.create("curve", [[0], [0]], attr);
  el.type = constants_default.OBJECT_TYPE_SECTOR;
  el.elType = "sector";
  el.autoRadius = function() {
    var r1 = 20 / el.board.unitX, r2 = Infinity, r3 = 50 / el.board.unitX;
    if (type_default.isPoint(el.center)) {
      r2 = el.center.Dist(el.point2) * 0.3333;
    }
    return Math.max(r1, Math.min(r2, r3));
  };
  if (type === "2lines") {
    el.Radius = function() {
      var r = type_default.evaluate(parents[4]);
      if (r === "auto") {
        return this.autoRadius();
      }
      return r;
    };
    el.line1 = board.select(parents[0]);
    el.line2 = board.select(parents[1]);
    el.line1.addChild(el);
    el.line2.addChild(el);
    el.setParents(parents);
    el.point1 = { visProp: {} };
    el.point2 = { visProp: {} };
    el.point3 = { visProp: {} };
    s = geometry_default.meetLineLine(el.line1.stdform, el.line2.stdform, 0, board);
    if (type_default.isArray(parents[2])) {
      if (parents[2].length === 2) {
        parents[2] = [1].concat(parents[2]);
      }
      v = geometry_default.projectPointToLine(
        { coords: { usrCoords: parents[2] } },
        el.line1,
        board
      );
      v = statistics_default.subtract(v.usrCoords, s.usrCoords);
      el.direction1 = math_default.innerProduct(v, [0, el.line1.stdform[2], -el.line1.stdform[1]], 3) >= 0 ? 1 : -1;
    } else {
      el.direction1 = parents[2] >= 0 ? 1 : -1;
    }
    if (type_default.isArray(parents[3])) {
      if (parents[3].length === 2) {
        parents[3] = [1].concat(parents[3]);
      }
      v = geometry_default.projectPointToLine(
        { coords: { usrCoords: parents[3] } },
        el.line2,
        board
      );
      v = statistics_default.subtract(v.usrCoords, s.usrCoords);
      el.direction2 = math_default.innerProduct(v, [0, el.line2.stdform[2], -el.line2.stdform[1]], 3) >= 0 ? 1 : -1;
    } else {
      el.direction2 = parents[3] >= 0 ? 1 : -1;
    }
    el.updateDataArray = function() {
      var r, l1, l2, A = [0, 0, 0], B = [0, 0, 0], C = [0, 0, 0], ar;
      l1 = this.line1;
      l2 = this.line2;
      B = math_default.crossProduct(l1.stdform, l2.stdform);
      if (Math.abs(B[0]) > math_default.eps * math_default.eps) {
        B[1] /= B[0];
        B[2] /= B[0];
        B[0] /= B[0];
      }
      r = this.direction1 * this.Radius();
      A = statistics_default.add(B, [0, r * l1.stdform[2], -r * l1.stdform[1]]);
      r = this.direction2 * this.Radius();
      C = statistics_default.add(B, [0, r * l2.stdform[2], -r * l2.stdform[1]]);
      this.point2.coords = new coords_default(constants_default.COORDS_BY_USER, A, el.board);
      this.point1.coords = new coords_default(constants_default.COORDS_BY_USER, B, el.board);
      this.point3.coords = new coords_default(constants_default.COORDS_BY_USER, C, el.board);
      if (Math.abs(A[0]) < math_default.eps || Math.abs(B[0]) < math_default.eps || Math.abs(C[0]) < math_default.eps) {
        this.dataX = [NaN];
        this.dataY = [NaN];
        return;
      }
      ar = geometry_default.bezierArc(A, B, C, true, 1);
      this.dataX = ar[0];
      this.dataY = ar[1];
      this.bezierDegree = 3;
    };
  } else if (type === "3points") {
    el.point1 = points[0];
    el.point2 = points[1];
    el.point3 = points[2];
    for (i2 = 0; i2 < 3; i2++) {
      if (type_default.exists(points[i2]._is_new)) {
        el.addChild(points[i2]);
        delete points[i2]._is_new;
      } else {
        points[i2].addChild(el);
      }
    }
    el.useDirection = attributes.usedirection;
    el.setParents(points);
    if (type_default.exists(points[3])) {
      el.point4 = points[3];
      el.point4.addChild(el);
    }
    el.methodMap = jxg_default.deepCopy(el.methodMap, {
      arc: "arc",
      center: "center",
      radiuspoint: "radiuspoint",
      anglepoint: "anglepoint"
    });
    el.updateDataArray = function() {
      var ar, det, p0c, p1c, p2c, A = this.point2, B = this.point1, C = this.point3, phi, sgn = 1, vp_s = type_default.evaluate(this.visProp.selection);
      if (!A.isReal || !B.isReal || !C.isReal) {
        this.dataX = [NaN];
        this.dataY = [NaN];
        return;
      }
      phi = geometry_default.rad(A, B, C);
      if (vp_s === "minor" && phi > Math.PI || vp_s === "major" && phi < Math.PI) {
        sgn = -1;
      }
      if (this.useDirection && type_default.exists(this.point4)) {
        p0c = this.point2.coords.usrCoords;
        p1c = this.point4.coords.usrCoords;
        p2c = this.point3.coords.usrCoords;
        det = (p0c[1] - p2c[1]) * (p0c[2] - p1c[2]) - (p0c[2] - p2c[2]) * (p0c[1] - p1c[1]);
        if (det >= 0) {
          C = this.point2;
          A = this.point3;
        }
      }
      A = A.coords.usrCoords;
      B = B.coords.usrCoords;
      C = C.coords.usrCoords;
      ar = geometry_default.bezierArc(A, B, C, true, sgn);
      this.dataX = ar[0];
      this.dataY = ar[1];
      this.bezierDegree = 3;
    };
    el.Radius = function() {
      return this.point2.Dist(this.point1);
    };
  }
  el.center = el.point1;
  el.radiuspoint = el.point2;
  el.anglepoint = el.point3;
  attr = type_default.copyAttributes(attributes, board.options, "arc");
  attr = type_default.copyAttributes(attr, board.options, "sector", "arc");
  attr.withLabel = false;
  attr.name += "_arc";
  if (type === "2lines") {
    el.updateDataArray();
    el.arc = board.create("arc", [
      function() {
        return el.point1.coords.usrCoords;
      },
      // Center
      function() {
        var d = el.point2.coords.distance(constants_default.COORDS_BY_USER, el.point1.coords);
        if (d === 0) {
          return [el.point1.coords.usrCoords[1], el.point1.coords.usrCoords[2]];
        }
        return [
          el.point1.coords.usrCoords[1] + el.Radius() * (el.point2.coords.usrCoords[1] - el.point1.coords.usrCoords[1]) / d,
          el.point1.coords.usrCoords[2] + el.Radius() * (el.point2.coords.usrCoords[2] - el.point1.coords.usrCoords[2]) / d
        ];
      },
      function() {
        return el.point3.coords.usrCoords;
      }
      // Center
    ], attr);
  } else {
    el.arc = board.create("arc", [
      el.point1,
      // Center
      function() {
        var d = el.point2.Dist(el.point1);
        if (d === 0) {
          return [el.point1.X(), el.point1.Y()];
        }
        return [
          el.point1.X() + el.Radius() * (el.point2.X() - el.point1.X()) / d,
          el.point1.Y() + el.Radius() * (el.point2.Y() - el.point1.Y()) / d
        ];
      },
      el.point3
    ], attr);
  }
  el.addChild(el.arc);
  el.hasPointCurve = function(x, y) {
    var angle, alpha, beta, prec, type2, checkPoint = new coords_default(constants_default.COORDS_BY_SCREEN, [x, y], this.board), r = this.Radius(), dist = this.center.coords.distance(constants_default.COORDS_BY_USER, checkPoint), has, vp_s = type_default.evaluate(this.visProp.selection);
    if (type_default.isObject(type_default.evaluate(this.visProp.precision))) {
      type2 = this.board._inputDevice;
      prec = type_default.evaluate(this.visProp.precision[type2]);
    } else {
      prec = this.board.options.precision.hasPoint;
    }
    prec /= Math.min(Math.abs(this.board.unitX), Math.abs(this.board.unitY));
    has = Math.abs(dist - r) < prec;
    if (has) {
      angle = geometry_default.rad(this.point2, this.center, checkPoint.usrCoords.slice(1));
      alpha = 0;
      beta = geometry_default.rad(this.point2, this.center, this.point3);
      if (vp_s === "minor" && beta > Math.PI || vp_s === "major" && beta < Math.PI) {
        alpha = beta;
        beta = 2 * Math.PI;
      }
      if (angle < alpha || angle > beta) {
        has = false;
      }
    }
    return has;
  };
  el.hasPointSector = function(x, y) {
    var angle, checkPoint = new coords_default(constants_default.COORDS_BY_SCREEN, [x, y], this.board), r = this.Radius(), dist = this.point1.coords.distance(constants_default.COORDS_BY_USER, checkPoint), alpha, beta, has = dist < r, vp_s = type_default.evaluate(this.visProp.selection);
    if (has) {
      angle = geometry_default.rad(this.radiuspoint, this.center, checkPoint.usrCoords.slice(1));
      alpha = 0;
      beta = geometry_default.rad(this.radiuspoint, this.center, this.anglepoint);
      if (vp_s === "minor" && beta > Math.PI || vp_s === "major" && beta < Math.PI) {
        alpha = beta;
        beta = 2 * Math.PI;
      }
      if (angle < alpha || angle > beta) {
        has = false;
      }
    }
    return has;
  };
  el.hasPoint = function(x, y) {
    if (type_default.evaluate(this.visProp.highlightonsector) || type_default.evaluate(this.visProp.hasinnerpoints)) {
      return this.hasPointSector(x, y);
    }
    return this.hasPointCurve(x, y);
  };
  el.getTextAnchor = function() {
    return this.point1.coords;
  };
  el.getLabelAnchor = function() {
    var coords, vec, vecx, vecy, len, angle = geometry_default.rad(this.point2, this.point1, this.point3), dx = 13 / this.board.unitX, dy = 13 / this.board.unitY, p2c = this.point2.coords.usrCoords, pmc = this.point1.coords.usrCoords, bxminusax = p2c[1] - pmc[1], byminusay = p2c[2] - pmc[2], vp_s = type_default.evaluate(this.visProp.selection), l_vp = this.label ? this.label.visProp : this.visProp.label;
    if (vp_s === "minor" && angle > Math.PI || vp_s === "major" && angle < Math.PI) {
      angle = -(2 * Math.PI - angle);
    }
    coords = new coords_default(
      constants_default.COORDS_BY_USER,
      [
        pmc[1] + Math.cos(angle * 0.5) * bxminusax - Math.sin(angle * 0.5) * byminusay,
        pmc[2] + Math.sin(angle * 0.5) * bxminusax + Math.cos(angle * 0.5) * byminusay
      ],
      this.board
    );
    vecx = coords.usrCoords[1] - pmc[1];
    vecy = coords.usrCoords[2] - pmc[2];
    len = math_default.hypot(vecx, vecy);
    vecx = vecx * (len + dx) / len;
    vecy = vecy * (len + dy) / len;
    vec = [pmc[1] + vecx, pmc[2] + vecy];
    l_vp.position = geometry_default.calcLabelQuadrant(geometry_default.rad([1, 0], [0, 0], vec));
    return new coords_default(constants_default.COORDS_BY_USER, vec, this.board);
  };
  el.setRadius = function(val) {
    var res, e = type_default.evaluate(val);
    if (val === "auto" || e === "auto") {
      res = "auto";
    } else if (type_default.isNumber(val)) {
      res = "number";
    } else if (type_default.isFunction(val) && !type_default.isString(e)) {
      res = "function";
    } else {
      res = "undefined";
    }
    if (res !== "undefined") {
      this.visProp.radius = val;
    }
    el.Radius = function() {
      var r = type_default.evaluate(val);
      if (r === "auto") {
        return this.autoRadius();
      }
      return r;
    };
  };
  el.getRadius = function() {
    jxg_default.deprecated("Sector.getRadius()", "Sector.Radius()");
    return this.Radius();
  };
  el.Value = function(unit) {
    return this.arc.Value(unit);
  };
  el.L = function() {
    return this.arc.L();
  };
  el.Area = function() {
    var r = this.Radius();
    return 0.5 * r * r * this.Value("radians");
  };
  el.Perimeter = function() {
    return this.L() + 2 * this.Radius();
  };
  if (type === "3points") {
    el.setPositionDirectly = function(method, coords, oldcoords) {
      var dc, t, c = new coords_default(method, coords, this.board), oldc = new coords_default(method, oldcoords, this.board);
      if (!el.point1.draggable() || !el.point2.draggable() || !el.point3.draggable()) {
        return this;
      }
      dc = statistics_default.subtract(c.usrCoords, oldc.usrCoords);
      t = this.board.create("transform", dc.slice(1), { type: "translate" });
      t.applyOnce([el.point1, el.point2, el.point3]);
      return this;
    };
  }
  el.methodMap = jxg_default.deepCopy(el.methodMap, {
    radius: "Radius",
    Radius: "Radius",
    getRadius: "Radius",
    setRadius: "setRadius",
    Value: "Value",
    L: "L",
    Area: "Area",
    Perimeter: "Perimeter"
  });
  return el;
};
jxg_default.registerElement("sector", jxg_default.createSector);
jxg_default.createCircumcircleSector = function(board, parents, attributes) {
  var el, mp, attr, points;
  points = type_default.providePoints(board, parents, attributes, "point");
  if (points === false) {
    throw new Error(
      "JSXGraph: Can't create circumcircle sector with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "' and '" + typeof parents[2] + "'."
    );
  }
  mp = board.create("circumcenter", points.slice(0, 3), attr);
  mp.dump = false;
  attr = type_default.copyAttributes(attributes, board.options, "circumcirclesector");
  el = board.create("sector", [mp, points[0], points[2], points[1]], attr);
  el.elType = "circumcirclesector";
  el.setParents(points);
  el.center = mp;
  el.subs = {
    center: mp
  };
  return el;
};
jxg_default.registerElement("circumcirclesector", jxg_default.createCircumcircleSector);
jxg_default.createMinorSector = function(board, parents, attributes) {
  attributes.selection = "minor";
  return jxg_default.createSector(board, parents, attributes);
};
jxg_default.registerElement("minorsector", jxg_default.createMinorSector);
jxg_default.createMajorSector = function(board, parents, attributes) {
  attributes.selection = "major";
  return jxg_default.createSector(board, parents, attributes);
};
jxg_default.registerElement("majorsector", jxg_default.createMajorSector);
jxg_default.createAngle = function(board, parents, attributes) {
  var el, radius, attr, attrsub, i2, points, type = "invalid";
  if (parents[0].elementClass === constants_default.OBJECT_CLASS_LINE && parents[1].elementClass === constants_default.OBJECT_CLASS_LINE && (type_default.isArray(parents[2]) || type_default.isNumber(parents[2])) && (type_default.isArray(parents[3]) || type_default.isNumber(parents[3]))) {
    type = "2lines";
  } else {
    attr = {
      name: ""
    };
    points = type_default.providePoints(board, parents, attr, "point");
    if (points === false) {
      throw new Error(
        "JSXGraph: Can't create angle with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "' and '" + typeof parents[2] + "'."
      );
    }
    type = "3points";
  }
  attr = type_default.copyAttributes(attributes, board.options, "angle");
  if (!type_default.exists(attr.name) || attr.name === "") {
    attr.name = board.generateName({ type: constants_default.OBJECT_TYPE_ANGLE });
  }
  if (type_default.exists(attr.radius)) {
    radius = attr.radius;
  } else {
    radius = 0;
  }
  board.suspendUpdate();
  if (type === "2lines") {
    parents.push(radius);
    el = board.create("sector", parents, attr);
    el.updateDataArraySector = el.updateDataArray;
    el.setAngle = function(val) {
    };
    el.free = function(val) {
    };
  } else {
    el = board.create("sector", [points[1], points[0], points[2]], attr);
    el.arc.visProp.priv = true;
    el.point = el.point2 = el.radiuspoint = points[0];
    el.pointsquare = el.point3 = el.anglepoint = points[2];
    el.Radius = function() {
      var r = type_default.evaluate(radius);
      if (r === "auto") {
        return el.autoRadius();
      }
      return r;
    };
    el.updateDataArraySector = function() {
      var A = this.point2, B = this.point1, C = this.point3, r = this.Radius(), d = B.Dist(A), ar, phi, sgn = 1, vp_s = type_default.evaluate(this.visProp.selection);
      phi = geometry_default.rad(A, B, C);
      if (vp_s === "minor" && phi > Math.PI || vp_s === "major" && phi < Math.PI) {
        sgn = -1;
      }
      A = A.coords.usrCoords;
      B = B.coords.usrCoords;
      C = C.coords.usrCoords;
      A = [1, B[1] + (A[1] - B[1]) * r / d, B[2] + (A[2] - B[2]) * r / d];
      C = [1, B[1] + (C[1] - B[1]) * r / d, B[2] + (C[2] - B[2]) * r / d];
      ar = geometry_default.bezierArc(A, B, C, true, sgn);
      this.dataX = ar[0];
      this.dataY = ar[1];
      this.bezierDegree = 3;
    };
    el.setAngle = function(val) {
      var t1, t2, val2, p = this.anglepoint, q = this.radiuspoint;
      if (p.draggable()) {
        t1 = this.board.create("transform", [val, this.center], {
          type: "rotate"
        });
        p.addTransform(q, t1);
        t1.update();
        p.moveTo(math_default.matVecMult(t1.matrix, q.coords.usrCoords));
        if (type_default.isFunction(val)) {
          val2 = function() {
            return Math.PI * 2 - val();
          };
        } else {
          val2 = function() {
            return Math.PI * 2 - val;
          };
        }
        t2 = this.board.create("transform", [val2, this.center], {
          type: "rotate"
        });
        p.coords.on("update", function() {
          t2.update();
          q.moveTo(math_default.matVecMult(t2.matrix, p.coords.usrCoords));
        });
        p.setParents(q);
        this.hasFixedAngle = true;
      }
      return this;
    };
    el.free = function() {
      var p = this.anglepoint;
      if (p.transformations.length > 0) {
        p.transformations.pop();
        p.isDraggable = true;
        p.parents = [];
        p.coords.off("update");
      }
      this.hasFixedAngle = false;
      return this;
    };
    el.setParents(points);
  }
  if (type_default.exists(el.visProp.text)) {
    el.label.setText(type_default.evaluate(el.visProp.text));
  }
  el.elType = "angle";
  el.type = constants_default.OBJECT_TYPE_ANGLE;
  el.subs = {};
  el.updateDataArraySquare = function() {
    var A, B, C, d1, d2, v, l1, l2, r = this.Radius();
    if (type === "2lines") {
      this.updateDataArraySector();
    }
    A = this.point2;
    B = this.point1;
    C = this.point3;
    A = A.coords.usrCoords;
    B = B.coords.usrCoords;
    C = C.coords.usrCoords;
    d1 = geometry_default.distance(A, B, 3);
    d2 = geometry_default.distance(C, B, 3);
    A = [1, B[1] + (A[1] - B[1]) * r / d1, B[2] + (A[2] - B[2]) * r / d1];
    C = [1, B[1] + (C[1] - B[1]) * r / d2, B[2] + (C[2] - B[2]) * r / d2];
    v = math_default.crossProduct(C, B);
    l1 = [-A[1] * v[1] - A[2] * v[2], A[0] * v[1], A[0] * v[2]];
    v = math_default.crossProduct(A, B);
    l2 = [-C[1] * v[1] - C[2] * v[2], C[0] * v[1], C[0] * v[2]];
    v = math_default.crossProduct(l1, l2);
    v[1] /= v[0];
    v[2] /= v[0];
    this.dataX = [B[1], A[1], v[1], C[1], B[1]];
    this.dataY = [B[2], A[2], v[2], C[2], B[2]];
    this.bezierDegree = 1;
  };
  el.updateDataArrayNone = function() {
    this.dataX = [NaN];
    this.dataY = [NaN];
    this.bezierDegree = 1;
  };
  el.updateDataArray = function() {
    var type2 = type_default.evaluate(this.visProp.type), deg = geometry_default.trueAngle(this.point2, this.point1, this.point3), vp_s = type_default.evaluate(this.visProp.selection);
    if (vp_s === "minor" && deg > 180 || vp_s === "major" && deg < 180) {
      deg = 360 - deg;
    }
    if (Math.abs(deg - 90) < type_default.evaluate(this.visProp.orthosensitivity) + math_default.eps) {
      type2 = type_default.evaluate(this.visProp.orthotype);
    }
    if (type2 === "none") {
      this.updateDataArrayNone();
    } else if (type2 === "square") {
      this.updateDataArraySquare();
    } else if (type2 === "sector") {
      this.updateDataArraySector();
    } else if (type2 === "sectordot") {
      this.updateDataArraySector();
      if (!this.dot.visProp.visible) {
        this.dot.setAttribute({ visible: true });
      }
    }
    if (!this.visProp.visible || type2 !== "sectordot" && this.dot.visProp.visible) {
      this.dot.setAttribute({ visible: false });
    }
  };
  attrsub = type_default.copyAttributes(attributes, board.options, "angle", "dot");
  el.dot = board.create(
    "point",
    [
      function() {
        var A, B, r, d, a2, co, si, mat, vp_s;
        if (type_default.exists(el.dot) && !el.dot.visProp.visible) {
          return [0, 0];
        }
        A = el.point2.coords.usrCoords;
        B = el.point1.coords.usrCoords;
        r = el.Radius();
        d = geometry_default.distance(A, B, 3);
        a2 = geometry_default.rad(el.point2, el.point1, el.point3);
        vp_s = type_default.evaluate(el.visProp.selection);
        if (vp_s === "minor" && a2 > Math.PI || vp_s === "major" && a2 < Math.PI) {
          a2 = -(2 * Math.PI - a2);
        }
        a2 *= 0.5;
        co = Math.cos(a2);
        si = Math.sin(a2);
        A = [1, B[1] + (A[1] - B[1]) * r / d, B[2] + (A[2] - B[2]) * r / d];
        mat = [
          [1, 0, 0],
          [B[1] - 0.5 * B[1] * co + 0.5 * B[2] * si, co * 0.5, -si * 0.5],
          [B[2] - 0.5 * B[1] * si - 0.5 * B[2] * co, si * 0.5, co * 0.5]
        ];
        return math_default.matVecMult(mat, A);
      }
    ],
    attrsub
  );
  el.dot.dump = false;
  el.subs.dot = el.dot;
  if (type === "2lines") {
    for (i2 = 0; i2 < 2; i2++) {
      board.select(parents[i2]).addChild(el.dot);
    }
  } else {
    for (i2 = 0; i2 < 3; i2++) {
      board.select(points[i2]).addChild(el.dot);
    }
  }
  board.unsuspendUpdate();
  el.Value = function(unit) {
    unit = unit || "radians";
    if (unit === "") {
      unit = "radians";
    }
    return el.arc.Value(unit);
  };
  el.getLabelAnchor = function() {
    var vec, dx = 12, A, B, r, d, a2, co, si, mat, vp_s = type_default.evaluate(el.visProp.selection), l_vp = this.label ? this.label.visProp : this.visProp.label;
    if (type_default.exists(this.label) && type_default.exists(this.label.visProp.fontsize)) {
      dx = type_default.evaluate(this.label.visProp.fontsize);
    }
    dx /= this.board.unitX;
    A = el.point2.coords.usrCoords;
    B = el.point1.coords.usrCoords;
    r = el.Radius();
    d = geometry_default.distance(A, B, 3);
    a2 = geometry_default.rad(el.point2, el.point1, el.point3);
    if (vp_s === "minor" && a2 > Math.PI || vp_s === "major" && a2 < Math.PI) {
      a2 = -(2 * Math.PI - a2);
    }
    a2 *= 0.5;
    co = Math.cos(a2);
    si = Math.sin(a2);
    A = [1, B[1] + (A[1] - B[1]) * r / d, B[2] + (A[2] - B[2]) * r / d];
    mat = [
      [1, 0, 0],
      [B[1] - 0.5 * B[1] * co + 0.5 * B[2] * si, co * 0.5, -si * 0.5],
      [B[2] - 0.5 * B[1] * si - 0.5 * B[2] * co, si * 0.5, co * 0.5]
    ];
    vec = math_default.matVecMult(mat, A);
    vec[1] /= vec[0];
    vec[2] /= vec[0];
    vec[0] /= vec[0];
    d = geometry_default.distance(vec, B, 3);
    vec = [
      vec[0],
      B[1] + (vec[1] - B[1]) * (r + dx) / d,
      B[2] + (vec[2] - B[2]) * (r + dx) / d
    ];
    l_vp.position = geometry_default.calcLabelQuadrant(geometry_default.rad([1, 0], [0, 0], vec));
    return new coords_default(constants_default.COORDS_BY_USER, vec, this.board);
  };
  el.methodMap = type_default.deepCopy(el.methodMap, {
    setAngle: "setAngle",
    Value: "Value",
    free: "free"
  });
  return el;
};
jxg_default.registerElement("angle", jxg_default.createAngle);
jxg_default.createNonreflexAngle = function(board, parents, attributes) {
  var el;
  attributes.selection = "minor";
  attributes = type_default.copyAttributes(attributes, board.options, "nonreflexangle");
  el = jxg_default.createAngle(board, parents, attributes);
  el.Value = function(unit) {
    var rad = geometry_default.rad(this.point2, this.point1, this.point3);
    unit = unit || "radians";
    if (unit === "") {
      unit = "radians";
    }
    rad = rad < Math.PI ? rad : 2 * Math.PI - rad;
    return this.arc.Value(unit, rad);
  };
  return el;
};
jxg_default.registerElement("nonreflexangle", jxg_default.createNonreflexAngle);
jxg_default.createReflexAngle = function(board, parents, attributes) {
  var el;
  attributes.selection = "major";
  attributes = type_default.copyAttributes(attributes, board.options, "reflexangle");
  el = jxg_default.createAngle(board, parents, attributes);
  el.Value = function(unit) {
    var rad = geometry_default.rad(this.point2, this.point1, this.point3);
    unit = unit || "radians";
    if (unit === "") {
      unit = "radians";
    }
    rad = rad >= Math.PI ? rad : 2 * Math.PI - rad;
    return this.arc.Value(unit, rad);
  };
  return el;
};
jxg_default.registerElement("reflexangle", jxg_default.createReflexAngle);

// node_modules/jsxgraph/src/element/composition.js
jxg_default.createOrthogonalProjection = function(board, parents, attributes) {
  var l, p, t, attr;
  parents[0] = board.select(parents[0]);
  parents[1] = board.select(parents[1]);
  if (type_default.isPointType(board, parents[0]) && parents[1].elementClass === constants_default.OBJECT_CLASS_LINE) {
    p = type_default.providePoints(board, [parents[0]], attributes, "point")[0];
    l = parents[1];
  } else if (type_default.isPointType(board, parents[1]) && parents[0].elementClass === constants_default.OBJECT_CLASS_LINE) {
    p = type_default.providePoints(board, [parents[1]], attributes, "point")[0];
    l = parents[0];
  } else {
    throw new Error(
      "JSXGraph: Can't create perpendicular point with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,line]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "orthogonalprojection");
  t = board.create(
    "point",
    [
      function() {
        return geometry_default.projectPointToLine(p, l, board);
      }
    ],
    attr
  );
  if (type_default.exists(p._is_new)) {
    t.addChild(p);
    delete p._is_new;
  } else {
    p.addChild(t);
  }
  l.addChild(t);
  t.elType = "orthogonalprojection";
  t.setParents([p.id, t.id]);
  t.update();
  t.generatePolynomial = function() {
    var a1 = l.point1.symbolic.x, a2 = l.point1.symbolic.y, b1 = l.point2.symbolic.x, b2 = l.point2.symbolic.y, p1 = p.symbolic.x, p2 = p.symbolic.y, t1 = t.symbolic.x, t2 = t.symbolic.y, poly1 = "(" + a2 + ")*(" + t1 + ")-(" + a2 + ")*(" + b1 + ")+(" + t2 + ")*(" + b1 + ")-(" + a1 + ")*(" + t2 + ")+(" + a1 + ")*(" + b2 + ")-(" + t1 + ")*(" + b2 + ")", poly2 = "(" + p2 + ")*(" + a2 + ")-(" + p2 + ")*(" + b2 + ")-(" + t2 + ")*(" + a2 + ")+(" + t2 + ")*(" + b2 + ")+(" + p1 + ")*(" + a1 + ")-(" + p1 + ")*(" + b1 + ")-(" + t1 + ")*(" + a1 + ")+(" + t1 + ")*(" + b1 + ")";
    return [poly1, poly2];
  };
  return t;
};
jxg_default.createPerpendicular = function(board, parents, attributes) {
  var p, l, pd, attr;
  parents[0] = board.select(parents[0]);
  parents[1] = board.select(parents[1]);
  if (type_default.isPointType(board, parents[0]) && parents[1].elementClass === constants_default.OBJECT_CLASS_LINE) {
    l = parents[1];
    p = type_default.providePoints(board, [parents[0]], attributes, "point")[0];
  } else if (type_default.isPointType(board, parents[1]) && parents[0].elementClass === constants_default.OBJECT_CLASS_LINE) {
    l = parents[0];
    p = type_default.providePoints(board, [parents[1]], attributes, "point")[0];
  } else {
    throw new Error(
      "JSXGraph: Can't create perpendicular with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [line,point]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "perpendicular");
  pd = jxg_default.createLine(
    board,
    [
      function() {
        return l.stdform[2] * p.X() - l.stdform[1] * p.Y();
      },
      function() {
        return -l.stdform[2] * p.Z();
      },
      function() {
        return l.stdform[1] * p.Z();
      }
    ],
    attr
  );
  pd.elType = "perpendicular";
  pd.setParents([l.id, p.id]);
  if (type_default.exists(p._is_new)) {
    pd.addChild(p);
    delete p._is_new;
  } else {
    p.addChild(pd);
  }
  l.addChild(pd);
  return pd;
};
jxg_default.createPerpendicularPoint = function(board, parents, attributes) {
  var l, p, t;
  parents[0] = board.select(parents[0]);
  parents[1] = board.select(parents[1]);
  if (type_default.isPointType(board, parents[0]) && parents[1].elementClass === constants_default.OBJECT_CLASS_LINE) {
    p = type_default.providePoints(board, [parents[0]], attributes, "point")[0];
    l = parents[1];
  } else if (type_default.isPointType(board, parents[1]) && parents[0].elementClass === constants_default.OBJECT_CLASS_LINE) {
    p = type_default.providePoints(board, [parents[1]], attributes, "point")[0];
    l = parents[0];
  } else {
    throw new Error(
      "JSXGraph: Can't create perpendicular point with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,line]"
    );
  }
  t = board.create(
    "point",
    [
      function() {
        return geometry_default.perpendicular(l, p, board)[0];
      }
    ],
    attributes
  );
  if (type_default.exists(p._is_new)) {
    t.addChild(p);
    delete p._is_new;
  } else {
    p.addChild(t);
  }
  l.addChild(t);
  t.elType = "perpendicularpoint";
  t.setParents([p.id, l.id]);
  t.update();
  t.generatePolynomial = function() {
    var a1 = l.point1.symbolic.x, a2 = l.point1.symbolic.y, b1 = l.point2.symbolic.x, b2 = l.point2.symbolic.y, p1 = p.symbolic.x, p2 = p.symbolic.y, t1 = t.symbolic.x, t2 = t.symbolic.y, poly1 = "(" + a2 + ")*(" + t1 + ")-(" + a2 + ")*(" + b1 + ")+(" + t2 + ")*(" + b1 + ")-(" + a1 + ")*(" + t2 + ")+(" + a1 + ")*(" + b2 + ")-(" + t1 + ")*(" + b2 + ")", poly2 = "(" + p2 + ")*(" + a2 + ")-(" + p2 + ")*(" + b2 + ")-(" + t2 + ")*(" + a2 + ")+(" + t2 + ")*(" + b2 + ")+(" + p1 + ")*(" + a1 + ")-(" + p1 + ")*(" + b1 + ")-(" + t1 + ")*(" + a1 + ")+(" + t1 + ")*(" + b1 + ")";
    return [poly1, poly2];
  };
  return t;
};
jxg_default.createPerpendicularSegment = function(board, parents, attributes) {
  var p, l, pd, t, attr;
  parents[0] = board.select(parents[0]);
  parents[1] = board.select(parents[1]);
  if (type_default.isPointType(board, parents[0]) && parents[1].elementClass === constants_default.OBJECT_CLASS_LINE) {
    l = parents[1];
    p = type_default.providePoints(board, [parents[0]], attributes, "point")[0];
  } else if (type_default.isPointType(board, parents[1]) && parents[0].elementClass === constants_default.OBJECT_CLASS_LINE) {
    l = parents[0];
    p = type_default.providePoints(board, [parents[1]], attributes, "point")[0];
  } else {
    throw new Error(
      "JSXGraph: Can't create perpendicular with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [line,point]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "perpendicularsegment", "point");
  t = jxg_default.createPerpendicularPoint(board, [l, p], attr);
  t.dump = false;
  if (!type_default.exists(attributes.layer)) {
    attributes.layer = board.options.layer.line;
  }
  attr = type_default.copyAttributes(attributes, board.options, "perpendicularsegment");
  pd = jxg_default.createLine(
    board,
    [
      function() {
        return geometry_default.perpendicular(l, p, board)[1] ? [t, p] : [p, t];
      }
    ],
    attr
  );
  pd.point = t;
  if (type_default.exists(p._is_new)) {
    pd.addChild(p);
    delete p._is_new;
  } else {
    p.addChild(pd);
  }
  l.addChild(pd);
  pd.elType = "perpendicularsegment";
  pd.setParents([p.id, l.id]);
  pd.subs = {
    point: t
  };
  pd.inherits.push(t);
  return pd;
};
jxg_default.createMidpoint = function(board, parents, attributes) {
  var a, b, t, i2, attr;
  for (i2 = 0; i2 < parents.length; ++i2) {
    parents[i2] = board.select(parents[i2]);
  }
  if (parents.length === 2 && type_default.isPointType(board, parents[0]) && type_default.isPointType(board, parents[1])) {
    parents = type_default.providePoints(board, parents, attributes, "point");
    a = parents[0];
    b = parents[1];
  } else if (parents.length === 1 && parents[0].elementClass === constants_default.OBJECT_CLASS_LINE) {
    a = parents[0].point1;
    b = parents[0].point2;
  } else {
    throw new Error(
      "JSXGraph: Can't create midpoint.\nPossible parent types: [point,point], [line]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "midpoint");
  t = board.create(
    "point",
    [
      function() {
        var x = a.coords.usrCoords[1] + b.coords.usrCoords[1];
        if (isNaN(x) || Math.abs(a.coords.usrCoords[0]) < math_default.eps || Math.abs(b.coords.usrCoords[0]) < math_default.eps) {
          return NaN;
        }
        return x * 0.5;
      },
      function() {
        var y = a.coords.usrCoords[2] + b.coords.usrCoords[2];
        if (isNaN(y) || Math.abs(a.coords.usrCoords[0]) < math_default.eps || Math.abs(b.coords.usrCoords[0]) < math_default.eps) {
          return NaN;
        }
        return y * 0.5;
      }
    ],
    attr
  );
  if (type_default.exists(a._is_new)) {
    t.addChild(a);
    delete a._is_new;
  } else {
    a.addChild(t);
  }
  if (type_default.exists(b._is_new)) {
    t.addChild(b);
    delete b._is_new;
  } else {
    b.addChild(t);
  }
  t.elType = "midpoint";
  t.setParents([a.id, b.id]);
  t.prepareUpdate().update();
  t.generatePolynomial = function() {
    var a1 = a.symbolic.x, a2 = a.symbolic.y, b1 = b.symbolic.x, b2 = b.symbolic.y, t1 = t.symbolic.x, t2 = t.symbolic.y, poly1 = "(" + a2 + ")*(" + t1 + ")-(" + a2 + ")*(" + b1 + ")+(" + t2 + ")*(" + b1 + ")-(" + a1 + ")*(" + t2 + ")+(" + a1 + ")*(" + b2 + ")-(" + t1 + ")*(" + b2 + ")", poly2 = "(" + a1 + ")^2 - 2*(" + a1 + ")*(" + t1 + ")+(" + a2 + ")^2-2*(" + a2 + ")*(" + t2 + ")-(" + b1 + ")^2+2*(" + b1 + ")*(" + t1 + ")-(" + b2 + ")^2+2*(" + b2 + ")*(" + t2 + ")";
    return [poly1, poly2];
  };
  return t;
};
jxg_default.createParallelPoint = function(board, parents, attributes) {
  var a, b, c, p, i2, attr;
  for (i2 = 0; i2 < parents.length; ++i2) {
    parents[i2] = board.select(parents[i2]);
  }
  if (parents.length === 3 && type_default.isPointType(board, parents[0]) && type_default.isPointType(board, parents[1]) && type_default.isPointType(board, parents[2])) {
    parents = type_default.providePoints(board, parents, attributes, "point");
    a = parents[0];
    b = parents[1];
    c = parents[2];
  } else if (type_default.isPointType(board, parents[0]) && parents[1].elementClass === constants_default.OBJECT_CLASS_LINE) {
    c = type_default.providePoints(board, [parents[0]], attributes, "point")[0];
    a = parents[1].point1;
    b = parents[1].point2;
  } else if (type_default.isPointType(board, parents[1]) && parents[0].elementClass === constants_default.OBJECT_CLASS_LINE) {
    c = type_default.providePoints(board, [parents[1]], attributes, "point")[0];
    a = parents[0].point1;
    b = parents[0].point2;
  } else {
    throw new Error(
      "JSXGraph: Can't create parallel point with parent types '" + typeof parents[0] + "', '" + typeof parents[1] + "' and '" + typeof parents[2] + "'.\nPossible parent types: [line,point], [point,point,point]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "parallelpoint");
  p = board.create(
    "point",
    [
      function() {
        return c.coords.usrCoords[1] + b.coords.usrCoords[1] - a.coords.usrCoords[1];
      },
      function() {
        return c.coords.usrCoords[2] + b.coords.usrCoords[2] - a.coords.usrCoords[2];
      }
    ],
    attr
  );
  if (type_default.exists(a._is_new)) {
    p.addChild(a);
    delete a._is_new;
  } else {
    a.addChild(p);
  }
  if (type_default.exists(b._is_new)) {
    p.addChild(b);
    delete b._is_new;
  } else {
    b.addChild(p);
  }
  if (type_default.exists(c._is_new)) {
    p.addChild(c);
    delete c._is_new;
  } else {
    c.addChild(p);
  }
  p.elType = "parallelpoint";
  p.setParents([a.id, b.id, c.id]);
  p.prepareUpdate().update();
  p.generatePolynomial = function() {
    var a1 = a.symbolic.x, a2 = a.symbolic.y, b1 = b.symbolic.x, b2 = b.symbolic.y, c1 = c.symbolic.x, c2 = c.symbolic.y, t1 = p.symbolic.x, t2 = p.symbolic.y, poly1 = "(" + b2 + ")*(" + t1 + ")-(" + b2 + ")*(" + c1 + ")-(" + a2 + ")*(" + t1 + ")+(" + a2 + ")*(" + c1 + ")-(" + t2 + ")*(" + b1 + ")+(" + t2 + ")*(" + a1 + ")+(" + c2 + ")*(" + b1 + ")-(" + c2 + ")*(" + a1 + ")", poly2 = "(" + t2 + ")*(" + a1 + ")-(" + t2 + ")*(" + c1 + ")-(" + b2 + ")*(" + a1 + ")+(" + b2 + ")*(" + c1 + ")-(" + t1 + ")*(" + a2 + ")+(" + t1 + ")*(" + c2 + ")+(" + b1 + ")*(" + a2 + ")-(" + b1 + ")*(" + c2 + ")";
    return [poly1, poly2];
  };
  return p;
};
jxg_default.createParallel = function(board, parents, attributes) {
  var p, pp, pl, li, i2, attr, ty = 1;
  for (i2 = 0; i2 < parents.length; ++i2) {
    parents[i2] = board.select(parents[i2]);
  }
  p = null;
  if (parents.length === 3) {
    parents = type_default.providePoints(board, parents, attributes, "point");
    p = parents[2];
    ty = 0;
  } else if (type_default.isPointType(board, parents[0])) {
    p = type_default.providePoints(board, [parents[0]], attributes, "point")[0];
    li = function() {
      return parents[1].stdform;
    };
  } else if (type_default.isPointType(board, parents[1])) {
    p = type_default.providePoints(board, [parents[1]], attributes, "point")[0];
    li = function() {
      return parents[0].stdform;
    };
  }
  if (!type_default.exists(attributes.layer)) {
    attributes.layer = board.options.layer.line;
  }
  attr = type_default.copyAttributes(attributes, board.options, "parallel", "point");
  if (ty === 1) {
    pp = board.create(
      "point",
      [
        function() {
          return math_default.crossProduct([1, 0, 0], li());
        }
      ],
      attr
    );
  } else {
    pp = board.create("parallelpoint", parents, attr);
  }
  pp.isDraggable = true;
  attr = type_default.copyAttributes(attributes, board.options, "parallel");
  pl = board.create("line", [p, pp], attr);
  pl.elType = "parallel";
  pl.subs = {
    point: pp
  };
  pl.inherits.push(pp);
  pl.setParents([parents[0].id, parents[1].id]);
  if (parents.length === 3) {
    pl.addParents(parents[2].id);
  }
  pl.point = pp;
  return pl;
};
jxg_default.createArrowParallel = function(board, parents, attributes) {
  var p, attr;
  try {
    attr = type_default.copyAttributes(attributes, board.options, "arrowparallel");
    if (attr.lastArrow === false) {
      attr.lastArrow = true;
    }
    p = jxg_default.createParallel(board, parents, attr).setAttribute({
      straightFirst: false,
      straightLast: false
    });
    p.type = constants_default.OBJECT_TYPE_VECTOR;
    p.elType = "arrowparallel";
    return p;
  } catch (e) {
    throw new Error(
      "JSXGraph: Can't create arrowparallel with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [line,point], [point,point,point]"
    );
  }
};
jxg_default.createNormal = function(board, parents, attributes) {
  var p, c, l, i2, g, f, attr, pp, attrp;
  for (i2 = 0; i2 < parents.length; ++i2) {
    parents[i2] = board.select(parents[i2]);
  }
  if (parents.length === 1) {
    p = parents[0];
    c = p.slideObject;
  } else if (parents.length === 2) {
    if (type_default.isPointType(board, parents[0])) {
      p = type_default.providePoints(board, [parents[0]], attributes, "point")[0];
      c = parents[1];
    } else if (type_default.isPointType(board, parents[1])) {
      c = parents[0];
      p = type_default.providePoints(board, [parents[1]], attributes, "point")[0];
    } else {
      throw new Error(
        "JSXGraph: Can't create normal with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,line], [point,circle], [glider]"
      );
    }
  } else {
    throw new Error(
      "JSXGraph: Can't create normal with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,line], [point,circle], [glider]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "normal");
  if (c.elementClass === constants_default.OBJECT_CLASS_LINE) {
    attrp = type_default.copyAttributes(attributes, board.options, "normal", "point");
    pp = board.create(
      "point",
      [
        function() {
          var p2 = math_default.crossProduct([1, 0, 0], c.stdform);
          return [p2[0], -p2[2], p2[1]];
        }
      ],
      attrp
    );
    pp.isDraggable = true;
    l = board.create("line", [p, pp], attr);
    l.point = pp;
    l.subs = {
      point: pp
    };
    l.inherits.push(pp);
  } else if (c.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
    l = board.create("line", [c.midpoint, p], attr);
  } else if (c.elementClass === constants_default.OBJECT_CLASS_CURVE) {
    if (type_default.evaluate(c.visProp.curvetype) !== "plot") {
      g = c.X;
      f = c.Y;
      l = board.create(
        "line",
        [
          function() {
            return -p.X() * numerics_default.D(g)(p.position) - p.Y() * numerics_default.D(f)(p.position);
          },
          function() {
            return numerics_default.D(g)(p.position);
          },
          function() {
            return numerics_default.D(f)(p.position);
          }
        ],
        attr
      );
    } else {
      l = board.create(
        "line",
        [
          function() {
            var i3 = Math.floor(p.position), lbda = p.position - i3, p1, p2, t, A, B, C, D, dx, dy, d;
            if (c.bezierdegree === 1) {
              if (i3 === c.numberPoints - 1) {
                i3 -= 1;
                lbda = 1;
              }
            } else if (c.bezierDegree === 3) {
              i3 = Math.floor(p.position * (c.numberPoints - 1) / 3) * 3;
              t = (p.position * (c.numberPoints - 1) - i3) / 3;
              if (i3 >= c.numberPoints - 1) {
                i3 = c.numberPoints - 4;
                t = 1;
              }
            } else {
              return 0;
            }
            if (i3 < 0) {
              return 1;
            }
            if (c.bezierDegree === 1) {
              return (c.Y(i3) + lbda * (c.Y(i3 + 1) - c.Y(i3))) * (c.Y(i3) - c.Y(i3 + 1)) - (c.X(i3) + lbda * (c.X(i3 + 1) - c.X(i3))) * (c.X(i3 + 1) - c.X(i3));
            } else {
              A = c.points[i3].usrCoords;
              B = c.points[i3 + 1].usrCoords;
              C = c.points[i3 + 2].usrCoords;
              D = c.points[i3 + 3].usrCoords;
              dx = (1 - t) * (1 - t) * (B[1] - A[1]) + 2 * (1 - t) * t * (C[1] - B[1]) + t * t * (D[1] - C[1]);
              dy = (1 - t) * (1 - t) * (B[2] - A[2]) + 2 * (1 - t) * t * (C[2] - B[2]) + t * t * (D[2] - C[2]);
              d = math_default.hypot(dx, dy);
              dx /= d;
              dy /= d;
              p1 = p.coords.usrCoords;
              p2 = [1, p1[1] - dy, p1[2] + dx];
              return p1[2] * p2[1] - p1[1] * p2[2];
            }
          },
          function() {
            var i3 = Math.floor(p.position), p1, p2, t, A, B, C, D, dx, dy, d;
            if (c.bezierdegree === 1) {
              if (i3 === c.numberPoints - 1) {
                i3 -= 1;
              }
            } else if (c.bezierDegree === 3) {
              i3 = Math.floor(p.position * (c.numberPoints - 1) / 3) * 3;
              t = (p.position * (c.numberPoints - 1) - i3) / 3;
              if (i3 >= c.numberPoints - 1) {
                i3 = c.numberPoints - 4;
                t = 1;
              }
            } else {
              return 0;
            }
            if (i3 < 0) {
              return 0;
            }
            if (c.bezierDegree === 1) {
              return c.X(i3 + 1) - c.X(i3);
            } else {
              A = c.points[i3].usrCoords;
              B = c.points[i3 + 1].usrCoords;
              C = c.points[i3 + 2].usrCoords;
              D = c.points[i3 + 3].usrCoords;
              dx = (1 - t) * (1 - t) * (B[1] - A[1]) + 2 * (1 - t) * t * (C[1] - B[1]) + t * t * (D[1] - C[1]);
              dy = (1 - t) * (1 - t) * (B[2] - A[2]) + 2 * (1 - t) * t * (C[2] - B[2]) + t * t * (D[2] - C[2]);
              d = math_default.hypot(dx, dy);
              dx /= d;
              dy /= d;
              p1 = p.coords.usrCoords;
              p2 = [1, p1[1] - dy, p1[2] + dx];
              return p2[2] - p1[2];
            }
          },
          function() {
            var i3 = Math.floor(p.position), p1, p2, t, A, B, C, D, dx, dy, d;
            if (c.bezierdegree === 1) {
              if (i3 === c.numberPoints - 1) {
                i3 -= 1;
              }
            } else if (c.bezierDegree === 3) {
              i3 = Math.floor(p.position * (c.numberPoints - 1) / 3) * 3;
              t = (p.position * (c.numberPoints - 1) - i3) / 3;
              if (i3 >= c.numberPoints - 1) {
                i3 = c.numberPoints - 4;
                t = 1;
              }
            } else {
              return 0;
            }
            if (i3 < 0) {
              return 0;
            }
            if (c.bezierDegree === 1) {
              return c.Y(i3 + 1) - c.Y(i3);
            } else {
              A = c.points[i3].usrCoords;
              B = c.points[i3 + 1].usrCoords;
              C = c.points[i3 + 2].usrCoords;
              D = c.points[i3 + 3].usrCoords;
              dx = (1 - t) * (1 - t) * (B[1] - A[1]) + 2 * (1 - t) * t * (C[1] - B[1]) + t * t * (D[1] - C[1]);
              dy = (1 - t) * (1 - t) * (B[2] - A[2]) + 2 * (1 - t) * t * (C[2] - B[2]) + t * t * (D[2] - C[2]);
              d = math_default.hypot(dx, dy);
              dx /= d;
              dy /= d;
              p1 = p.coords.usrCoords;
              p2 = [1, p1[1] - dy, p1[2] + dx];
              return p1[1] - p2[1];
            }
          }
        ],
        attr
      );
    }
  } else if (c.type === constants_default.OBJECT_TYPE_TURTLE) {
    l = board.create(
      "line",
      [
        function() {
          var el, j, i3 = Math.floor(p.position), lbda = p.position - i3;
          for (j = 0; j < c.objects.length; j++) {
            el = c.objects[j];
            if (el.type === constants_default.OBJECT_TYPE_CURVE) {
              if (i3 < el.numberPoints) {
                break;
              }
              i3 -= el.numberPoints;
            }
          }
          if (i3 === el.numberPoints - 1) {
            i3 -= 1;
            lbda = 1;
          }
          if (i3 < 0) {
            return 1;
          }
          return (el.Y(i3) + lbda * (el.Y(i3 + 1) - el.Y(i3))) * (el.Y(i3) - el.Y(i3 + 1)) - (el.X(i3) + lbda * (el.X(i3 + 1) - el.X(i3))) * (el.X(i3 + 1) - el.X(i3));
        },
        function() {
          var el, j, i3 = Math.floor(p.position);
          for (j = 0; j < c.objects.length; j++) {
            el = c.objects[j];
            if (el.type === constants_default.OBJECT_TYPE_CURVE) {
              if (i3 < el.numberPoints) {
                break;
              }
              i3 -= el.numberPoints;
            }
          }
          if (i3 === el.numberPoints - 1) {
            i3 -= 1;
          }
          if (i3 < 0) {
            return 0;
          }
          return el.X(i3 + 1) - el.X(i3);
        },
        function() {
          var el, j, i3 = Math.floor(p.position);
          for (j = 0; j < c.objects.length; j++) {
            el = c.objects[j];
            if (el.type === constants_default.OBJECT_TYPE_CURVE) {
              if (i3 < el.numberPoints) {
                break;
              }
              i3 -= el.numberPoints;
            }
          }
          if (i3 === el.numberPoints - 1) {
            i3 -= 1;
          }
          if (i3 < 0) {
            return 0;
          }
          return el.Y(i3 + 1) - el.Y(i3);
        }
      ],
      attr
    );
  } else {
    throw new Error(
      "JSXGraph: Can't create normal with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,line], [point,circle], [glider]"
    );
  }
  l.elType = "normal";
  l.setParents(parents);
  if (type_default.exists(p._is_new)) {
    l.addChild(p);
    delete p._is_new;
  } else {
    p.addChild(l);
  }
  c.addChild(l);
  return l;
};
jxg_default.createBisector = function(board, parents, attributes) {
  var p, l, i2, attr;
  parents = type_default.providePoints(board, parents, attributes, "point");
  if (type_default.isPoint(parents[0]) && type_default.isPoint(parents[1]) && type_default.isPoint(parents[2])) {
    attr = type_default.copyAttributes(attributes, board.options, "bisector", "point");
    attr.snapToGrid = false;
    p = board.create(
      "point",
      [
        function() {
          return geometry_default.angleBisector(parents[0], parents[1], parents[2], board);
        }
      ],
      attr
    );
    p.dump = false;
    for (i2 = 0; i2 < 3; i2++) {
      if (type_default.exists(parents[i2]._is_new)) {
        p.addChild(parents[i2]);
        delete parents[i2]._is_new;
      } else {
        parents[i2].addChild(p);
      }
    }
    if (!type_default.exists(attributes.layer)) {
      attributes.layer = board.options.layer.line;
    }
    attr = type_default.copyAttributes(attributes, board.options, "bisector");
    l = jxg_default.createLine(board, [parents[1], p], attr);
    l.point = p;
    l.elType = "bisector";
    l.setParents(parents);
    l.subs = {
      point: p
    };
    l.inherits.push(p);
    return l;
  }
  throw new Error(
    "JSXGraph: Can't create angle bisector with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,point,point]"
  );
};
jxg_default.createAngularBisectorsOfTwoLines = function(board, parents, attributes) {
  var g1, g2, attr, ret, l1 = board.select(parents[0]), l2 = board.select(parents[1]);
  if (l1.elementClass !== constants_default.OBJECT_CLASS_LINE || l2.elementClass !== constants_default.OBJECT_CLASS_LINE) {
    throw new Error(
      "JSXGraph: Can't create angle bisectors of two lines with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [line,line]"
    );
  }
  if (!type_default.exists(attributes.layer)) {
    attributes.layer = board.options.layer.line;
  }
  attr = type_default.copyAttributes(attributes, board.options, "bisectorlines", "line1");
  g1 = board.create(
    "line",
    [
      function() {
        var d1 = math_default.hypot(l1.stdform[1], l1.stdform[2]), d2 = math_default.hypot(l2.stdform[1], l2.stdform[2]);
        return l1.stdform[0] / d1 - l2.stdform[0] / d2;
      },
      function() {
        var d1 = math_default.hypot(l1.stdform[1], l1.stdform[2]), d2 = math_default.hypot(l2.stdform[1], l2.stdform[2]);
        return l1.stdform[1] / d1 - l2.stdform[1] / d2;
      },
      function() {
        var d1 = math_default.hypot(l1.stdform[1], l1.stdform[2]), d2 = math_default.hypot(l2.stdform[1], l2.stdform[2]);
        return l1.stdform[2] / d1 - l2.stdform[2] / d2;
      }
    ],
    attr
  );
  if (!type_default.exists(attributes.layer)) {
    attributes.layer = board.options.layer.line;
  }
  attr = type_default.copyAttributes(attributes, board.options, "bisectorlines", "line2");
  g2 = board.create(
    "line",
    [
      function() {
        var d1 = math_default.hypot(l1.stdform[1], l1.stdform[2]), d2 = math_default.hypot(l2.stdform[1], l2.stdform[2]);
        return l1.stdform[0] / d1 + l2.stdform[0] / d2;
      },
      function() {
        var d1 = math_default.hypot(l1.stdform[1], l1.stdform[2]), d2 = math_default.hypot(l2.stdform[1], l2.stdform[2]);
        return l1.stdform[1] / d1 + l2.stdform[1] / d2;
      },
      function() {
        var d1 = math_default.hypot(l1.stdform[1], l1.stdform[2]), d2 = math_default.hypot(l2.stdform[1], l2.stdform[2]);
        return l1.stdform[2] / d1 + l2.stdform[2] / d2;
      }
    ],
    attr
  );
  ret = new composition_default({ line1: g1, line2: g2 });
  g1.dump = false;
  g2.dump = false;
  ret.elType = "bisectorlines";
  ret.setParents([l1.id, l2.id]);
  ret.subs = {
    line1: g1,
    line2: g2
  };
  return ret;
};
jxg_default.createCircumcenter = function(board, parents, attributes) {
  var p, i2, a, b, c;
  parents = type_default.providePoints(board, parents, attributes, "point");
  if (type_default.isPoint(parents[0]) && type_default.isPoint(parents[1]) && type_default.isPoint(parents[2])) {
    a = parents[0];
    b = parents[1];
    c = parents[2];
    p = jxg_default.createPoint(
      board,
      [
        function() {
          return geometry_default.circumcenter(a, b, c, board);
        }
      ],
      attributes
    );
    for (i2 = 0; i2 < 3; i2++) {
      if (type_default.exists(parents[i2]._is_new)) {
        p.addChild(parents[i2]);
        delete parents[i2]._is_new;
      } else {
        parents[i2].addChild(p);
      }
    }
    p.elType = "circumcenter";
    p.setParents(parents);
    p.generatePolynomial = function() {
      var a1 = a.symbolic.x, a2 = a.symbolic.y, b1 = b.symbolic.x, b2 = b.symbolic.y, c1 = c.symbolic.x, c2 = c.symbolic.y, t1 = p.symbolic.x, t2 = p.symbolic.y, poly1 = ["((", t1, ")-(", a1, "))^2+((", t2, ")-(", a2, "))^2-((", t1, ")-(", b1, "))^2-((", t2, ")-(", b2, "))^2"].join(""), poly2 = ["((", t1, ")-(", a1, "))^2+((", t2, ")-(", a2, "))^2-((", t1, ")-(", c1, "))^2-((", t2, ")-(", c2, "))^2"].join("");
      return [poly1, poly2];
    };
    return p;
  }
  throw new Error(
    "JSXGraph: Can't create circumcircle midpoint with parent types '" + typeof parents[0] + "', '" + typeof parents[1] + "' and '" + typeof parents[2] + "'.\nPossible parent types: [point,point,point]"
  );
};
jxg_default.createIncenter = function(board, parents, attributes) {
  var p, A, B, C, i2;
  parents = type_default.providePoints(board, parents, attributes, "point");
  if (parents.length >= 3 && type_default.isPoint(parents[0]) && type_default.isPoint(parents[1]) && type_default.isPoint(parents[2])) {
    A = parents[0];
    B = parents[1];
    C = parents[2];
    p = board.create(
      "point",
      [
        function() {
          var a, b, c;
          a = math_default.hypot(B.X() - C.X(), B.Y() - C.Y());
          b = math_default.hypot(A.X() - C.X(), A.Y() - C.Y());
          c = math_default.hypot(B.X() - A.X(), B.Y() - A.Y());
          return new coords_default(
            constants_default.COORDS_BY_USER,
            [
              (a * A.X() + b * B.X() + c * C.X()) / (a + b + c),
              (a * A.Y() + b * B.Y() + c * C.Y()) / (a + b + c)
            ],
            board
          );
        }
      ],
      attributes
    );
    for (i2 = 0; i2 < 3; i2++) {
      if (type_default.exists(parents[i2]._is_new)) {
        p.addChild(parents[i2]);
        delete parents[i2]._is_new;
      } else {
        parents[i2].addChild(p);
      }
    }
    p.elType = "incenter";
    p.setParents(parents);
  } else {
    throw new Error(
      "JSXGraph: Can't create incenter with parent types '" + typeof parents[0] + "', '" + typeof parents[1] + "' and '" + typeof parents[2] + "'.\nPossible parent types: [point,point,point]"
    );
  }
  return p;
};
jxg_default.createCircumcircle = function(board, parents, attributes) {
  var p, c, attr, i2;
  parents = type_default.providePoints(board, parents, attributes, "point");
  if (parents === false) {
    throw new Error(
      "JSXGraph: Can't create circumcircle with parent types '" + typeof parents[0] + "', '" + typeof parents[1] + "' and '" + typeof parents[2] + "'.\nPossible parent types: [point,point,point]"
    );
  }
  try {
    attr = type_default.copyAttributes(attributes, board.options, "circumcircle", "center");
    p = jxg_default.createCircumcenter(board, parents, attr);
    p.dump = false;
    if (!type_default.exists(attributes.layer)) {
      attributes.layer = board.options.layer.circle;
    }
    attr = type_default.copyAttributes(attributes, board.options, "circumcircle");
    c = jxg_default.createCircle(board, [p, parents[0]], attr);
    c.elType = "circumcircle";
    c.setParents(parents);
    c.subs = {
      center: p
    };
    c.inherits.push(c);
    for (i2 = 0; i2 < 3; i2++) {
      if (type_default.exists(parents[i2]._is_new)) {
        c.addChild(parents[i2]);
        delete parents[i2]._is_new;
      } else {
        parents[i2].addChild(c);
      }
    }
  } catch (e) {
    throw new Error(
      "JSXGraph: Can't create circumcircle with parent types '" + typeof parents[0] + "', '" + typeof parents[1] + "' and '" + typeof parents[2] + "'.\nPossible parent types: [point,point,point]"
    );
  }
  return c;
};
jxg_default.createIncircle = function(board, parents, attributes) {
  var i2, p, c, attr;
  parents = type_default.providePoints(board, parents, attributes, "point");
  if (parents === false) {
    throw new Error(
      "JSXGraph: Can't create circumcircle with parent types '" + typeof parents[0] + "', '" + typeof parents[1] + "' and '" + typeof parents[2] + "'.\nPossible parent types: [point,point,point]"
    );
  }
  try {
    attr = type_default.copyAttributes(attributes, board.options, "incircle", "center");
    p = jxg_default.createIncenter(board, parents, attr);
    p.dump = false;
    if (!type_default.exists(attributes.layer)) {
      attributes.layer = board.options.layer.circle;
    }
    attr = type_default.copyAttributes(attributes, board.options, "incircle");
    c = jxg_default.createCircle(
      board,
      [
        p,
        function() {
          var a = math_default.hypot(parents[1].X() - parents[2].X(), parents[1].Y() - parents[2].Y()), b = math_default.hypot(parents[0].X() - parents[2].X(), parents[0].Y() - parents[2].Y()), c2 = math_default.hypot(parents[1].X() - parents[0].X(), parents[1].Y() - parents[0].Y()), s = (a + b + c2) / 2;
          return Math.sqrt((s - a) * (s - b) * (s - c2) / s);
        }
      ],
      attr
    );
    c.elType = "incircle";
    c.setParents(parents);
    for (i2 = 0; i2 < 3; i2++) {
      if (type_default.exists(parents[i2]._is_new)) {
        c.addChild(parents[i2]);
        delete parents[i2]._is_new;
      } else {
        parents[i2].addChild(c);
      }
    }
    c.center = p;
    c.subs = {
      center: c.center
    };
    c.inherits.push(p);
  } catch (e) {
    throw new Error(
      "JSXGraph: Can't create circumcircle with parent types '" + typeof parents[0] + "', '" + typeof parents[1] + "' and '" + typeof parents[2] + "'.\nPossible parent types: [point,point,point]"
    );
  }
  return c;
};
jxg_default.createReflection = function(board, parents, attributes) {
  var l, org, r, r_c, t, i2, attr, attr2, errStr = "\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, line]";
  for (i2 = 0; i2 < parents.length; ++i2) {
    parents[i2] = board.select(parents[i2]);
  }
  attr = type_default.copyAttributes(attributes, board.options, "reflection");
  if (type_default.isPoint(parents[0])) {
    org = type_default.providePoints(board, [parents[0]], attr2)[0];
  } else if (parents[0].elementClass === constants_default.OBJECT_CLASS_CURVE || parents[0].elementClass === constants_default.OBJECT_CLASS_LINE || parents[0].type === constants_default.OBJECT_TYPE_POLYGON || parents[0].elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
    org = parents[0];
  } else {
    throw new Error(
      "JSXGraph: Can't create reflection element with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'." + errStr
    );
  }
  if (parents[1].elementClass === constants_default.OBJECT_CLASS_LINE) {
    l = parents[1];
  } else {
    throw new Error(
      "JSXGraph: Can't create reflected element with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'." + errStr
    );
  }
  t = jxg_default.createTransform(board, [l], { type: "reflect" });
  if (type_default.isPoint(org)) {
    r = jxg_default.createPoint(board, [org, t], attr);
  } else if (org.elementClass === constants_default.OBJECT_CLASS_CURVE) {
    r = jxg_default.createCurve(board, [org, t], attr);
  } else if (org.elementClass === constants_default.OBJECT_CLASS_LINE) {
    r = jxg_default.createLine(board, [org, t], attr);
  } else if (org.type === constants_default.OBJECT_TYPE_POLYGON) {
    r = jxg_default.createPolygon(board, [org, t], attr);
  } else if (org.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
    if (attr.type.toLowerCase() === "euclidean") {
      attr2 = type_default.copyAttributes(attributes, board.options, "reflection", "center");
      r_c = jxg_default.createPoint(board, [org.center, t], attr2);
      r_c.prepareUpdate().update().updateVisibility(type_default.evaluate(r_c.visProp.visible)).updateRenderer();
      r = jxg_default.createCircle(
        board,
        [
          r_c,
          function() {
            return org.Radius();
          }
        ],
        attr
      );
    } else {
      r = jxg_default.createCircle(board, [org, t], attr);
    }
  } else {
    throw new Error(
      "JSXGraph: Can't create reflected element with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'." + errStr
    );
  }
  if (type_default.exists(org._is_new)) {
    r.addChild(org);
    delete org._is_new;
  } else {
  }
  l.addChild(r);
  r.elType = "reflection";
  r.addParents(l);
  r.prepareUpdate().update();
  if (type_default.isPoint(r)) {
    r.generatePolynomial = function() {
      var a1 = l.point1.symbolic.x, a2 = l.point1.symbolic.y, b1 = l.point2.symbolic.x, b2 = l.point2.symbolic.y, p1 = org.symbolic.x, p2 = org.symbolic.y, r1 = r.symbolic.x, r2 = r.symbolic.y, poly1 = ["((", r2, ")-(", p2, "))*((", a2, ")-(", b2, "))+((", a1, ")-(", b1, "))*((", r1, ")-(", p1, "))"].join(""), poly2 = ["((", r1, ")-(", a1, "))^2+((", r2, ")-(", a2, "))^2-((", p1, ")-(", a1, "))^2-((", p2, ")-(", a2, "))^2"].join("");
      return [poly1, poly2];
    };
  }
  return r;
};
jxg_default.createMirrorElement = function(board, parents, attributes) {
  var org, i2, m, r, r_c, t, attr, attr2, errStr = "\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, point]";
  for (i2 = 0; i2 < parents.length; ++i2) {
    parents[i2] = board.select(parents[i2]);
  }
  attr = type_default.copyAttributes(attributes, board.options, "mirrorelement");
  if (type_default.isPoint(parents[0])) {
    org = type_default.providePoints(board, [parents[0]], attr)[0];
  } else if (parents[0].elementClass === constants_default.OBJECT_CLASS_CURVE || parents[0].elementClass === constants_default.OBJECT_CLASS_LINE || parents[0].type === constants_default.OBJECT_TYPE_POLYGON || parents[0].elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
    org = parents[0];
  } else {
    throw new Error(
      "JSXGraph: Can't create mirror element with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'." + errStr
    );
  }
  if (type_default.isPoint(parents[1])) {
    attr2 = type_default.copyAttributes(attributes, board.options, "mirrorelement", "point");
    m = type_default.providePoints(board, [parents[1]], attr2)[0];
  } else {
    throw new Error(
      "JSXGraph: Can't create mirror element with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'." + errStr
    );
  }
  t = jxg_default.createTransform(board, [Math.PI, m], { type: "rotate" });
  if (type_default.isPoint(org)) {
    r = jxg_default.createPoint(board, [org, t], attr);
  } else if (org.elementClass === constants_default.OBJECT_CLASS_CURVE) {
    r = jxg_default.createCurve(board, [org, t], attr);
  } else if (org.elementClass === constants_default.OBJECT_CLASS_LINE) {
    r = jxg_default.createLine(board, [org, t], attr);
  } else if (org.type === constants_default.OBJECT_TYPE_POLYGON) {
    r = jxg_default.createPolygon(board, [org, t], attr);
  } else if (org.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
    if (attr.type.toLowerCase() === "euclidean") {
      attr2 = type_default.copyAttributes(attributes, board.options, "mirrorelement", "center");
      r_c = jxg_default.createPoint(board, [org.center, t], attr2);
      r_c.prepareUpdate().update().updateVisibility(type_default.evaluate(r_c.visProp.visible)).updateRenderer();
      r = jxg_default.createCircle(
        board,
        [
          r_c,
          function() {
            return org.Radius();
          }
        ],
        attr
      );
    } else {
      r = jxg_default.createCircle(board, [org, t], attr);
    }
  } else {
    throw new Error(
      "JSXGraph: Can't create mirror element with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'." + errStr
    );
  }
  if (type_default.exists(org._is_new)) {
    r.addChild(org);
    delete org._is_new;
  } else {
  }
  m.addChild(r);
  r.elType = "mirrorelement";
  r.addParents(m);
  r.prepareUpdate().update();
  return r;
};
jxg_default.createMirrorPoint = function(board, parents, attributes) {
  var el = jxg_default.createMirrorElement(board, parents, attributes);
  el.elType = "mirrorpoint";
  return el;
};
jxg_default.createIntegral = function(board, parents, attributes) {
  var interval, curve, attr, start, end, startx, starty, endx, endy, pa_on_curve, pa_on_axis, pb_on_curve, pb_on_axis, txt_fun, t = null, p;
  if (type_default.isArray(parents[0]) && parents[1].elementClass === constants_default.OBJECT_CLASS_CURVE) {
    interval = parents[0];
    curve = parents[1];
  } else if (type_default.isArray(parents[1]) && parents[0].elementClass === constants_default.OBJECT_CLASS_CURVE) {
    interval = parents[1];
    curve = parents[0];
  } else {
    throw new Error(
      "JSXGraph: Can't create integral with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [[number|function,number|function],curve]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "integral");
  attr.withLabel = false;
  p = board.create("curve", [[0], [0]], attr);
  start = interval[0];
  end = interval[1];
  if (type_default.isFunction(start)) {
    startx = start;
    starty = function() {
      return curve.Y(startx());
    };
    start = startx();
  } else {
    startx = start;
    starty = curve.Y(start);
  }
  if (type_default.isFunction(end)) {
    endx = end;
    endy = function() {
      return curve.Y(endx());
    };
    end = endx();
  } else {
    endx = end;
    endy = curve.Y(end);
  }
  attr = type_default.copyAttributes(attributes, board.options, "integral", "curveLeft");
  pa_on_curve = board.create("glider", [startx, starty, curve], attr);
  if (type_default.isFunction(startx)) {
    pa_on_curve.hideElement();
  }
  attr = type_default.copyAttributes(attributes, board.options, "integral", "baseLeft");
  pa_on_axis = board.create("point", [
    function() {
      if (type_default.evaluate(p.visProp.axis) === "y") {
        return 0;
      }
      return pa_on_curve.X();
    },
    function() {
      if (type_default.evaluate(p.visProp.axis) === "y") {
        return pa_on_curve.Y();
      }
      return 0;
    }
  ], attr);
  attr = type_default.copyAttributes(attributes, board.options, "integral", "curveRight");
  pb_on_curve = board.create("glider", [endx, endy, curve], attr);
  if (type_default.isFunction(endx)) {
    pb_on_curve.hideElement();
  }
  attr = type_default.copyAttributes(attributes, board.options, "integral", "baseRight");
  pb_on_axis = board.create("point", [
    function() {
      if (type_default.evaluate(p.visProp.axis) === "y") {
        return 0;
      }
      return pb_on_curve.X();
    },
    function() {
      if (type_default.evaluate(p.visProp.axis) === "y") {
        return pb_on_curve.Y();
      }
      return 0;
    }
  ], attr);
  attr = type_default.copyAttributes(attributes, board.options, "integral");
  if (attr.withlabel !== false && attr.axis !== "y") {
    attr = type_default.copyAttributes(attributes, board.options, "integral", "label");
    attr = type_default.copyAttributes(attr, board.options, "label");
    t = board.create("text", [
      function() {
        var off = new coords_default(
          constants_default.COORDS_BY_SCREEN,
          [
            type_default.evaluate(this.visProp.offset[0]) + this.board.origin.scrCoords[1],
            0
          ],
          this.board,
          false
        ), bb = this.board.getBoundingBox(), dx = (bb[2] - bb[0]) * 0.1, x = pb_on_curve.X();
        if (x < bb[0]) {
          x = bb[0] + dx;
        } else if (x > bb[2]) {
          x = bb[2] - dx;
        }
        return x + off.usrCoords[1];
      },
      function() {
        var off = new coords_default(
          constants_default.COORDS_BY_SCREEN,
          [
            0,
            type_default.evaluate(this.visProp.offset[1]) + this.board.origin.scrCoords[2]
          ],
          this.board,
          false
        ), bb = this.board.getBoundingBox(), dy = (bb[1] - bb[3]) * 0.1, y = pb_on_curve.Y();
        if (y > bb[1]) {
          y = bb[1] - dy;
        } else if (y < bb[3]) {
          y = bb[3] + dy;
        }
        return y + off.usrCoords[2];
      },
      ""
    ], attr);
    txt_fun = function() {
      var Int = numerics_default.NewtonCotes([pa_on_axis.X(), pb_on_axis.X()], curve.Y), digits = type_default.evaluate(t.visProp.digits), val;
      if (t.useLocale()) {
        val = t.formatNumberLocale(Int, digits);
      } else {
        val = type_default.toFixed(Int, digits);
      }
      return "&int; = " + val;
    };
    t.setText(txt_fun);
    t.dump = false;
    pa_on_curve.addChild(t);
    pb_on_curve.addChild(t);
  }
  pa_on_curve.dump = false;
  pa_on_axis.dump = false;
  pb_on_curve.dump = false;
  pb_on_axis.dump = false;
  p.elType = "integral";
  p.setParents([curve.id, interval]);
  p.subs = {
    curveLeft: pa_on_curve,
    baseLeft: pa_on_axis,
    curveRight: pb_on_curve,
    baseRight: pb_on_axis
  };
  p.inherits.push(pa_on_curve, pa_on_axis, pb_on_curve, pb_on_axis);
  if (attr.withLabel) {
    p.subs.label = t;
    p.inherits.push(t);
  }
  p.Value = function() {
    return numerics_default.I([pa_on_axis.X(), pb_on_axis.X()], curve.Y);
  };
  p.updateDataArray = function() {
    var x, y, i2, left, right, lowx, upx, lowy, upy;
    if (type_default.evaluate(this.visProp.axis) === "y") {
      if (pa_on_curve.Y() < pb_on_curve.Y()) {
        lowx = pa_on_curve.X();
        lowy = pa_on_curve.Y();
        upx = pb_on_curve.X();
        upy = pb_on_curve.Y();
      } else {
        lowx = pb_on_curve.X();
        lowy = pb_on_curve.Y();
        upx = pa_on_curve.X();
        upy = pa_on_curve.Y();
      }
      left = Math.min(lowx, upx);
      right = Math.max(lowx, upx);
      x = [0, lowx];
      y = [lowy, lowy];
      for (i2 = 0; i2 < curve.numberPoints; i2++) {
        if (lowy <= curve.points[i2].usrCoords[2] && left <= curve.points[i2].usrCoords[1] && curve.points[i2].usrCoords[2] <= upy && curve.points[i2].usrCoords[1] <= right) {
          x.push(curve.points[i2].usrCoords[1]);
          y.push(curve.points[i2].usrCoords[2]);
        }
      }
      x.push(upx);
      y.push(upy);
      x.push(0);
      y.push(upy);
      x.push(0);
      y.push(lowy);
    } else {
      if (pa_on_axis.X() < pb_on_axis.X()) {
        left = pa_on_axis.X();
        right = pb_on_axis.X();
      } else {
        left = pb_on_axis.X();
        right = pa_on_axis.X();
      }
      x = [left, left];
      y = [0, curve.Y(left)];
      for (i2 = 0; i2 < curve.numberPoints; i2++) {
        if (left <= curve.points[i2].usrCoords[1] && curve.points[i2].usrCoords[1] <= right) {
          x.push(curve.points[i2].usrCoords[1]);
          y.push(curve.points[i2].usrCoords[2]);
        }
      }
      x.push(right);
      y.push(curve.Y(right));
      x.push(right);
      y.push(0);
      x.push(left);
      y.push(0);
    }
    this.dataX = x;
    this.dataY = y;
  };
  pa_on_curve.addChild(p);
  pb_on_curve.addChild(p);
  pa_on_axis.addChild(p);
  pb_on_axis.addChild(p);
  p.baseLeft = pa_on_axis;
  p.baseRight = pb_on_axis;
  p.curveLeft = pa_on_curve;
  p.curveRight = pb_on_curve;
  p.methodMap = jxg_default.deepCopy(p.methodMap, {
    curveLeft: "curveLeft",
    baseLeft: "baseLeft",
    curveRight: "curveRight",
    baseRight: "baseRight",
    Value: "Value"
  });
  p.label = t;
  return p;
};
jxg_default.createInequality = function(board, parents, attributes) {
  var f, a, attr;
  attr = type_default.copyAttributes(attributes, board.options, "inequality");
  if (parents[0].elementClass === constants_default.OBJECT_CLASS_LINE) {
    a = board.create("curve", [[], []], attr);
    a.hasPoint = function() {
      return false;
    };
    a.updateDataArray = function() {
      var i1, i2, h, bb = board.getBoundingBox(), inverse = type_default.evaluate(this.visProp.inverse), factor = inverse ? -1 : 1, expansion = 1.5, w = expansion * Math.max(bb[2] - bb[0], bb[1] - bb[3]), dp = {
        coords: {
          usrCoords: [1, (bb[0] + bb[2]) * 0.5, inverse ? bb[1] : bb[3]]
        }
      }, slope1 = parents[0].stdform.slice(1), slope2 = slope1;
      h = expansion * Math.max(
        geometry_default.perpendicular(parents[0], dp, board)[0].distance(
          constants_default.COORDS_BY_USER,
          dp.coords
        ),
        w
      );
      h *= factor;
      dp = {
        coords: {
          usrCoords: [1, (bb[0] + bb[2]) * 0.5, (bb[1] + bb[3]) * 0.5]
        }
      };
      if (Math.abs(math_default.innerProduct(dp.coords.usrCoords, parents[0].stdform, 3)) >= math_default.eps) {
        dp = geometry_default.perpendicular(parents[0], dp, board)[0].usrCoords;
      } else {
        dp = dp.coords.usrCoords;
      }
      i1 = [1, dp[1] + slope1[1] * w, dp[2] - slope1[0] * w];
      i2 = [1, dp[1] - slope2[1] * w, dp[2] + slope2[0] * w];
      this.dataX = [i1[1], i1[1] + slope1[0] * h, i2[1] + slope2[0] * h, i2[1], i1[1]];
      this.dataY = [i1[2], i1[2] + slope1[1] * h, i2[2] + slope2[1] * h, i2[2], i1[2]];
    };
  } else if (parents[0].elementClass === constants_default.OBJECT_CLASS_CURVE && parents[0].visProp.curvetype === "functiongraph") {
    a = board.create("curve", [[], []], attr);
    a.updateDataArray = function() {
      var bbox = this.board.getBoundingBox(), points = [], infty, first, last, len, i2, mi = parents[0].minX(), ma = parents[0].maxX(), curve_mi, curve_ma, firstx, lastx, enlarge = (bbox[1] - bbox[3]) * 0.3, inverse = type_default.evaluate(this.visProp.inverse);
      infty = inverse ? 1 : 3;
      this.dataX = [];
      this.dataY = [];
      len = parents[0].points.length;
      if (len === 0) {
        return;
      }
      bbox[1] += enlarge;
      bbox[3] -= enlarge;
      last = -1;
      while (last < len - 1) {
        for (i2 = last + 1, first = len; i2 < len; i2++) {
          if (parents[0].points[i2].isReal()) {
            first = i2;
            break;
          }
        }
        if (first >= len) {
          break;
        }
        for (i2 = first, last = len - 1; i2 < len - 1; i2++) {
          if (!parents[0].points[i2 + 1].isReal()) {
            last = i2;
            break;
          }
        }
        firstx = parents[0].points[first].usrCoords[1];
        lastx = parents[0].points[last].usrCoords[1];
        curve_mi = bbox[0] < mi ? mi : bbox[0];
        curve_ma = bbox[2] > ma ? ma : bbox[2];
        curve_mi = first === 0 ? curve_mi : Math.max(curve_mi, firstx);
        curve_ma = last === len - 1 ? curve_ma : Math.min(curve_ma, lastx);
        curve_mi = first === 0 ? mi : firstx;
        curve_ma = last === len - 1 ? ma : lastx;
        points = [];
        points.push([1, curve_mi, bbox[infty]]);
        points.push([1, curve_mi, parents[0].points[first].usrCoords[2]]);
        for (i2 = first; i2 <= last; i2++) {
          points.push(parents[0].points[i2].usrCoords);
        }
        points.push([1, curve_ma, parents[0].points[last].usrCoords[2]]);
        points.push([1, curve_ma, bbox[infty]]);
        points.push(points[0]);
        for (i2 = 0; i2 < points.length; i2++) {
          this.dataX.push(points[i2][1]);
          this.dataY.push(points[i2][2]);
        }
        if (last < len - 1) {
          this.dataX.push(NaN);
          this.dataY.push(NaN);
        }
      }
    };
    a.hasPoint = function() {
      return false;
    };
  } else {
    f = type_default.createFunction(parents[0]);
    a.addParentsFromJCFunctions([f]);
    if (!type_default.exists(f)) {
      throw new Error(
        "JSXGraph: Can't create area with the given parents.\nPossible parent types: [line], [function]"
      );
    }
  }
  a.addParents(parents[0]);
  return a;
};
jxg_default.registerElement("arrowparallel", jxg_default.createArrowParallel);
jxg_default.registerElement("bisector", jxg_default.createBisector);
jxg_default.registerElement("bisectorlines", jxg_default.createAngularBisectorsOfTwoLines);
jxg_default.registerElement("msector", jxg_default.createMsector);
jxg_default.registerElement("circumcircle", jxg_default.createCircumcircle);
jxg_default.registerElement("circumcirclemidpoint", jxg_default.createCircumcenter);
jxg_default.registerElement("circumcenter", jxg_default.createCircumcenter);
jxg_default.registerElement("incenter", jxg_default.createIncenter);
jxg_default.registerElement("incircle", jxg_default.createIncircle);
jxg_default.registerElement("integral", jxg_default.createIntegral);
jxg_default.registerElement("midpoint", jxg_default.createMidpoint);
jxg_default.registerElement("mirrorelement", jxg_default.createMirrorElement);
jxg_default.registerElement("mirrorpoint", jxg_default.createMirrorPoint);
jxg_default.registerElement("normal", jxg_default.createNormal);
jxg_default.registerElement("orthogonalprojection", jxg_default.createOrthogonalProjection);
jxg_default.registerElement("parallel", jxg_default.createParallel);
jxg_default.registerElement("parallelpoint", jxg_default.createParallelPoint);
jxg_default.registerElement("perpendicular", jxg_default.createPerpendicular);
jxg_default.registerElement("perpendicularpoint", jxg_default.createPerpendicularPoint);
jxg_default.registerElement("perpendicularsegment", jxg_default.createPerpendicularSegment);
jxg_default.registerElement("reflection", jxg_default.createReflection);
jxg_default.registerElement("inequality", jxg_default.createInequality);

// node_modules/jsxgraph/src/element/grid.js
jxg_default.createGrid = function(board, parents, attributes) {
  const eps = math_default.eps, maxLines = 5e3;
  var majorGrid, minorGrid, parentAxes, attrGrid, attrMajor, attrMinor, majorStep, majorSize = [], majorRadius = [], createDataArrayForFace;
  parentAxes = parents;
  if (parentAxes.length > 2 || parentAxes.length >= 1 && parentAxes[0].elType !== "axis" || parentAxes.length >= 2 && parentAxes[1].elType !== "axis") {
    throw new Error(
      "JSXGraph: Can't create 'grid' with parent type '" + parents[0].elType + "'. Possible parent types: [axis,axis]"
    );
  }
  if (!type_default.exists(parentAxes[0]) && type_default.exists(board.defaultAxes)) {
    parentAxes[0] = board.defaultAxes.x;
  }
  if (!type_default.exists(parentAxes[1]) && type_default.exists(board.defaultAxes)) {
    parentAxes[1] = board.defaultAxes.y;
  }
  createDataArrayForFace = function(face, grid, x, y, radiusX, radiusY, bbox) {
    var t, q, m, n, array, rx2, ry2;
    switch (face.toLowerCase()) {
      case ".":
      case "point":
        grid.visProp.linecap = "round";
        return [
          [x, x, NaN],
          [y, y, NaN]
        ];
      case "o":
      case "circle":
        grid.visProp.linecap = "square";
        grid.bezierDegree = 3;
        q = 4 * Math.tan(Math.PI / 8) / 3;
        return [
          [
            x + radiusX,
            x + radiusX,
            x + q * radiusX,
            x,
            x - q * radiusX,
            x - radiusX,
            x - radiusX,
            x - radiusX,
            x - q * radiusX,
            x,
            x + q * radiusX,
            x + radiusX,
            x + radiusX,
            NaN
          ],
          [
            y,
            y + q * radiusY,
            y + radiusY,
            y + radiusY,
            y + radiusY,
            y + q * radiusY,
            y,
            y - q * radiusY,
            y - radiusY,
            y - radiusY,
            y - radiusY,
            y - q * radiusY,
            y,
            NaN
          ]
        ];
      case "regpol":
      case "regularpolygon":
        grid.visProp.linecap = "round";
        n = type_default.evaluate(grid.visProp.polygonvertices);
        array = [[], []];
        for (t = 0; t <= 2 * Math.PI; t += 2 * Math.PI / n) {
          array[0].push(x - radiusX * Math.sin(t));
          array[1].push(y - radiusY * Math.cos(t));
        }
        array[0].push(NaN);
        array[1].push(NaN);
        return array;
      case "[]":
      case "square":
        grid.visProp.linecap = "square";
        return [
          [x - radiusX, x + radiusX, x + radiusX, x - radiusX, x - radiusX, NaN],
          [y + radiusY, y + radiusY, y - radiusY, y - radiusY, y + radiusY, NaN]
        ];
      case "<>":
      case "diamond":
        grid.visProp.linecap = "square";
        return [
          [x, x + radiusX, x, x - radiusX, x, NaN],
          [y + radiusY, y, y - radiusY, y, y + radiusY, NaN]
        ];
      case "<<>>":
      case "diamond2":
        grid.visProp.linecap = "square";
        rx2 = radiusX * Math.sqrt(2);
        ry2 = radiusY * Math.sqrt(2);
        return [
          [x, x + rx2, x, x - rx2, x, NaN],
          [y + ry2, y, y - ry2, y, y + ry2, NaN]
        ];
      case "x":
      case "cross":
        return [
          [x - radiusX, x + radiusX, NaN, x - radiusX, x + radiusX, NaN],
          [y + radiusY, y - radiusY, NaN, y - radiusY, y + radiusY, NaN]
        ];
      case "+":
      case "plus":
        return [
          [x - radiusX, x + radiusX, NaN, x, x, NaN],
          [y, y, NaN, y - radiusY, y + radiusY, NaN]
        ];
      case "-":
      case "minus":
        return [
          [x - radiusX, x + radiusX, NaN],
          [y, y, NaN]
        ];
      case "|":
      case "divide":
        return [
          [x, x, NaN],
          [y - radiusY, y + radiusY, NaN]
        ];
      case "^":
      case "a":
      case "A":
      case "triangleup":
        return [
          [x - radiusX, x, x + radiusX, NaN],
          [y - radiusY, y, y - radiusY, NaN]
        ];
      case "v":
      case "triangledown":
        return [
          [x - radiusX, x, x + radiusX, NaN],
          [y + radiusY, y, y + radiusY, NaN]
        ];
      case "<":
      case "triangleleft":
        return [
          [x + radiusX, x, x + radiusX, NaN],
          [y + radiusY, y, y - radiusY, NaN]
        ];
      case ">":
      case "triangleright":
        return [
          [x - radiusX, x, x - radiusX, NaN],
          [y + radiusY, y, y - radiusY, NaN]
        ];
      case "line":
        m = type_default.evaluate(grid.visProp.margin);
        return [
          // [x, x, NaN, bbox[0] + (4 / grid.board.unitX), bbox[2] - (4 / grid.board.unitX), NaN],
          [x, x, NaN, bbox[0] - m / grid.board.unitX, bbox[2] + m / grid.board.unitX, NaN],
          [bbox[1] + m / grid.board.unitY, bbox[3] - m / grid.board.unitY, NaN, y, y, NaN]
        ];
      default:
        return [[], []];
    }
  };
  attrGrid = type_default.copyAttributes(attributes, board.options, "grid");
  type_default.mergeAttr(board.options.grid, attrGrid.themes[attrGrid.theme], false);
  attrGrid = type_default.copyAttributes(attributes, board.options, "grid");
  attrMajor = type_default.copyAttributes(attributes, board.options, "grid", "major");
  type_default.mergeAttr(attrMajor, attrGrid, true);
  majorGrid = board.create("curve", [[null], [null]], attrMajor);
  majorGrid.elType = "grid";
  majorGrid.type = constants_default.OBJECT_TYPE_GRID;
  attrMinor = type_default.copyAttributes(attributes, board.options, "grid", "minor");
  type_default.mergeAttr(attrMinor, attrGrid, true);
  if (attrMinor.id === attrMajor.id) {
    attrMinor.id = attrMajor.id + "_minor";
  }
  if (attrMinor.name === attrMajor.name) {
    attrMinor.name = attrMajor.name + "_minor";
  }
  minorGrid = board.create("curve", [[null], [null]], attrMinor);
  minorGrid.elType = "grid";
  minorGrid.type = constants_default.OBJECT_TYPE_GRID;
  majorGrid.minorGrid = minorGrid;
  minorGrid.majorGrid = majorGrid;
  majorGrid.hasPoint = function() {
    return false;
  };
  minorGrid.hasPoint = function() {
    return false;
  };
  majorGrid.inherits.push(minorGrid);
  majorGrid.updateDataArray = function() {
    var bbox = this.board.getBoundingBox(), startX, startY, x, y, dataArr, finite, gridX = type_default.evaluate(this.visProp.gridx), gridY = type_default.evaluate(this.visProp.gridy), face = type_default.evaluate(this.visProp.face), drawZero = type_default.evaluate(this.visProp.drawzero), drawZeroOrigin = drawZero === true || type_default.isObject(drawZero) && type_default.evaluate(drawZero.origin) === true, drawZeroX = drawZero === true || type_default.isObject(drawZero) && type_default.evaluate(drawZero.x) === true, drawZeroY = drawZero === true || type_default.isObject(drawZero) && type_default.evaluate(drawZero.y) === true, includeBoundaries = type_default.evaluate(this.visProp.includeboundaries), forceSquare = type_default.evaluate(this.visProp.forcesquare);
    this.dataX = [];
    this.dataY = [];
    majorStep = type_default.evaluate(this.visProp.majorstep);
    if (!type_default.isArray(majorStep)) {
      majorStep = [majorStep, majorStep];
    }
    if (majorStep.length < 2) {
      majorStep = [majorStep[0], majorStep[0]];
    }
    if (type_default.exists(gridX)) {
      jxg_default.deprecated("gridX", "majorStep");
      majorStep[0] = gridX;
    }
    if (type_default.exists(gridY)) {
      jxg_default.deprecated("gridY", "majorStep");
      majorStep[1] = gridY;
    }
    if (majorStep[0] === "auto") {
      majorStep[0] = 1;
      if (type_default.exists(parentAxes[0])) {
        majorStep[0] = parentAxes[0].ticks[0].getDistanceMajorTicks();
      }
    } else {
      majorStep[0] = type_default.parseNumber(majorStep[0], Math.abs(bbox[1] - bbox[3]), 1 / this.board.unitX);
    }
    if (majorStep[1] === "auto") {
      majorStep[1] = 1;
      if (type_default.exists(parentAxes[1])) {
        majorStep[1] = parentAxes[1].ticks[0].getDistanceMajorTicks();
      }
    } else {
      majorStep[1] = type_default.parseNumber(majorStep[1], Math.abs(bbox[0] - bbox[2]), 1 / this.board.unitY);
    }
    if (forceSquare === "min" || forceSquare === true) {
      if (majorStep[0] * this.board.unitX <= majorStep[1] * this.board.unitY) {
        majorStep[1] = majorStep[0] / this.board.unitY * this.board.unitX;
      } else {
        majorStep[0] = majorStep[1] / this.board.unitX * this.board.unitY;
      }
    } else if (forceSquare === "max") {
      if (majorStep[0] * this.board.unitX <= majorStep[1] * this.board.unitY) {
        majorStep[0] = majorStep[1] / this.board.unitX * this.board.unitY;
      } else {
        majorStep[1] = majorStep[0] / this.board.unitY * this.board.unitX;
      }
    }
    majorSize = type_default.evaluate(this.visProp.size);
    if (!type_default.isArray(majorSize)) {
      majorSize = [majorSize, majorSize];
    }
    if (majorSize.length < 2) {
      majorSize = [majorSize[0], majorSize[0]];
    }
    if (type_default.isNumber(majorSize[0], true) || majorSize[0].indexOf("abs") > -1) {
      majorSize[0] = ("" + majorSize[0]).replace(/\s+abs\s+/, "") + "px";
    }
    if (type_default.isNumber(majorSize[1], true) || majorSize[1].indexOf("abs") > -1) {
      majorSize[1] = ("" + majorSize[1]).replace(/\s+abs\s+/, "") + "px";
    }
    majorSize[0] = type_default.parseNumber(majorSize[0], majorStep[0], 1 / this.board.unitX);
    majorRadius[0] = majorSize[0] / 2;
    majorSize[1] = type_default.parseNumber(majorSize[1], majorStep[1], 1 / this.board.unitY);
    majorRadius[1] = majorSize[1] / 2;
    startX = math_default.roundToStep(bbox[0], majorStep[0]);
    startY = math_default.roundToStep(bbox[1], majorStep[1]);
    finite = isFinite(startX) && isFinite(startY) && isFinite(bbox[2]) && isFinite(bbox[3]) && Math.abs(bbox[2]) < Math.abs(majorStep[0] * maxLines) && Math.abs(bbox[3]) < Math.abs(majorStep[1] * maxLines);
    for (y = startY; finite && y >= bbox[3]; y -= majorStep[1]) {
      for (x = startX; finite && x <= bbox[2]; x += majorStep[0]) {
        if (!drawZeroOrigin && Math.abs(y) < eps && Math.abs(x) < eps || !drawZeroX && Math.abs(y) < eps && Math.abs(x) >= eps || !drawZeroY && Math.abs(x) < eps && Math.abs(y) >= eps || !includeBoundaries && (x <= bbox[0] + majorRadius[0] || x >= bbox[2] - majorRadius[0] || y <= bbox[3] + majorRadius[1] || y >= bbox[1] - majorRadius[1])) {
          continue;
        }
        dataArr = createDataArrayForFace(face, majorGrid, x, y, majorRadius[0], majorRadius[1], bbox);
        this.dataX = this.dataX.concat(dataArr[0]);
        this.dataY = this.dataY.concat(dataArr[1]);
      }
    }
  };
  minorGrid.updateDataArray = function() {
    var bbox = this.board.getBoundingBox(), startX, startY, x, y, dataArr, finite, minorStep = [], minorRadius = [], XdisTo0, XdisFrom0, YdisTo0, YdisFrom0, dis0To, dis1To, dis2To, dis3To, dis0From, dis1From, dis2From, dis3From, minorElements = type_default.evaluate(this.visProp.minorelements), minorSize = type_default.evaluate(this.visProp.size), minorFace = type_default.evaluate(this.visProp.face), minorDrawZero = type_default.evaluate(this.visProp.drawzero), minorDrawZeroX = minorDrawZero === true || type_default.isObject(minorDrawZero) && type_default.evaluate(minorDrawZero.x) === true, minorDrawZeroY = minorDrawZero === true || type_default.isObject(minorDrawZero) && type_default.evaluate(minorDrawZero.y) === true, majorFace = type_default.evaluate(this.majorGrid.visProp.face), majorDrawZero = type_default.evaluate(this.majorGrid.visProp.drawzero), majorDrawZeroOrigin = majorDrawZero === true || type_default.isObject(majorDrawZero) && type_default.evaluate(majorDrawZero.origin) === true, majorDrawZeroX = majorDrawZero === true || type_default.isObject(majorDrawZero) && type_default.evaluate(majorDrawZero.x) === true, majorDrawZeroY = majorDrawZero === true || type_default.isObject(majorDrawZero) && type_default.evaluate(majorDrawZero.y) === true, includeBoundaries = type_default.evaluate(this.visProp.includeboundaries);
    this.dataX = [];
    this.dataY = [];
    if (!type_default.isArray(minorElements)) {
      minorElements = [minorElements, minorElements];
    }
    if (minorElements.length < 2) {
      minorElements = [minorElements[0], minorElements[0]];
    }
    if (type_default.isNumber(minorElements[0], true)) {
      minorElements[0] = parseFloat(minorElements[0]);
    } else {
      minorElements[0] = 0;
      if (type_default.exists(parentAxes[0])) {
        minorElements[0] = type_default.evaluate(parentAxes[0].getAttribute("ticks").minorticks);
      }
    }
    minorStep[0] = majorStep[0] / (minorElements[0] + 1);
    if (type_default.isNumber(minorElements[1], true)) {
      minorElements[1] = parseFloat(minorElements[1]);
    } else {
      minorElements[1] = 0;
      if (type_default.exists(parentAxes[1])) {
        minorElements[1] = type_default.evaluate(parentAxes[1].getAttribute("ticks").minorticks);
      }
    }
    minorStep[1] = majorStep[1] / (minorElements[1] + 1);
    if (!type_default.isArray(minorSize)) {
      minorSize = [minorSize, minorSize];
    }
    if (minorSize.length < 2) {
      minorSize = [minorSize[0], minorSize[0]];
    }
    minorSize[0] = type_default.parseNumber(minorSize[0], minorStep[0], 1 / this.board.unitX);
    minorSize[1] = type_default.parseNumber(minorSize[1], minorStep[1], 1 / this.board.unitY);
    minorRadius[0] = minorSize[0] * 0.5;
    minorRadius[1] = minorSize[1] * 0.5;
    startX = math_default.roundToStep(bbox[0], minorStep[0]);
    startY = math_default.roundToStep(bbox[1], minorStep[1]);
    finite = isFinite(startX) && isFinite(startY) && isFinite(bbox[2]) && isFinite(bbox[3]) && Math.abs(bbox[2]) <= Math.abs(minorStep[0] * maxLines) && Math.abs(bbox[3]) < Math.abs(minorStep[1] * maxLines);
    for (y = startY; finite && y >= bbox[3]; y -= minorStep[1]) {
      for (x = startX; finite && x <= bbox[2]; x += minorStep[0]) {
        XdisTo0 = math_default.roundToStep(Math.abs(x), majorStep[0]);
        XdisTo0 = Math.abs(XdisTo0 - Math.abs(x));
        XdisFrom0 = majorStep[0] - XdisTo0;
        YdisTo0 = math_default.roundToStep(Math.abs(y), majorStep[1]);
        YdisTo0 = Math.abs(YdisTo0 - Math.abs(y));
        YdisFrom0 = majorStep[1] - YdisTo0;
        if (majorFace === "line") {
          if (XdisTo0 - minorRadius[0] - majorRadius[0] < eps || XdisFrom0 - minorRadius[0] - majorRadius[0] < eps || YdisTo0 - minorRadius[1] - majorRadius[1] < eps || YdisFrom0 - minorRadius[1] - majorRadius[1] < eps) {
            continue;
          }
        } else {
          if ((XdisTo0 - minorRadius[0] - majorRadius[0] < eps || XdisFrom0 - minorRadius[0] - majorRadius[0] < eps) && (YdisTo0 - minorRadius[1] - majorRadius[1] < eps || YdisFrom0 - minorRadius[1] - majorRadius[1] < eps)) {
            if ((majorDrawZeroOrigin || majorRadius[1] - Math.abs(y) + minorRadius[1] < eps || majorRadius[0] - Math.abs(x) + minorRadius[0] < eps) && (majorDrawZeroX || majorRadius[1] - Math.abs(y) + minorRadius[1] < eps || majorRadius[0] + Math.abs(x) - minorRadius[0] < eps) && (majorDrawZeroY || majorRadius[0] - Math.abs(x) + minorRadius[0] < eps || majorRadius[1] + Math.abs(y) - minorRadius[1] < eps)) {
              continue;
            }
          }
        }
        if (!minorDrawZeroY && Math.abs(x) < eps || !minorDrawZeroX && Math.abs(y) < eps) {
          continue;
        }
        dis0To = Math.abs(bbox[0] % majorStep[0]);
        dis1To = Math.abs(bbox[1] % majorStep[1]);
        dis2To = Math.abs(bbox[2] % majorStep[0]);
        dis3To = Math.abs(bbox[3] % majorStep[1]);
        dis0From = majorStep[0] - dis0To;
        dis1From = majorStep[1] - dis1To;
        dis2From = majorStep[0] - dis2To;
        dis3From = majorStep[1] - dis3To;
        if (!includeBoundaries && (x - minorRadius[0] - bbox[0] - majorRadius[0] + dis0From < eps && dis0From - majorRadius[0] < eps || x - minorRadius[0] - bbox[0] - majorRadius[0] - dis0To < eps && dis0To - majorRadius[0] < eps || -x - minorRadius[0] + bbox[2] - majorRadius[0] + dis2From < eps && dis2From - majorRadius[0] < eps || -x - minorRadius[0] + bbox[2] - majorRadius[0] - dis2To < eps && dis2To - majorRadius[0] < eps || -y - minorRadius[1] + bbox[1] - majorRadius[1] + dis1From < eps && dis1From - majorRadius[1] < eps || -y - minorRadius[1] + bbox[1] - majorRadius[1] - dis1To < eps && dis1To - majorRadius[1] < eps || y - minorRadius[1] - bbox[3] - majorRadius[1] + dis3From < eps && dis3From - majorRadius[1] < eps || y - minorRadius[1] - bbox[3] - majorRadius[1] - dis3To < eps && dis3To - majorRadius[1] < eps || -y - minorRadius[1] + bbox[1] < eps || x - minorRadius[0] - bbox[0] < eps || y - minorRadius[1] - bbox[3] < eps || -x - minorRadius[0] + bbox[2] < eps)) {
          continue;
        }
        dataArr = createDataArrayForFace(minorFace, minorGrid, x, y, minorRadius[0], minorRadius[1], bbox);
        this.dataX = this.dataX.concat(dataArr[0]);
        this.dataY = this.dataY.concat(dataArr[1]);
      }
    }
  };
  board.grids.push(majorGrid);
  board.grids.push(minorGrid);
  return majorGrid;
};
jxg_default.registerElement("grid", jxg_default.createGrid);

// node_modules/jsxgraph/src/element/locus.js
jxg_default.createLocus = function(board, parents, attributes) {
  var c, p;
  if (type_default.isArray(parents) && parents.length === 1 && type_default.isPoint(parents[0])) {
    p = parents[0];
  } else {
    throw new Error(
      "JSXGraph: Can't create locus with parent of type other than point.\nPossible parent types: [point]"
    );
  }
  c = board.create("curve", [[null], [null]], attributes);
  c.dontCallServer = false;
  c.elType = "locus";
  c.setParents([p.id]);
  c.updateDataArray = function() {
    var spe, cb, data;
    if (c.board.mode > 0) {
      return;
    }
    spe = symbolic_default.generatePolynomials(board, p, true).join("|");
    if (spe === c.spe) {
      return;
    }
    c.spe = spe;
    cb = function(x, y, eq, t) {
      c.dataX = x;
      c.dataY = y;
      c.eq = eq;
      c.ctime = t;
      c.generatePolynomial = function(equations) {
        return function(point) {
          var i2, x2 = "(" + point.symbolic.x + ")", y2 = "(" + point.symbolic.y + ")", res = [];
          for (i2 = 0; i2 < equations.length; i2++) {
            res[i2] = equations[i2].replace(/\*\*/g, "^").replace(/x/g, x2).replace(/y/g, y2);
          }
          return res;
        };
      }(eq);
    };
    data = symbolic_default.geometricLocusByGroebnerBase(board, p, cb);
    cb(data.datax, data.datay, data.polynomial, data.exectime);
  };
  return c;
};
jxg_default.registerElement("locus", jxg_default.createLocus);

// node_modules/jsxgraph/src/base/image.js
jxg_default.Image = function(board, coords, attributes, url, size2) {
  this.constructor(board, attributes, constants_default.OBJECT_TYPE_IMAGE, constants_default.OBJECT_CLASS_OTHER);
  this.element = this.board.select(attributes.anchor);
  this.coordsConstructor(coords);
  this.W = type_default.createFunction(size2[0], this.board, "");
  this.H = type_default.createFunction(size2[1], this.board, "");
  this.addParentsFromJCFunctions([this.W, this.H]);
  this.usrSize = [this.W(), this.H()];
  this.size = [
    Math.abs(this.usrSize[0] * board.unitX),
    Math.abs(this.usrSize[1] * board.unitY)
  ];
  this.url = url;
  this.elType = "image";
  this.span = [
    this.coords.usrCoords.slice(0),
    [this.coords.usrCoords[0], this.W(), 0],
    [this.coords.usrCoords[0], 0, this.H()]
  ];
  this.id = this.board.setId(this, "Im");
  this.board.renderer.drawImage(this);
  this.board.finalizeAdding(this);
  this.methodMap = jxg_default.deepCopy(this.methodMap, {
    addTransformation: "addTransform",
    trans: "addTransform",
    W: "W",
    Width: "W",
    H: "H",
    Height: "H",
    setSize: "setSize"
  });
};
jxg_default.Image.prototype = new element_default();
type_default.copyPrototypeMethods(jxg_default.Image, coordselement_default, "coordsConstructor");
jxg_default.extend(
  jxg_default.Image.prototype,
  /** @lends JXG.Image.prototype */
  {
    /**
     * Checks whether (x,y) is over or near the image;
     * @param {Number} x Coordinate in x direction, screen coordinates.
     * @param {Number} y Coordinate in y direction, screen coordinates.
     * @returns {Boolean} True if (x,y) is over the image, False otherwise.
     */
    hasPoint: function(x, y) {
      var dx, dy, r, type, prec, c, v, p, dot, len = this.transformations.length;
      if (type_default.isObject(type_default.evaluate(this.visProp.precision))) {
        type = this.board._inputDevice;
        prec = type_default.evaluate(this.visProp.precision[type]);
      } else {
        prec = this.board.options.precision.hasPoint;
      }
      if (len === 0) {
        dx = x - this.coords.scrCoords[1];
        dy = this.coords.scrCoords[2] - y;
        r = prec;
        return dx >= -r && dx - this.size[0] <= r && dy >= -r && dy - this.size[1] <= r;
      }
      c = new coords_default(constants_default.COORDS_BY_SCREEN, [x, y], this.board);
      c = c.usrCoords;
      v = [c[0] - this.span[0][0], c[1] - this.span[0][1], c[2] - this.span[0][2]];
      dot = math_default.innerProduct;
      p = dot(v, this.span[1]);
      if (0 <= p && p <= dot(this.span[1], this.span[1])) {
        p = dot(v, this.span[2]);
        if (0 <= p && p <= dot(this.span[2], this.span[2])) {
          return true;
        }
      }
      return false;
    },
    /**
     * Recalculate the coordinates of lower left corner and the width and height.
     *
     * @returns {JXG.GeometryElement} A reference to the element
     * @private
     */
    update: function(fromParent) {
      if (!this.needsUpdate) {
        return this;
      }
      this.updateCoords(fromParent);
      this.updateSize();
      this.updateSpan();
      return this;
    },
    /**
     * Send an update request to the renderer.
     * @private
     */
    updateRenderer: function() {
      return this.updateRendererGeneric("updateImage");
    },
    /**
     * Updates the internal arrays containing size of the image.
     * @returns {JXG.GeometryElement} A reference to the element
     * @private
     */
    updateSize: function() {
      this.usrSize = [this.W(), this.H()];
      this.size = [
        Math.abs(this.usrSize[0] * this.board.unitX),
        Math.abs(this.usrSize[1] * this.board.unitY)
      ];
      return this;
    },
    /**
     * Update the anchor point of the image, i.e. the lower left corner
     * and the two vectors which span the rectangle.
     * @returns {JXG.GeometryElement} A reference to the element
     * @private
     *
     */
    updateSpan: function() {
      var i2, j, len = this.transformations.length, v = [];
      if (len === 0) {
        this.span = [
          [this.Z(), this.X(), this.Y()],
          [this.Z(), this.W(), 0],
          [this.Z(), 0, this.H()]
        ];
      } else {
        v[0] = [this.Z(), this.X(), this.Y()];
        v[1] = [this.Z(), this.X() + this.W(), this.Y()];
        v[2] = [this.Z(), this.X(), this.Y() + this.H()];
        for (i2 = 0; i2 < len; i2++) {
          for (j = 0; j < 3; j++) {
            v[j] = math_default.matVecMult(this.transformations[i2].matrix, v[j]);
          }
        }
        for (j = 0; j < 3; j++) {
          v[j][1] /= v[j][0];
          v[j][2] /= v[j][0];
          v[j][0] /= v[j][0];
        }
        for (j = 1; j < 3; j++) {
          v[j][0] -= v[0][0];
          v[j][1] -= v[0][1];
          v[j][2] -= v[0][2];
        }
        this.span = v;
      }
      return this;
    },
    addTransform: function(transform) {
      var i2;
      if (type_default.isArray(transform)) {
        for (i2 = 0; i2 < transform.length; i2++) {
          this.transformations.push(transform[i2]);
        }
      } else {
        this.transformations.push(transform);
      }
      return this;
    },
    // Documented in element.js
    getParents: function() {
      var p = [this.url, [this.Z(), this.X(), this.Y()], this.usrSize];
      if (this.parents.length !== 0) {
        p = this.parents;
      }
      return p;
    },
    /**
     * Set the width and height of the image. After setting a new size,
     * board.update() or image.fullUpdate()
     * has to be called to make the change visible.
     * @param  {number|function|string} width  Number, function or string
     *                            that determines the new width of the image
     * @param  {number|function|string} height Number, function or string
     *                            that determines the new height of the image
     * @returns {JXG.GeometryElement} A reference to the element
     *
     * @example
     * var im = board.create('image', ['https://jsxgraph.org/distrib/images/uccellino.jpg',
     *                                [-3,-2], [3,3]]);
     * im.setSize(4, 4);
     * board.update();
     *
     * </pre><div id="JXG8411e60c-f009-11e5-b1bf-901b0e1b8723" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG8411e60c-f009-11e5-b1bf-901b0e1b8723',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var im = board.create('image', ['https://jsxgraph.org/distrib/images/uccellino.jpg', [-3,-2],    [3,3]]);
     *     //im.setSize(4, 4);
     *     //board.update();
     *
     *     })();
     *
     * <\/script><pre>
     *
     * @example
     * var p0 = board.create('point', [-3, -2]),
     *     im = board.create('image', ['https://jsxgraph.org/distrib/images/uccellino.jpg',
     *                     [function(){ return p0.X(); }, function(){ return p0.Y(); }],
     *                     [3,3]]),
     *     p1 = board.create('point', [1, 2]);
     *
     * im.setSize(function(){ return p1.X() - p0.X(); }, function(){ return p1.Y() - p0.Y(); });
     * board.update();
     *
     * </pre><div id="JXG4ce706c0-f00a-11e5-b1bf-901b0e1b8723" class="jxgbox" style="width: 300px; height: 300px;"></div>
     * <script type="text/javascript">
     *     (function() {
     *         var board = JXG.JSXGraph.initBoard('JXG4ce706c0-f00a-11e5-b1bf-901b0e1b8723',
     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *     var p0 = board.create('point', [-3, -2]),
     *         im = board.create('image', ['https://jsxgraph.org/distrib/images/uccellino.jpg',
     *                         [function(){ return p0.X(); }, function(){ return p0.Y(); }],
     *                         [3,3]]),
     *         p1 = board.create('point', [1, 2]);
     *
     *     im.setSize(function(){ return p1.X() - p0.X(); }, function(){ return p1.Y() - p0.Y(); });
     *     board.update();
     *
     *     })();
     *
     * <\/script><pre>
     *
     */
    setSize: function(width, height) {
      this.W = type_default.createFunction(width, this.board, "");
      this.H = type_default.createFunction(height, this.board, "");
      this.addParentsFromJCFunctions([this.W, this.H]);
      return this;
    },
    /**
     * Returns the width of the image in user coordinates.
     * @returns {number} width of the image in user coordinates
     */
    W: function() {
    },
    // Needed for docs, defined in constructor
    /**
     * Returns the height of the image in user coordinates.
     * @returns {number} height of the image in user coordinates
     */
    H: function() {
    }
    // Needed for docs, defined in constructor
  }
);
jxg_default.createImage = function(board, parents, attributes) {
  var attr, im, url = parents[0], coords = parents[1], size2 = parents[2];
  attr = type_default.copyAttributes(attributes, board.options, "image");
  im = coordselement_default.create(jxg_default.Image, board, coords, attr, url, size2);
  if (!im) {
    throw new Error(
      "JSXGraph: Can't create image with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [x,y], [z,x,y], [element,transformation]"
    );
  }
  if (attr.rotate !== 0) {
    im.addRotation(attr.rotate);
  }
  return im;
};
jxg_default.registerElement("image", jxg_default.createImage);
var image_default = jxg_default.Image;

// node_modules/jsxgraph/src/element/slider.js
jxg_default.createSlider = function(board, parents, attributes) {
  var pos0, pos1, smin, start, smax, diff, p1, p2, p3, l1, l2, ticks, ti, t, startx, starty, withText, withTicks, snapValues, snapValueDistance, snapWidth, sw, s, attr;
  attr = type_default.copyAttributes(attributes, board.options, "slider");
  withTicks = attr.withticks;
  withText = attr.withlabel;
  snapWidth = attr.snapwidth;
  snapValues = attr.snapvalues;
  snapValueDistance = attr.snapvaluedistance;
  p1 = board.create("point", parents[0], attr.point1);
  p2 = board.create("point", parents[1], attr.point2);
  l1 = board.create("segment", [p1, p2], attr.baseline);
  l1.updateStdform();
  pos0 = p1.coords.usrCoords.slice(1);
  pos1 = p2.coords.usrCoords.slice(1);
  smin = parents[2][0];
  start = parents[2][1];
  smax = parents[2][2];
  diff = smax - smin;
  sw = type_default.evaluate(snapWidth);
  s = sw === -1 ? start : Math.round(start / sw) * sw;
  startx = pos0[0] + (pos1[0] - pos0[0]) * (s - smin) / (smax - smin);
  starty = pos0[1] + (pos1[1] - pos0[1]) * (s - smin) / (smax - smin);
  attr.withLabel = false;
  p3 = board.create("glider", [startx, starty, l1], attr);
  p3.setAttribute({ snapwidth: snapWidth, snapvalues: snapValues, snapvaluedistance: snapValueDistance });
  l2 = board.create("segment", [p1, p3], attr.highline);
  p3.Value = function() {
    var d = this._smax - this._smin, ev_sw = type_default.evaluate(this.visProp.snapwidth);
    return ev_sw === -1 ? this.position * d + this._smin : Math.round((this.position * d + this._smin) / ev_sw) * ev_sw;
  };
  p3.methodMap = type_default.deepCopy(p3.methodMap, {
    Value: "Value",
    setValue: "setValue",
    smax: "_smax",
    // Max: "_smax",
    smin: "_smin",
    // Min: "_smin",
    setMax: "setMax",
    setMin: "setMin",
    point1: "point1",
    point2: "point2",
    baseline: "baseline",
    highline: "highline",
    ticks: "ticks",
    label: "label"
  });
  p3._smax = smax;
  p3._smin = smin;
  p3.setMax = function(val) {
    this._smax = val;
    return this;
  };
  p3.setValue = function(val) {
    var d = this._smax - this._smin;
    if (Math.abs(d) > math_default.eps) {
      this.position = (val - this._smin) / d;
    } else {
      this.position = 0;
    }
    this.position = Math.max(0, Math.min(1, this.position));
    return this;
  };
  p3.setMin = function(val) {
    this._smin = val;
    return this;
  };
  if (withText) {
    t = board.create(
      "text",
      [
        function() {
          return (p2.X() - p1.X()) * 0.05 + p2.X();
        },
        function() {
          return (p2.Y() - p1.Y()) * 0.05 + p2.Y();
        },
        function() {
          var n, d = type_default.evaluate(p3.visProp.digits), sl = type_default.evaluate(p3.visProp.suffixlabel), ul = type_default.evaluate(p3.visProp.unitlabel), pl = type_default.evaluate(p3.visProp.postlabel);
          if (d === 2 && type_default.evaluate(p3.visProp.precision) !== 2) {
            d = type_default.evaluate(p3.visProp.precision);
          }
          if (sl !== null) {
            n = sl;
          } else if (p3.name && p3.name !== "") {
            n = p3.name + " = ";
          } else {
            n = "";
          }
          if (p3.useLocale()) {
            n += p3.formatNumberLocale(p3.Value(), d);
          } else {
            n += type_default.toFixed(p3.Value(), d);
          }
          if (ul !== null) {
            n += ul;
          }
          if (pl !== null) {
            n += pl;
          }
          return n;
        }
      ],
      attr.label
    );
    p3.label = t;
    p3.visProp.withlabel = true;
    p3.hasLabel = true;
  }
  p3.point1 = p1;
  p3.point2 = p2;
  p3.baseline = l1;
  p3.highline = l2;
  if (withTicks) {
    if (!type_default.exists(attr.generatelabeltext)) {
      attr.ticks.generateLabelText = function(tick, zero, value) {
        var labelText, dFull = p3.point1.Dist(p3.point2), smin2 = p3._smin, smax2 = p3._smax, val = this.getDistanceFromZero(zero, tick) * (smax2 - smin2) / dFull + smin2;
        if (dFull < math_default.eps || Math.abs(val) < math_default.eps) {
          labelText = "0";
        } else {
          labelText = this.formatLabelText(val);
        }
        return labelText;
      };
    }
    ticks = 2;
    ti = board.create(
      "ticks",
      [
        p3.baseline,
        p3.point1.Dist(p1) / ticks,
        function(tick) {
          var dFull = p3.point1.Dist(p3.point2), d = p3.point1.coords.distance(constants_default.COORDS_BY_USER, tick);
          if (dFull < math_default.eps) {
            return 0;
          }
          return d / dFull * diff + smin;
        }
      ],
      attr.ticks
    );
    p3.ticks = ti;
  }
  p3.remove = function() {
    if (withText) {
      board.removeObject(t);
    }
    board.removeObject(l2);
    board.removeObject(l1);
    board.removeObject(p2);
    board.removeObject(p1);
    point_default.prototype.remove.call(p3);
  };
  p1.dump = false;
  p2.dump = false;
  l1.dump = false;
  l2.dump = false;
  if (withText) {
    t.dump = false;
  }
  p3.elType = "slider";
  p3.parents = parents;
  p3.subs = {
    point1: p1,
    point2: p2,
    baseLine: l1,
    highLine: l2
  };
  p3.inherits.push(p1, p2, l1, l2);
  if (withTicks) {
    ti.dump = false;
    p3.subs.ticks = ti;
    p3.inherits.push(ti);
  }
  p3.getParents = function() {
    return [
      this.point1.coords.usrCoords.slice(1),
      this.point2.coords.usrCoords.slice(1),
      [this._smin, this.position * (this._smax - this._smin) + this._smin, this._smax]
    ];
  };
  p3.baseline.on("up", function(evt) {
    var pos, c;
    if (type_default.evaluate(p3.visProp.moveonup) && !type_default.evaluate(p3.visProp.fixed)) {
      pos = l1.board.getMousePosition(evt, 0);
      c = new coords_default(constants_default.COORDS_BY_SCREEN, pos, this.board);
      p3.moveTo([c.usrCoords[1], c.usrCoords[2]]);
      p3.triggerEventHandlers(["drag"], [evt]);
    }
  });
  p3.prepareUpdate().update();
  if (!board.isSuspendedUpdate) {
    p3.updateVisibility().updateRenderer();
    p3.baseline.updateVisibility().updateRenderer();
    p3.highline.updateVisibility().updateRenderer();
    if (withTicks) {
      p3.ticks.updateVisibility().updateRenderer();
    }
  }
  return p3;
};
jxg_default.registerElement("slider", jxg_default.createSlider);

// node_modules/jsxgraph/src/parser/prefix.js
jxg_default.PrefixParser = {
  /**
   * Parse a prefix expression and apply an action.
   * @param {array|number} term Expression
   * @param {String} action Determines what to do. So far, the only
   * action available is 'execute', which evaluates the expression.
   * @returns {Number} What ever the action does.
   */
  parse: function(term, action) {
    var method, i2, le, res, fun2, v;
    if (type_default.isNumber(term) || type_default.isString(term)) {
      return term;
    }
    if (!type_default.isArray(term) || term.length < 2) {
      throw new Error("prefixParser.parse: term is not an array, number or string");
    }
    method = term[0];
    le = term.length;
    if (action === "execute") {
      if (type_default.isInArray(["+", "-", "*", "/"], method)) {
        res = this.parse(term[1], action);
        for (i2 = 2; i2 < le; i2++) {
          v = this.parse(term[i2], action);
          switch (method) {
            case "+":
              res += v;
              break;
            case "-":
              res -= v;
              break;
            case "*":
              res *= v;
              break;
            case "/":
              res /= v;
              break;
            default:
          }
        }
      } else if (method === "exec") {
        fun2 = term[1];
        v = [];
        for (i2 = 2; i2 < le; i2++) {
          v.push(this.parse(term[i2], action));
        }
        if (type_default.exists(Math[fun2])) {
          res = Math[fun2].apply(this, v);
        } else if (type_default.exists(math_default[fun2])) {
          res = math_default[fun2].apply(this, v);
        } else {
          throw new Error("PrefixParser.parse: " + fun2 + " is not allowed");
        }
      } else {
        fun2 = term[0];
        if (fun2 === "V") {
          fun2 = "Value";
        }
        if (!type_default.exists(term[1][fun2])) {
          throw new Error("PrefixParser.parse: " + fun2 + " is not a method of " + term[1]);
        }
        v = [];
        for (i2 = 2; i2 < le; i2++) {
          v.push(this.parse(term[i2], action));
        }
        res = term[1][fun2].apply(term[1], v);
      }
    }
    return res;
  },
  /**
   * Determine the dimension of the resulting value, i.e. ['L', obj] as well as
   * ['+', ['L', obj1], ['L', obj2]] have dimension 1.
   * <p>
   * ['+', ['Area', obj1], ['L', obj2]] will retrun NaN, because the two
   * operands have conflicting dimensions.
   * <p>
   * If an element is a measurement element, then it's dimension can be set as attribute.
   * This overrules the computed dimension.
   *
   * @param {Array|Number} term Prefix expression
   * @returns Number
   */
  dimension: function(term) {
    var method, i2, le, res, fun2, d, v, unit;
    if (type_default.isNumber(term)) {
      return 0;
    }
    if (!type_default.isArray(term) || term.length < 2) {
      throw new Error("PrefixParser.dimension: term is not an array");
    }
    method = term[0];
    le = term.length;
    if (type_default.isInArray(["+", "-", "*", "/"], method)) {
      res = this.dimension(term[1]);
      for (i2 = 2; i2 < le; i2++) {
        v = this.dimension(term[i2]);
        switch (method) {
          case "+":
            if (v !== res) {
              res = NaN;
            }
            break;
          case "-":
            if (v !== res) {
              res = NaN;
            }
            break;
          case "*":
            res += v;
            break;
          case "/":
            res -= v;
            break;
          default:
        }
      }
    } else if (method === "exec") {
      if (term[2].type === type_default.OBJECT_TYPE_MEASUREMENT) {
        res = term[2].Dimension();
        if (type_default.exists(term[2].visProp.dim)) {
          d = type_default.evaluate(term[2].visProp.dim);
          if (d !== null) {
            res = d;
          }
        }
      } else {
        res = 0;
      }
    } else {
      fun2 = term[0];
      switch (fun2) {
        case "L":
        case "Length":
        case "Perimeter":
        case "Radius":
        case "R":
          res = 1;
          break;
        case "Area":
        case "A":
          res = 2;
          break;
        default:
          if (term[1].type === type_default.OBJECT_TYPE_MEASUREMENT) {
            res = term[1].Dimension();
            if (type_default.exists(term[1].visProp.dim)) {
              d = type_default.evaluate(term[1].visProp.dim);
              if (d !== null) {
                res = d;
              }
            }
          } else {
            res = 0;
            if (fun2 === "Value" || fun2 === "V") {
              if ([constants_default.OBJECT_TYPE_ARC, constants_default.OBJECT_TYPE_SECTOR, constants_default.OBJECT_TYPE_ANGLE].indexOf(term[1].type) >= 0) {
                unit = "";
                if (term.length === 3 && type_default.isString(term[2])) {
                  unit = term[2].toLowerCase();
                }
                if (unit === "") {
                  if (term[1].type === constants_default.OBJECT_TYPE_ANGLE) {
                    res = 0;
                  } else {
                    res = 1;
                  }
                } else if (unit.indexOf("len") === 0) {
                  res = 1;
                } else {
                  res = 0;
                }
              }
            }
          }
      }
    }
    return res;
  },
  /**
   * Convert a prefix expression into a new prefix expression in which
   * JSXGraph elements have been replaced by their ids.
   *
   * @param {Array|Number} term
   * @returns {Array|Number}
   */
  toPrefix: function(term) {
    var method, i2, le, res;
    if (type_default.isNumber(term)) {
      return term;
    }
    if (!type_default.isArray(term) || term.length < 2) {
      throw new Error("PrefixParser.toPrefix: term is not an array");
    }
    method = term[0];
    le = term.length;
    res = [method];
    for (i2 = 1; i2 < le; i2++) {
      if (type_default.isInArray(["+", "-", "*", "/"], method)) {
        res.push(this.toPrefix(term[i2]));
      } else {
        if (method === "V" && term[i2].type === type_default.OBJECT_TYPE_MEASUREMENT) {
          res = term[i2].toPrefix();
        } else if (method === "exec") {
          if (i2 === 1) {
            res.push(term[i2]);
          } else {
            res.push(this.toPrefix(term[i2]));
          }
        } else {
          res = [method, term[i2].id];
        }
      }
    }
    return res;
  },
  /**
   * Determine parent elements of a prefix expression.
   * @param {Array|Number} term prefix expression
   * @returns Array
   * @private
   */
  getParents: function(term) {
    var method, i2, le, res;
    if (type_default.isNumber(term)) {
      return [];
    }
    if (!type_default.isArray(term) || term.length < 2) {
      throw new Error("PrefixParser.getParents: term is not an array");
    }
    method = term[0];
    le = term.length;
    res = [];
    for (i2 = 1; i2 < le; i2++) {
      if (type_default.isInArray(["+", "-", "*", "/"], method)) {
        res = res.concat(this.getParents(term[i2]));
      } else {
        if (method === "V" && term[i2].type === type_default.OBJECT_TYPE_MEASUREMENT) {
          res = res.concat(term[i2].getParents());
        } else if (method === "exec") {
          if (i2 > 1) {
            res = res.concat(this.getParents(term[i2]));
          }
        } else {
          res.push(term[i2]);
        }
      }
    }
    return res;
  }
};
var prefix_default = jxg_default.PrefixParser;

// node_modules/jsxgraph/src/element/measure.js
jxg_default.createTapemeasure = function(board, parents, attributes) {
  var pos0, pos1, attr, withTicks, withText, digits, li, p1, p2, n, ti;
  pos0 = parents[0];
  pos1 = parents[1];
  attr = type_default.copyAttributes(attributes, board.options, "tapemeasure", "point1");
  p1 = board.create("point", pos0, attr);
  attr = type_default.copyAttributes(attributes, board.options, "tapemeasure", "point2");
  p2 = board.create("point", pos1, attr);
  p1.setAttribute({ ignoredSnapToPoints: [p2] });
  p2.setAttribute({ ignoredSnapToPoints: [p1] });
  attr = type_default.copyAttributes(attributes, board.options, "tapemeasure");
  withTicks = attr.withticks;
  withText = attr.withlabel;
  digits = attr.digits;
  if (digits === 2 && attr.precision !== 2) {
    digits = attr.precision;
  }
  if (withText) {
    attr.withlabel = true;
  }
  li = board.create("segment", [p1, p2], attr);
  if (withText) {
    if (attributes.name && attributes.name !== "") {
      n = attributes.name + " = ";
    } else {
      n = "";
    }
    li.label.setText(function() {
      var digits2 = type_default.evaluate(li.label.visProp.digits);
      if (li.label.useLocale()) {
        return n + li.label.formatNumberLocale(p1.Dist(p2), digits2);
      }
      return n + type_default.toFixed(p1.Dist(p2), digits2);
    });
  }
  if (withTicks) {
    attr = type_default.copyAttributes(attributes, board.options, "tapemeasure", "ticks");
    ti = board.create("ticks", [li, 0.1], attr);
    li.inherits.push(ti);
  }
  li.remove = function() {
    if (withTicks) {
      li.removeTicks(ti);
    }
    board.removeObject(p2);
    board.removeObject(p1);
    element_default.prototype.remove.call(this);
  };
  li.Value = function() {
    return p1.Dist(p2);
  };
  p1.dump = false;
  p2.dump = false;
  li.elType = "tapemeasure";
  li.getParents = function() {
    return [
      [p1.X(), p1.Y()],
      [p2.X(), p2.Y()]
    ];
  };
  li.subs = {
    point1: p1,
    point2: p2
  };
  if (withTicks) {
    ti.dump = false;
  }
  li.methodMap = jxg_default.deepCopy(li.methodMap, {
    Value: "Value"
  });
  li.prepareUpdate().update();
  if (!board.isSuspendedUpdate) {
    li.updateVisibility().updateRenderer();
    li.point1.updateVisibility().updateRenderer();
    li.point2.updateVisibility().updateRenderer();
  }
  return li;
};
jxg_default.registerElement("tapemeasure", jxg_default.createTapemeasure);
jxg_default.createMeasurement = function(board, parents, attributes) {
  var el, attr, x, y, term, i2;
  attr = type_default.copyAttributes(attributes, board.options, "measurement");
  x = parents[0];
  y = parents[1];
  term = parents[2];
  el = board.create("text", [x, y, ""], attr);
  el.type = type_default.OBJECT_TYPE_MEASUREMENT;
  el.elType = "measurement";
  el.Value = function() {
    return prefix_default.parse(term, "execute");
  };
  el.Dimension = function() {
    var d = type_default.evaluate(el.visProp.dim);
    if (d !== null) {
      return d;
    }
    return prefix_default.dimension(term);
  };
  el.Unit = function() {
    let unit = "", units = type_default.evaluate(el.visProp.units), dim = el.Dimension();
    if (type_default.isObject(units) && type_default.exists(units[dim]) && units[dim] !== false) {
      unit = type_default.evaluate(units[dim]);
    } else if (type_default.isObject(units) && type_default.exists(units["dim" + dim]) && units["dim" + dim] !== false) {
      unit = type_default.evaluate(units["dim" + dim]);
    } else {
      unit = type_default.evaluate(el.visProp.baseunit);
      if (dim === 0) {
        unit = "";
      } else if (dim > 1 && unit !== "") {
        unit = unit + "^{" + dim + "}";
      }
    }
    return unit;
  };
  el.getTerm = function() {
    return term;
  };
  el.toPrefix = function() {
    return prefix_default.toPrefix(term);
  };
  el.getParents = function() {
    return prefix_default.getParents(term);
  };
  el.addParents(el.getParents());
  for (i2 = 0; i2 < el.parents.length; i2++) {
    board.select(el.parents[i2]).addChild(el);
  }
  el.setText(function() {
    var prefix = "", suffix = "", dim = el.Dimension(), digits = type_default.evaluate(el.visProp.digits), unit = el.Unit(), val = el.Value(), i3;
    if (type_default.evaluate(el.visProp.showprefix)) {
      prefix = el.visProp.formatprefix.apply(el, [type_default.evaluate(el.visProp.prefix)]);
    }
    if (type_default.evaluate(el.visProp.showsuffix)) {
      suffix = el.visProp.formatsuffix.apply(el, [type_default.evaluate(el.visProp.suffix)]);
    }
    if (type_default.isNumber(val)) {
      if (digits === "none") {
      } else if (digits === "auto") {
        if (el.useLocale()) {
          val = el.formatNumberLocale(val);
        } else {
          val = type_default.autoDigits(val);
        }
      } else {
        if (el.useLocale()) {
          val = el.formatNumberLocale(val, digits);
        } else {
          val = type_default.toFixed(val, digits);
        }
      }
    } else if (type_default.isArray(val)) {
      for (i3 = 0; i3 < val.length; i3++) {
        if (!type_default.isNumber(val[i3])) {
          continue;
        }
        if (digits === "none") {
        } else if (digits === "auto") {
          if (el.useLocale()) {
            val[i3] = el.formatNumberLocale(val[i3]);
          } else {
            val[i3] = type_default.autoDigits(val[i3]);
          }
        } else {
          if (el.useLocale()) {
            val[i3] = el.formatNumberLocale(val[i3], digits);
          } else {
            val[i3] = type_default.toFixed(val[i3], digits);
          }
        }
      }
    }
    if (dim === "coords" && type_default.isArray(val)) {
      if (val.length === 2) {
        val.unshift(void 0);
      }
      val = el.visProp.formatcoords.apply(el, [val[1], val[2], val[0]]);
    }
    if (dim === "direction" && type_default.isArray(val)) {
      if (val.length === 2) {
        val.unshift(void 0);
      }
      val = el.visProp.formatdirection.apply(el, [val[1], val[2]]);
    }
    if (type_default.isString(dim)) {
      return prefix + val + suffix;
    }
    if (isNaN(dim)) {
      return prefix + "NaN" + suffix;
    }
    return prefix + val + unit + suffix;
  });
  el.methodMap = type_default.deepCopy(el.methodMap, {
    Value: "Value",
    Dimension: "Dimension",
    Unit: "Unit",
    getTerm: "getTerm",
    Term: "getTerm",
    getTermPrefix: "getTermPrefix",
    TermPrefix: "getTermPrefix",
    getParents: "getParents",
    Parents: "getParents"
  });
  return el;
};
jxg_default.registerElement("measurement", jxg_default.createMeasurement);

// node_modules/jsxgraph/src/parser/datasource.js
jxg_default.DataSource = function() {
  this.data = [];
  this.columnHeaders = [];
  this.rowHeaders = [];
  return this;
};
jxg_default.extend(
  jxg_default.DataSource.prototype,
  /** @lends JXG.DataSource.prototype */
  {
    loadFromArray: function(table, columnHeader, rowHeader) {
      var i2, j, cell;
      if (type_default.isArray(columnHeader)) {
        this.columnHeaders = columnHeader;
        columnHeader = false;
      }
      if (type_default.isArray(rowHeader)) {
        this.rowHeaders = rowHeader;
        rowHeader = false;
      }
      this.data = [];
      if (columnHeader) {
        this.columnHeaders = [];
      }
      if (rowHeader) {
        this.rowHeaders = [];
      }
      if (type_default.exists(table)) {
        this.data = [];
        for (i2 = 0; i2 < table.length; i2++) {
          this.data[i2] = [];
          for (j = 0; j < table[i2].length; j++) {
            cell = table[i2][j];
            if (parseFloat(cell).toString() === cell) {
              this.data[i2][j] = parseFloat(cell);
            } else if (cell !== "-") {
              this.data[i2][j] = cell;
            } else {
              this.data[i2][j] = NaN;
            }
          }
        }
        if (columnHeader) {
          this.columnHeaders = this.data[0].slice(1);
          this.data = this.data.slice(1);
        }
        if (rowHeader) {
          this.rowHeaders = [];
          for (i2 = 0; i2 < this.data.length; i2++) {
            this.rowHeaders.push(this.data[i2][0]);
            this.data[i2] = this.data[i2].slice(1);
          }
        }
      }
      return this;
    },
    loadFromTable: function(table, columnHeader, rowHeader) {
      var row, i2, j, col, cell;
      if (type_default.isArray(columnHeader)) {
        this.columnHeaders = columnHeader;
        columnHeader = false;
      }
      if (type_default.isArray(rowHeader)) {
        this.rowHeaders = rowHeader;
        rowHeader = false;
      }
      this.data = [];
      if (columnHeader) {
        this.columnHeaders = [];
      }
      if (rowHeader) {
        this.rowHeaders = [];
      }
      table = document.getElementById(table);
      if (type_default.exists(table)) {
        row = table.getElementsByTagName("tr");
        this.data = [];
        for (i2 = 0; i2 < row.length; i2++) {
          col = row[i2].getElementsByTagName("td");
          this.data[i2] = [];
          for (j = 0; j < col.length; j++) {
            cell = col[j].innerHTML;
            if (parseFloat(cell).toString() === cell) {
              this.data[i2][j] = parseFloat(cell);
            } else if (cell !== "-") {
              this.data[i2][j] = cell;
            } else {
              this.data[i2][j] = NaN;
            }
          }
        }
        if (columnHeader) {
          this.columnHeaders = this.data[0].slice(1);
          this.data = this.data.slice(1);
        }
        if (rowHeader) {
          this.rowHeaders = [];
          for (i2 = 0; i2 < this.data.length; i2++) {
            this.rowHeaders.push(this.data[i2][0]);
            this.data[i2] = this.data[i2].slice(1);
          }
        }
      }
      return this;
    },
    addColumn: function(name, pos, data) {
      throw new Error("not implemented");
    },
    addRow: function(name, pos, data) {
      throw new Error("not implemented");
    },
    getColumn: function(col) {
      var i2, result = [];
      if (type_default.isString(col)) {
        for (i2 = 0; i2 < this.columnHeaders.length; i2++) {
          if (col === this.columnHeaders[i2]) {
            col = i2;
            break;
          }
        }
      }
      for (i2 = 0; i2 < this.data.length; i2++) {
        if (this.data[i2].length > col) {
          result[i2] = parseFloat(this.data[i2][col]);
        }
      }
      return result;
    },
    getRow: function(row) {
      var result, i2;
      if (type_default.isString(row)) {
        for (i2 = 0; i2 < this.rowHeaders.length; i2++) {
          if (row === this.rowHeaders[i2]) {
            row = i2;
            break;
          }
        }
      }
      result = [];
      for (i2 = 0; i2 < this.data[row].length; i2++) {
        result[i2] = this.data[row][i2];
      }
      return result;
    }
  }
);
var datasource_default = jxg_default.DataSource;

// node_modules/jsxgraph/src/base/chart.js
jxg_default.Chart = function(board, parents, attributes) {
  this.constructor(board, attributes);
  var x, y, i2, c, style, len;
  if (!type_default.isArray(parents) || parents.length === 0) {
    throw new Error("JSXGraph: Can't create a chart without data");
  }
  this.elements = [];
  if (type_default.isNumber(parents[0])) {
    y = parents;
    x = [];
    for (i2 = 0; i2 < y.length; i2++) {
      x[i2] = i2 + 1;
    }
  } else if (parents.length === 1 && type_default.isArray(parents[0])) {
    y = parents[0];
    x = [];
    len = type_default.evaluate(y).length;
    for (i2 = 0; i2 < len; i2++) {
      x[i2] = i2 + 1;
    }
  } else if (parents.length === 2) {
    len = Math.min(parents[0].length, parents[1].length);
    x = parents[0].slice(0, len);
    y = parents[1].slice(0, len);
  }
  if (type_default.isArray(y) && y.length === 0) {
    throw new Error("JSXGraph: Can't create charts without data.");
  }
  style = attributes.chartstyle.replace(/ /g, "").split(",");
  for (i2 = 0; i2 < style.length; i2++) {
    switch (style[i2]) {
      case "bar":
        c = this.drawBar(board, x, y, attributes);
        break;
      case "line":
        c = this.drawLine(board, x, y, attributes);
        break;
      case "fit":
        c = this.drawFit(board, x, y, attributes);
        break;
      case "spline":
        c = this.drawSpline(board, x, y, attributes);
        break;
      case "pie":
        c = this.drawPie(board, y, attributes);
        break;
      case "point":
        c = this.drawPoints(board, x, y, attributes);
        break;
      case "radar":
        c = this.drawRadar(board, parents, attributes);
        break;
    }
    this.elements.push(c);
  }
  this.id = this.board.setId(this, "Chart");
  return this.elements;
};
jxg_default.Chart.prototype = new element_default();
jxg_default.extend(
  jxg_default.Chart.prototype,
  /** @lends JXG.Chart.prototype */
  {
    /**
     * Create line chart defined by two data arrays.
     *
     * @param  {String|JXG.Board} board      The board the chart is drawn on
     * @param  {Array} x          Array of x-coordinates
     * @param  {Array} y          Array of y-coordinates
     * @param  {Object} attributes  Javascript object containing attributes like colors
     * @returns {JXG.Curve}       JSXGraph curve
     */
    drawLine: function(board, x, y, attributes) {
      attributes.fillcolor = "none";
      attributes.highlightfillcolor = "none";
      return board.create("curve", [x, y], attributes);
    },
    /**
     * Create line chart that consists of a natural spline curve
     * defined by two data arrays.
     *
     * @param  {String|JXG.Board} board      The board the chart is drawn on
     * @param  {Array} x          Array of x-coordinates
     * @param  {Array} y          Array of y-coordinates
     * @param  {Object} attributes Javascript object containing attributes like colors
     * @returns {JXG.Curve}       JSXGraph (natural) spline curve
     */
    drawSpline: function(board, x, y, attributes) {
      attributes.fillColor = "none";
      attributes.highlightfillcolor = "none";
      return board.create("spline", [x, y], attributes);
    },
    /**
     * Create line chart where the curve is given by a regression polynomial
     * defined by two data arrays. The degree of the polynomial is supplied
     * through the attribute "degree" in attributes.
     *
     * @param  {String|JXG.Board} board      The board the chart is drawn on
     * @param  {Array} x          Array of x-coordinates
     * @param  {Array} y          Array of y-coordinates
     * @param  {Object} attributes Javascript object containing attributes like colors
     * @returns {JXG.Curve}    JSXGraph function graph object
     */
    drawFit: function(board, x, y, attributes) {
      var deg = attributes.degree;
      deg = Math.max(parseInt(deg, 10), 1) || 1;
      attributes.fillcolor = "none";
      attributes.highlightfillcolor = "none";
      return board.create(
        "functiongraph",
        [numerics_default.regressionPolynomial(deg, x, y)],
        attributes
      );
    },
    /**
     * Create bar chart defined by two data arrays.
     * Attributes to change the layout of the bar chart are:
     * <ul>
     * <li> width (optional)
     * <li> dir: 'horizontal' or 'vertical'
     * <li> colors: array of colors
     * <li> labels: array of labels
     * </ul>
     *
     * @param  {String|JXG.Board} board      The board the chart is drawn on
     * @param  {Array} x          Array of x-coordinates
     * @param  {Array} y          Array of y-coordinates
     * @param  {Object} attributes Javascript object containing attributes like colors
     * @returns {Array}    Array of JXG polygons defining the bars
     */
    drawBar: function(board, x, y, attributes) {
      var i2, strwidth, text, w, xp0, xp1, xp2, yp, colors, pols = [], p = [], attr, attrSub, makeXpFun = function(i3, f) {
        return function() {
          return x[i3]() - f * w;
        };
      }, hiddenPoint = {
        fixed: true,
        withLabel: false,
        visible: false,
        name: ""
      };
      attr = type_default.copyAttributes(attributes, board.options, "chart");
      if (attr && attr.width) {
        w = attr.width;
      } else {
        if (x.length <= 1) {
          w = 1;
        } else {
          w = x[1] - x[0];
          for (i2 = 1; i2 < x.length - 1; i2++) {
            w = x[i2 + 1] - x[i2] < w ? x[i2 + 1] - x[i2] : w;
          }
        }
        w *= 0.8;
      }
      attrSub = type_default.copyAttributes(attributes, board.options, "chart", "label");
      for (i2 = 0; i2 < x.length; i2++) {
        if (type_default.isFunction(x[i2])) {
          xp0 = makeXpFun(i2, -0.5);
          xp1 = makeXpFun(i2, 0);
          xp2 = makeXpFun(i2, 0.5);
        } else {
          xp0 = x[i2] - w * 0.5;
          xp1 = x[i2];
          xp2 = x[i2] + w * 0.5;
        }
        if (type_default.isFunction(y[i2])) {
          yp = y[i2]();
        } else {
          yp = y[i2];
        }
        yp = y[i2];
        if (attr.dir === "horizontal") {
          p[0] = board.create("point", [0, xp0], hiddenPoint);
          p[1] = board.create("point", [yp, xp0], hiddenPoint);
          p[2] = board.create("point", [yp, xp2], hiddenPoint);
          p[3] = board.create("point", [0, xp2], hiddenPoint);
          if (type_default.exists(attr.labels) && type_default.exists(attr.labels[i2])) {
            attrSub.anchorY = "middle";
            text = board.create("text", [yp, xp1, attr.labels[i2]], attrSub);
            text.visProp.anchorx = function(txt) {
              return function() {
                return txt.X() >= 0 ? "left" : "right";
              };
            }(text);
          }
        } else {
          p[0] = board.create("point", [xp0, 0], hiddenPoint);
          p[1] = board.create("point", [xp0, yp], hiddenPoint);
          p[2] = board.create("point", [xp2, yp], hiddenPoint);
          p[3] = board.create("point", [xp2, 0], hiddenPoint);
          if (type_default.exists(attr.labels) && type_default.exists(attr.labels[i2])) {
            attrSub.anchorX = "middle";
            text = board.create("text", [xp1, yp, attr.labels[i2]], attrSub);
            text.visProp.anchory = function(txt) {
              return function() {
                return txt.Y() >= 0 ? "bottom" : "top";
              };
            }(text);
          }
        }
        if (type_default.isArray(attr.colors)) {
          colors = attr.colors;
          attr.fillcolor = colors[i2 % colors.length];
        }
        pols[i2] = board.create("polygon", p, attr);
        if (type_default.exists(attr.labels) && type_default.exists(attr.labels[i2])) {
          pols[i2].text = text;
        }
      }
      return pols;
    },
    /**
     * Create chart consisting of JSXGraph points.
     * Attributes to change the layout of the point chart are:
     * <ul>
     * <li> fixed (Boolean)
     * <li> infoboxArray (Array): Texts for the infobox
     * </ul>
     *
     * @param  {String|JXG.Board} board      The board the chart is drawn on
     * @param  {Array} x          Array of x-coordinates
     * @param  {Array} y          Array of y-coordinates
     * @param  {Object} attributes Javascript object containing attributes like colors
     * @returns {Array} Array of JSXGraph points
     */
    drawPoints: function(board, x, y, attributes) {
      var i2, points = [], infoboxArray = attributes.infoboxarray;
      attributes.fixed = true;
      attributes.name = "";
      for (i2 = 0; i2 < x.length; i2++) {
        attributes.infoboxtext = infoboxArray ? infoboxArray[i2 % infoboxArray.length] : false;
        points[i2] = board.create("point", [x[i2], y[i2]], attributes);
      }
      return points;
    },
    /**
     * Create pie chart.
     * Attributes to change the layout of the pie chart are:
     * <ul>
     * <li> labels: array of labels
     * <li> colors: (Array)
     * <li> highlightColors (Array)
     * <li> radius
     * <li> center (coordinate array)
     * <li> highlightOnSector (Boolean)
     * </ul>
     *
     * @param  {String|JXG.Board} board      The board the chart is drawn on
     * @param  {Array} y          Array of x-coordinates
     * @param  {Object} attributes Javascript object containing attributes like colors
     * @returns {Object}  with keys: "{sectors, points, midpoint}"
     */
    drawPie: function(board, y, attributes) {
      var i2, center, p = [], sector = [], s = statistics_default.sum(y), colorArray = attributes.colors, highlightColorArray = attributes.highlightcolors, labelArray = attributes.labels, r = attributes.radius || 4, radius = r, cent = attributes.center || [0, 0], xc = cent[0], yc = cent[1], makeRadPointFun = function(j, fun2, xc2) {
        return function() {
          var s2, i3, rad, t = 0;
          for (i3 = 0; i3 <= j; i3++) {
            t += parseFloat(type_default.evaluate(y[i3]));
          }
          s2 = t;
          for (i3 = j + 1; i3 < y.length; i3++) {
            s2 += parseFloat(type_default.evaluate(y[i3]));
          }
          rad = s2 !== 0 ? 2 * Math.PI * t / s2 : 0;
          return radius() * Math[fun2](rad) + xc2;
        };
      }, highlightHandleLabel = function(f, s2) {
        var dx = -this.point1.coords.usrCoords[1] + this.point2.coords.usrCoords[1], dy = -this.point1.coords.usrCoords[2] + this.point2.coords.usrCoords[2];
        if (type_default.exists(this.label)) {
          this.label.rendNode.style.fontSize = s2 * type_default.evaluate(this.label.visProp.fontsize) + "px";
          this.label.fullUpdate();
        }
        this.point2.coords = new coords_default(
          constants_default.COORDS_BY_USER,
          [
            this.point1.coords.usrCoords[1] + dx * f,
            this.point1.coords.usrCoords[2] + dy * f
          ],
          this.board
        );
        this.fullUpdate();
      }, highlightFun = function() {
        if (!this.highlighted) {
          this.highlighted = true;
          this.board.highlightedObjects[this.id] = this;
          this.board.renderer.highlight(this);
          highlightHandleLabel.call(this, 1.1, 2);
        }
      }, noHighlightFun = function() {
        if (this.highlighted) {
          this.highlighted = false;
          this.board.renderer.noHighlight(this);
          highlightHandleLabel.call(this, 0.9090909, 1);
        }
      }, hiddenPoint = {
        fixed: true,
        withLabel: false,
        visible: false,
        name: ""
      };
      if (!type_default.isArray(labelArray)) {
        labelArray = [];
        for (i2 = 0; i2 < y.length; i2++) {
          labelArray[i2] = "";
        }
      }
      if (!type_default.isFunction(r)) {
        radius = function() {
          return r;
        };
      }
      attributes.highlightonsector = attributes.highlightonsector || false;
      attributes.straightfirst = false;
      attributes.straightlast = false;
      center = board.create("point", [xc, yc], hiddenPoint);
      p[0] = board.create(
        "point",
        [
          function() {
            return radius() + xc;
          },
          function() {
            return yc;
          }
        ],
        hiddenPoint
      );
      for (i2 = 0; i2 < y.length; i2++) {
        p[i2 + 1] = board.create(
          "point",
          [makeRadPointFun(i2, "cos", xc), makeRadPointFun(i2, "sin", yc)],
          hiddenPoint
        );
        attributes.name = labelArray[i2];
        attributes.withlabel = attributes.name !== "";
        attributes.fillcolor = colorArray && colorArray[i2 % colorArray.length];
        attributes.labelcolor = colorArray && colorArray[i2 % colorArray.length];
        attributes.highlightfillcolor = highlightColorArray && highlightColorArray[i2 % highlightColorArray.length];
        sector[i2] = board.create("sector", [center, p[i2], p[i2 + 1]], attributes);
        if (attributes.highlightonsector) {
          sector[i2].hasPoint = sector[i2].hasPointSector;
        }
        if (attributes.highlightbysize) {
          sector[i2].highlight = highlightFun;
          sector[i2].noHighlight = noHighlightFun;
        }
      }
      return { sectors: sector, points: p, midpoint: center };
    },
    /**
     * Create radar chart.
     * Attributes to change the layout of the pie chart are:
     * <ul>
     * <li> paramArray: labels for axes, [ paramx, paramy, paramz ]
     * <li> startShiftRatio: 0 <= offset from chart center <=1
     * <li> endShiftRatio:  0 <= offset from chart radius <=1
     * <li> startShiftArray: Adjust offsets per each axis
     * <li> endShiftArray: Adjust offsets per each axis
     * <li> startArray: Values for inner circle. Default values: minimums
     * <li> start: one value to overwrite all startArray values
     * <li> endArray: Values for outer circle, maximums by default
     * <li> end: one value to overwrite all endArray values
     * <li> labelArray
     * <li> polyStrokeWidth
     * <li> colors
     * <li> highlightcolors
     * <li> labelArray: [ row1, row2, row3 ]
     * <li> radius
     * <li> legendPosition
     * <li> showCircles
     * <li> circleLabelArray
     * <li> circleStrokeWidth
     * </ul>
     *
     * @param  {String|JXG.Board} board      The board the chart is drawn on
     * @param  {Array} parents    Array of coordinates, e.g. [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3]]
     * @param  {Object} attributes Javascript object containing attributes like colors
     * @returns {Object} with keys "{circles, lines, points, midpoint, polygons}"
     */
    drawRadar: function(board, parents, attributes) {
      var i2, j, paramArray, numofparams, maxes, mins, la, pdata, ssa, esa, ssratio, esratio, sshifts, eshifts, starts, ends, labelArray, colorArray, highlightColorArray, radius, myAtts, cent, xc, yc, center, start_angle, rad, p, line, t, xcoord, ycoord, polygons, legend_position, circles, lxoff, lyoff, cla, clabelArray, ncircles, pcircles, angle, dr, sw, data, len = parents.length, get_anchor = function() {
        var x1, x2, y1, y2, relCoords = type_default.evaluate(this.visProp.label.offset).slice(0);
        x1 = this.point1.X();
        x2 = this.point2.X();
        y1 = this.point1.Y();
        y2 = this.point2.Y();
        if (x2 < x1) {
          relCoords[0] = -relCoords[0];
        }
        if (y2 < y1) {
          relCoords[1] = -relCoords[1];
        }
        this.setLabelRelativeCoords(relCoords);
        return new coords_default(
          constants_default.COORDS_BY_USER,
          [this.point2.X(), this.point2.Y()],
          this.board
        );
      }, get_transform = function(angle2, i3) {
        var t2, tscale, trot;
        t2 = board.create("transform", [-(starts[i3] - sshifts[i3]), 0], {
          type: "translate"
        });
        tscale = board.create(
          "transform",
          [radius / (ends[i3] + eshifts[i3] - (starts[i3] - sshifts[i3])), 1],
          { type: "scale" }
        );
        t2.melt(tscale);
        trot = board.create("transform", [angle2], { type: "rotate" });
        t2.melt(trot);
        return t2;
      };
      if (len <= 0) {
        throw new Error("JSXGraph radar chart: no data");
      }
      paramArray = attributes.paramarray;
      if (!type_default.exists(paramArray)) {
        throw new Error("JSXGraph radar chart: need paramArray attribute");
      }
      numofparams = paramArray.length;
      if (numofparams <= 1) {
        throw new Error("JSXGraph radar chart: need more than one param in paramArray");
      }
      for (i2 = 0; i2 < len; i2++) {
        if (numofparams !== parents[i2].length) {
          throw new Error(
            "JSXGraph radar chart: use data length equal to number of params (" + parents[i2].length + " != " + numofparams + ")"
          );
        }
      }
      maxes = [];
      mins = [];
      for (j = 0; j < numofparams; j++) {
        maxes[j] = parents[0][j];
        mins[j] = maxes[j];
      }
      for (i2 = 1; i2 < len; i2++) {
        for (j = 0; j < numofparams; j++) {
          if (parents[i2][j] > maxes[j]) {
            maxes[j] = parents[i2][j];
          }
          if (parents[i2][j] < mins[j]) {
            mins[j] = parents[i2][j];
          }
        }
      }
      la = [];
      pdata = [];
      for (i2 = 0; i2 < len; i2++) {
        la[i2] = "";
        pdata[i2] = [];
      }
      ssa = [];
      esa = [];
      ssratio = attributes.startshiftratio || 0;
      esratio = attributes.endshiftratio || 0;
      for (i2 = 0; i2 < numofparams; i2++) {
        ssa[i2] = (maxes[i2] - mins[i2]) * ssratio;
        esa[i2] = (maxes[i2] - mins[i2]) * esratio;
      }
      sshifts = attributes.startshiftarray || ssa;
      eshifts = attributes.endshiftarray || esa;
      starts = attributes.startarray || mins;
      if (type_default.exists(attributes.start)) {
        for (i2 = 0; i2 < numofparams; i2++) {
          starts[i2] = attributes.start;
        }
      }
      ends = attributes.endarray || maxes;
      if (type_default.exists(attributes.end)) {
        for (i2 = 0; i2 < numofparams; i2++) {
          ends[i2] = attributes.end;
        }
      }
      if (sshifts.length !== numofparams) {
        throw new Error(
          "JSXGraph radar chart: start shifts length is not equal to number of parameters"
        );
      }
      if (eshifts.length !== numofparams) {
        throw new Error(
          "JSXGraph radar chart: end shifts length is not equal to number of parameters"
        );
      }
      if (starts.length !== numofparams) {
        throw new Error(
          "JSXGraph radar chart: starts length is not equal to number of parameters"
        );
      }
      if (ends.length !== numofparams) {
        throw new Error(
          "JSXGraph radar chart: snds length is not equal to number of parameters"
        );
      }
      labelArray = attributes.labelarray || la;
      colorArray = attributes.colors;
      highlightColorArray = attributes.highlightcolors;
      radius = attributes.radius || 10;
      sw = attributes.strokewidth || 1;
      if (!type_default.exists(attributes.highlightonsector)) {
        attributes.highlightonsector = false;
      }
      myAtts = {
        name: attributes.name,
        id: attributes.id,
        strokewidth: sw,
        polystrokewidth: attributes.polystrokewidth || sw,
        strokecolor: attributes.strokecolor || "black",
        straightfirst: false,
        straightlast: false,
        fillcolor: attributes.fillColor || "#FFFF88",
        fillopacity: attributes.fillOpacity || 0.4,
        highlightfillcolor: attributes.highlightFillColor || "#FF7400",
        highlightstrokecolor: attributes.highlightStrokeColor || "black",
        gradient: attributes.gradient || "none"
      };
      cent = attributes.center || [0, 0];
      xc = cent[0];
      yc = cent[1];
      center = board.create("point", [xc, yc], {
        name: "",
        fixed: true,
        withlabel: false,
        visible: false
      });
      start_angle = Math.PI / 2 - Math.PI / numofparams;
      start_angle = attributes.startangle || 0;
      rad = start_angle;
      p = [];
      line = [];
      for (i2 = 0; i2 < numofparams; i2++) {
        rad += 2 * Math.PI / numofparams;
        xcoord = radius * Math.cos(rad) + xc;
        ycoord = radius * Math.sin(rad) + yc;
        p[i2] = board.create("point", [xcoord, ycoord], {
          name: "",
          fixed: true,
          withlabel: false,
          visible: false
        });
        line[i2] = board.create("line", [center, p[i2]], {
          name: paramArray[i2],
          strokeColor: myAtts.strokecolor,
          strokeWidth: myAtts.strokewidth,
          strokeOpacity: 1,
          straightFirst: false,
          straightLast: false,
          withLabel: true,
          highlightStrokeColor: myAtts.highlightstrokecolor
        });
        line[i2].getLabelAnchor = get_anchor;
        t = get_transform(rad, i2);
        for (j = 0; j < parents.length; j++) {
          data = parents[j][i2];
          pdata[j][i2] = board.create("point", [data, 0], {
            name: "",
            fixed: true,
            withlabel: false,
            visible: false
          });
          pdata[j][i2].addTransform(pdata[j][i2], t);
        }
      }
      polygons = [];
      for (i2 = 0; i2 < len; i2++) {
        myAtts.labelcolor = colorArray && colorArray[i2 % colorArray.length];
        myAtts.strokecolor = colorArray && colorArray[i2 % colorArray.length];
        myAtts.fillcolor = colorArray && colorArray[i2 % colorArray.length];
        polygons[i2] = board.create("polygon", pdata[i2], {
          withLines: true,
          withLabel: false,
          fillColor: myAtts.fillcolor,
          fillOpacity: myAtts.fillopacity,
          highlightFillColor: myAtts.highlightfillcolor
        });
        for (j = 0; j < numofparams; j++) {
          polygons[i2].borders[j].setAttribute(
            "strokecolor:" + colorArray[i2 % colorArray.length]
          );
          polygons[i2].borders[j].setAttribute(
            "strokewidth:" + myAtts.polystrokewidth
          );
        }
      }
      legend_position = attributes.legendposition || "none";
      switch (legend_position) {
        case "right":
          lxoff = attributes.legendleftoffset || 2;
          lyoff = attributes.legendtopoffset || 1;
          this.legend = board.create(
            "legend",
            [xc + radius + lxoff, yc + radius - lyoff],
            {
              labels: labelArray,
              colors: colorArray
            }
          );
          break;
        case "none":
          break;
        default:
          jxg_default.debug("Unknown legend position");
      }
      circles = [];
      if (attributes.showcircles) {
        cla = [];
        for (i2 = 0; i2 < 6; i2++) {
          cla[i2] = 20 * i2;
        }
        cla[0] = "0";
        clabelArray = attributes.circlelabelarray || cla;
        ncircles = clabelArray.length;
        if (ncircles < 2) {
          throw new Error(
            "JSXGraph radar chart: too less circles in circleLabelArray"
          );
        }
        pcircles = [];
        angle = start_angle + Math.PI / numofparams;
        t = get_transform(angle, 0);
        myAtts.fillcolor = "none";
        myAtts.highlightfillcolor = "none";
        myAtts.strokecolor = attributes.strokecolor || "black";
        myAtts.strokewidth = attributes.circlestrokewidth || 0.5;
        myAtts.layer = 0;
        dr = (ends[0] - starts[0]) / (ncircles - 1);
        for (i2 = 0; i2 < ncircles; i2++) {
          pcircles[i2] = board.create("point", [starts[0] + i2 * dr, 0], {
            name: clabelArray[i2],
            size: 0,
            fixed: true,
            withLabel: true,
            visible: true
          });
          pcircles[i2].addTransform(pcircles[i2], t);
          circles[i2] = board.create("circle", [center, pcircles[i2]], myAtts);
        }
      }
      this.rendNode = polygons[0].rendNode;
      return {
        circles,
        lines: line,
        points: pdata,
        midpoint: center,
        polygons
      };
    },
    /**
     * Uses the boards renderer to update the chart.
     * @private
     */
    updateRenderer: function() {
      return this;
    },
    // documented in base/element
    update: function() {
      if (this.needsUpdate) {
        this.updateDataArray();
      }
      return this;
    },
    /**
     * Template for dynamic charts update.
     * This method is used to compute new entries
     * for the arrays this.dataX and
     * this.dataY. It is used in update.
     * Default is an empty method, can be overwritten
     * by the user.
     *
     * @returns {JXG.Chart} Reference to this chart object.
     */
    updateDataArray: function() {
      return this;
    }
  }
);
jxg_default.createChart = function(board, parents, attributes) {
  var data, row, i2, j, col, charts = [], w, x, showRows, attr, originalWidth, name, strokeColor, fillColor, hStrokeColor, hFillColor, len, table = env_default.isBrowser ? board.document.getElementById(parents[0]) : null;
  if (parents.length === 1 && type_default.isString(parents[0])) {
    if (type_default.exists(table)) {
      attr = type_default.copyAttributes(attributes, board.options, "chart");
      table = new datasource_default().loadFromTable(
        parents[0],
        attr.withheaders,
        attr.withheaders
      );
      data = table.data;
      col = table.columnHeaders;
      row = table.rowHeaders;
      originalWidth = attr.width;
      name = attr.name;
      strokeColor = attr.strokecolor;
      fillColor = attr.fillcolor;
      hStrokeColor = attr.highlightstrokecolor;
      hFillColor = attr.highlightfillcolor;
      board.suspendUpdate();
      len = data.length;
      showRows = [];
      if (attr.rows && type_default.isArray(attr.rows)) {
        for (i2 = 0; i2 < len; i2++) {
          for (j = 0; j < attr.rows.length; j++) {
            if (attr.rows[j] === i2 || attr.withheaders && attr.rows[j] === row[i2]) {
              showRows.push(data[i2]);
              break;
            }
          }
        }
      } else {
        showRows = data;
      }
      len = showRows.length;
      for (i2 = 0; i2 < len; i2++) {
        x = [];
        if (attr.chartstyle && attr.chartstyle.indexOf("bar") !== -1) {
          if (originalWidth) {
            w = originalWidth;
          } else {
            w = 0.8;
          }
          x.push(1 - w / 2 + (i2 + 0.5) * w / len);
          for (j = 1; j < showRows[i2].length; j++) {
            x.push(x[j - 1] + 1);
          }
          attr.width = w / len;
        }
        if (name && name.length === len) {
          attr.name = name[i2];
        } else if (attr.withheaders) {
          attr.name = col[i2];
        }
        if (strokeColor && strokeColor.length === len) {
          attr.strokecolor = strokeColor[i2];
        } else {
          attr.strokecolor = color_default.hsv2rgb((i2 + 1) / len * 360, 0.9, 0.6);
        }
        if (fillColor && fillColor.length === len) {
          attr.fillcolor = fillColor[i2];
        } else {
          attr.fillcolor = color_default.hsv2rgb((i2 + 1) / len * 360, 0.9, 1);
        }
        if (hStrokeColor && hStrokeColor.length === len) {
          attr.highlightstrokecolor = hStrokeColor[i2];
        } else {
          attr.highlightstrokecolor = color_default.hsv2rgb((i2 + 1) / len * 360, 0.9, 1);
        }
        if (hFillColor && hFillColor.length === len) {
          attr.highlightfillcolor = hFillColor[i2];
        } else {
          attr.highlightfillcolor = color_default.hsv2rgb((i2 + 1) / len * 360, 0.9, 0.6);
        }
        if (attr.chartstyle && attr.chartstyle.indexOf("bar") !== -1) {
          charts.push(new jxg_default.Chart(board, [x, showRows[i2]], attr));
        } else {
          charts.push(new jxg_default.Chart(board, [showRows[i2]], attr));
        }
      }
      board.unsuspendUpdate();
    }
    return charts;
  }
  attr = type_default.copyAttributes(attributes, board.options, "chart");
  return new jxg_default.Chart(board, parents, attr);
};
jxg_default.registerElement("chart", jxg_default.createChart);
jxg_default.Legend = function(board, coords, attributes) {
  var attr;
  this.constructor();
  attr = type_default.copyAttributes(attributes, board.options, "legend");
  this.board = board;
  this.coords = new coords_default(constants_default.COORDS_BY_USER, coords, this.board);
  this.myAtts = {};
  this.label_array = attr.labelarray || attr.labels;
  this.color_array = attr.colorarray || attr.colors;
  this.lines = [];
  this.myAtts.strokewidth = attr.strokewidth || 5;
  this.myAtts.straightfirst = false;
  this.myAtts.straightlast = false;
  this.myAtts.withlabel = true;
  this.myAtts.fixed = true;
  this.style = attr.legendstyle || attr.style;
  if (this.style === "vertical") {
    this.drawVerticalLegend(board, attr);
  } else {
    throw new Error("JSXGraph: Unknown legend style: " + this.style);
  }
};
jxg_default.Legend.prototype = new element_default();
jxg_default.Legend.prototype.drawVerticalLegend = function(board, attributes) {
  var i2, line_length = attributes.linelength || 1, offy = (attributes.rowheight || 20) / this.board.unitY, getLabelAnchor = function() {
    this.setLabelRelativeCoords(this.visProp.label.offset);
    return new coords_default(
      constants_default.COORDS_BY_USER,
      [this.point2.X(), this.point2.Y()],
      this.board
    );
  };
  for (i2 = 0; i2 < this.label_array.length; i2++) {
    this.myAtts.name = this.label_array[i2];
    this.myAtts.strokecolor = this.color_array[i2 % this.color_array.length];
    this.myAtts.highlightstrokecolor = this.color_array[i2 % this.color_array.length];
    this.myAtts.label = {
      offset: [10, 0],
      strokeColor: this.color_array[i2 % this.color_array.length],
      strokeWidth: this.myAtts.strokewidth
    };
    this.lines[i2] = board.create(
      "line",
      [
        [this.coords.usrCoords[1], this.coords.usrCoords[2] - i2 * offy],
        [this.coords.usrCoords[1] + line_length, this.coords.usrCoords[2] - i2 * offy]
      ],
      this.myAtts
    );
    this.lines[i2].getLabelAnchor = getLabelAnchor;
    this.lines[i2].prepareUpdate().update().updateVisibility(type_default.evaluate(this.lines[i2].visProp.visible)).updateRenderer();
  }
};
jxg_default.createLegend = function(board, parents, attributes) {
  var start_from = [0, 0];
  if (type_default.exists(parents) && parents.length === 2) {
    start_from = parents;
  } else {
    throw new Error("JSXGraph: Legend element needs two numbers as parameters");
  }
  return new jxg_default.Legend(board, start_from, attributes);
};
jxg_default.registerElement("legend", jxg_default.createLegend);
var chart_default = {
  Chart: jxg_default.Chart,
  Legend: jxg_default.Legend
  // createChart: JXG.createChart,
  // createLegend: JXG.createLegend
};

// node_modules/jsxgraph/src/base/transformation.js
jxg_default.Transformation = function(board, type, params) {
  this.elementClass = constants_default.OBJECT_CLASS_OTHER;
  this.type = constants_default.OBJECT_TYPE_TRANSFORMATION;
  this.matrix = [
    [1, 0, 0],
    [0, 1, 0],
    [0, 0, 1]
  ];
  this.board = board;
  this.isNumericMatrix = false;
  this.setMatrix(board, type, params);
  this.methodMap = {
    apply: "apply",
    applyOnce: "applyOnce",
    bindTo: "bindTo",
    bind: "bindTo",
    melt: "melt"
  };
};
jxg_default.Transformation.prototype = {};
jxg_default.extend(
  jxg_default.Transformation.prototype,
  /** @lends JXG.Transformation.prototype */
  {
    /**
     * Updates the numerical data for the transformation, i.e. the entry of the subobject matrix.
     * @returns {JXG.Transform} returns pointer to itself
     */
    update: function() {
      return this;
    },
    /**
     * Set the transformation matrix for different types of standard transforms.
     * @param {JXG.Board} board
     * @param {String} type   Transformation type, possible values are
     *                        'translate', 'scale', 'reflect', 'rotate',
     *                        'shear', 'generic'.
     * @param {Array} params Parameters for the various transformation types.
     *
     * <p>These are
     * @param {Array} x,y Shift vector (number or function) in case of 'translate'.
     * @param {Array} scale_x,scale_y Scale vector (number or function) in case of 'scale'.
     * @param {Array} line|point_pair|"four coordinates" In case of 'reflect' the parameters could
     *                be a line, a pair of points or four number (or functions) p_x, p_y, q_x, q_y,
     *                determining a line through points (p_x, p_y) and (q_x, q_y).
     * @param {Array} angle,x,y|angle,[x,y] In case of 'rotate' the parameters are an angle or angle function,
     *                returning the angle in Radians and - optionally - a coordinate pair or a point defining the
     *                rotation center. If the rotation center is not given, the transformation rotates around (0,0).
     * @param {Array} shear_x,shear_y Shear vector (number or function) in case of 'shear'.
     * @param {Array} a,b,c,d,e,f,g,h,i Nine matrix entries (numbers or functions) for a generic
     *                projective transformation  in case of 'generic'.
     *
     * <p>A transformation with a generic matrix looks like:
     * <pre>
     * ( a  b  c )   ( z )
     * ( d  e  f ) * ( x )
     * ( g  h  i )   ( y )
     * </pre>
     *
     */
    setMatrix: function(board, type, params) {
      var i2;
      this.isNumericMatrix = true;
      for (i2 = 0; i2 < params.length; i2++) {
        if (typeof params[i2] !== "number") {
          this.isNumericMatrix = false;
          break;
        }
      }
      if (type === "translate") {
        if (params.length !== 2) {
          throw new Error("JSXGraph: translate transformation needs 2 parameters.");
        }
        this.evalParam = type_default.createEvalFunction(board, params, 2);
        this.update = function() {
          this.matrix[1][0] = this.evalParam(0);
          this.matrix[2][0] = this.evalParam(1);
        };
      } else if (type === "scale") {
        if (params.length !== 2) {
          throw new Error("JSXGraph: scale transformation needs 2 parameters.");
        }
        this.evalParam = type_default.createEvalFunction(board, params, 2);
        this.update = function() {
          this.matrix[1][1] = this.evalParam(0);
          this.matrix[2][2] = this.evalParam(1);
        };
      } else if (type === "reflect") {
        if (params.length < 4) {
          params[0] = board.select(params[0]);
        }
        if (params.length === 2) {
          params[1] = board.select(params[1]);
        }
        if (params.length === 4) {
          this.evalParam = type_default.createEvalFunction(board, params, 4);
        }
        this.update = function() {
          var x, y, z, xoff, yoff, d, v, p;
          if (params.length === 1) {
            v = params[0].stdform;
          } else if (params.length === 2) {
            v = math_default.crossProduct(
              params[1].coords.usrCoords,
              params[0].coords.usrCoords
            );
          } else if (params.length === 4) {
            v = math_default.crossProduct(
              [1, this.evalParam(2), this.evalParam(3)],
              [1, this.evalParam(0), this.evalParam(1)]
            );
          }
          x = v[1];
          y = v[2];
          z = v[0];
          p = [-z * x, -z * y, x * x + y * y];
          d = p[2];
          xoff = p[0] / p[2];
          yoff = p[1] / p[2];
          x = -v[2];
          y = v[1];
          this.matrix[1][1] = (x * x - y * y) / d;
          this.matrix[1][2] = 2 * x * y / d;
          this.matrix[2][1] = this.matrix[1][2];
          this.matrix[2][2] = -this.matrix[1][1];
          this.matrix[1][0] = xoff * (1 - this.matrix[1][1]) - yoff * this.matrix[1][2];
          this.matrix[2][0] = yoff * (1 - this.matrix[2][2]) - xoff * this.matrix[2][1];
        };
      } else if (type === "rotate") {
        if (params.length === 3) {
          this.evalParam = type_default.createEvalFunction(board, params, 3);
        } else if (params.length > 0 && params.length <= 2) {
          this.evalParam = type_default.createEvalFunction(board, params, 1);
          if (params.length === 2 && !type_default.isArray(params[1])) {
            params[1] = board.select(params[1]);
          }
        }
        this.update = function() {
          var x, y, beta = this.evalParam(0), co = Math.cos(beta), si = Math.sin(beta);
          this.matrix[1][1] = co;
          this.matrix[1][2] = -si;
          this.matrix[2][1] = si;
          this.matrix[2][2] = co;
          if (params.length > 1) {
            if (params.length === 3) {
              x = this.evalParam(1);
              y = this.evalParam(2);
            } else {
              if (type_default.isArray(params[1])) {
                x = params[1][0];
                y = params[1][1];
              } else {
                x = params[1].X();
                y = params[1].Y();
              }
            }
            this.matrix[1][0] = x * (1 - co) + y * si;
            this.matrix[2][0] = y * (1 - co) - x * si;
          }
        };
      } else if (type === "shear") {
        if (params.length !== 2) {
          throw new Error("JSXGraph: shear transformation needs 2 parameters.");
        }
        this.evalParam = type_default.createEvalFunction(board, params, 2);
        this.update = function() {
          this.matrix[1][2] = this.evalParam(0);
          this.matrix[2][1] = this.evalParam(1);
        };
      } else if (type === "generic") {
        if (params.length !== 9) {
          throw new Error("JSXGraph: generic transformation needs 9 parameters.");
        }
        this.evalParam = type_default.createEvalFunction(board, params, 9);
        this.update = function() {
          this.matrix[0][0] = this.evalParam(0);
          this.matrix[0][1] = this.evalParam(1);
          this.matrix[0][2] = this.evalParam(2);
          this.matrix[1][0] = this.evalParam(3);
          this.matrix[1][1] = this.evalParam(4);
          this.matrix[1][2] = this.evalParam(5);
          this.matrix[2][0] = this.evalParam(6);
          this.matrix[2][1] = this.evalParam(7);
          this.matrix[2][2] = this.evalParam(8);
        };
      }
    },
    /**
     * Transform a GeometryElement:
     * First, the transformation matrix is updated, then do the matrix-vector-multiplication.
     * @private
     * @param {JXG.GeometryElement} p element which is transformed
     * @param {String} 'self' Apply the transformation to the initialCoords instead of the coords if this is set.
     * @returns {Array}
     */
    apply: function(p, self2) {
      this.update();
      if (type_default.exists(self2)) {
        return math_default.matVecMult(this.matrix, p.initialCoords.usrCoords);
      }
      return math_default.matVecMult(this.matrix, p.coords.usrCoords);
    },
    /**
     * Applies a transformation once to a GeometryElement or an array of elements.
     * If it is a free point, then it can be dragged around later
     * and will overwrite the transformed coordinates.
     * @param {JXG.Point|Array} p
     */
    applyOnce: function(p) {
      var c, len, i2;
      if (!type_default.isArray(p)) {
        p = [p];
      }
      len = p.length;
      for (i2 = 0; i2 < len; i2++) {
        this.update();
        c = math_default.matVecMult(this.matrix, p[i2].coords.usrCoords);
        p[i2].coords.setCoordinates(constants_default.COORDS_BY_USER, c);
      }
    },
    /**
     * Binds a transformation to a GeometryElement or an array of elements. In every update of the
     * GeometryElement(s), the transformation is executed. That means, in order to immediately
     * apply the transformation, a call of board.update() has to follow.
     * @param  {Array|JXG.Object} p JXG.Object or array of JXG.Object to
     *                            which the transformation is bound to.
     */
    bindTo: function(p) {
      var i2, len;
      if (type_default.isArray(p)) {
        len = p.length;
        for (i2 = 0; i2 < len; i2++) {
          p[i2].transformations.push(this);
        }
      } else {
        p.transformations.push(this);
      }
    },
    /**
     * Unused
     * @deprecated Use setAttribute
     * @param term
     */
    setProperty: function(term) {
      jxg_default.deprecated("Transformation.setProperty()", "Transformation.setAttribute()");
    },
    /**
     * Empty method. Unused.
     * @param {Object} term Key-value pairs of the attributes.
     */
    setAttribute: function(term) {
    },
    /**
     * Combine two transformations to one transformation. This only works if
     * both of transformation matrices consist solely of numbers, and do not
     * contain functions.
     *
     * Multiplies the transformation with a transformation t from the left.
     * i.e. (this) = (t) join (this)
     * @param  {JXG.Transform} t Transformation which is the left multiplicand
     * @returns {JXG.Transform} the transformation object.
     */
    melt: function(t) {
      var res = [], i2, len, len0, k, s, j;
      len = t.matrix.length;
      len0 = this.matrix[0].length;
      for (i2 = 0; i2 < len; i2++) {
        res[i2] = [];
      }
      this.update();
      t.update();
      for (i2 = 0; i2 < len; i2++) {
        for (j = 0; j < len0; j++) {
          s = 0;
          for (k = 0; k < len; k++) {
            s += t.matrix[i2][k] * this.matrix[k][j];
          }
          res[i2][j] = s;
        }
      }
      this.update = function() {
        var len2 = this.matrix.length, len02 = this.matrix[0].length;
        for (i2 = 0; i2 < len2; i2++) {
          for (j = 0; j < len02; j++) {
            this.matrix[i2][j] = res[i2][j];
          }
        }
      };
      return this;
    },
    // documented in element.js
    // Not yet, since transformations are not listed in board.objects.
    getParents: function() {
      var p = [[].concat.apply([], this.matrix)];
      if (this.parents.length !== 0) {
        p = this.parents;
      }
      return p;
    }
  }
);
jxg_default.createTransform = function(board, parents, attributes) {
  return new jxg_default.Transformation(board, attributes.type, parents);
};
jxg_default.registerElement("transform", jxg_default.createTransform);
var transformation_default = jxg_default.Transformation;

// node_modules/jsxgraph/src/base/turtle.js
jxg_default.Turtle = function(board, parents, attributes) {
  var x, y, dir;
  this.constructor(board, attributes, constants_default.OBJECT_TYPE_TURTLE, constants_default.OBJECT_CLASS_OTHER);
  this.turtleIsHidden = false;
  this.board = board;
  this.visProp.curveType = "plot";
  this._attributes = type_default.copyAttributes(this.visProp, board.options, "turtle");
  delete this._attributes.id;
  x = 0;
  y = 0;
  dir = 90;
  if (parents.length !== 0) {
    if (parents.length === 3) {
      x = parents[0];
      y = parents[1];
      dir = parents[2];
    } else if (parents.length === 2) {
      if (type_default.isArray(parents[0])) {
        x = parents[0][0];
        y = parents[0][1];
        dir = parents[1];
      } else {
        x = parents[0];
        y = parents[1];
      }
    } else {
      x = parents[0][0];
      y = parents[0][1];
    }
  }
  this.init(x, y, dir);
  this.methodMap = type_default.deepCopy(this.methodMap, {
    forward: "forward",
    fd: "forward",
    back: "back",
    bk: "back",
    right: "right",
    rt: "right",
    left: "left",
    lt: "left",
    penUp: "penUp",
    pu: "penUp",
    up: "penUp",
    penDown: "penDown",
    pd: "penDown",
    down: "penDown",
    clearScreen: "clearScreen",
    cs: "clearScreen",
    clean: "clean",
    setPos: "setPos",
    home: "home",
    hideTurtle: "hideTurtle",
    ht: "hideTurtle",
    hide: "hideTurtle",
    showTurtle: "showTurtle",
    st: "showTurtle",
    show: "showTurtle",
    penSize: "setPenSize",
    setPenSize: "setPenSize",
    penColor: "setPenColor",
    setPenColor: "setPenColor",
    highlightPenColor: "setHighlightPenColor",
    setHighlightPenColor: "setHighlightPenColor",
    getPenColor: "getPenColor",
    Color: "getPenColor",
    getHighlightPenColor: "getHighlightPenColor",
    HighlightColor: "getHighlightPenColor",
    getPenSize: "getPenSize",
    Size: "getPenSize",
    pushTurtle: "pushTurtle",
    push: "pushTurtle",
    popTurtle: "popTurtle",
    pop: "popTurtle",
    lookTo: "lookTo",
    pos: "pos",
    Pos: "pos",
    moveTo: "moveTo",
    X: "X",
    Y: "Y"
  });
  return this;
};
jxg_default.Turtle.prototype = new element_default();
jxg_default.extend(
  jxg_default.Turtle.prototype,
  /** @lends JXG.Turtle.prototype */
  {
    /**
     * Initialize a new turtle or reinitialize a turtle after {@link JXG.Turtle#clearScreen}.
     * @private
     */
    init: function(x, y, dir) {
      var hiddenPointAttr = {
        fixed: true,
        name: "",
        visible: false,
        withLabel: false
      };
      this.arrowLen = 20 / math_default.hypot(this.board.unitX, this.board.unitY);
      this.pos = [x, y];
      this.isPenDown = true;
      this.dir = 90;
      this.stack = [];
      this.objects = [];
      this.curve = this.board.create(
        "curve",
        [[this.pos[0]], [this.pos[1]]],
        this._attributes
      );
      this.objects.push(this.curve);
      this.turtle = this.board.create("point", this.pos, hiddenPointAttr);
      this.objects.push(this.turtle);
      this.turtle2 = this.board.create(
        "point",
        [this.pos[0], this.pos[1] + this.arrowLen],
        hiddenPointAttr
      );
      this.objects.push(this.turtle2);
      this.visProp.arrow.lastArrow = true;
      this.visProp.arrow.straightFirst = false;
      this.visProp.arrow.straightLast = false;
      this.arrow = this.board.create(
        "line",
        [this.turtle, this.turtle2],
        this.visProp.arrow
      );
      this.objects.push(this.arrow);
      this.subs = {
        arrow: this.arrow
      };
      this.inherits.push(this.arrow);
      this.right(90 - dir);
      this.board.update();
    },
    /**
     * Move the turtle forward.
     * @param {Number} len of forward move in user coordinates
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    forward: function(len) {
      if (len === 0) {
        return this;
      }
      var t, dx = len * Math.cos(this.dir * Math.PI / 180), dy = len * Math.sin(this.dir * Math.PI / 180);
      if (!this.turtleIsHidden) {
        t = this.board.create("transform", [dx, dy], { type: "translate" });
        t.applyOnce(this.turtle);
        t.applyOnce(this.turtle2);
      }
      if (this.isPenDown) {
        if (this.curve.dataX.length >= 8192) {
          this.curve = this.board.create(
            "curve",
            [[this.pos[0]], [this.pos[1]]],
            this._attributes
          );
          this.objects.push(this.curve);
        }
      }
      this.pos[0] += dx;
      this.pos[1] += dy;
      if (this.isPenDown) {
        this.curve.dataX.push(this.pos[0]);
        this.curve.dataY.push(this.pos[1]);
      }
      this.board.update();
      return this;
    },
    /**
     * Move the turtle backwards.
     * @param {Number} len of backwards move in user coordinates
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    back: function(len) {
      return this.forward(-len);
    },
    /**
     * Rotate the turtle direction to the right
     * @param {Number} angle of the rotation in degrees
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    right: function(angle) {
      this.dir -= angle;
      this.dir %= 360;
      if (!this.turtleIsHidden) {
        var t = this.board.create(
          "transform",
          [-angle * Math.PI / 180, this.turtle],
          { type: "rotate" }
        );
        t.applyOnce(this.turtle2);
      }
      this.board.update();
      return this;
    },
    /**
     * Rotate the turtle direction to the right.
     * @param {Number} angle of the rotation in degrees
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    left: function(angle) {
      return this.right(-angle);
    },
    /**
     * Pen up, stops visible drawing
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    penUp: function() {
      this.isPenDown = false;
      return this;
    },
    /**
     * Pen down, continues visible drawing
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    penDown: function() {
      this.isPenDown = true;
      this.curve = this.board.create(
        "curve",
        [[this.pos[0]], [this.pos[1]]],
        this._attributes
      );
      this.objects.push(this.curve);
      return this;
    },
    /**
     * Removes the turtle curve from the board. The turtle stays in its position.
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    clean: function() {
      var i2, el;
      for (i2 = 0; i2 < this.objects.length; i2++) {
        el = this.objects[i2];
        if (el.type === constants_default.OBJECT_TYPE_CURVE) {
          this.board.removeObject(el);
          this.objects.splice(i2, 1);
        }
      }
      this.curve = this.board.create(
        "curve",
        [[this.pos[0]], [this.pos[1]]],
        this._attributes
      );
      this.objects.push(this.curve);
      this.board.update();
      return this;
    },
    /**
     *  Removes the turtle completely and resets it to its initial position and direction.
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    clearScreen: function() {
      var i2, el, len = this.objects.length;
      for (i2 = 0; i2 < len; i2++) {
        el = this.objects[i2];
        this.board.removeObject(el);
      }
      this.init(0, 0, 90);
      return this;
    },
    /**
     *  Moves the turtle without drawing to a new position
     * @param {Number} x new x- coordinate
     * @param {Number} y new y- coordinate
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    setPos: function(x, y) {
      var t;
      if (type_default.isArray(x)) {
        this.pos = x;
      } else {
        this.pos = [x, y];
      }
      if (!this.turtleIsHidden) {
        this.turtle.setPositionDirectly(constants_default.COORDS_BY_USER, [x, y]);
        this.turtle2.setPositionDirectly(constants_default.COORDS_BY_USER, [x, y + this.arrowLen]);
        t = this.board.create(
          "transform",
          [-(this.dir - 90) * Math.PI / 180, this.turtle],
          { type: "rotate" }
        );
        t.applyOnce(this.turtle2);
      }
      this.curve = this.board.create(
        "curve",
        [[this.pos[0]], [this.pos[1]]],
        this._attributes
      );
      this.objects.push(this.curve);
      this.board.update();
      return this;
    },
    /**
     *  Sets the pen size. Equivalent to setAttribute({strokeWidth:size})
     * but affects only the future turtle.
     * @param {Number} size
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    setPenSize: function(size2) {
      this.curve = this.board.create(
        "curve",
        [[this.pos[0]], [this.pos[1]]],
        this.copyAttr("strokeWidth", size2)
      );
      this.objects.push(this.curve);
      return this;
    },
    /**
     *  Sets the pen color. Equivalent to setAttribute({strokeColor:color})
     * but affects only the future turtle.
     * @param {String} color
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    setPenColor: function(color2) {
      this.curve = this.board.create(
        "curve",
        [[this.pos[0]], [this.pos[1]]],
        this.copyAttr("strokeColor", color2)
      );
      this.objects.push(this.curve);
      return this;
    },
    /**
     * Get attribute of the last turtle curve object.
     *
     * @param {String} key
     * @returns attribute value
     * @private
     */
    getPenAttribute: function(key) {
      var pos, le = this.objects.length;
      if (le === 4) {
        pos = 0;
      } else {
        pos = le - 1;
      }
      return type_default.evaluate(this.objects[pos].visProp[key]);
    },
    /**
     * Get most recently set turtle size (in pixel).
     * @returns Number Size of the last turtle segment in pixel.
     */
    getPenSize: function() {
      return this.getPenAttribute("strokewidth");
    },
    /**
     * Get most recently set turtle color.
     * @returns String RGB color value of the last turtle segment.
     */
    getPenColor: function() {
      return this.getPenAttribute("strokecolor");
    },
    /**
     * Get most recently set turtle color.
     * @returns String RGB highlight color value of the last turtle segment.
     */
    getHighlightPenColor: function() {
      return this.getPenAttribute("highlightstrokecolor");
    },
    /**
     *  Sets the highlight pen color. Equivalent to setAttribute({highlightStrokeColor:color})
     * but affects only the future turtle.
     * @param {String} color
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    setHighlightPenColor: function(color2) {
      this.curve = this.board.create(
        "curve",
        [[this.pos[0]], [this.pos[1]]],
        this.copyAttr("highlightStrokeColor", color2)
      );
      this.objects.push(this.curve);
      return this;
    },
    /**
     * Sets properties of the turtle, see also {@link JXG.GeometryElement#setAttribute}.
     * Sets the property for all curves of the turtle in the past and in the future.
     * @param {Object} attributes key:value pairs
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    setAttribute: function(attributes) {
      var i2, el, tmp, len = this.objects.length;
      for (i2 = 0; i2 < len; i2++) {
        el = this.objects[i2];
        if (el.type === constants_default.OBJECT_TYPE_CURVE) {
          el.setAttribute(attributes);
        }
      }
      tmp = this.visProp.id;
      this.visProp = type_default.deepCopy(this.curve.visProp);
      this.visProp.id = tmp;
      this._attributes = type_default.deepCopy(this.visProp);
      delete this._attributes.id;
      return this;
    },
    /**
     * Set a future attribute of the turtle.
     * @private
     * @param {String} key
     * @param {Number|String} val
     * @returns {Object} pointer to the attributes object
     */
    copyAttr: function(key, val) {
      this._attributes[key.toLowerCase()] = val;
      return this._attributes;
    },
    /**
     * Sets the visibility of the turtle head to true,
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    showTurtle: function() {
      this.turtleIsHidden = false;
      this.arrow.setAttribute({ visible: true });
      this.visProp.arrow.visible = false;
      this.setPos(this.pos[0], this.pos[1]);
      this.board.update();
      return this;
    },
    /**
     * Sets the visibility of the turtle head to false,
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    hideTurtle: function() {
      this.turtleIsHidden = true;
      this.arrow.setAttribute({ visible: false });
      this.visProp.arrow.visible = false;
      this.board.update();
      return this;
    },
    /**
     * Moves the turtle to position [0,0].
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    home: function() {
      this.pos = [0, 0];
      this.setPos(this.pos[0], this.pos[1]);
      return this;
    },
    /**
     *  Pushes the position of the turtle on the stack.
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    pushTurtle: function() {
      this.stack.push([this.pos[0], this.pos[1], this.dir]);
      return this;
    },
    /**
     *  Gets the last position of the turtle on the stack, sets the turtle to this position and removes this
     * position from the stack.
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    popTurtle: function() {
      var status = this.stack.pop();
      this.pos[0] = status[0];
      this.pos[1] = status[1];
      this.dir = status[2];
      this.setPos(this.pos[0], this.pos[1]);
      return this;
    },
    /**
     * Rotates the turtle into a new direction.
     * There are two possibilities:
     * @param {Number|Array} target If a number is given, it is interpreted as the new direction to look to; If an array
     * consisting of two Numbers is given targeted is used as a pair coordinates.
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    lookTo: function(target) {
      var ax, ay, bx, by, beta;
      if (type_default.isArray(target)) {
        ax = this.pos[0];
        ay = this.pos[1];
        bx = target[0];
        by = target[1];
        beta = Math.atan2(by - ay, bx - ax);
        this.right(this.dir - beta * 180 / Math.PI);
      } else if (type_default.isNumber(target)) {
        this.right(this.dir - target);
      }
      return this;
    },
    /**
     * Moves the turtle to a given coordinate pair.
     * The direction is not changed.
     * @param {Array} target Coordinates of the point where the turtle looks to.
     * @returns {JXG.Turtle} pointer to the turtle object
     */
    moveTo: function(target) {
      var dx, dy, t;
      if (type_default.isArray(target)) {
        dx = target[0] - this.pos[0];
        dy = target[1] - this.pos[1];
        if (!this.turtleIsHidden) {
          t = this.board.create("transform", [dx, dy], { type: "translate" });
          t.applyOnce(this.turtle);
          t.applyOnce(this.turtle2);
        }
        if (this.isPenDown) {
          if (this.curve.dataX.length >= 8192) {
            this.curve = this.board.create(
              "curve",
              [[this.pos[0]], [this.pos[1]]],
              this._attributes
            );
            this.objects.push(this.curve);
          }
        }
        this.pos[0] = target[0];
        this.pos[1] = target[1];
        if (this.isPenDown) {
          this.curve.dataX.push(this.pos[0]);
          this.curve.dataY.push(this.pos[1]);
        }
        this.board.update();
      }
      return this;
    },
    /**
     * Alias for {@link JXG.Turtle#forward}
     */
    fd: function(len) {
      return this.forward(len);
    },
    /**
     * Alias for {@link JXG.Turtle#back}
     */
    bk: function(len) {
      return this.back(len);
    },
    /**
     * Alias for {@link JXG.Turtle#left}
     */
    lt: function(angle) {
      return this.left(angle);
    },
    /**
     * Alias for {@link JXG.Turtle#right}
     */
    rt: function(angle) {
      return this.right(angle);
    },
    /**
     * Alias for {@link JXG.Turtle#penUp}
     */
    pu: function() {
      return this.penUp();
    },
    /**
     * Alias for {@link JXG.Turtle#penDown}
     */
    pd: function() {
      return this.penDown();
    },
    /**
     * Alias for {@link JXG.Turtle#hideTurtle}
     */
    ht: function() {
      return this.hideTurtle();
    },
    /**
     * Alias for {@link JXG.Turtle#showTurtle}
     */
    st: function() {
      return this.showTurtle();
    },
    /**
     * Alias for {@link JXG.Turtle#clearScreen}
     */
    cs: function() {
      return this.clearScreen();
    },
    /**
     * Alias for {@link JXG.Turtle#pushTurtle}
     */
    push: function() {
      return this.pushTurtle();
    },
    /**
     * Alias for {@link JXG.Turtle#popTurtle}
     */
    pop: function() {
      return this.popTurtle();
    },
    /**
     * The "co"-coordinate of the turtle curve at position t is returned.
     *
     * @param {Number} t parameter
     * @param {String} co. Either 'X' or 'Y'.
     * @returns {Number} x-coordinate of the turtle position or x-coordinate of turtle at position t
     */
    evalAt: function(t, co) {
      var i2, j, el, tc, len = this.objects.length;
      for (i2 = 0, j = 0; i2 < len; i2++) {
        el = this.objects[i2];
        if (el.elementClass === constants_default.OBJECT_CLASS_CURVE) {
          if (j <= t && t < j + el.numberPoints) {
            tc = t - j;
            return el[co](tc);
          }
          j += el.numberPoints;
        }
      }
      return this[co]();
    },
    /**
     * if t is not supplied the x-coordinate of the turtle is returned. Otherwise
     * the x-coordinate of the turtle curve at position t is returned.
     * @param {Number} t parameter
     * @returns {Number} x-coordinate of the turtle position or x-coordinate of turtle at position t
     */
    X: function(t) {
      if (!type_default.exists(t)) {
        return this.pos[0];
      }
      return this.evalAt(t, "X");
    },
    /**
     * if t is not supplied the y-coordinate of the turtle is returned. Otherwise
     * the y-coordinate of the turtle curve at position t is returned.
     * @param {Number} t parameter
     * @returns {Number} x-coordinate of the turtle position or x-coordinate of turtle at position t
     */
    Y: function(t) {
      if (!type_default.exists(t)) {
        return this.pos[1];
      }
      return this.evalAt(t, "Y");
    },
    /**
     * @returns {Number} z-coordinate of the turtle position
     */
    Z: function(t) {
      return 1;
    },
    /**
     * Gives the lower bound of the parameter if the turtle is treated as parametric curve.
     */
    minX: function() {
      return 0;
    },
    /**
     * Gives the upper bound of the parameter if the turtle is treated as parametric curve.
     * May be overwritten in @see generateTerm.
     */
    maxX: function() {
      var i2, el, len = this.objects.length, np = 0;
      for (i2 = 0; i2 < len; i2++) {
        el = this.objects[i2];
        if (el.elementClass === constants_default.OBJECT_CLASS_CURVE) {
          np += this.objects[i2].numberPoints;
        }
      }
      return np;
    },
    /**
     * Checks whether (x,y) is near the curve.
     * @param {Number} x Coordinate in x direction, screen coordinates.
     * @param {Number} y Coordinate in y direction, screen coordinates.
     * @returns {Boolean} True if (x,y) is near the curve, False otherwise.
     */
    hasPoint: function(x, y) {
      var i2, el;
      for (i2 = 0; i2 < this.objects.length; i2++) {
        el = this.objects[i2];
        if (el.type === constants_default.OBJECT_TYPE_CURVE) {
          if (el.hasPoint(x, y)) {
            return true;
          }
        }
      }
      return false;
    }
  }
);
jxg_default.createTurtle = function(board, parents, attributes) {
  var attr;
  parents = parents || [];
  attr = type_default.copyAttributes(attributes, board.options, "turtle");
  return new jxg_default.Turtle(board, parents, attr);
};
jxg_default.registerElement("turtle", jxg_default.createTurtle);
var turtle_default = jxg_default.Turtle;

// node_modules/jsxgraph/src/base/ticks.js
jxg_default.Ticks = function(line, ticks, attributes) {
  this.constructor(line.board, attributes, constants_default.OBJECT_TYPE_TICKS, constants_default.OBJECT_CLASS_OTHER);
  this.line = line;
  this.board = this.line.board;
  this.fixedTicks = null;
  this.equidistant = false;
  this.labelsData = [];
  if (type_default.isFunction(ticks)) {
    this.ticksFunction = ticks;
    throw new Error("Function arguments are no longer supported.");
  }
  if (type_default.isArray(ticks)) {
    this.fixedTicks = ticks;
  } else {
    this.equidistant = true;
  }
  this.ticks = [];
  this.labels = [];
  this.labelCounter = 0;
  this.id = this.line.addTicks(this);
  this.elType = "ticks";
  this.inherits.push(this.labels);
  this.board.setId(this, "Ti");
};
jxg_default.Ticks.prototype = new element_default();
jxg_default.extend(
  jxg_default.Ticks.prototype,
  /** @lends JXG.Ticks.prototype */
  {
    // /**
    //  * Ticks function:
    //  * determines the distance (in user units) of two major ticks.
    //  * See above in constructor and in @see JXG.GeometryElement#setAttribute
    //  *
    //  * @private
    //  * @param {Number} ticks Distance between two major ticks
    //  * @returns {Function} returns method ticksFunction
    //  */
    // // makeTicksFunction: function (ticks) {
    //     // return function () {
    //         ticksFunction: function () {
    //                     var delta, b, dist,
    //                     number_major_tick_intervals = 5;
    //                 if (Type.evaluate(this.visProp.insertticks)) {
    //                     b = this.getLowerAndUpperBounds(this.getZeroCoordinates(), 'ticksdistance');
    //                     dist = b.upper - b.lower;
    //                     // delta: Proposed distance in user units between two major ticks
    //                     delta = Math.pow(10, Math.floor(Math.log(dist / number_major_tick_intervals) / Math.LN10));
    // console.log("delta", delta,  b.upper, b.lower, dist, dist / number_major_tick_intervals * 1.1)
    //                     if (5 * delta < dist / number_major_tick_intervals * 1.1) {
    //                         return 5 * delta;
    //                     }
    //                     if (2 * delta < dist / number_major_tick_intervals * 1.1) {
    //                         return 2 * delta;
    //                     }
    //                     // < v1.6.0:
    //                     // delta = Math.pow(10, Math.floor(Math.log(0.6 * dist) / Math.LN10));
    //                     if (false && dist <= 6 * delta) {
    //                         delta *= 0.5;
    //                     }
    //                     return delta;
    //                 }
    //                 // In case of insertTicks==false
    //                 return Type.evaluate(this.visProp.ticksdistance);
    //                 // return ticks;
    //             // };
    //         },
    /**
     * Checks whether (x,y) is near the line.
     * Only available for line elements,  not for ticks on curves.
     * @param {Number} x Coordinate in x direction, screen coordinates.
     * @param {Number} y Coordinate in y direction, screen coordinates.
     * @returns {Boolean} True if (x,y) is near the line, False otherwise.
     */
    hasPoint: function(x, y) {
      var i2, t, r, type, len = this.ticks && this.ticks.length || 0;
      if (type_default.isObject(type_default.evaluate(this.visProp.precision))) {
        type = this.board._inputDevice;
        r = type_default.evaluate(this.visProp.precision[type]);
      } else {
        r = this.board.options.precision.hasPoint;
      }
      r += type_default.evaluate(this.visProp.strokewidth) * 0.5;
      if (!type_default.evaluate(this.line.visProp.scalable) || this.line.elementClass === constants_default.OBJECT_CLASS_CURVE) {
        return false;
      }
      if (this.line.stdform[1] !== 0 && this.line.stdform[2] !== 0 && this.line.type !== constants_default.OBJECT_TYPE_AXIS) {
        return false;
      }
      for (i2 = 0; i2 < len; i2++) {
        t = this.ticks[i2];
        if (t[2]) {
          if (!(this.line.stdform[1] === 0 && Math.abs(t[0][0] - this.line.point1.coords.scrCoords[1]) < math_default.eps || this.line.stdform[2] === 0 && Math.abs(t[1][0] - this.line.point1.coords.scrCoords[2]) < math_default.eps)) {
            if (Math.abs(t[0][0] - t[0][1]) >= 1 || Math.abs(t[1][0] - t[1][1]) >= 1) {
              if (this.line.stdform[1] === 0) {
                if (Math.abs(y - this.line.point1.coords.scrCoords[2]) < 2 * r && t[0][0] - r < x && x < t[0][1] + r) {
                  return true;
                }
              } else if (this.line.stdform[2] === 0) {
                if (Math.abs(x - this.line.point1.coords.scrCoords[1]) < 2 * r && t[1][0] - r < y && y < t[1][1] + r) {
                  return true;
                }
              }
            }
          }
        }
      }
      return false;
    },
    /**
     * Sets x and y coordinate of the tick.
     * @param {number} method The type of coordinates used here. Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.
     * @param {Array} coords coordinates in screen/user units
     * @param {Array} oldcoords previous coordinates in screen/user units
     * @returns {JXG.Ticks} this element
     */
    setPositionDirectly: function(method, coords, oldcoords) {
      var dx, dy, c = new coords_default(method, coords, this.board), oldc = new coords_default(method, oldcoords, this.board), bb = this.board.getBoundingBox();
      if (this.line.type !== constants_default.OBJECT_TYPE_AXIS || !type_default.evaluate(this.line.visProp.scalable)) {
        return this;
      }
      if (Math.abs(this.line.stdform[1]) < math_default.eps && Math.abs(c.usrCoords[1] * oldc.usrCoords[1]) > math_default.eps) {
        dx = oldc.usrCoords[1] / c.usrCoords[1];
        bb[0] *= dx;
        bb[2] *= dx;
        this.board.setBoundingBox(bb, this.board.keepaspectratio, "update");
      } else if (Math.abs(this.line.stdform[2]) < math_default.eps && Math.abs(c.usrCoords[2] * oldc.usrCoords[2]) > math_default.eps) {
        dy = oldc.usrCoords[2] / c.usrCoords[2];
        bb[3] *= dy;
        bb[1] *= dy;
        this.board.setBoundingBox(bb, this.board.keepaspectratio, "update");
      }
      return this;
    },
    /**
     * (Re-)calculates the ticks coordinates.
     * @private
     */
    calculateTicksCoordinates: function() {
      var coordsZero, b, r_max, bb;
      if (this.line.elementClass === constants_default.OBJECT_CLASS_LINE) {
        this.setTicksSizeVariables();
        if (Math.abs(this.dx) < math_default.eps && Math.abs(this.dy) < math_default.eps) {
          return;
        }
      }
      coordsZero = this.getZeroCoordinates();
      if (this.line.elementClass === constants_default.OBJECT_CLASS_LINE) {
        b = this.getLowerAndUpperBounds(coordsZero, "ticksdistance");
      } else {
        b = {
          lower: this.line.minX(),
          upper: this.line.maxX(),
          a1: 0,
          a2: 0,
          m1: 0,
          m2: 0
        };
      }
      if (type_default.evaluate(this.visProp.type) === "polar") {
        bb = this.board.getBoundingBox();
        r_max = Math.max(
          math_default.hypot(bb[0], bb[1]),
          math_default.hypot(bb[2], bb[3])
        );
        b.upper = r_max;
      }
      this.ticks = [];
      this.labelsData = [];
      if (this.equidistant) {
        this.generateEquidistantTicks(coordsZero, b);
      } else {
        this.generateFixedTicks(coordsZero, b);
      }
      return this;
    },
    /**
     * Sets the variables used to set the height and slope of each tick.
     *
     * @private
     */
    setTicksSizeVariables: function(pos) {
      var d, mi, ma, len, distMaj = type_default.evaluate(this.visProp.majorheight) * 0.5, distMin = type_default.evaluate(this.visProp.minorheight) * 0.5;
      if (type_default.exists(pos)) {
        mi = this.line.minX();
        ma = this.line.maxX();
        len = this.line.points.length;
        if (len < 2) {
          this.dxMaj = 0;
          this.dyMaj = 0;
        } else if (math_default.relDif(pos, mi) < math_default.eps) {
          this.dxMaj = this.line.points[0].usrCoords[2] - this.line.points[1].usrCoords[2];
          this.dyMaj = this.line.points[1].usrCoords[1] - this.line.points[0].usrCoords[1];
        } else if (math_default.relDif(pos, ma) < math_default.eps) {
          this.dxMaj = this.line.points[len - 2].usrCoords[2] - this.line.points[len - 1].usrCoords[2];
          this.dyMaj = this.line.points[len - 1].usrCoords[1] - this.line.points[len - 2].usrCoords[1];
        } else {
          this.dxMaj = -numerics_default.D(this.line.Y)(pos);
          this.dyMaj = numerics_default.D(this.line.X)(pos);
        }
      } else {
        this.dxMaj = this.line.stdform[1];
        this.dyMaj = this.line.stdform[2];
      }
      this.dxMin = this.dxMaj;
      this.dyMin = this.dyMaj;
      this.dx = this.dxMaj;
      this.dy = this.dyMaj;
      d = math_default.hypot(this.dxMaj * this.board.unitX, this.dyMaj * this.board.unitY);
      this.dxMaj *= distMaj / d * this.board.unitX;
      this.dyMaj *= distMaj / d * this.board.unitY;
      this.dxMin *= distMin / d * this.board.unitX;
      this.dyMin *= distMin / d * this.board.unitY;
      this.minStyle = type_default.evaluate(this.visProp.minorheight) < 0 ? "infinite" : "finite";
      this.majStyle = type_default.evaluate(this.visProp.majorheight) < 0 ? "infinite" : "finite";
    },
    /**
     * Returns the coordinates of the point zero of the line.
     *
     * If the line is an {@link Axis}, the coordinates of the projection of the board's zero point is returned
     *
     * Otherwise, the coordinates of the point that acts as zero are
     * established depending on the value of {@link JXG.Ticks#anchor}
     *
     * @returns {JXG.Coords} Coords object for the zero point on the line
     * @private
     */
    getZeroCoordinates: function() {
      var c1x, c1y, c1z, c2x, c2y, c2z, t, mi, ma, ev_a = type_default.evaluate(this.visProp.anchor);
      if (this.line.elementClass === constants_default.OBJECT_CLASS_LINE) {
        if (this.line.type === constants_default.OBJECT_TYPE_AXIS) {
          return geometry_default.projectPointToLine(
            {
              coords: {
                usrCoords: [1, 0, 0]
              }
            },
            this.line,
            this.board
          );
        }
        c1z = this.line.point1.coords.usrCoords[0];
        c1x = this.line.point1.coords.usrCoords[1];
        c1y = this.line.point1.coords.usrCoords[2];
        c2z = this.line.point2.coords.usrCoords[0];
        c2x = this.line.point2.coords.usrCoords[1];
        c2y = this.line.point2.coords.usrCoords[2];
        if (ev_a === "right") {
          return this.line.point2.coords;
        }
        if (ev_a === "middle") {
          return new coords_default(
            constants_default.COORDS_BY_USER,
            [(c1z + c2z) * 0.5, (c1x + c2x) * 0.5, (c1y + c2y) * 0.5],
            this.board
          );
        }
        if (type_default.isNumber(ev_a)) {
          return new coords_default(
            constants_default.COORDS_BY_USER,
            [
              c1z + (c2z - c1z) * ev_a,
              c1x + (c2x - c1x) * ev_a,
              c1y + (c2y - c1y) * ev_a
            ],
            this.board
          );
        }
        return this.line.point1.coords;
      }
      mi = this.line.minX();
      ma = this.line.maxX();
      if (ev_a === "right") {
        t = ma;
      } else if (ev_a === "middle") {
        t = (mi + ma) * 0.5;
      } else if (type_default.isNumber(ev_a)) {
        t = mi * (1 - ev_a) + ma * ev_a;
      } else {
        t = mi;
      }
      return t;
    },
    /**
     * Calculate the lower and upper bounds for tick rendering.
     * If {@link JXG.Ticks#includeBoundaries} is false, the boundaries will exclude point1 and point2.
     *
     * @param  {JXG.Coords} coordsZero
     * @returns {String} [type] If type=='ticksdistance', the bounds are
     *                         the intersection of the line with the bounding box of the board, respecting
     *                         the value of the line attribute 'margin' and the width of arrow heads.
     *                         Otherwise, it is the projection of the corners of the bounding box
     *                         to the line - without the attribute 'margin' and width of arrow heads.
     *  <br>
     *                         The first case is needed to determine which ticks are displayed, i.e. where to stop.
     *                         The second case is to determine the distance between ticks in case of 'insertTicks:true'.
     * @returns {Object}     {lower: Number, upper: Number } containing the lower and upper bounds in user units.
     *
     * @private
     */
    getLowerAndUpperBounds: function(coordsZero, type) {
      var lowerBound, upperBound, fA, lA, point1, point2, isPoint1inBoard, isPoint2inBoard, dZeroPoint1, dZeroPoint2, arrowData, a1, a2, m1, m2, eps = math_default.eps * 10, ev_sf = type_default.evaluate(this.line.visProp.straightfirst), ev_sl = type_default.evaluate(this.line.visProp.straightlast), ev_i = type_default.evaluate(this.visProp.includeboundaries);
      if (this.line.elementClass === constants_default.OBJECT_CLASS_CURVE) {
        return {
          lower: this.line.minX(),
          upper: this.line.maxX()
        };
      }
      point1 = new coords_default(constants_default.COORDS_BY_USER, this.line.point1.coords.usrCoords, this.board);
      point2 = new coords_default(constants_default.COORDS_BY_USER, this.line.point2.coords.usrCoords, this.board);
      isPoint1inBoard = Math.abs(point1.usrCoords[0]) >= math_default.eps && point1.scrCoords[1] >= 0 && point1.scrCoords[1] <= this.board.canvasWidth && point1.scrCoords[2] >= 0 && point1.scrCoords[2] <= this.board.canvasHeight;
      isPoint2inBoard = Math.abs(point2.usrCoords[0]) >= math_default.eps && point2.scrCoords[1] >= 0 && point2.scrCoords[1] <= this.board.canvasWidth && point2.scrCoords[2] >= 0 && point2.scrCoords[2] <= this.board.canvasHeight;
      if (type_default.exists(type) && type === "ticksdistance") {
        geometry_default.calcStraight(this.line, point1, point2, 0);
        m1 = this.getDistanceFromZero(coordsZero, point1);
        m2 = this.getDistanceFromZero(coordsZero, point2);
        geometry_default.calcStraight(this.line, point1, point2, type_default.evaluate(this.line.visProp.margin));
        m1 = this.getDistanceFromZero(coordsZero, point1) - m1;
        m2 = this.getDistanceFromZero(coordsZero, point2).m2;
      } else {
        geometry_default.calcLineDelimitingPoints(this.line, point1, point2);
      }
      fA = type_default.evaluate(this.line.visProp.firstarrow);
      lA = type_default.evaluate(this.line.visProp.lastarrow);
      a1 = this.getDistanceFromZero(coordsZero, point1);
      a2 = this.getDistanceFromZero(coordsZero, point2);
      if (fA || lA) {
        arrowData = this.board.renderer.getArrowHeadData(
          this.line,
          type_default.evaluate(this.line.visProp.strokewidth),
          ""
        );
        this.board.renderer.getPositionArrowHead(
          this.line,
          point1,
          point2,
          arrowData
        );
      }
      dZeroPoint1 = this.getDistanceFromZero(coordsZero, point1);
      dZeroPoint2 = this.getDistanceFromZero(coordsZero, point2);
      a1 = dZeroPoint1 - a1;
      a2 = dZeroPoint1 - a2;
      if (dZeroPoint1 < dZeroPoint2) {
        lowerBound = dZeroPoint1;
        upperBound = dZeroPoint2;
        if (!ev_sf && isPoint1inBoard && !ev_i) {
          lowerBound += eps;
        }
        if (!ev_sl && isPoint2inBoard && !ev_i) {
          upperBound -= eps;
        }
      } else if (dZeroPoint2 < dZeroPoint1) {
        lowerBound = dZeroPoint2;
        upperBound = dZeroPoint1;
        if (!ev_sl && isPoint2inBoard && !ev_i) {
          lowerBound += eps;
        }
        if (!ev_sf && isPoint1inBoard && !ev_i) {
          upperBound -= eps;
        }
      } else {
        lowerBound = 0;
        upperBound = 0;
      }
      return {
        lower: lowerBound,
        upper: upperBound,
        a1,
        a2,
        m1,
        m2
      };
    },
    /**
     * Calculates the signed distance in user coordinates from zero to a given point.
     * Sign is positive, if the direction from zero to point is the same as the direction
     * zero to point2 of the line.
     *
     * @param  {JXG.Coords} zero  coordinates of the point considered zero
     * @param  {JXG.Coords} point coordinates of the point to find out the distance
     * @returns {Number}           distance between zero and point, including its sign
     * @private
     */
    getDistanceFromZero: function(zero, point) {
      var p1, p2, dirLine, dirPoint, distance;
      p1 = this.line.point1.coords;
      p2 = this.line.point2.coords;
      distance = zero.distance(constants_default.COORDS_BY_USER, point);
      dirLine = [
        p2.usrCoords[0] - p1.usrCoords[0],
        p2.usrCoords[1] - p1.usrCoords[1],
        p2.usrCoords[2] - p1.usrCoords[2]
      ];
      dirPoint = [
        point.usrCoords[0] - zero.usrCoords[0],
        point.usrCoords[1] - zero.usrCoords[1],
        point.usrCoords[2] - zero.usrCoords[2]
      ];
      if (math_default.innerProduct(dirLine, dirPoint, 3) < 0) {
        distance *= -1;
      }
      return distance;
    },
    /**
     * Creates ticks coordinates and labels automatically.
     * The frequency of ticks is affected by the values of {@link JXG.Ticks#insertTicks}, {@link JXG.Ticks#minTicksDistance},
     * and {@link JXG.Ticks#ticksDistance}
     *
     * @param  {JXG.Coords} coordsZero coordinates of the point considered zero
     * @param  {Object}     bounds     contains the lower and upper bounds for ticks placement
     * @private
     */
    generateEquidistantTicks: function(coordsZero, bounds) {
      var tickPosition, eps = math_default.eps, deltas, ticksDelta, ev_mt = type_default.evaluate(this.visProp.minorticks);
      ticksDelta = this.getDistanceMajorTicks();
      if (this.line.elementClass === constants_default.OBJECT_CLASS_LINE) {
        deltas = this.getXandYdeltas();
      }
      ticksDelta *= type_default.evaluate(this.visProp.scale);
      ticksDelta /= ev_mt + 1;
      this.ticksDelta = ticksDelta;
      if (ticksDelta < math_default.eps) {
        return;
      }
      tickPosition = 0;
      if (!type_default.evaluate(this.visProp.drawzero)) {
        tickPosition = ticksDelta;
      }
      while (tickPosition <= bounds.upper + eps) {
        if (tickPosition >= bounds.lower - eps) {
          this.processTickPosition(coordsZero, tickPosition, ticksDelta, deltas);
        }
        tickPosition += ticksDelta;
        if (bounds.upper - tickPosition > ticksDelta * 1e4) {
          break;
        }
      }
      tickPosition = -ticksDelta;
      while (tickPosition >= bounds.lower - eps) {
        if (tickPosition <= bounds.upper + eps) {
          this.processTickPosition(coordsZero, tickPosition, ticksDelta, deltas);
        }
        tickPosition -= ticksDelta;
        if (tickPosition - bounds.lower > ticksDelta * 1e4) {
          break;
        }
      }
    },
    /**
     * Calculates the distance between two major ticks in user units.
     * <ul>
     * <li> If the attribute "insertTicks" is false, the value of the attribute
     * "ticksDistance" is returned. The attribute "minTicksDistance" is ignored in this case.
     * <li> If the attribute "insertTicks" is true, the attribute "ticksDistance" is ignored.
     * The distance between two major ticks is computed
     * as <i>a 10<sup>i</sup></i>, where <i>a</i> is one of <i>{1, 2, 5}</i> and
     * the number <i>a 10<sup>i</sup></i> is maximized such that there are approximately
     * 6 major ticks and there are at least "minTicksDistance" pixel between minor ticks.
     * The latter restriction has priority over the number of major ticks.
     * </ul>
     * @returns Number
     * @private
     */
    getDistanceMajorTicks: function() {
      var delta, delta2, b, d, dist, scale, numberMajorTicks = 5, maxDist, minDist, ev_minti;
      if (type_default.evaluate(this.visProp.insertticks)) {
        b = this.getLowerAndUpperBounds(this.getZeroCoordinates(), "");
        dist = b.upper - b.lower;
        scale = type_default.evaluate(this.visProp.scale);
        maxDist = dist / (numberMajorTicks + 1) / scale;
        minDist = type_default.evaluate(this.visProp.minticksdistance) / scale;
        ev_minti = type_default.evaluate(this.visProp.minorticks);
        d = this.getXandYdeltas();
        d.x *= this.board.unitX;
        d.y *= this.board.unitY;
        minDist /= math_default.hypot(d.x, d.y);
        minDist *= ev_minti + 1;
        delta = Math.pow(10, Math.floor(Math.log(minDist) / Math.LN10));
        if (2 * delta >= minDist) {
          delta *= 2;
        } else if (5 * delta >= minDist) {
          delta *= 5;
        }
        delta2 = Math.pow(10, Math.floor(Math.log(maxDist) / Math.LN10));
        if (5 * delta2 < maxDist) {
          delta2 *= 5;
        } else if (2 * delta2 < maxDist) {
          delta2 *= 2;
        }
        delta = Math.max(delta, delta2);
        return delta;
      }
      return type_default.evaluate(this.visProp.ticksdistance);
    },
    //         /**
    //          * Auxiliary method used by {@link JXG.Ticks#generateEquidistantTicks} to adjust the
    //          * distance between two ticks depending on {@link JXG.Ticks#minTicksDistance} value
    //          *
    //          * @param  {Number}     ticksDelta  distance between two major ticks in user coordinates
    //          * @param  {JXG.Coords} coordsZero  coordinates of the point considered zero
    //          * @param  {Object}     deltas      x and y distance in pixel between two user units
    //          * @param  {Object}     bounds      upper and lower bound of the tick positions in user units.
    //          * @private
    //          */
    //         adjustTickDistance: function (ticksDelta, coordsZero, deltas) {
    //             var nx,
    //                 ny,
    //                 // bounds,
    //                 distScr,
    //                 sgn = 1,
    //                 ev_mintd = Type.evaluate(this.visProp.minticksdistance),
    //                 ev_minti = Type.evaluate(this.visProp.minorticks);
    //             if (this.line.elementClass === Const.OBJECT_CLASS_CURVE) {
    //                 return ticksDelta;
    //             }
    //             // Seems to be ignored:
    //             // bounds = this.getLowerAndUpperBounds(coordsZero, "ticksdistance");
    //             // distScr is the distance between two major Ticks in pixel
    //             nx = coordsZero.usrCoords[1] + deltas.x * ticksDelta;
    //             ny = coordsZero.usrCoords[2] + deltas.y * ticksDelta;
    //             distScr = coordsZero.distance(
    //                 Const.COORDS_BY_SCREEN,
    //                 new Coords(Const.COORDS_BY_USER, [nx, ny], this.board)
    //             );
    // // console.log(deltas, distScr, this.board.unitX, this.board.unitY, "ticksDelta:", ticksDelta);
    //             if (ticksDelta === 0.0) {
    //                 return 0.0;
    //             }
    // // console.log(":", distScr, ev_minti + 1, distScr / (ev_minti + 1), ev_mintd)
    //             while (false && distScr / (ev_minti + 1) < ev_mintd) {
    //                 if (sgn === 1) {
    //                     ticksDelta *= 2;
    //                 } else {
    //                     ticksDelta *= 5;
    //                 }
    //                 sgn *= -1;
    //                 nx = coordsZero.usrCoords[1] + deltas.x * ticksDelta;
    //                 ny = coordsZero.usrCoords[2] + deltas.y * ticksDelta;
    //                 distScr = coordsZero.distance(
    //                     Const.COORDS_BY_SCREEN,
    //                     new Coords(Const.COORDS_BY_USER, [nx, ny], this.board)
    //                 );
    //             }
    //             return ticksDelta;
    //         },
    /**
     * Auxiliary method used by {@link JXG.Ticks#generateEquidistantTicks} to create a tick
     * in the line at the given tickPosition.
     *
     * @param  {JXG.Coords} coordsZero    coordinates of the point considered zero
     * @param  {Number}     tickPosition  current tick position relative to zero
     * @param  {Number}     ticksDelta    distance between two major ticks in user coordinates
     * @param  {Object}     deltas      x and y distance between two major ticks
     * @private
     */
    processTickPosition: function(coordsZero, tickPosition, ticksDelta, deltas) {
      var x, y, tickCoords, ti, isLabelPosition, ticksPerLabel = type_default.evaluate(this.visProp.ticksperlabel), labelVal = null;
      if (this.line.elementClass === constants_default.OBJECT_CLASS_LINE) {
        x = coordsZero.usrCoords[1] + tickPosition * deltas.x;
        y = coordsZero.usrCoords[2] + tickPosition * deltas.y;
      } else {
        x = this.line.X(coordsZero + tickPosition);
        y = this.line.Y(coordsZero + tickPosition);
      }
      tickCoords = new coords_default(constants_default.COORDS_BY_USER, [x, y], this.board);
      if (this.line.elementClass === constants_default.OBJECT_CLASS_CURVE) {
        labelVal = coordsZero + tickPosition;
        this.setTicksSizeVariables(labelVal);
      }
      tickCoords.major = Math.round(tickPosition / ticksDelta) % (type_default.evaluate(this.visProp.minorticks) + 1) === 0;
      if (!ticksPerLabel) {
        ticksPerLabel = type_default.evaluate(this.visProp.minorticks) + 1;
      }
      isLabelPosition = Math.round(tickPosition / ticksDelta) % ticksPerLabel === 0;
      ti = this.createTickPath(tickCoords, tickCoords.major);
      if (ti.length === 3) {
        this.ticks.push(ti);
        if (isLabelPosition && type_default.evaluate(this.visProp.drawlabels)) {
          this.labelsData.push(
            this.generateLabelData(
              this.generateLabelText(tickCoords, coordsZero, labelVal),
              tickCoords,
              this.ticks.length
            )
          );
        } else {
          this.labelsData.push(null);
        }
      }
    },
    /**
     * Creates ticks coordinates and labels based on {@link JXG.Ticks#fixedTicks} and {@link JXG.Ticks#labels}.
     *
     * @param  {JXG.Coords} coordsZero Coordinates of the point considered zero
     * @param  {Object}     bounds     contains the lower and upper bounds for ticks placement
     * @private
     */
    generateFixedTicks: function(coordsZero, bounds) {
      var tickCoords, labelText, i2, ti, x, y, eps2 = math_default.eps, fixedTick, hasLabelOverrides = type_default.isArray(this.visProp.labels), deltas, ev_dl = type_default.evaluate(this.visProp.drawlabels);
      if (this.line.elementClass === constants_default.OBJECT_CLASS_LINE) {
        deltas = this.getXandYdeltas();
      }
      for (i2 = 0; i2 < this.fixedTicks.length; i2++) {
        if (this.line.elementClass === constants_default.OBJECT_CLASS_LINE) {
          fixedTick = this.fixedTicks[i2];
          x = coordsZero.usrCoords[1] + fixedTick * deltas.x;
          y = coordsZero.usrCoords[2] + fixedTick * deltas.y;
        } else {
          fixedTick = coordsZero + this.fixedTicks[i2];
          x = this.line.X(fixedTick);
          y = this.line.Y(fixedTick);
        }
        tickCoords = new coords_default(constants_default.COORDS_BY_USER, [x, y], this.board);
        if (this.line.elementClass === constants_default.OBJECT_CLASS_CURVE) {
          this.setTicksSizeVariables(fixedTick);
        }
        ti = this.createTickPath(tickCoords, true);
        if (ti.length === 3 && fixedTick >= bounds.lower - eps2 && fixedTick <= bounds.upper + eps2) {
          this.ticks.push(ti);
          if (ev_dl && (hasLabelOverrides || type_default.exists(this.visProp.labels[i2]))) {
            labelText = hasLabelOverrides ? type_default.evaluate(this.visProp.labels[i2]) : fixedTick;
            this.labelsData.push(
              this.generateLabelData(
                this.generateLabelText(tickCoords, coordsZero, labelText),
                tickCoords,
                i2
              )
            );
          } else {
            this.labelsData.push(null);
          }
        }
      }
    },
    /**
     * Calculates the x and y distances in user coordinates between two units in user space.
     * In essence, these are cosine and sine. The only work to be done is to determine
     * the direction of the line.
     *
     * @returns {Object}
     * @private
     */
    getXandYdeltas: function() {
      var point1UsrCoords, point2UsrCoords, distP1P2 = this.line.point1.Dist(this.line.point2);
      point1UsrCoords = this.line.point1.coords.usrCoords;
      point2UsrCoords = this.line.point2.coords.usrCoords;
      return {
        x: (point2UsrCoords[1] - point1UsrCoords[1]) / distP1P2,
        y: (point2UsrCoords[2] - point1UsrCoords[2]) / distP1P2
      };
    },
    /**
     * Check if (parts of) the tick is inside the canvas. The tick intersects the boundary
     * at two positions: [x[0], y[0]] and [x[1], y[1]] in screen coordinates.
     * @param  {Array}  x Array of length two
     * @param  {Array}  y Array of length two
     * @return {Boolean}   true if parts of the tick are inside of the canvas or on the boundary.
     */
    _isInsideCanvas: function(x, y, m) {
      var cw = this.board.canvasWidth, ch = this.board.canvasHeight;
      if (m === void 0) {
        m = 0;
      }
      return x[0] >= m && x[0] <= cw - m && y[0] >= m && y[0] <= ch - m || x[1] >= m && x[1] <= cw - m && y[1] >= m && y[1] <= ch - m;
    },
    /**
     * @param {JXG.Coords} coords Coordinates of the tick on the line.
     * @param {Boolean} major True if tick is major tick.
     * @returns {Array} Array of length 3 containing path coordinates in screen coordinates
     *                 of the tick (arrays of length 2). 3rd entry is true if major tick otherwise false.
     *                 If the tick is outside of the canvas, the return array is empty.
     * @private
     */
    createTickPath: function(coords, major2) {
      var c, lineStdForm, intersection, dxs, dys, dxr, dyr, alpha, style, x = [-2e6, -2e6], y = [-2e6, -2e6], i2, r, r_max, bb, full, delta, te0, te1, dists;
      c = coords.scrCoords;
      if (major2) {
        dxs = this.dxMaj;
        dys = this.dyMaj;
        style = this.majStyle;
        te0 = type_default.evaluate(this.visProp.majortickendings[0]) > 0;
        te1 = type_default.evaluate(this.visProp.majortickendings[1]) > 0;
      } else {
        dxs = this.dxMin;
        dys = this.dyMin;
        style = this.minStyle;
        te0 = type_default.evaluate(this.visProp.tickendings[0]) > 0;
        te1 = type_default.evaluate(this.visProp.tickendings[1]) > 0;
      }
      lineStdForm = [-dys * c[1] - dxs * c[2], dys, dxs];
      if (major2 && type_default.evaluate(this.visProp.type) === "polar") {
        bb = this.board.getBoundingBox();
        full = 2 * Math.PI;
        delta = full / 180;
        c = coords.usrCoords;
        r = math_default.hypot(c[1], c[2]);
        r_max = Math.max(
          math_default.hypot(bb[0], bb[1]),
          math_default.hypot(bb[2], bb[3])
        );
        if (r < r_max) {
          x = [];
          y = [];
          for (i2 = 0; i2 <= full; i2 += delta) {
            x.push(
              this.board.origin.scrCoords[1] + r * Math.cos(i2) * this.board.unitX
            );
            y.push(
              this.board.origin.scrCoords[2] + r * Math.sin(i2) * this.board.unitY
            );
          }
          return [x, y, major2];
        }
      } else {
        if (style === "infinite") {
          if (type_default.evaluate(this.visProp.ignoreinfinitetickendings)) {
            te0 = te1 = true;
          }
          intersection = geometry_default.meetLineBoard(lineStdForm, this.board);
          if (te0 && te1) {
            x[0] = intersection[0].scrCoords[1];
            x[1] = intersection[1].scrCoords[1];
            y[0] = intersection[0].scrCoords[2];
            y[1] = intersection[1].scrCoords[2];
          } else {
            dists = [
              math_default.innerProduct(
                intersection[0].usrCoords.slice(1, 3),
                this.line.stdform.slice(1, 3)
              ) + this.line.stdform[0],
              math_default.innerProduct(
                intersection[1].usrCoords.slice(1, 3),
                this.line.stdform.slice(1, 3)
              ) + this.line.stdform[0]
            ];
            if (dists[0] < dists[1]) {
              intersection.reverse();
              dists.reverse();
            }
            if (te0) {
              if (dists[0] < 0) {
                return [];
              } else if (dists[1] < 0) {
                x[0] = intersection[0].scrCoords[1];
                y[0] = intersection[0].scrCoords[2];
                x[1] = c[1];
                y[1] = c[2];
              } else {
                x[0] = intersection[0].scrCoords[1];
                y[0] = intersection[0].scrCoords[2];
                x[1] = intersection[1].scrCoords[1];
                y[1] = intersection[1].scrCoords[2];
              }
            } else if (te1) {
              if (dists[1] > 0) {
                return [];
              } else if (dists[0] > 0) {
                x[0] = c[1];
                y[0] = c[2];
                x[1] = intersection[1].scrCoords[1];
                y[1] = intersection[1].scrCoords[2];
              } else {
                x[0] = intersection[0].scrCoords[1];
                y[0] = intersection[0].scrCoords[2];
                x[1] = intersection[1].scrCoords[1];
                y[1] = intersection[1].scrCoords[2];
              }
            }
          }
        } else {
          if (type_default.evaluate(this.visProp.face) === ">") {
            alpha = Math.PI / 4;
          } else if (type_default.evaluate(this.visProp.face) === "<") {
            alpha = -Math.PI / 4;
          } else {
            alpha = 0;
          }
          dxr = Math.cos(alpha) * dxs - Math.sin(alpha) * dys;
          dyr = Math.sin(alpha) * dxs + Math.cos(alpha) * dys;
          x[0] = c[1] + dxr * te0;
          y[0] = c[2] - dyr * te0;
          x[1] = c[1];
          y[1] = c[2];
          alpha = -alpha;
          dxr = Math.cos(alpha) * dxs - Math.sin(alpha) * dys;
          dyr = Math.sin(alpha) * dxs + Math.cos(alpha) * dys;
          x[2] = c[1] - dxr * te1;
          y[2] = c[2] + dyr * te1;
        }
        if (this._isInsideCanvas(x, y)) {
          return [x, y, major2];
        }
      }
      return [];
    },
    /**
     * Format label texts. Show the desired number of digits
     * and use utf-8 minus sign.
     * @param  {Number} value Number to be displayed
     * @return {String}       The value converted into a string.
     * @private
     */
    formatLabelText: function(value) {
      var labelText, digits, ev_um = type_default.evaluate(this.visProp.label.usemathjax), ev_uk = type_default.evaluate(this.visProp.label.usekatex), ev_s = type_default.evaluate(this.visProp.scalesymbol);
      if (type_default.isNumber(value)) {
        if (type_default.evaluate(this.visProp.label.tofraction)) {
          if (ev_um) {
            labelText = "\\(" + type_default.toFraction(value, true) + "\\)";
          } else {
            labelText = type_default.toFraction(value, ev_uk);
          }
        } else {
          digits = type_default.evaluate(this.visProp.digits);
          if (this.useLocale()) {
            labelText = this.formatNumberLocale(value, digits);
          } else {
            labelText = (Math.round(value * 1e11) / 1e11).toString();
            if (labelText.length > type_default.evaluate(this.visProp.maxlabellength) || labelText.indexOf("e") !== -1) {
              if (type_default.evaluate(this.visProp.precision) !== 3 && digits === 3) {
                digits = type_default.evaluate(this.visProp.precision);
              }
              labelText = value.toExponential(digits).toString();
            }
          }
        }
        if (type_default.evaluate(this.visProp.beautifulscientificticklabels)) {
          labelText = this.beautifyScientificNotationLabel(labelText);
        }
        if (labelText.indexOf(".") > -1 && labelText.indexOf("e") === -1) {
          labelText = labelText.replace(/0+$/, "");
          labelText = labelText.replace(/\.$/, "");
        }
      } else {
        labelText = value.toString();
      }
      if (ev_s.length > 0) {
        if (labelText === "1") {
          labelText = ev_s;
        } else if (labelText === "-1") {
          labelText = "-" + ev_s;
        } else if (labelText !== "0") {
          labelText = labelText + ev_s;
        }
      }
      if (type_default.evaluate(this.visProp.useunicodeminus)) {
        labelText = labelText.replace(/-/g, "\u2212");
      }
      return labelText;
    },
    /**
     * Formats label texts to make labels displayed in scientific notation look beautiful.
     * For example, label 5.00e+6 will become 5•10⁶, label -1.00e-7 will become into -1•10⁻⁷
     * @param {String} labelText - The label that we want to convert
     * @returns {String} If labelText was not in scientific notation, return labelText without modifications.
     * Otherwise returns beautified labelText with proper superscript notation.
     */
    beautifyScientificNotationLabel: function(labelText) {
      var returnString;
      if (labelText.indexOf("e") === -1) {
        return labelText;
      }
      returnString = parseFloat(labelText.substring(0, labelText.indexOf("e"))) + labelText.substring(labelText.indexOf("e"));
      returnString = returnString.replace(/e(.*)$/g, function(match, $1) {
        var temp = "\u202210";
        temp += $1.replace(/-/g, "\u207B").replace(/\+/g, "").replace(/0/g, "\u2070").replace(/1/g, "\xB9").replace(/2/g, "\xB2").replace(/3/g, "\xB3").replace(/4/g, "\u2074").replace(/5/g, "\u2075").replace(/6/g, "\u2076").replace(/7/g, "\u2077").replace(/8/g, "\u2078").replace(/9/g, "\u2079");
        return temp;
      });
      return returnString;
    },
    /**
     * Creates the label text for a given tick. A value for the text can be provided as a number or string
     *
     * @param  {JXG.Coords}    tick  The Coords-object of the tick to create a label for
     * @param  {JXG.Coords}    zero  The Coords-object of line's zero
     * @param  {Number|String} value A predefined value for this tick
     * @returns {String}
     * @private
     */
    generateLabelText: function(tick, zero, value) {
      var labelText, distance;
      if (!type_default.exists(value)) {
        distance = this.getDistanceFromZero(zero, tick);
        if (Math.abs(distance) < math_default.eps) {
          return "0";
        }
        value = distance / type_default.evaluate(this.visProp.scale);
      }
      labelText = this.formatLabelText(value);
      return labelText;
    },
    /**
     * Create a tick label data, i.e. text and coordinates
     * @param  {String}     labelText
     * @param  {JXG.Coords} tick
     * @param  {Number}     tickNumber
     * @returns {Object} with properties 'x', 'y', 't' (text), 'i' (tick number) or null in case of o label
     * @private
     */
    generateLabelData: function(labelText, tick, tickNumber) {
      var xa, ya, m, fs;
      fs = type_default.evaluate(this.visProp.label.fontsize);
      xa = [tick.scrCoords[1], tick.scrCoords[1]];
      ya = [tick.scrCoords[2], tick.scrCoords[2]];
      m = fs === void 0 ? 12 : fs;
      m *= 0.5;
      if (!this._isInsideCanvas(xa, ya, m)) {
        return null;
      }
      xa = type_default.evaluate(this.visProp.label.offset[0]);
      ya = type_default.evaluate(this.visProp.label.offset[1]);
      return {
        x: tick.usrCoords[1] + xa / this.board.unitX,
        y: tick.usrCoords[2] + ya / this.board.unitY,
        t: labelText,
        i: tickNumber
      };
    },
    /**
     * Recalculate the tick positions and the labels.
     * @returns {JXG.Ticks}
     */
    update: function() {
      if (this.needsUpdate) {
        if (this.board.canvasWidth !== 0 && this.board.canvasHeight !== 0) {
          this.calculateTicksCoordinates();
        }
      }
      return this;
    },
    /**
     * Uses the boards renderer to update the arc.
     * @returns {JXG.Ticks} Reference to the object.
     */
    updateRenderer: function() {
      if (!this.needsUpdate) {
        return this;
      }
      if (this.visPropCalc.visible) {
        this.board.renderer.updateTicks(this);
      }
      this.updateRendererLabels();
      this.setDisplayRendNode();
      this.needsUpdate = false;
      return this;
    },
    /**
     * Updates the label elements of the major ticks.
     *
     * @private
     * @returns {JXG.Ticks} Reference to the object.
     */
    updateRendererLabels: function() {
      var i2, j, lenData, lenLabels, attr, label, ld, visible;
      lenData = this.labelsData.length;
      lenLabels = this.labels.length;
      for (i2 = 0, j = 0; i2 < lenData; i2++) {
        if (this.labelsData[i2] === null) {
          continue;
        }
        ld = this.labelsData[i2];
        if (j < lenLabels) {
          label = this.labels[j];
          label.setText(ld.t);
          label.setCoords(ld.x, ld.y);
          j++;
        } else {
          this.labelCounter += 1;
          attr = {
            isLabel: true,
            layer: this.board.options.layer.line,
            highlightStrokeColor: this.board.options.text.strokeColor,
            highlightStrokeWidth: this.board.options.text.strokeWidth,
            highlightStrokeOpacity: this.board.options.text.strokeOpacity,
            priv: this.visProp.priv
          };
          attr = type_default.deepCopy(attr, this.visProp.label);
          attr.id = this.id + ld.i + "Label" + this.labelCounter;
          label = jxg_default.createText(this.board, [ld.x, ld.y, ld.t], attr);
          this.addChild(label);
          label.setParents(this);
          label.isDraggable = false;
          label.dump = false;
          this.labels.push(label);
        }
        visible = type_default.evaluate(this.visProp.label.visible);
        if (visible === "inherit") {
          visible = this.visPropCalc.visible;
        }
        label.prepareUpdate().updateVisibility(visible).updateRenderer();
        label.distanceX = type_default.evaluate(this.visProp.label.offset[0]);
        label.distanceY = type_default.evaluate(this.visProp.label.offset[1]);
      }
      lenData = j;
      for (j = lenData; j < lenLabels; j++) {
        this.board.renderer.display(this.labels[j], false);
        this.labels[j].visProp.visible = this.labels[j].visPropCalc.visible = false;
      }
      return this;
    },
    hideElement: function() {
      var i2;
      jxg_default.deprecated("Element.hideElement()", "Element.setDisplayRendNode()");
      this.visPropCalc.visible = false;
      this.board.renderer.display(this, false);
      for (i2 = 0; i2 < this.labels.length; i2++) {
        if (type_default.exists(this.labels[i2])) {
          this.labels[i2].hideElement();
        }
      }
      return this;
    },
    showElement: function() {
      var i2;
      jxg_default.deprecated("Element.showElement()", "Element.setDisplayRendNode()");
      this.visPropCalc.visible = true;
      this.board.renderer.display(this, false);
      for (i2 = 0; i2 < this.labels.length; i2++) {
        if (type_default.exists(this.labels[i2])) {
          this.labels[i2].showElement();
        }
      }
      return this;
    }
  }
);
jxg_default.createTicks = function(board, parents, attributes) {
  var el, dist, attr = type_default.copyAttributes(attributes, board.options, "ticks");
  if (parents.length < 2) {
    dist = attr.ticksdistance;
  } else {
    dist = parents[1];
  }
  if (parents[0].elementClass === constants_default.OBJECT_CLASS_LINE || parents[0].elementClass === constants_default.OBJECT_CLASS_CURVE) {
    el = new jxg_default.Ticks(parents[0], dist, attr);
  } else {
    throw new Error(
      "JSXGraph: Can't create Ticks with parent types '" + typeof parents[0] + "'."
    );
  }
  if (type_default.isFunction(attr.generatelabelvalue)) {
    el.generateLabelText = attr.generatelabelvalue;
  }
  if (type_default.isFunction(attr.generatelabeltext)) {
    el.generateLabelText = attr.generatelabeltext;
  }
  el.setParents(parents[0]);
  el.isDraggable = true;
  el.fullUpdate(parents[0].visPropCalc.visible);
  return el;
};
jxg_default.createHatchmark = function(board, parents, attributes) {
  var num, i2, base, width, totalwidth, el, pos = [], attr = type_default.copyAttributes(attributes, board.options, "hatch");
  if (parents[0].elementClass !== constants_default.OBJECT_CLASS_LINE && parents[0].elementClass !== constants_default.OBJECT_CLASS_CURVE || typeof parents[1] !== "number") {
    throw new Error(
      "JSXGraph: Can't create Hatch mark with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + " and ''" + typeof parents[2] + "'."
    );
  }
  num = parents[1];
  width = attr.ticksdistance;
  totalwidth = (num - 1) * width;
  base = -totalwidth * 0.5;
  for (i2 = 0; i2 < num; i2++) {
    pos[i2] = base + i2 * width;
  }
  el = board.create("ticks", [parents[0], pos], attr);
  el.elType = "hatch";
  parents[0].inherits.push(el);
  return el;
};
jxg_default.registerElement("ticks", jxg_default.createTicks);
jxg_default.registerElement("hash", jxg_default.createHatchmark);
jxg_default.registerElement("hatch", jxg_default.createHatchmark);
var ticks_default = jxg_default.Ticks;

// node_modules/jsxgraph/src/parser/ca.js
jxg_default.CA = function(node2, createNode, parser2) {
  this.node = node2;
  this.createNode = createNode;
  this.parser = parser2;
};
jxg_default.extend(
  jxg_default.CA.prototype,
  /** @lends JXG.CA.prototype */
  {
    findMapNode: function(mapname, node2) {
      var i2, len, ret;
      if (node2.value === "op_assign" && node2.children[0].value === mapname) {
        return node2.children[1];
      } else if (node2.children) {
        len = node2.children.length;
        for (i2 = 0; i2 < len; ++i2) {
          ret = this.findMapNode(mapname, node2.children[i2]);
          if (ret !== null) {
            return ret;
          }
        }
      }
      return null;
    },
    /**
     * Declare all subnodes as math nodes,
     * i.e recursively set node.isMath = true;
     */
    setMath: function(node2) {
      var i2, len;
      if (node2.type == "node_op" && (node2.value == "op_add" || node2.value == "op_sub" || node2.value == "op_mul" || node2.value == "op_div" || node2.value == "op_neg" || node2.value == "op_execfun" || node2.value == "op_exp") || node2.type == "node_var" || node2.type == "node_const") {
        node2.isMath = true;
      }
      if (node2.children) {
        len = node2.children.length;
        for (i2 = 0; i2 < len; ++i2) {
          this.setMath(node2.children[i2]);
        }
      }
    },
    deriveElementary: function(node2, varname) {
      var fun2 = node2.children[0].value, arg = node2.children[1], newNode;
      switch (fun2) {
        case "abs":
          newNode = this.createNode(
            "node_op",
            "op_div",
            arg[0],
            this.createNode(
              "node_op",
              "op_execfun",
              this.createNode("node_var", "sqrt"),
              [
                this.createNode(
                  "node_op",
                  "op_mul",
                  type_default.deepCopy(arg[0]),
                  type_default.deepCopy(arg[0])
                )
              ]
            )
          );
          break;
        case "sqrt":
          newNode = this.createNode(
            "node_op",
            "op_div",
            this.createNode("node_const", 1),
            this.createNode(
              "node_op",
              "op_mul",
              this.createNode("node_const", 2),
              this.createNode(
                node2.type,
                node2.value,
                type_default.deepCopy(node2.children[0]),
                type_default.deepCopy(node2.children[1])
              )
            )
          );
          break;
        case "sin":
          newNode = this.createNode(
            "node_op",
            "op_execfun",
            this.createNode("node_var", "cos"),
            type_default.deepCopy(arg)
          );
          break;
        case "cos":
          newNode = this.createNode(
            "node_op",
            "op_neg",
            this.createNode(
              "node_op",
              "op_execfun",
              this.createNode("node_var", "sin"),
              type_default.deepCopy(arg)
            )
          );
          break;
        case "tan":
          newNode = this.createNode(
            "node_op",
            "op_div",
            this.createNode("node_const", 1),
            this.createNode(
              "node_op",
              "op_exp",
              this.createNode(
                "node_op",
                "op_execfun",
                this.createNode("node_var", "cos"),
                type_default.deepCopy(arg)
              ),
              this.createNode("node_const", 2)
            )
          );
          break;
        case "cot":
          newNode = this.createNode(
            "node_op",
            "op_neg",
            this.createNode(
              "node_op",
              "op_div",
              this.createNode("node_const", 1),
              this.createNode(
                "node_op",
                "op_exp",
                this.createNode(
                  "node_op",
                  "op_execfun",
                  this.createNode("node_var", "sin"),
                  type_default.deepCopy(arg)
                ),
                this.createNode("node_const", 2)
              )
            )
          );
          break;
        case "exp":
          newNode = this.createNode(
            node2.type,
            node2.value,
            type_default.deepCopy(node2.children[0]),
            type_default.deepCopy(node2.children[1])
          );
          break;
        case "pow":
          newNode = this.createNode(
            "node_op",
            "op_mul",
            this.createNode(
              "node_op",
              "op_execfun",
              type_default.deepCopy(node2.children[0]),
              type_default.deepCopy(node2.children[1])
            ),
            this.createNode(
              "node_op",
              "op_add",
              this.createNode(
                "node_op",
                "op_mul",
                this.derivative(node2.children[1][0], varname),
                this.createNode(
                  "node_op",
                  "op_div",
                  type_default.deepCopy(node2.children[1][1]),
                  type_default.deepCopy(node2.children[1][0])
                )
              ),
              this.createNode(
                "node_op",
                "op_mul",
                this.derivative(node2.children[1][1], varname),
                this.createNode(
                  "node_op",
                  "op_execfun",
                  this.createNode("node_var", "log"),
                  [type_default.deepCopy(node2.children[1][0])]
                )
              )
            )
          );
          break;
        case "log":
        case "ln":
          newNode = this.createNode(
            "node_op",
            "op_div",
            this.createNode("node_const", 1),
            // Attention: single variable mode
            type_default.deepCopy(arg[0])
          );
          break;
        case "log2":
        case "lb":
        case "ld":
          newNode = this.createNode(
            "node_op",
            "op_mul",
            this.createNode(
              "node_op",
              "op_div",
              this.createNode("node_const", 1),
              // Attention: single variable mode
              type_default.deepCopy(arg[0])
            ),
            this.createNode("node_const", 1.4426950408889634)
            // 1/log(2)
          );
          break;
        case "log10":
        case "lg":
          newNode = this.createNode(
            "node_op",
            "op_mul",
            this.createNode(
              "node_op",
              "op_div",
              this.createNode("node_const", 1),
              // Attention: single variable mode
              type_default.deepCopy(arg[0])
            ),
            this.createNode("node_const", 0.43429448190325176)
            // 1/log(10)
          );
          break;
        case "asin":
          newNode = this.createNode(
            "node_op",
            "op_div",
            this.createNode("node_const", 1),
            this.createNode(
              "node_op",
              "op_execfun",
              this.createNode("node_var", "sqrt"),
              [
                this.createNode(
                  "node_op",
                  "op_sub",
                  this.createNode("node_const", 1),
                  this.createNode(
                    "node_op",
                    "op_mul",
                    type_default.deepCopy(arg[0]),
                    type_default.deepCopy(arg[0])
                  )
                )
              ]
            )
          );
          break;
        case "acos":
          newNode = this.createNode(
            "node_op",
            "op_neg",
            this.createNode(
              "node_op",
              "op_div",
              this.createNode("node_const", 1),
              this.createNode(
                "node_op",
                "op_execfun",
                this.createNode("node_var", "sqrt"),
                [
                  this.createNode(
                    "node_op",
                    "op_sub",
                    this.createNode("node_const", 1),
                    this.createNode(
                      "node_op",
                      "op_mul",
                      type_default.deepCopy(arg[0]),
                      type_default.deepCopy(arg[0])
                    )
                  )
                ]
              )
            )
          );
          break;
        case "atan":
          newNode = this.createNode(
            "node_op",
            "op_div",
            this.createNode("node_const", 1),
            this.createNode(
              "node_op",
              "op_add",
              this.createNode("node_const", 1),
              this.createNode(
                "node_op",
                "op_mul",
                type_default.deepCopy(arg[0]),
                type_default.deepCopy(arg[0])
              )
            )
          );
          break;
        case "acot":
          newNode = this.createNode(
            "node_op",
            "op_neg",
            this.createNode(
              "node_op",
              "op_div",
              this.createNode("node_const", 1),
              this.createNode(
                "node_op",
                "op_add",
                this.createNode("node_const", 1),
                this.createNode(
                  "node_op",
                  "op_mul",
                  type_default.deepCopy(arg[0]),
                  type_default.deepCopy(arg[0])
                )
              )
            )
          );
          break;
        case "sinh":
          newNode = this.createNode(
            "node_op",
            "op_execfun",
            this.createNode("node_var", "cosh"),
            [type_default.deepCopy(arg[0])]
          );
          break;
        case "cosh":
          newNode = this.createNode(
            "node_op",
            "op_execfun",
            this.createNode("node_var", "sinh"),
            [type_default.deepCopy(arg[0])]
          );
          break;
        case "tanh":
          newNode = this.createNode(
            "node_op",
            "op_sub",
            this.createNode("node_const", 1),
            this.createNode(
              "node_op",
              "op_exp",
              this.createNode(
                "node_op",
                "op_execfun",
                this.createNode("node_var", "tanh"),
                [type_default.deepCopy(arg[0])]
              ),
              this.createNode("node_const", 2)
            )
          );
          break;
        case "asinh":
          newNode = this.createNode(
            "node_op",
            "op_div",
            this.createNode("node_const", 1),
            this.createNode(
              "node_op",
              "op_execfun",
              this.createNode("node_var", "sqrt"),
              [
                this.createNode(
                  "node_op",
                  "op_add",
                  this.createNode(
                    "node_op",
                    "op_mul",
                    type_default.deepCopy(arg[0]),
                    type_default.deepCopy(arg[0])
                  ),
                  this.createNode("node_const", 1)
                )
              ]
            )
          );
          break;
        case "acosh":
          newNode = this.createNode(
            "node_op",
            "op_div",
            this.createNode("node_const", 1),
            this.createNode(
              "node_op",
              "op_execfun",
              this.createNode("node_var", "sqrt"),
              [
                this.createNode(
                  "node_op",
                  "op_sub",
                  this.createNode(
                    "node_op",
                    "op_mul",
                    type_default.deepCopy(arg[0]),
                    type_default.deepCopy(arg[0])
                  ),
                  this.createNode("node_const", 1)
                )
              ]
            )
          );
          break;
        case "atanh":
          newNode = this.createNode(
            "node_op",
            "op_div",
            this.createNode("node_const", 1),
            this.createNode(
              "node_op",
              "op_sub",
              this.createNode("node_const", 1),
              this.createNode(
                "node_op",
                "op_mul",
                type_default.deepCopy(arg[0]),
                type_default.deepCopy(arg[0])
              )
            )
          );
          break;
        default:
          newNode = this.createNode("node_const", 0);
          console.log('Derivative of "' + fun2 + '" not yet implemented');
          throw new Error("Error(" + this.line + "): ");
      }
      return newNode;
    },
    derivative: function(node2, varname) {
      var newNode;
      switch (node2.type) {
        case "node_op":
          switch (node2.value) {
            case "op_execfun":
              if (node2.children[0].value == "pow") {
                newNode = this.deriveElementary(node2, varname);
              } else {
                if (node2.children[1].length === 0) {
                  newNode = this.createNode("node_const", 0);
                } else {
                  newNode = this.createNode(
                    "node_op",
                    "op_mul",
                    this.deriveElementary(node2, varname),
                    // Warning: single variable mode
                    this.derivative(node2.children[1][0], varname)
                  );
                }
              }
              break;
            case "op_div":
              newNode = this.createNode(
                "node_op",
                "op_div",
                this.createNode(
                  "node_op",
                  "op_sub",
                  this.createNode(
                    "node_op",
                    "op_mul",
                    this.derivative(node2.children[0], varname),
                    type_default.deepCopy(node2.children[1])
                  ),
                  this.createNode(
                    "node_op",
                    "op_mul",
                    type_default.deepCopy(node2.children[0]),
                    this.derivative(node2.children[1], varname)
                  )
                ),
                this.createNode(
                  "node_op",
                  "op_mul",
                  type_default.deepCopy(node2.children[1]),
                  type_default.deepCopy(node2.children[1])
                )
              );
              break;
            case "op_mul":
              newNode = this.createNode(
                "node_op",
                "op_add",
                this.createNode(
                  "node_op",
                  "op_mul",
                  type_default.deepCopy(node2.children[0]),
                  this.derivative(node2.children[1], varname)
                ),
                this.createNode(
                  "node_op",
                  "op_mul",
                  this.derivative(node2.children[0], varname),
                  type_default.deepCopy(node2.children[1])
                )
              );
              break;
            case "op_neg":
              newNode = this.createNode(
                "node_op",
                "op_neg",
                this.derivative(node2.children[0], varname)
              );
              break;
            case "op_add":
            case "op_sub":
              newNode = this.createNode(
                "node_op",
                node2.value,
                this.derivative(node2.children[0], varname),
                this.derivative(node2.children[1], varname)
              );
              break;
            case "op_exp":
              newNode = this.createNode(
                "node_op",
                "op_mul",
                type_default.deepCopy(node2),
                this.createNode(
                  "node_op",
                  "op_add",
                  this.createNode(
                    "node_op",
                    "op_mul",
                    this.derivative(node2.children[0], varname),
                    this.createNode(
                      "node_op",
                      "op_div",
                      type_default.deepCopy(node2.children[1]),
                      type_default.deepCopy(node2.children[0])
                    )
                  ),
                  this.createNode(
                    "node_op",
                    "op_mul",
                    this.derivative(node2.children[1], varname),
                    this.createNode(
                      "node_op",
                      "op_execfun",
                      this.createNode("node_var", "log"),
                      [type_default.deepCopy(node2.children[0])]
                    )
                  )
                )
              );
              break;
          }
          break;
        case "node_var":
          if (node2.value === varname) {
            newNode = this.createNode("node_const", 1);
          } else {
            newNode = this.createNode("node_const", 0);
          }
          break;
        case "node_const":
          newNode = this.createNode("node_const", 0);
          break;
        case "node_const_bool":
          break;
        case "node_str":
          break;
      }
      return newNode;
    },
    /**
     * f = map (x) -> x*sin(x);
     * Usages:
     *   h = D(f, x);
     *   h = map (x) -> D(f, x);
     * or
     *   D(x^2, x);
     */
    expandDerivatives: function(node2, parent, ast) {
      var len, i2, j, mapNode, codeNode, ret, node22, newNode, mapName, varname, vArray, order, isMap;
      ret = 0;
      if (!node2) {
        return ret;
      }
      this.line = node2.line;
      this.col = node2.col;
      len = node2.children.length;
      for (i2 = 0; i2 < len; ++i2) {
        if (node2.children[i2] && node2.children[i2].type) {
          node2.children[i2] = this.expandDerivatives(node2.children[i2], node2, ast);
        } else if (type_default.isArray(node2.children[i2])) {
          for (j = 0; j < node2.children[i2].length; ++j) {
            if (node2.children[i2][j] && node2.children[i2][j].type) {
              node2.children[i2][j] = this.expandDerivatives(
                node2.children[i2][j],
                node2,
                ast
              );
            }
          }
        }
      }
      switch (node2.type) {
        case "node_op":
          switch (node2.value) {
            case "op_execfun":
              if (node2.children[0] && node2.children[0].value === "D") {
                isMap = false;
                if (node2.children[1][0].type == "node_var") {
                  mapName = node2.children[1][0].value;
                  mapNode = this.findMapNode(mapName, ast);
                  if (mapNode !== null) {
                    isMap = true;
                  }
                }
                if (isMap) {
                  vArray = mapNode.children[0];
                  if (node2.children[1].length >= 2) {
                    varname = node2.children[1][1].value;
                  } else {
                    varname = mapNode.children[0][0];
                  }
                  codeNode = mapNode.children[1];
                } else {
                  codeNode = node2.children[1][0];
                  vArray = ["x"];
                  if (node2.children[1].length >= 2) {
                    varname = node2.children[1][1].value;
                  } else {
                    varname = "x";
                  }
                }
                if (node2.children[1].length >= 3) {
                  order = node2.children[1][2].value;
                } else {
                  order = 1;
                }
                newNode = codeNode;
                if (order >= 1) {
                  while (order >= 1) {
                    newNode = this.derivative(newNode, varname);
                    newNode = this.removeTrivialNodes(newNode);
                    order--;
                  }
                }
                if (parent.type == "node_op" && parent.value == "op_assign") {
                  node22 = this.createNode(
                    "node_op",
                    "op_map",
                    vArray,
                    newNode
                  );
                } else {
                  node22 = newNode;
                }
                this.setMath(node22);
                node2.type = node22.type;
                node2.value = node22.value;
                if (node22.children.length > 0) {
                  node2.children[0] = node22.children[0];
                }
                if (node22.children.length > 1) {
                  node2.children[1] = node22.children[1];
                }
              }
          }
          break;
        case "node_var":
        case "node_const":
        case "node_const_bool":
        case "node_str":
          break;
      }
      return node2;
    },
    removeTrivialNodes: function(node2) {
      var i2, len, n0, n1, swap2;
      if (type_default.isArray(node2)) {
        len = node2.length;
        for (i2 = 0; i2 < len; ++i2) {
          node2[i2] = this.removeTrivialNodes(node2[i2]);
        }
      }
      if (node2.type != "node_op" || !node2.children) {
        return node2;
      }
      len = node2.children.length;
      for (i2 = 0; i2 < len; ++i2) {
        this.mayNotBeSimplified = false;
        do {
          node2.children[i2] = this.removeTrivialNodes(node2.children[i2]);
        } while (this.mayNotBeSimplified);
      }
      switch (node2.value) {
        case "op_map":
          n0 = node2.children[0];
          n1 = node2.children[1];
          if (n1.type == "node_var") {
            for (i2 = 0; i2 < n0.length; ++i2) {
              if (n0[i2] == n1.value) {
                n1.isMath = true;
                break;
              }
            }
          }
          break;
        case "op_add":
          n0 = node2.children[0];
          n1 = node2.children[1];
          if (n0.type == "node_const" && n0.value === 0) {
            return n1;
          }
          if (n1.type == "node_const" && n1.value === 0) {
            return n0;
          }
          if (n0.type == "node_const" && n1.type == "node_const") {
            n0.value += n1.value;
            return n0;
          }
          break;
        case "op_mul":
          n0 = node2.children[0];
          n1 = node2.children[1];
          if (n0.type == "node_const" && n0.value == 1) {
            return n1;
          }
          if (n1.type == "node_const" && n1.value == 1) {
            return n0;
          }
          if (n0.type == "node_const" && n0.value === 0) {
            return n0;
          }
          if (n1.type == "node_const" && n1.value === 0) {
            return n1;
          }
          if (n1.type == "node_const" && n1.value === 0) {
            return n1;
          }
          if (n0.type == "node_op" && n0.value == "op_neg" && n1.type == "node_op" && n1.value == "op_neg") {
            node2.children = [n0.children[0], n1.children[0]];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.value == "op_neg" && n1.value != "op_neg") {
            node2.type = "node_op";
            node2.value = "op_neg";
            node2.children = [
              this.createNode("node_op", "op_mul", n0.children[0], n1)
            ];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.value != "op_neg" && n1.value == "op_neg") {
            node2.type = "node_op";
            node2.value = "op_neg";
            node2.children = [
              this.createNode("node_op", "op_mul", n0, n1.children[0])
            ];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.value == "op_div" && n0.children[0].type == "node_const" && n0.children[0].value == 1) {
            node2.type = "node_op";
            node2.value = "op_div";
            node2.children = [n1, n0.children[1]];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n1.value == "op_div" && n1.children[0].type == "node_const" && n1.children[0].value == 1) {
            node2.type = "node_op";
            node2.value = "op_div";
            node2.children = [n0, n1.children[1]];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.type != "node_const" && n1.type == "node_const") {
            node2.children = [n1, n0];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.type != "node_const" && n1.type == "node_op" && n1.value == "op_neg" && n1.children[0].type == "node_const") {
            node2.children = [n1, n0];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.type == "node_op" && n0.value != "op_execfun" && (n1.type == "node_var" || n1.type == "node_op" && n1.value == "op_execfun")) {
            node2.children = [n1, n0];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.type != "node_op" && n1.type == "node_op" && n1.value == "op_neg" && n1.children[0].type == "node_var") {
            node2.children = [n1, n0];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.type != "node_const" && n1.type == "node_op" && (n1.value == "op_mul" || n1.value == "op_div") && n1.children[0].type == "node_const") {
            swap2 = n1.children[0];
            n1.children[0] = n0;
            node2.children = [swap2, n1];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n1.type != "node_const" && n0.type == "node_op" && n0.value == "op_mul" && n0.children[0].type == "node_const") {
            node2.children = [
              n0.children[0],
              this.createNode("node_op", "op_mul", n0.children[1], n1)
            ];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.type == "node_const" && n1.type == "node_const") {
            n0.value *= n1.value;
            return n0;
          }
          if (n0.type == "node_const" && n1.type == "node_op" && (n1.value == "op_mul" || n1.value == "op_div") && n1.children[0].type == "node_const") {
            n1.children[0].value *= n0.value;
            return n1;
          }
          n0.hash = this.parser.compile(n0);
          n1.hash = this.parser.compile(n1);
          if (n0.hash === n1.hash) {
            node2.value = "op_exp";
            node2.children[1] = this.createNode("node_const", 2);
            return node2;
          }
          if (n0.type == "node_const" && n1.type == "node_op" && (n1.value == "op_mul" || n1.value == "op_div") && n1.children[0].type == "node_const") {
            n1.children[0].value *= n0.value;
            return n1;
          }
          if (n1.type == "node_op" && n1.value == "op_exp") {
            if (!n0.hash) {
              n0.hash = this.parser.compile(n0);
            }
            if (!n1.children[0].hash) {
              n1.children[0].hash = this.parser.compile(n1.children[0]);
            }
            if (n0.hash === n1.children[0].hash) {
              n1.children[1] = this.createNode(
                "node_op",
                "op_add",
                n1.children[1],
                this.createNode("node_const", 1)
              );
              this.mayNotBeSimplified = true;
              return n1;
            }
          }
          if (n0.type == "node_op" && n0.value == "op_exp" && n1.type == "node_op" && n1.value == "op_exp") {
            n0.children[0].hash = this.parser.compile(n0.children[0]);
            n1.children[0].hash = this.parser.compile(n1.children[0]);
            if (n0.children[0].hash === n1.children[0].hash) {
              n0.children[1] = this.createNode(
                "node_op",
                "op_add",
                n0.children[1],
                n1.children[1]
              );
              this.mayNotBeSimplified = true;
              return n0;
            }
          }
          break;
        case "op_sub":
          n0 = node2.children[0];
          n1 = node2.children[1];
          if (n0.type == "node_const" && n0.value === 0) {
            node2.value = "op_neg";
            node2.children[0] = n1;
            return node2;
          }
          if (n1.type == "node_const" && n1.value === 0) {
            return n0;
          }
          if (n0.type == "node_const" && n1.type == "node_const" && n0.value == n1.value) {
            return this.createNode("node_const", 0);
          }
          if (n0.type == "node_var" && n1.type == "node_var" && n0.value == n1.value) {
            return this.createNode("node_const", 0);
          }
          if (n0.type == "node_const" && n1.type == "node_const") {
            n0.value -= n1.value;
            return n0;
          }
          if (n0.type == "node_op" && n0.value == "op_mul" && n1.type == "node_op" && n1.value == "op_mul") {
            n0.children[1].hash = this.parser.compile(n0.children[1]);
            n1.children[1].hash = this.parser.compile(n1.children[1]);
            if (n0.children[1].hash === n1.children[1].hash) {
              node2.value = "op_mul";
              node2.children = [
                this.createNode(
                  "node_op",
                  "op_sub",
                  n0.children[0],
                  n1.children[0]
                ),
                n0.children[1]
              ];
              this.mayNotBeSimplified = true;
              return node2;
            }
          }
          if (n0.type == "node_op" && n0.value == "op_mul") {
            n0.children[1].hash = this.parser.compile(n0.children[1]);
            n1.hash = this.parser.compile(n1);
            if (n0.children[1].hash === n1.hash) {
              node2.value = "op_mul";
              node2.children = [
                this.createNode(
                  "node_op",
                  "op_sub",
                  n0.children[0],
                  this.createNode("node_const", 1)
                ),
                n1
              ];
              this.mayNotBeSimplified = true;
              return node2;
            }
          }
          if (n1.type == "node_op" && n1.value == "op_mul") {
            n1.children[1].hash = this.parser.compile(n1.children[1]);
            n0.hash = this.parser.compile(n0);
            if (n1.children[1].hash === n0.hash) {
              node2.value = "op_mul";
              node2.children = [
                this.createNode(
                  "node_op",
                  "op_sub",
                  this.createNode("node_const", 1),
                  n1.children[0]
                ),
                n0
              ];
              this.mayNotBeSimplified = true;
              return node2;
            }
          }
          break;
        case "op_neg":
          n0 = node2.children[0];
          if (n0.type == "node_const" && n0.value === 0) {
            return n0;
          }
          if (n0.type == "node_op" && n0.value == "op_neg") {
            return n0.children[0];
          }
          break;
        case "op_div":
          n0 = node2.children[0];
          n1 = node2.children[1];
          if (n0.type == "node_const" && n1.type == "node_const" && n0.value == n1.value && n0.value !== 0) {
            n0.value = 1;
            return n0;
          }
          if (n0.type == "node_const" && n0.value === 0 && n1.type == "node_const" && n1.value !== 0) {
            n0.value = 0;
            return n0;
          }
          if (n0.type == "node_const" && n0.value === 0 && (n1.type == "node_op" || n1.type == "node_var")) {
            node2.type = "node_const";
            node2.value = 0;
            return node2;
          }
          if (n0.type == "node_var" && n1.type == "node_var" && n0.value == n1.value) {
            return this.createNode("node_const", 1);
          }
          if (n0.type == "node_const" && n0.value !== 0 && n1.type == "node_const" && n1.value === 0) {
            if (n0.value > 0) {
              n0.value = Infinity;
            } else {
              n0.value = -Infinity;
            }
            return n0;
          }
          if (n0.type == "node_op" && n0.value == "op_neg" && n1.type == "node_op" && n1.value == "op_neg") {
            node2.children = [n0.children[0], n1.children[0]];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.value == "op_neg" && n1.value != "op_neg") {
            node2.type = "node_op";
            node2.value = "op_neg";
            node2.children = [
              this.createNode("node_op", "op_div", n0.children[0], n1)
            ];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.value != "op_neg" && n1.value == "op_neg") {
            node2.type = "node_op";
            node2.value = "op_neg";
            node2.children = [
              this.createNode("node_op", "op_div", n0, n1.children[0])
            ];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.type == "node_op" && n0.value == "op_exp") {
            if (!n1.hash) {
              n1.hash = this.parser.compile(n1);
            }
            if (!n0.children[0].hash) {
              n0.children[0].hash = this.parser.compile(n0.children[0]);
            }
            if (n1.hash === n0.children[0].hash) {
              n0.children[1] = this.createNode(
                "node_op",
                "op_sub",
                n0.children[1],
                this.createNode("node_const", 1)
              );
              this.mayNotBeSimplified = true;
              return n0;
            }
          }
          if (n1.type != "node_const" && n0.type == "node_op" && n0.value == "op_mul" && n0.children[0].type == "node_const") {
            node2.value = "op_mul";
            node2.children = [
              n0.children[0],
              this.createNode("node_op", "op_div", n0.children[1], n1)
            ];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.type == "node_op" && n0.value == "op_exp" && n1.type == "node_op" && n1.value == "op_exp") {
            n0.children[0].hash = this.parser.compile(n0.children[0]);
            n1.children[0].hash = this.parser.compile(n1.children[0]);
            if (n0.children[0].hash === n1.children[0].hash) {
              n0.children[1] = this.createNode(
                "node_op",
                "op_sub",
                n0.children[1],
                n1.children[1]
              );
              this.mayNotBeSimplified = true;
              return n0;
            }
          }
          break;
        case "op_exp":
          n0 = node2.children[0];
          n1 = node2.children[1];
          if (n1.type == "node_const" && n1.value === 0) {
            n1.value = 1;
            return n1;
          }
          if (n1.type == "node_const" && n1.value == 1) {
            return n0;
          }
          if (n0.type == "node_const" && n0.value == 1) {
            return n0;
          }
          if (n0.type == "node_const" && n0.value === 0 && n1.type == "node_const" && n1.value !== 0) {
            return n0;
          }
          if (n0.type == "node_op" && n0.value == "op_exp") {
            node2.children = [
              n0.children[0],
              this.createNode("node_op", "op_mul", n0.children[1], n1)
            ];
            return node2;
          }
          break;
      }
      switch (node2.value) {
        case "op_add":
          n0 = node2.children[0];
          n1 = node2.children[1];
          if (n0.type == "node_const" && n1.type == "node_const" && n0.value == n1.value) {
            n0.value += n1.value;
            return n0;
          }
          if (n0.type == "node_var" && n1.type == "node_var" && n0.value == n1.value) {
            node2.children[0] = this.createNode("node_const", 2);
            node2.value = "op_mul";
            return node2;
          }
          if (n0.type == "node_op" && n0.value == "op_neg") {
            node2.value = "op_sub";
            node2.children[0] = n1;
            node2.children[1] = n0.children[0];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n1.type == "node_op" && n1.value == "op_neg") {
            node2.value = "op_sub";
            node2.children[1] = n1.children[0];
            this.mayNotBeSimplified = true;
            return node2;
          }
          if (n0.type == "node_op" && n0.value == "op_mul" && n1.type == "node_op" && n1.value == "op_mul") {
            n0.children[1].hash = this.parser.compile(n0.children[1]);
            n1.children[1].hash = this.parser.compile(n1.children[1]);
            if (n0.children[1].hash === n1.children[1].hash) {
              node2.value = "op_mul";
              node2.children = [
                this.createNode(
                  "node_op",
                  "op_add",
                  n0.children[0],
                  n1.children[0]
                ),
                n0.children[1]
              ];
              this.mayNotBeSimplified = true;
              return node2;
            }
          }
          if (n0.type == "node_op" && n0.value == "op_mul") {
            n0.children[1].hash = this.parser.compile(n0.children[1]);
            n1.hash = this.parser.compile(n1);
            if (n0.children[1].hash === n1.hash) {
              node2.value = "op_mul";
              node2.children = [
                this.createNode(
                  "node_op",
                  "op_add",
                  n0.children[0],
                  this.createNode("node_const", 1)
                ),
                n1
              ];
              this.mayNotBeSimplified = true;
              return node2;
            }
          }
          if (n1.type == "node_op" && n1.value == "op_mul") {
            n1.children[1].hash = this.parser.compile(n1.children[1]);
            n0.hash = this.parser.compile(n0);
            if (n1.children[1].hash === n0.hash) {
              node2.value = "op_mul";
              node2.children = [
                this.createNode(
                  "node_op",
                  "op_add",
                  this.createNode("node_const", 1),
                  n1.children[0]
                ),
                n0
              ];
              this.mayNotBeSimplified = true;
              return node2;
            }
          }
          break;
        case "op_sub":
          n0 = node2.children[0];
          n1 = node2.children[1];
          if (n1.type == "node_op" && n1.value == "op_neg") {
            node2.value = "op_add";
            node2.children[1] = n1.children[0];
            this.mayNotBeSimplified = true;
            return node2;
          }
          break;
        case "op_execfun":
          return this.simplifyElementary(node2);
      }
      return node2;
    },
    simplifyElementary: function(node2) {
      var fun2 = node2.children[0].value, arg = node2.children[1];
      if (arg.length == 0) {
        return node2;
      }
      switch (fun2) {
        case "sin":
        case "tan":
          if (arg[0].type == "node_const" && arg[0].value === 0) {
            node2.type = "node_const";
            node2.value = 0;
            return node2;
          }
          if (arg[0].type == "node_var" && arg[0].value == "PI") {
            node2.type = "node_const";
            node2.value = 0;
            return node2;
          }
          if (arg[0].type == "node_op" && arg[0].value == "op_mul" && arg[0].children[0].type == "node_const" && arg[0].children[0].value % 1 === 0 && arg[0].children[1].type == "node_var" && arg[0].children[1].value == "PI") {
            node2.type = "node_const";
            node2.value = 0;
            return node2;
          }
          break;
        case "cos":
          if (arg[0].type == "node_const" && arg[0].value === 0) {
            node2.type = "node_const";
            node2.value = 1;
            return node2;
          }
          if (arg[0].type == "node_var" && arg[0].value == "PI") {
            node2.type = "node_op";
            node2.value = "op_neg";
            node2.children = [this.createNode("node_const", 1)];
            return node2;
          }
          break;
        case "exp":
          if (arg[0].type == "node_const" && arg[0].value === 0) {
            node2.type = "node_const";
            node2.value = 1;
            return node2;
          }
          break;
        case "pow":
          if (arg[1].type == "node_const" && arg[1].value === 0) {
            node2.type = "node_const";
            node2.value = 1;
            return node2;
          }
          break;
      }
      return node2;
    }
  }
);
var ca_default = jxg_default.CA;

// node_modules/jsxgraph/src/utils/dump.js
jxg_default.Dump = {
  /**
   * Adds markers to every element of the board
   * @param {JXG.Board} board
   * @param {Array|String} markers
   * @param {Array} values
   */
  addMarkers: function(board, markers, values) {
    var e, l, i2;
    if (!type_default.isArray(markers)) {
      markers = [markers];
    }
    if (!type_default.isArray(values)) {
      values = [values];
    }
    l = Math.min(markers.length, values.length);
    markers.length = l;
    values.length = l;
    for (e in board.objects) {
      if (board.objects.hasOwnProperty(e)) {
        for (i2 = 0; i2 < l; i2++) {
          board.objects[e][markers[i2]] = values[i2];
        }
      }
    }
  },
  /**
   * Removes markers from every element on the board.
   * @param {JXG.Board} board
   * @param {Array|String} markers
   */
  deleteMarkers: function(board, markers) {
    var e, l, i2;
    if (!type_default.isArray(markers)) {
      markers = [markers];
    }
    l = markers.length;
    markers.length = l;
    for (e in board.objects) {
      if (board.objects.hasOwnProperty(e)) {
        for (i2 = 0; i2 < l; i2++) {
          delete board.objects[e][markers[i2]];
        }
      }
    }
  },
  /**
   * Stringifies a string, i.e. puts some quotation marks around <tt>s</tt> if it is of type string.
   * @param {*} s
   * @returns {String} " + s + "
   */
  str: function(s) {
    if (typeof s === "string" && s.slice(0, 7) !== "function") {
      s = '"' + s + '"';
    }
    return s;
  },
  /**
   * Eliminate default values given by {@link JXG.Options} from the attributes object.
   * @param {Object} instance Attribute object of the element
   * @param {Object} s Arbitrary number of objects <tt>instance</tt> will be compared to. Usually these are
   * sub-objects of the {@link JXG.Board#options} structure.
   * @returns {Object} Minimal attributes object
   */
  minimizeObject: function(instance, s) {
    var p, pl, i2, def2 = {}, copy = type_default.deepCopy(instance), defaults = [];
    for (i2 = 1; i2 < arguments.length; i2++) {
      defaults.push(arguments[i2]);
    }
    def2 = type_default.deepCopy(def2, jxg_default.Options.elements, true);
    for (i2 = defaults.length; i2 > 0; i2--) {
      def2 = type_default.deepCopy(def2, defaults[i2 - 1], true);
    }
    for (p in def2) {
      if (def2.hasOwnProperty(p)) {
        pl = p.toLowerCase();
        if (typeof def2[p] !== "object" && def2[p] === copy[pl]) {
          delete copy[pl];
        }
      }
    }
    return copy;
  },
  /**
   * Prepare the attributes object for an element to be dumped as JavaScript or JessieCode code.
   * @param {JXG.Board} board
   * @param {JXG.GeometryElement} obj Geometry element which attributes object is generated
   * @returns {Object} An attributes object.
   */
  prepareAttributes: function(board, obj) {
    var a, s;
    a = this.minimizeObject(obj.getAttributes(), jxg_default.Options[obj.elType]);
    for (s in obj.subs) {
      if (obj.subs.hasOwnProperty(s)) {
        a[s] = this.minimizeObject(
          obj.subs[s].getAttributes(),
          jxg_default.Options[obj.elType][s],
          jxg_default.Options[obj.subs[s].elType]
        );
        a[s].id = obj.subs[s].id;
        a[s].name = obj.subs[s].name;
      }
    }
    a.id = obj.id;
    a.name = obj.name;
    return a;
  },
  setBoundingBox: function(methods, board, boardVarName) {
    methods.push({
      obj: boardVarName,
      method: "setBoundingBox",
      params: [board.getBoundingBox(), board.keepaspectratio]
    });
    return methods;
  },
  /**
   * Generate a save-able structure with all elements. This is used by {@link JXG.Dump#toJessie} and
   * {@link JXG.Dump#toJavaScript} to generate the script.
   * @param {JXG.Board} board
   * @returns {Array} An array with all metadata necessary to save the construction.
   */
  dump: function(board) {
    var e, obj, element, s, props = [], methods = [], elementList = [], len = board.objectsList.length;
    this.addMarkers(board, "dumped", false);
    for (e = 0; e < len; e++) {
      obj = board.objectsList[e];
      element = {};
      if (!obj.dumped && obj.dump) {
        element.type = obj.getType();
        element.parents = obj.getParents().slice();
        if (element.type === "point" && element.parents[0] === 1) {
          element.parents = element.parents.slice(1);
        }
        for (s = 0; s < element.parents.length; s++) {
          if (type_default.isString(element.parents[s]) && element.parents[s][0] !== "'" && element.parents[s][0] !== '"') {
            element.parents[s] = '"' + element.parents[s] + '"';
          } else if (type_default.isArray(element.parents[s])) {
            element.parents[s] = "[" + element.parents[s].toString() + "]";
          }
        }
        element.attributes = this.prepareAttributes(board, obj);
        if (element.type === "glider" && obj.onPolygon) {
          props.push({
            obj: obj.id,
            prop: "onPolygon",
            val: true
          });
        }
        elementList.push(element);
      }
    }
    this.deleteMarkers(board, "dumped");
    return {
      elements: elementList,
      props,
      methods
    };
  },
  /**
   * Converts an array of different values into a parameter string that can be used by the code generators.
   * @param {Array} a
   * @param {function} converter A function that is used to transform the elements of <tt>a</tt>. Usually
   * {@link JXG.toJSON} or {@link JXG.Dump.toJCAN} are used.
   * @returns {String}
   */
  arrayToParamStr: function(a, converter) {
    var i2, s = [];
    for (i2 = 0; i2 < a.length; i2++) {
      s.push(converter.call(this, a[i2]));
    }
    return s.join(", ");
  },
  /**
   * Converts a JavaScript object into a JCAN (JessieCode Attribute Notation) string.
   * @param {Object} obj A JavaScript object, functions will be ignored.
   * @returns {String} The given object stored in a JCAN string.
   */
  toJCAN: function(obj) {
    var i2, list2, prop;
    switch (typeof obj) {
      case "object":
        if (obj) {
          list2 = [];
          if (type_default.isArray(obj)) {
            for (i2 = 0; i2 < obj.length; i2++) {
              list2.push(this.toJCAN(obj[i2]));
            }
            return "[" + list2.join(",") + "]";
          }
          for (prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              list2.push(prop + ": " + this.toJCAN(obj[prop]));
            }
          }
          return "<<" + list2.join(", ") + ">> ";
        }
        return "null";
      case "string":
        return "'" + obj.replace(/\\/g, "\\\\").replace(/(["'])/g, "\\$1") + "'";
      case "number":
      case "boolean":
        return obj.toString();
      case "null":
        return "null";
    }
  },
  /**
   * Saves the construction in <tt>board</tt> to JessieCode.
   * @param {JXG.Board} board
   * @returns {String} JessieCode
   */
  toJessie: function(board) {
    var i2, elements2, id, dump = this.dump(board), script = [];
    dump.methods = this.setBoundingBox(dump.methods, board, "$board");
    elements2 = dump.elements;
    for (i2 = 0; i2 < elements2.length; i2++) {
      if (elements2[i2].attributes.name.length > 0) {
        script.push("// " + elements2[i2].attributes.name);
      }
      script.push(
        "s" + i2 + " = " + elements2[i2].type + "(" + elements2[i2].parents.join(", ") + ") " + this.toJCAN(elements2[i2].attributes).replace(/\n/, "\\n") + ";"
      );
      if (elements2[i2].type === "axis") {
        id = elements2[i2].attributes.id;
        if (board.objects[id].defaultTicks === null) {
          script.push("s" + i2 + ".removeAllTicks();");
        }
      }
      script.push("");
    }
    for (i2 = 0; i2 < dump.methods.length; i2++) {
      script.push(
        dump.methods[i2].obj + "." + dump.methods[i2].method + "(" + this.arrayToParamStr(dump.methods[i2].params, this.toJCAN) + ");"
      );
      script.push("");
    }
    for (i2 = 0; i2 < dump.props.length; i2++) {
      script.push(
        dump.props[i2].obj + "." + dump.props[i2].prop + " = " + this.toJCAN(dump.props[i2].val) + ";"
      );
      script.push("");
    }
    return script.join("\n");
  },
  /**
   * Saves the construction in <tt>board</tt> to JavaScript.
   * @param {JXG.Board} board
   * @returns {String} JavaScript
   */
  toJavaScript: function(board) {
    var i2, elements2, id, dump = this.dump(board), script = [];
    dump.methods = this.setBoundingBox(dump.methods, board, "board");
    elements2 = dump.elements;
    for (i2 = 0; i2 < elements2.length; i2++) {
      script.push(
        'board.create("' + elements2[i2].type + '", [' + elements2[i2].parents.join(", ") + "], " + type_default.toJSON(elements2[i2].attributes) + ");"
      );
      if (elements2[i2].type === "axis") {
        id = elements2[i2].attributes.id;
        if (board.objects[id].defaultTicks === null) {
          script.push(
            'board.objects["' + id + '"].removeTicks(board.objects["' + id + '"].defaultTicks);'
          );
        }
      }
    }
    for (i2 = 0; i2 < dump.methods.length; i2++) {
      script.push(
        dump.methods[i2].obj + "." + dump.methods[i2].method + "(" + this.arrayToParamStr(dump.methods[i2].params, type_default.toJSON) + ");"
      );
      script.push("");
    }
    for (i2 = 0; i2 < dump.props.length; i2++) {
      script.push(
        dump.props[i2].obj + "." + dump.props[i2].prop + " = " + type_default.toJSON(dump.props[i2].val) + ";"
      );
      script.push("");
    }
    return script.join("\n");
  }
};
var dump_default = jxg_default.Dump;

// node_modules/jsxgraph/src/element/comb.js
jxg_default.createComb = function(board, parents, attributes) {
  var p1, p2, c, attr, parent_types;
  if (parents.length === 2) {
    if (type_default.isArray(parents[0]) && parents[0].length > 1) {
      attr = type_default.copyAttributes(attributes, board.options, "comb", "point1");
      p1 = board.create("point", parents[0], attr);
    } else if (type_default.isString(parents[0]) || type_default.isPoint(parents[0])) {
      p1 = board.select(parents[0]);
    } else if (type_default.isFunction(parents[0]) && type_default.isPoint(parents[0]())) {
      p1 = parents[0]();
    } else if (type_default.isFunction(parents[0]) && parents[0]().length && parents[0]().length >= 2) {
      attr = type_default.copyAttributes(attributes, board.options, "comb", "point1");
      p1 = jxg_default.createPoint(board, parents[0](), attr);
    } else {
      throw new Error(
        "JSXGraph: Can't create comb with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]"
      );
    }
    if (type_default.isArray(parents[1]) && parents[1].length > 1) {
      attr = type_default.copyAttributes(attributes, board.options, "comb", "point2");
      p2 = board.create("point", parents[1], attr);
    } else if (type_default.isString(parents[1]) || type_default.isPoint(parents[1])) {
      p2 = board.select(parents[1]);
    } else if (type_default.isFunction(parents[1]) && type_default.isPoint(parents[1]())) {
      p2 = parents[1]();
    } else if (type_default.isFunction(parents[1]) && parents[1]().length && parents[1]().length >= 2) {
      attr = type_default.copyAttributes(attributes, board.options, "comb", "point2");
      p2 = jxg_default.createPoint(board, parents[1](), attr);
    } else {
      throw new Error(
        "JSXGraph: Can't create comb with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]"
      );
    }
  } else {
    parent_types = parents.map(function(parent) {
      return "'" + typeof parent + "'";
    });
    throw new Error(
      "JSXGraph: Can't create comb with parent types " + parent_types.join(", ") + ".\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "comb");
  c = board.create("curve", [[0], [0]], attr);
  c.updateDataArray = function() {
    var s = 0, max_s = p1.Dist(p2), cs, sn, dx, dy, x, y, f, p1_inner = p1, p2_inner = p2, ds, angle, width;
    ds = type_default.evaluate(c.visProp.frequency);
    angle = -type_default.evaluate(c.visProp.angle);
    width = type_default.evaluate(c.visProp.width);
    if (type_default.evaluate(c.visProp.reverse)) {
      p1_inner = p2;
      p2_inner = p1;
      angle = -angle;
    }
    cs = Math.cos(angle);
    sn = Math.sin(angle);
    dx = (p2_inner.X() - p1_inner.X()) / max_s;
    dy = (p2_inner.Y() - p1_inner.Y()) / max_s;
    cs *= width / Math.abs(sn);
    sn *= width / Math.abs(sn);
    this.dataX = [];
    this.dataY = [];
    while (s < max_s) {
      x = p1_inner.X() + dx * s;
      y = p1_inner.Y() + dy * s;
      f = Math.min(cs, max_s - s) / Math.abs(cs);
      sn *= f;
      cs *= f;
      this.dataX.push(x);
      this.dataY.push(y);
      this.dataX.push(x + dx * cs + dy * sn);
      this.dataY.push(y - dx * sn + dy * cs);
      this.dataX.push(NaN);
      this.dataY.push(NaN);
      s += ds;
    }
  };
  return c;
};
jxg_default.registerElement("comb", jxg_default.createComb);

// node_modules/jsxgraph/src/element/slopetriangle.js
var priv3 = {
  removeSlopeTriangle: function() {
    polygon_default.prototype.remove.call(this);
    this.board.removeObject(this.toppoint);
    this.board.removeObject(this.glider);
    this.board.removeObject(this.baseline);
    this.board.removeObject(this.basepoint);
    this.board.removeObject(this.label);
    if (this._isPrivateTangent) {
      this.board.removeObject(this.tangent);
    }
  },
  Value: function() {
    return this.tangent.getSlope();
  },
  Direction: function() {
    return this.tangent.Direction();
  }
};
jxg_default.createSlopeTriangle = function(board, parents, attributes) {
  var el, tangent, tglide, glider, toppoint, baseline, basepoint, label, attr, isPrivateTangent = false;
  if (parents.length === 1 && parents[0].type === constants_default.OBJECT_TYPE_TANGENT) {
    tangent = parents[0];
    tglide = tangent.glider;
  } else if (parents.length === 1 && parents[0].type === constants_default.OBJECT_TYPE_GLIDER) {
    tglide = parents[0];
    attr = type_default.copyAttributes(attributes, board.options, "slopetriangle", "tangent");
    tangent = board.create("tangent", [tglide], attr);
    isPrivateTangent = true;
  } else if (parents.length === 2 && parents[0].elementClass === constants_default.OBJECT_CLASS_LINE && type_default.isPoint(parents[1])) {
    tangent = parents[0];
    tglide = parents[1];
  } else {
    throw new Error(
      "JSXGraph: Can't create slope triangle with parent types '" + typeof parents[0] + "'."
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "slopetriangle", "basepoint");
  basepoint = board.create(
    "point",
    [
      function() {
        return [tglide.X() + 1, tglide.Y()];
      }
    ],
    attr
  );
  attr = type_default.copyAttributes(attributes, board.options, "slopetriangle", "baseline");
  baseline = board.create("line", [tglide, basepoint], attr);
  attr = type_default.copyAttributes(attributes, board.options, "slopetriangle", "glider");
  glider = board.create("glider", [tglide.X() + 1, tglide.Y(), baseline], attr);
  attr = type_default.copyAttributes(attributes, board.options, "slopetriangle", "toppoint");
  toppoint = board.create(
    "point",
    [
      function() {
        return [
          glider.X(),
          glider.Y() + (glider.X() - tglide.X()) * tangent.getSlope()
        ];
      }
    ],
    attr
  );
  attr = type_default.copyAttributes(attributes, board.options, "slopetriangle");
  el = board.create("polygon", [tglide, glider, toppoint], attr);
  el.Value = priv3.Value;
  el.Direction = priv3.Direction;
  el.tangent = tangent;
  el._isPrivateTangent = isPrivateTangent;
  el.borders[2].setArrow(false, false);
  attr = type_default.copyAttributes(attributes, board.options, "slopetriangle", "label");
  attr = type_default.copyAttributes(attr, board.options, "label");
  attr.isLabel = true;
  attr.anchor = el.borders[1];
  attr.priv = el.borders[1].visProp.priv;
  attr.id = el.borders[1].id + "Label";
  label = board.create("text", [0, 0, function() {
    return "";
  }], attr);
  label.needsUpdate = true;
  label.dump = false;
  el.borders[1].label = label;
  el.borders[1].hasLabel = true;
  el.borders[1].visProp.withlabel = true;
  label._setText(function() {
    var digits = type_default.evaluate(label.visProp.digits);
    if (label.useLocale()) {
      return label.formatNumberLocale(el.Value(), digits);
    }
    return type_default.toFixed(el.Value(), digits);
  });
  label.fullUpdate();
  el.glider = glider;
  el.basepoint = basepoint;
  el.baseline = baseline;
  el.toppoint = toppoint;
  el.label = label;
  el.subs = {
    glider,
    basePoint: basepoint,
    baseLine: baseline,
    topPoint: toppoint,
    label
  };
  el.inherits.push(glider, basepoint, baseline, toppoint, label);
  el.methodMap = jxg_default.deepCopy(el.methodMap, {
    tangent: "tangent",
    glider: "glider",
    basepoint: "basepoint",
    baseline: "baseline",
    toppoint: "toppoint",
    label: "label",
    Value: "Value",
    V: "Value",
    Direction: "Direction"
  });
  el.remove = priv3.removeSlopeTriangle;
  return el;
};
jxg_default.registerElement("slopetriangle", jxg_default.createSlopeTriangle);

// node_modules/jsxgraph/src/element/checkbox.js
var priv4 = {
  /**
   * @class
   * @ignore
   */
  CheckboxChangeEventHandler: function() {
    this._value = this.rendNodeCheckbox.checked;
    this.board.update();
  }
};
jxg_default.createCheckbox = function(board, parents, attributes) {
  var t, par, attr = type_default.copyAttributes(attributes, board.options, "checkbox");
  par = [
    parents[0],
    parents[1],
    '<span style="display:inline"><input type="checkbox" /><label for=""></label></span>'
  ];
  t = board.create("text", par, attr);
  t.type = type_default.OBJECT_TYPE_CHECKBOX;
  t.rendNodeCheckbox = t.rendNode.childNodes[0].childNodes[0];
  t.rendNodeLabel = t.rendNode.childNodes[0].childNodes[1];
  t.rendNodeTag = t.rendNodeCheckbox;
  t.rendNodeTag.disabled = !!attr.disabled;
  t.rendNodeCheckbox.id = t.rendNode.id + "_checkbox";
  t.rendNodeLabel.id = t.rendNode.id + "_label";
  t.rendNodeLabel.setAttribute("for", t.rendNodeCheckbox.id);
  t.setText(parents[2]);
  t.visPropOld.fontsize = "0px";
  board.renderer.updateTextStyle(t, false);
  t.rendNodeCheckbox.checked = attr.checked;
  t._value = attr.checked;
  t.Value = function() {
    return this._value;
  };
  t.update = function() {
    if (this.needsUpdate) {
      jxg_default.Text.prototype.update.call(this);
      this._value = this.rendNodeCheckbox.checked;
    }
    return this;
  };
  env_default.addEvent(t.rendNodeCheckbox, "change", priv4.CheckboxChangeEventHandler, t);
  return t;
};
jxg_default.registerElement("checkbox", jxg_default.createCheckbox);

// node_modules/jsxgraph/src/element/input.js
var priv5 = {
  /**
  * @class
  * @ignore
  */
  InputInputEventHandler: function(evt) {
    this._value = this.rendNodeInput.value;
    this.board.update();
  }
};
jxg_default.createInput = function(board, parents, attributes) {
  var t, par, attr = type_default.copyAttributes(attributes, board.options, "input");
  par = [
    parents[0],
    parents[1],
    '<span style="display:inline; white-space:nowrap; padding:0px;"><span></span><input type="text" maxlength="' + attr.maxlength + '" style="width:100%"/></span>'
  ];
  t = board.create("text", par, attr);
  t.type = type_default.OBJECT_TYPE_INPUT;
  t.rendNodeLabel = t.rendNode.childNodes[0].childNodes[0];
  t.rendNodeInput = t.rendNode.childNodes[0].childNodes[1];
  t.rendNodeInput.value = parents[2];
  t.rendNodeTag = t.rendNodeInput;
  t.rendNodeTag.disabled = !!attr.disabled;
  t.rendNodeLabel.id = t.rendNode.id + "_label";
  t.rendNodeInput.id = t.rendNode.id + "_input";
  t.setText(parents[3]);
  t._value = parents[2];
  t.update = function() {
    if (this.needsUpdate) {
      jxg_default.Text.prototype.update.call(this);
      this._value = this.rendNodeInput.value;
    }
    return this;
  };
  t.Value = function() {
    return this._value;
  };
  t.set = function(val) {
    this._value = val;
    this.rendNodeInput.value = val;
    return this;
  };
  env_default.addEvent(t.rendNodeInput, "input", priv5.InputInputEventHandler, t);
  env_default.addEvent(
    t.rendNodeInput,
    "mousedown",
    function(evt) {
      if (type_default.exists(evt.stopPropagation)) {
        evt.stopPropagation();
      }
    },
    t
  );
  env_default.addEvent(
    t.rendNodeInput,
    "touchstart",
    function(evt) {
      if (type_default.exists(evt.stopPropagation)) {
        evt.stopPropagation();
      }
    },
    t
  );
  env_default.addEvent(
    t.rendNodeInput,
    "pointerdown",
    function(evt) {
      if (type_default.exists(evt.stopPropagation)) {
        evt.stopPropagation();
      }
    },
    t
  );
  t.visPropOld.fontsize = "0px";
  board.renderer.updateTextStyle(t, false);
  return t;
};
jxg_default.registerElement("input", jxg_default.createInput);

// node_modules/jsxgraph/src/element/button.js
var priv6 = {
  ButtonClickEventHandler: function() {
    if (this._handler) {
      this._handler();
    }
    this.board.update();
  }
};
jxg_default.createButton = function(board, parents, attributes) {
  var t, par, attr = type_default.copyAttributes(attributes, board.options, "button");
  par = [parents[0], parents[1], '<button type="button" style="width:100%;"></button>'];
  t = board.create("text", par, attr);
  t.type = type_default.OBJECT_TYPE_BUTTON;
  t.rendNodeButton = t.rendNode.childNodes[0];
  t.rendNodeButton.id = t.rendNode.id + "_button";
  t.rendNodeTag = t.rendNodeButton;
  t.rendNodeTag.disabled = !!attr.disabled;
  t.setText(parents[2]);
  t.visPropOld.fontsize = "0px";
  board.renderer.updateTextStyle(t, false);
  if (parents[3]) {
    if (type_default.isString(parents[3])) {
      t._jc = new jxg_default.JessieCode();
      t._jc.use(board);
      t._handler = function() {
        t._jc.parse(parents[3]);
      };
    } else {
      t._handler = parents[3];
    }
  }
  env_default.addEvent(t.rendNodeButton, "click", priv6.ButtonClickEventHandler, t);
  env_default.addEvent(
    t.rendNodeButton,
    "mousedown",
    function(evt) {
      if (type_default.exists(evt.stopPropagation)) {
        evt.stopPropagation();
      }
    },
    t
  );
  env_default.addEvent(
    t.rendNodeButton,
    "touchstart",
    function(evt) {
      if (type_default.exists(evt.stopPropagation)) {
        evt.stopPropagation();
      }
    },
    t
  );
  env_default.addEvent(
    t.rendNodeButton,
    "pointerdown",
    function(evt) {
      if (type_default.exists(evt.stopPropagation)) {
        evt.stopPropagation();
      }
    },
    t
  );
  return t;
};
jxg_default.registerElement("button", jxg_default.createButton);

// node_modules/jsxgraph/src/element/vectorfield.js
jxg_default.createVectorField = function(board, parents, attributes) {
  var el, attr;
  if (!(parents.length >= 3 && (type_default.isArray(parents[0]) || type_default.isFunction(parents[0]) || type_default.isString(parents[0])) && (type_default.isArray(parents[1]) && parents[1].length === 3) && (type_default.isArray(parents[2]) && parents[2].length === 3))) {
    throw new Error(
      "JSXGraph: Can't create vector field with parent types '" + typeof parents[0] + "', '" + typeof parents[1] + "', '" + typeof parents[2] + "'."
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "vectorfield");
  el = board.create("curve", [[], []], attr);
  el.elType = "vectorfield";
  el.setF = function(func, varnames) {
    var f0, f1;
    if (type_default.isArray(func)) {
      f0 = type_default.createFunction(func[0], this.board, varnames);
      f1 = type_default.createFunction(func[1], this.board, varnames);
      this.F = function(x, y) {
        return [f0(x, y), f1(x, y)];
      };
    } else {
      this.F = type_default.createFunction(func, el.board, varnames);
    }
    return this;
  };
  el.setF(parents[0], "x, y");
  el.xData = parents[1];
  el.yData = parents[2];
  el.updateDataArray = function() {
    var x, y, i2, j, scale = type_default.evaluate(this.visProp.scale), start_x = type_default.evaluate(this.xData[0]), steps_x = type_default.evaluate(this.xData[1]), end_x = type_default.evaluate(this.xData[2]), delta_x = (end_x - start_x) / steps_x, start_y = type_default.evaluate(this.yData[0]), steps_y = type_default.evaluate(this.yData[1]), end_y = type_default.evaluate(this.yData[2]), delta_y = (end_y - start_y) / steps_y, v, theta, phi1, phi2, showArrow = type_default.evaluate(this.visProp.arrowhead.enabled), leg, leg_x, leg_y, alpha;
    if (showArrow) {
      leg = type_default.evaluate(this.visProp.arrowhead.size);
      leg_x = leg / board.unitX;
      leg_y = leg / board.unitY;
      alpha = type_default.evaluate(this.visProp.arrowhead.angle);
    }
    this.dataX = [];
    this.dataY = [];
    for (i2 = 0, x = start_x; i2 <= steps_x; x += delta_x, i2++) {
      for (j = 0, y = start_y; j <= steps_y; y += delta_y, j++) {
        v = this.F(x, y);
        v[0] *= scale;
        v[1] *= scale;
        this.dataX = this.dataX.concat([x, x + v[0], NaN]);
        this.dataY = this.dataY.concat([y, y + v[1], NaN]);
        if (showArrow && Math.abs(v[0]) + Math.abs(v[1]) > 0) {
          theta = Math.atan2(v[1], v[0]);
          phi1 = theta + alpha;
          phi2 = theta - alpha;
          this.dataX = this.dataX.concat([x + v[0] - Math.cos(phi1) * leg_x, x + v[0], x + v[0] - Math.cos(phi2) * leg_x, NaN]);
          this.dataY = this.dataY.concat([y + v[1] - Math.sin(phi1) * leg_y, y + v[1], y + v[1] - Math.sin(phi2) * leg_y, NaN]);
        }
      }
    }
  };
  el.methodMap = type_default.deepCopy(el.methodMap, {
    setF: "setF"
  });
  return el;
};
jxg_default.registerElement("vectorfield", jxg_default.createVectorField);
jxg_default.createSlopeField = function(board, parents, attributes) {
  var el, f, attr;
  if (!(parents.length >= 3 && (type_default.isFunction(parents[0]) || type_default.isString(parents[0])) && (type_default.isArray(parents[1]) && parents[1].length === 3) && (type_default.isArray(parents[2]) && parents[2].length === 3))) {
    throw new Error(
      "JSXGraph: Can't create slope field with parent types '" + typeof parents[0] + "', '" + typeof parents[1] + "', '" + typeof parents[2] + "'."
    );
  }
  f = type_default.createFunction(parents[0], board, "x, y");
  parents[0] = function(x, y) {
    var z = f(x, y), nrm = Math.sqrt(1 + z * z);
    return [1 / nrm, z / nrm];
  };
  attr = type_default.copyAttributes(attributes, board.options, "slopefield");
  el = board.create("vectorfield", parents, attr);
  el.elType = "slopefield";
  el.setF = function(func, varnames) {
    var f2 = type_default.createFunction(func, el.board, varnames);
    this.F = function(x, y) {
      var z = f2(x, y), nrm = Math.sqrt(1 + z * z);
      return [1 / nrm, z / nrm];
    };
  };
  el.methodMap = type_default.deepCopy(el.methodMap, {
    setF: "setF"
  });
  return el;
};
jxg_default.registerElement("slopefield", jxg_default.createSlopeField);

// node_modules/jsxgraph/src/element/smartlabel.js
jxg_default.createSmartLabel = function(board, parents, attributes) {
  var el, attr, p, user_supplied_text, getTextFun, txt_fun;
  if (parents.length === 0 || [constants_default.OBJECT_CLASS_POINT, constants_default.OBJECT_CLASS_LINE, constants_default.OBJECT_CLASS_CIRCLE].indexOf(parents[0].elementClass) < 0 && [constants_default.OBJECT_TYPE_POLYGON, constants_default.OBJECT_TYPE_ANGLE].indexOf(parents[0].type) < 0) {
    throw new Error(
      "JSXGraph: Can't create smartlabel with parent types '" + typeof parents[0] + "', '" + typeof parents[1] + "'."
    );
  }
  p = parents[0];
  user_supplied_text = parents[1] || "";
  if (p.elementClass === constants_default.OBJECT_CLASS_POINT) {
    attr = type_default.copyAttributes(attributes, board.options, "smartlabelpoint");
  } else if (p.elementClass === constants_default.OBJECT_CLASS_LINE) {
    attr = type_default.copyAttributes(attributes, board.options, "smartlabelline");
    attr.rotate = function() {
      return Math.atan(p.getSlope()) * 180 / Math.PI;
    };
    attr.visible = function() {
      return p.L() < 1.5 ? false : true;
    };
  } else if (p.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
    attr = type_default.copyAttributes(attributes, board.options, "smartlabelcircle");
    attr.visible = function() {
      return p.Radius() < 1.5 ? false : true;
    };
  } else if (p.type === constants_default.OBJECT_TYPE_POLYGON) {
    attr = type_default.copyAttributes(attributes, board.options, "smartlabelpolygon");
  } else if (p.type === constants_default.OBJECT_TYPE_ANGLE) {
    attr = type_default.copyAttributes(attributes, board.options, "smartlabelangle");
    attr.rotate = function() {
      var c1 = p.center.coords.usrCoords, c2 = p.getLabelAnchor().usrCoords, v = Math.atan2(c2[2] - c1[2], c2[1] - c1[1]) * 180 / Math.PI;
      return v > 90 && v < 270 ? v + 180 : v;
    };
    attr.anchorX = function() {
      var c1 = p.center.coords.usrCoords, c2 = p.getLabelAnchor().usrCoords, v = Math.atan2(c2[2] - c1[2], c2[1] - c1[1]) * 180 / Math.PI;
      return v > 90 && v < 270 ? "right" : "left";
    };
  }
  getTextFun = function(el2, p2, elType, mType) {
    var measure;
    switch (mType) {
      case "length":
        measure = function() {
          return p2.L();
        };
        break;
      case "slope":
        measure = function() {
          return p2.Slope();
        };
        break;
      case "area":
        measure = function() {
          return p2.Area();
        };
        break;
      case "radius":
        measure = function() {
          return p2.Radius();
        };
        break;
      case "perimeter":
        measure = function() {
          return p2.Perimeter();
        };
        break;
      case "rad":
        measure = function() {
          return p2.Value();
        };
        break;
      case "deg":
        measure = function() {
          return p2.Value() * 180 / Math.PI;
        };
        break;
      default:
        measure = function() {
          return 0;
        };
    }
    return function() {
      var str2 = "", val, txt = type_default.evaluate(user_supplied_text), digits = type_default.evaluate(el2.visProp.digits), u = type_default.evaluate(el2.visProp.unit), pre = type_default.evaluate(el2.visProp.prefix), suf = type_default.evaluate(el2.visProp.suffix), mj = type_default.evaluate(el2.visProp.usemathjax) || type_default.evaluate(el2.visProp.usekatex);
      if (txt === "") {
        if (el2.useLocale()) {
          val = el2.formatNumberLocale(measure(), digits);
        } else {
          val = type_default.toFixed(measure(), digits);
        }
        if (mj) {
          str2 = ["\\(", pre, val, "\\,", u, suf, "\\)"].join("");
        } else {
          str2 = [pre, val, u, suf].join("");
        }
      } else {
        str2 = txt;
      }
      return str2;
    };
  };
  if (p.elementClass === constants_default.OBJECT_CLASS_POINT) {
    el = board.create("text", [
      function() {
        return p.X();
      },
      function() {
        return p.Y();
      },
      ""
    ], attr);
    txt_fun = function() {
      var str2 = "", txt = type_default.evaluate(user_supplied_text), digits = type_default.evaluate(el.visProp.digits), u = type_default.evaluate(el.visProp.unit), pre = type_default.evaluate(el.visProp.prefix), suf = type_default.evaluate(el.visProp.suffix), dir = type_default.evaluate(el.visProp.dir), mj = type_default.evaluate(el.visProp.usemathjax) || type_default.evaluate(el.visProp.usekatex), x, y;
      if (el.useLocale()) {
        x = el.formatNumberLocale(p.X(), digits);
        y = el.formatNumberLocale(p.Y(), digits);
      } else {
        x = type_default.toFixed(p.X(), digits);
        y = type_default.toFixed(p.Y(), digits);
      }
      if (txt === "") {
        if (dir === "row") {
          if (mj) {
            str2 = ["\\(", pre, x, "\\,", u, " / ", y, "\\,", u, suf, "\\)"].join("");
          } else {
            str2 = [pre, x, " ", u, " / ", y, " ", u, suf].join("");
          }
        } else if (dir.indexOf("col") === 0) {
          if (mj) {
            str2 = ["\\(", pre, "\\left(\\array{", x, "\\,", u, "\\\\ ", y, "\\,", u, "}\\right)", suf, "\\)"].join("");
          } else {
            str2 = [pre, x, " ", u, "<br/>", y, " ", u, suf].join("");
          }
        }
      } else {
        str2 = txt;
      }
      return str2;
    };
  } else if (p.elementClass === constants_default.OBJECT_CLASS_LINE) {
    if (attr.measure === "length") {
      el = board.create("text", [
        function() {
          return (p.point1.X() + p.point2.X()) * 0.5;
        },
        function() {
          return (p.point1.Y() + p.point2.Y()) * 0.5;
        },
        ""
      ], attr);
      txt_fun = getTextFun(el, p, "line", "length");
    } else if (attr.measure === "slope") {
      el = board.create("text", [
        function() {
          return p.point1.X() * 0.25 + p.point2.X() * 0.75;
        },
        function() {
          return p.point1.Y() * 0.25 + p.point2.Y() * 0.75;
        },
        ""
      ], attr);
      txt_fun = getTextFun(el, p, "line", "slope");
    }
  } else if (p.elementClass === constants_default.OBJECT_CLASS_CIRCLE) {
    if (attr.measure === "radius") {
      el = board.create("text", [
        function() {
          return p.center.X() + p.Radius() * 0.5;
        },
        function() {
          return p.center.Y();
        },
        ""
      ], attr);
      txt_fun = getTextFun(el, p, "circle", "radius");
    } else if (attr.measure === "area") {
      el = board.create("text", [
        function() {
          return p.center.X();
        },
        function() {
          return p.center.Y() + p.Radius() * 0.5;
        },
        ""
      ], attr);
      txt_fun = getTextFun(el, p, "circle", "area");
    } else if (attr.measure === "circumference" || attr.measure === "perimeter") {
      el = board.create("text", [
        function() {
          return p.getLabelAnchor();
        },
        ""
      ], attr);
      txt_fun = getTextFun(el, p, "circle", "perimeter");
    }
  } else if (p.type === constants_default.OBJECT_TYPE_POLYGON) {
    if (attr.measure === "area") {
      el = board.create("text", [
        function() {
          return p.getTextAnchor();
        },
        ""
      ], attr);
      txt_fun = getTextFun(el, p, "polygon", "area");
    } else if (attr.measure === "perimeter") {
      el = board.create("text", [
        function() {
          var last = p.borders.length - 1;
          if (last >= 0) {
            return [
              (p.borders[last].point1.X() + p.borders[last].point2.X()) * 0.5,
              (p.borders[last].point1.Y() + p.borders[last].point2.Y()) * 0.5
            ];
          } else {
            return p.getTextAnchor();
          }
        },
        ""
      ], attr);
      txt_fun = getTextFun(el, p, "polygon", "perimeter");
    }
  } else if (p.type === constants_default.OBJECT_TYPE_ANGLE) {
    el = board.create("text", [
      function() {
        return p.getLabelAnchor();
      },
      ""
    ], attr);
    txt_fun = getTextFun(el, p, "angle", attr.measure);
  }
  if (type_default.exists(el)) {
    el.setText(txt_fun);
    p.addChild(el);
    el.setParents([p]);
  }
  return el;
};
jxg_default.registerElement("smartlabel", jxg_default.createSmartLabel);

// node_modules/jsxgraph/src/base/foreignobject.js
jxg_default.ForeignObject = function(board, coords, attributes, content, size2) {
  this.constructor(
    board,
    attributes,
    constants_default.OBJECT_TYPE_FOREIGNOBJECT,
    constants_default.OBJECT_CLASS_OTHER
  );
  this.element = this.board.select(attributes.anchor);
  this.coordsConstructor(coords);
  this._useUserSize = false;
  this.size = [1, 1];
  if (type_default.exists(size2) && size2.length > 0) {
    this._useUserSize = true;
    this.W = type_default.createFunction(size2[0], this.board, "");
    this.H = type_default.createFunction(size2[1], this.board, "");
    this.addParentsFromJCFunctions([this.W, this.H]);
    this.usrSize = [this.W(), this.H()];
  }
  this.content = content;
  this.elType = "foreignobject";
  this.id = this.board.setId(this, "Im");
  this.board.renderer.drawForeignObject(this);
  this.board.finalizeAdding(this);
  this.methodMap = jxg_default.deepCopy(this.methodMap, {
    addTransformation: "addTransform",
    trans: "addTransform",
    W: "W",
    Width: "W",
    H: "H",
    Height: "H"
  });
};
jxg_default.ForeignObject.prototype = new element_default();
type_default.copyPrototypeMethods(jxg_default.ForeignObject, coordselement_default, "coordsConstructor");
jxg_default.extend(
  jxg_default.ForeignObject.prototype,
  /** @lends JXG.ForeignObject.prototype */
  {
    /**
     * Checks whether (x,y) is over or near the image;
     * @param {Number} x Coordinate in x direction, screen coordinates.
     * @param {Number} y Coordinate in y direction, screen coordinates.
     * @returns {Boolean} True if (x,y) is over the image, False otherwise.
     */
    hasPoint: function(x, y) {
      var dx, dy, r, type, prec, c, v, p, dot, len = this.transformations.length;
      if (type_default.isObject(type_default.evaluate(this.visProp.precision))) {
        type = this.board._inputDevice;
        prec = type_default.evaluate(this.visProp.precision[type]);
      } else {
        prec = this.board.options.precision.hasPoint;
      }
      if (len === 0) {
        dx = x - this.coords.scrCoords[1];
        dy = this.coords.scrCoords[2] - y;
        r = prec;
        return dx >= -r && dx - this.size[0] <= r && dy >= -r && dy - this.size[1] <= r;
      }
      c = new coords_default(constants_default.COORDS_BY_SCREEN, [x, y], this.board);
      c = c.usrCoords;
      v = [c[0] - this.span[0][0], c[1] - this.span[0][1], c[2] - this.span[0][2]];
      dot = math_default.innerProduct;
      p = dot(v, this.span[1]);
      if (0 <= p && p <= dot(this.span[1], this.span[1])) {
        p = dot(v, this.span[2]);
        if (0 <= p && p <= dot(this.span[2], this.span[2])) {
          return true;
        }
      }
      return false;
    },
    /**
     * Recalculate the coordinates of lower left corner and the width and height.
     *
     * @returns {JXG.ForeignObject} A reference to the element
     * @private
     */
    update: function(fromParent) {
      if (!this.needsUpdate) {
        return this;
      }
      this.updateCoords(fromParent);
      this.updateSize();
      return this;
    },
    /**
     * Send an update request to the renderer.
     * @private
     */
    updateRenderer: function() {
      return this.updateRendererGeneric("updateForeignObject");
    },
    /**
     * Updates the internal arrays containing size of the foreignObject.
     * @returns {JXG.ForeignObject} A reference to the element
     * @private
     */
    updateSize: function() {
      var bb = [0, 0];
      if (this._useUserSize) {
        this.usrSize = [this.W(), this.H()];
        this.size = [
          Math.abs(this.usrSize[0] * this.board.unitX),
          Math.abs(this.usrSize[1] * this.board.unitY)
        ];
      } else {
        if (this.rendNode.hasChildNodes()) {
          bb = this.rendNode.childNodes[0].getBoundingClientRect();
          this.size = [bb.width, bb.height];
        }
      }
      return this;
    },
    /**
     * Update the anchor point of the foreignObject, i.e. the lower left corner
     * and the two vectors which span the rectangle.
     * @returns {JXG.ForeignObject} A reference to the element
     * @private
     *
     */
    updateSpan: function() {
      var i2, j, len = this.transformations.length, v = [];
      if (len === 0) {
        this.span = [
          [this.Z(), this.X(), this.Y()],
          [this.Z(), this.W(), 0],
          [this.Z(), 0, this.H()]
        ];
      } else {
        v[0] = [this.Z(), this.X(), this.Y()];
        v[1] = [this.Z(), this.X() + this.W(), this.Y()];
        v[2] = [this.Z(), this.X(), this.Y() + this.H()];
        for (i2 = 0; i2 < len; i2++) {
          for (j = 0; j < 3; j++) {
            v[j] = math_default.matVecMult(this.transformations[i2].matrix, v[j]);
          }
        }
        for (j = 0; j < 3; j++) {
          v[j][1] /= v[j][0];
          v[j][2] /= v[j][0];
          v[j][0] /= v[j][0];
        }
        for (j = 1; j < 3; j++) {
          v[j][0] -= v[0][0];
          v[j][1] -= v[0][1];
          v[j][2] -= v[0][2];
        }
        this.span = v;
      }
      return this;
    },
    addTransform: function(transform) {
      var i2;
      if (type_default.isArray(transform)) {
        for (i2 = 0; i2 < transform.length; i2++) {
          this.transformations.push(transform[i2]);
        }
      } else {
        this.transformations.push(transform);
      }
      return this;
    },
    // Documented in element.js
    getParents: function() {
      var p = [this.url, [this.Z(), this.X(), this.Y()], this.usrSize];
      if (this.parents.length !== 0) {
        p = this.parents;
      }
      return p;
    },
    /**
     * Set the width and height of the foreignObject. After setting a new size,
     * board.update() or foreignobject.fullUpdate()
     * has to be called to make the change visible.
     * @param  {numbe|function|string} width  Number, function or string
     *                            that determines the new width of the foreignObject
     * @param  {number|function|string} height Number, function or string
     *                            that determines the new height of the foreignObject
     * @returns {JXG.ForeignObject} A reference to the element
     *
     */
    setSize: function(width, height) {
      this.W = type_default.createFunction(width, this.board, "");
      this.H = type_default.createFunction(height, this.board, "");
      this._useUserSize = true;
      this.addParentsFromJCFunctions([this.W, this.H]);
      return this;
    },
    /**
     * Returns the width of the foreignObject in user coordinates.
     * @returns {number} width of the image in user coordinates
     */
    W: function() {
    },
    // Needed for docs, defined in constructor
    /**
     * Returns the height of the foreignObject in user coordinates.
     * @returns {number} height of the image in user coordinates
     */
    H: function() {
    }
    // Needed for docs, defined in constructor
  }
);
jxg_default.createForeignObject = function(board, parents, attributes) {
  var attr, fo, content = parents[0], coords = parents[1], size2 = [];
  if (parents.length >= 2) {
    size2 = parents[2];
  }
  attr = type_default.copyAttributes(attributes, board.options, "foreignobject");
  fo = coordselement_default.create(jxg_default.ForeignObject, board, coords, attr, content, size2);
  if (!fo) {
    throw new Error(
      "JSXGraph: Can't create foreignObject with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [string, [x, y], [w, h]], [string, [x, y]], [element,transformation]"
    );
  }
  return fo;
};
jxg_default.registerElement("foreignobject", jxg_default.createForeignObject);
jxg_default.registerElement("fo", jxg_default.createForeignObject);
var foreignobject_default = jxg_default.ForeignObject;

// node_modules/jsxgraph/src/options3d.js
jxg_default.extend(options_default, {
  // infobox: {
  //     strokeColor: 'black'
  // },
  axes3d: {
    /**#@+
     * @visprop
     */
    /**
     * Position of the main axes in a View3D element. Possible values are
     * 'center' and 'border'.
     *
     * @type String
     * @name View3D#axesPosition
     * @default 'center'
     */
    axesPosition: "center",
    // Possible values: 'center', otherwise: border
    // Main axes
    /**
     * Attributes of the 3D x-axis.
     *
     * @type Line3D
     * @name View3D#xAxis
     */
    xAxis: { visible: true, point2: { name: "x" } },
    /**
     * Attributes of the 3D y-axis.
     *
     * @type Line3D
     * @name View3D#yAxis
     */
    yAxis: { visible: true, point2: { name: "y" } },
    /**
     * Attributes of the 3D z-axis.
     *
     * @type Line3D
     * @name View3D#zAxis
     */
    zAxis: { visible: true, point2: { name: "z" } },
    // Planes
    /**
     * Attributes of the 3D plane orthogonal to the x-axis at the "rear" of the cube.
     * @type Plane3D
     * @name View3D#xPlaneRear
     */
    xPlaneRear: { visible: true, layer: 0, mesh3d: { layer: 1 } },
    /**
     * Attributes of the 3D plane orthogonal to the y-axis at the "rear" of the cube.
     * @type Plane3D
     * @name View3D#yPlaneRear
     */
    yPlaneRear: { visible: true, layer: 0, mesh3d: { layer: 1 } },
    /**
     * Attributes of the 3D plane orthogonal to the z-axis at the "rear" of the cube.
     * @type Plane3D
     * @name View3D#zPlaneRear
     */
    zPlaneRear: { visible: true, layer: 0, mesh3d: { layer: 1 } },
    /**
     * Attributes of the 3D plane orthogonal to the x-axis at the "front" of the cube.
     * @type Plane3D
     * @name View3D#xPlaneFront
     */
    xPlaneFront: { visible: false, layer: 0, mesh3d: { layer: 1 } },
    /**
     * Attributes of the 3D plane orthogonal to the y-axis at the "front" of the cube.
     * @type Plane3D
     * @name View3D#yPlaneFront
     */
    yPlaneFront: { visible: false, layer: 0, mesh3d: { layer: 1 } },
    /**
     * Attributes of the 3D plane orthogonal to the z-axis at the "front" of the cube.
     * @type Plane3D
     * @name View3D#zPlaneFront
     */
    zPlaneFront: { visible: false, layer: 0, mesh3d: { layer: 1 } },
    // Axes on the planes
    /**
     * Attributes of the 3D y-axis on the 3D plane orthogonal to the x-axis at the "rear" of the cube.
     * @type Plane3D
     * @name View3D#xPlaneRearYAxis
     */
    xPlaneRearYAxis: {
      visible: "inherit",
      strokeColor: "#888888",
      strokeWidth: 1
    },
    /**
     * Attributes of the 3D z-axis on the 3D plane orthogonal to the x-axis at the "rear" of the cube.
     * @type Plane3D
     * @name View3D#xPlaneRearZAxis
     */
    xPlaneRearZAxis: {
      visible: "inherit",
      strokeColor: "#888888",
      strokeWidth: 1
    },
    /**
     * Attributes of the 3D y-axis on the 3D plane orthogonal to the x-axis at the "front" of the cube.
     * @type Plane3D
     * @name View3D#xPlaneFrontYAxis
     */
    xPlaneFrontYAxis: {
      visible: "inherit",
      strokeColor: "#888888",
      strokeWidth: 1
    },
    /**
     * Attributes of the 3D z-axis on the 3D plane orthogonal to the x-axis at the "front" of the cube.
     * @type Plane3D
     * @name View3D#xPlaneFrontZAxis
     */
    xPlaneFrontZAxis: {
      visible: "inherit",
      strokeColor: "#888888",
      strokeWidth: 1
    },
    /**
     * Attributes of the 3D x-axis on the 3D plane orthogonal to the y-axis at the "rear" of the cube.
     * @type Plane3D
     * @name View3D#yPlaneRearXAxis
     */
    yPlaneRearXAxis: {
      visible: "inherit",
      strokeColor: "#888888",
      strokeWidth: 1
    },
    /**
     * Attributes of the 3D z-axis on the 3D plane orthogonal to the y-axis at the "rear" of the cube.
     * @type Plane3D
     * @name View3D#yPlaneRearZAxis
     */
    yPlaneRearZAxis: {
      visible: "inherit",
      strokeColor: "#888888",
      strokeWidth: 1
    },
    /**
     * Attributes of the 3D x-axis on the 3D plane orthogonal to the y-axis at the "front" of the cube.
     * @type Plane3D
     * @name View3D#yPlaneFrontXAxis
     */
    yPlaneFrontXAxis: {
      visible: "inherit",
      strokeColor: "#888888",
      strokeWidth: 1
    },
    /**
     * Attributes of the 3D z-axis on the 3D plane orthogonal to the y-axis at the "front" of the cube.
     * @type Plane3D
     * @name View3D#yPlaneFrontZAxis
     */
    yPlaneFrontZAxis: {
      visible: "inherit",
      strokeColor: "#888888",
      strokeWidth: 1
    },
    /**
     * Attributes of the 3D x-axis on the 3D plane orthogonal to the z-axis at the "rear" of the cube.
     * @type Plane3D
     * @name View3D#zPlaneRearXAxis
     */
    zPlaneRearXAxis: {
      visible: "inherit",
      strokeColor: "#888888",
      strokeWidth: 1
    },
    /**
     * Attributes of the 3D y-axis on the 3D plane orthogonal to the z-axis at the "rear" of the cube.
     * @type Plane3D
     * @name View3D#zPlaneRearYAxis
     */
    zPlaneRearYAxis: {
      visible: "inherit",
      strokeColor: "#888888",
      strokeWidth: 1
    },
    /**
     * Attributes of the 3D x-axis on the 3D plane orthogonal to the z-axis at the "front" of the cube.
     * @type Plane3D
     * @name View3D#zPlaneFrontXAxis
     */
    zPlaneFrontXAxis: {
      visible: "inherit",
      strokeColor: "#888888",
      strokeWidth: 1
    },
    /**
     * Attributes of the 3D y-axis on the 3D plane orthogonal to the z-axis at the "front" of the cube.
     * @type Plane3D
     * @name View3D#zPlaneFrontYAxis
     */
    zPlaneFrontYAxis: {
      visible: "inherit",
      strokeColor: "#888888",
      strokeWidth: 1
    }
    /**#@-*/
  },
  axis3d: {
    highlight: false,
    strokecolor: "black",
    strokeWidth: 1,
    tabindex: null,
    point1: { visible: false, name: "" },
    point2: { visible: false, name: "", label: { visible: true } }
  },
  curve3d: {
    /**#@+
     * @visprop
     */
    highlight: false,
    tabindex: -1,
    strokeWidth: 1,
    numberPointsHigh: 200
    /**#@-*/
  },
  mesh3d: {
    /**#@+
     * @visprop
     */
    strokeWidth: 1,
    strokeColor: "#9a9a9a",
    strokeOpacity: 0.6,
    highlight: false,
    fillColor: "#9a9a9a",
    fillOpacity: 0.1,
    tabindex: null,
    visible: "inherit"
    /**#@-*/
  },
  line3d: {
    strokeWidth: 1,
    strokeColor: "black",
    fixed: true,
    tabindex: null,
    gradient: "linear",
    gradientSecondColor: "#ffffff",
    point: { visible: false, name: "" },
    // Used in cases of point/direction/range
    point1: { visible: false, name: "" },
    // Used in point/point
    point2: { visible: false, name: "" }
  },
  plane3d: {
    strokeWidth: 0,
    strokeColor: "black",
    strokeOpacity: 1,
    highlight: false,
    tabindex: null,
    gradient: "linear",
    gradientSecondColor: "#ffffff",
    gradientAngle: Math.PI,
    fillColor: "#a7a7a7",
    fillOpacity: 0.6,
    point: { visible: false, name: "", fixed: true }
  },
  point3d: {
    infoboxDigits: "auto",
    strokeWidth: 0,
    gradient: "radial",
    gradientSecondColor: "#555555",
    fillColor: "yellow",
    highlightStrokeColor: "#555555"
  },
  surface3d: {
    /**#@+
     * @visprop
     */
    highlight: false,
    tabindex: -1,
    strokeWidth: 1,
    /**
     * Number of intervals the mesh is divided into in direction of parameter u.
     * @type Number
     * @name ParametricSurface3D#stepsU
     */
    stepsU: 30,
    /**
     * Number of intervals the mesh is divided into in direction of parameter v.
     * @type Number
     * @name ParametricSurface3D#stepsV
     */
    stepsV: 30
    /**#@-*/
  },
  vectorfield3d: {
    /**#@+
     * @visprop
     */
    /**
     * Scaling factor of the vectors. This in contrast to slope fields, where this attribute sets the vector to the given length.
     * @name scale
     * @memberOf Vectorfield3D.prototype
     * @type {Number|Function}
     * @see Slopefield.scale
     * @default 1
     */
    scale: 1,
    /**
     * Customize arrow heads of vectors. Be careful! If enabled this will slow down the performance.
     * Fields are:
     * <ul>
     *  <li> enabled: Boolean
     *  <li> size: length of the arrow head legs (in pixel)
     *  <li> angle: angle of the arrow head legs In radians.
     * </ul>
     * @name arrowhead
     * @memberOf Vectorfield3D.prototype
     * @type {Object}
     * @default <tt>{enabled: true, size: 5, angle: Math.PI * 0.125}</tt>
     */
    arrowhead: {
      enabled: true,
      size: 5,
      angle: Math.PI * 0.125
    }
    /**#@-*/
  },
  view3d: {
    /**#@+
     * @visprop
     */
    needsRegularUpdate: true,
    /**
     * Choose the projection is to be used: `parallel` or `central`.
     *
     * @name View3D#projection
     * @type String
     * @default 'parallel'
     */
    projection: "parallel",
    /**
     * Allow vertical dragging of objects, i.e. in direction of the z-axis.
     * Subobjects are
     * <ul>
     *  <li>enabled: true
     *  <li>key: 'shift'
     * </ul>
     * <p>
     * Possible values for attribute <i>key</i>: 'shift' or 'ctrl'.
     *
     * @name View3D#verticalDrag
     * @type Object
     * @default <tt>{enabled: true, key: 'shift'}</tt>
     */
    verticalDrag: {
      enabled: true,
      key: "shift"
    },
    /**
     * Specify the user handling of the azimuth.
     * <ul>
     *  <li><tt>pointer</tt> sub-attributes:
     *      <ul>
     *          <li><tt>enabled</tt>: Boolean that specifies whether pointer navigation is allowed by azimuth.
     *          <li><tt>speed</tt>: Number indicating how many passes the range of the az_slider makes when the cursor crosses the entire board once in the horizontal direction.
     *          <li><tt>outside</tt>: Boolean that specifies whether the pointer navigation is continued when the cursor leaves the board.
     *          <li><tt>button</tt>: Which button of the pointer should be used? (<tt>'-1'</tt> (=no button), <tt>'0'</tt> or <tt>'2'</tt>)
     *          <li><tt>key</tt>: Should an additional key be pressed? (<tt>'none'</tt>, <tt>'shift'</tt> or <tt>'ctrl'</tt>)
     *      </ul>
     *  <li><tt>keyboard</tt> sub-attributes:
     *      <ul>
     *          <li><tt>enabled</tt>: Boolean that specifies whether the keyboard (arrow keys) can be used to navigate the board.
     *          <li><tt>step</tt>: Size of the step per keystroke.
     *          <li><tt>key</tt>: Should an additional key be pressed? (<tt>'none'</tt>, <tt>'shift'</tt> or <tt>'ctrl'</tt>)
     *      </ul>
     *  <li><tt>continuous</tt>: Boolean that specifies whether the az_slider starts again from the beginning when its end is reached.
     *  <li><tt>slider</tt> attributes of the az_slider ({@link Slider}) with additional
     *      <ul>
     *          <li><tt>min</tt>: Minimum value.
     *          <li><tt>max</tt>: Maximum value.
     *          <li><tt>start</tt>: Start value.
     *      </ul>
     * </ul>
     *
     * @name View3D#az
     * @type Object
     * @default <pre>{
     *      pointer: {enabled: true, speed: 1, outside: true, button: -1, key: 'none'},
     *      keyboard: {enabled: true, step: 10, key: 'ctrl'},
     *      continuous: true,
     *      slider: {
     *          visible: true,
     *          style: 6,
     *          point1: {frozen: true},
     *          point2: {frozen: true},
     *          min: 0,
     *          max: 2 * Math.PI,
     *          start: 1.0
     *      },
     * }</pre>
     */
    az: {
      pointer: {
        enabled: true,
        speed: 1,
        outside: true,
        button: -1,
        key: "none"
      },
      keyboard: {
        enabled: true,
        step: 10,
        key: "ctrl"
      },
      continuous: true,
      slider: {
        visible: true,
        style: 6,
        point1: { frozen: true },
        point2: { frozen: true },
        min: 0,
        max: 2 * Math.PI,
        start: 1
      }
    },
    /**
     * Specify the user handling of the elevation.
     * <ul>
     *  <li><tt>pointer</tt> sub-attributes:
     *      <ul>
     *          <li><tt>enabled</tt>: Boolean that specifies whether pointer navigation is allowed by elevation.
     *          <li><tt>speed</tt>: Number indicating how many passes the range of the el_slider makes when the cursor crosses the entire board once in the horizontal direction.
     *          <li><tt>outside</tt>: Boolean that specifies whether the pointer navigation is continued when the cursor leaves the board.
     *          <li><tt>button</tt>: Which button of the pointer should be used? (<tt>'-1'</tt> (=no button), <tt>'0'</tt> or <tt>'2'</tt>)
     *          <li><tt>key</tt>: Should an additional key be pressed? (<tt>'none'</tt>, <tt>'shift'</tt> or <tt>'ctrl'</tt>)
     *      </ul>
     *  <li><tt>keyboard</tt> sub-attributes:
     *      <ul>
     *          <li><tt>enabled</tt>: Boolean that specifies whether the keyboard (arrow keys) can be used to navigate the board.
     *          <li><tt>step</tt>: Size of the step per keystroke.
     *          <li><tt>key</tt>: Should an additional key be pressed? (<tt>'none'</tt>, <tt>'shift'</tt> or <tt>'ctrl'</tt>)
     *      </ul>
     *  <li><tt>continuous</tt>: Boolean that specifies whether the el_slider starts again from the beginning when its end is reached.
     *  <li><tt>slider</tt> attributes of the el_slider ({@link Slider}) with additional
     *      <ul>
     *          <li><tt>min</tt>: Minimum value.
     *          <li><tt>max</tt>: Maximum value.
     *          <li><tt>start</tt>: Start value.
     *      </ul>
     * </ul>
     *
     * @name View3D#el
     * @type Object
     * @default <pre>{
     *      pointer: {enabled: true, speed: 1, outside: true, button: -1, key: 'none'},
     *      keyboard: {enabled: true, step: 10, key: 'ctrl'},
     *      continuous: true,
     *      slider: {
     *          visible: true,
     *          style: 6,
     *          point1: {frozen: true},
     *          point2: {frozen: true},
     *          min: 0,
     *          max: 2 * Math.PI,
     *          start: 0.3
     *      },
     * }<pre>
     */
    el: {
      pointer: {
        enabled: true,
        speed: 1,
        outside: true,
        button: -1,
        key: "none"
      },
      keyboard: {
        enabled: true,
        step: 10,
        key: "ctrl"
      },
      continuous: true,
      slider: {
        visible: true,
        style: 6,
        point1: { frozen: true },
        point2: { frozen: true },
        min: 0,
        max: 2 * Math.PI,
        start: 0.3
      }
    },
    /**
     * Distance of the camera to the center of the view.
     * If set to 'auto', r will be calculated automatically.
     *
     * @type {Number|String}
     * @default 'auto'
     */
    r: "auto",
    /**
     * Field of View defines the angle of view (in radians) of the camera, determining how much of the scene is captured within the frame.
     *
     * @type Number
     * @default 2/5*Math.PI
     */
    fov: 1 / 5 * 2 * Math.PI,
    /**
     * Fixed values for the view, which can be changed using keyboard keys `picture-up` and `picture-down`.
     * Array of the form: [[el0, az0, r0], [el1, az1, r1, ...[eln, azn, rn]]
     *
     * @name View3D#values
     * @type Array
     * @default <tt>{[[0, 1.57], [0.78, 0.62], [0, 0], [5.49, 0.62], [4.71, 0], [3.93, 0.62], [3.14, 0], [2.36, 0.62], [1.57, 1.57]]}<tt>
     */
    values: [
      [0, 1.57],
      [0.78, 0.62],
      [0, 0],
      [5.49, 0.62],
      [4.71, 0],
      [3.93, 0.62],
      [3.14, 0],
      [2.36, 0.62],
      [1.57, 1.57]
    ],
    /**
     * @class
     * @ignore
     */
    _currentView: -1
    /**#@-*/
  }
});
var options3d_default = jxg_default.Options;

// node_modules/jsxgraph/src/3d/view3d.js
jxg_default.View3D = function(board, parents, attributes) {
  this.constructor(board, attributes, constants_default.OBJECT_TYPE_VIEW3D, constants_default.OBJECT_CLASS_3D);
  this.objects = {};
  this.elementsByName = {};
  this.defaultAxes = null;
  this.matrix3D = [
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 1, 0]
  ];
  this.llftCorner = parents[0];
  this.size = parents[1];
  this.bbox3D = parents[2];
  this.r = -1;
  this.projectionType = "parallel";
  this.timeoutAzimuth = null;
  this.id = this.board.setId(this, "V");
  this.board.finalizeAdding(this);
  this.elType = "view3d";
  this.methodMap = type_default.deepCopy(this.methodMap, {
    // TODO
  });
};
jxg_default.View3D.prototype = new element_default();
jxg_default.extend(
  jxg_default.View3D.prototype,
  /** @lends JXG.View3D.prototype */
  {
    /**
     * Creates a new 3D element of type elementType.
     * @param {String} elementType Type of the element to be constructed given as a string e.g. 'point3d' or 'surface3d'.
     * @param {Array} parents Array of parent elements needed to construct the element e.g. coordinates for a 3D point or two
     * 3D points to construct a line. This highly depends on the elementType that is constructed. See the corresponding JXG.create*
     * methods for a list of possible parameters.
     * @param {Object} [attributes] An object containing the attributes to be set. This also depends on the elementType.
     * Common attributes are name, visible, strokeColor.
     * @returns {Object} Reference to the created element. This is usually a GeometryElement3D, but can be an array containing
     * two or more elements.
     */
    create: function(elementType, parents, attributes) {
      var prefix = [], el;
      if (elementType.indexOf("3d") > 0) {
        prefix.push(this);
      }
      el = this.board.create(elementType, prefix.concat(parents), attributes);
      return el;
    },
    /**
     * Select a single or multiple elements at once.
     * @param {String|Object|function} str The name, id or a reference to a JSXGraph 3D element in the 3D view. An object will
     * be used as a filter to return multiple elements at once filtered by the properties of the object.
     * @param {Boolean} onlyByIdOrName If true (default:false) elements are only filtered by their id, name or groupId.
     * The advanced filters consisting of objects or functions are ignored.
     * @returns {JXG.GeometryElement3D|JXG.Composition}
     * @example
     * // select the element with name A
     * view.select('A');
     *
     * // select all elements with strokecolor set to 'red' (but not '#ff0000')
     * view.select({
     *   strokeColor: 'red'
     * });
     *
     * // select all points on or below the x/y plane and make them black.
     * view.select({
     *   elType: 'point3d',
     *   Z: function (v) {
     *     return v <= 0;
     *   }
     * }).setAttribute({color: 'black'});
     *
     * // select all elements
     * view.select(function (el) {
     *   return true;
     * });
     */
    select: function(str2, onlyByIdOrName) {
      var flist, olist, i2, l, s = str2;
      if (s === null) {
        return s;
      }
      if (type_default.isString(s) && s !== "") {
        if (type_default.exists(this.objects[s])) {
          s = this.objects[s];
        } else if (type_default.exists(this.elementsByName[s])) {
          s = this.elementsByName[s];
        }
      } else if (!onlyByIdOrName && (type_default.isFunction(s) || type_default.isObject(s) && !type_default.isFunction(s.setAttribute))) {
        flist = type_default.filterElements(this.objectsList, s);
        olist = {};
        l = flist.length;
        for (i2 = 0; i2 < l; i2++) {
          olist[flist[i2].id] = flist[i2];
        }
        s = new composition_default(olist);
      } else if (type_default.isObject(s) && type_default.exists(s.id) && !type_default.exists(this.objects[s.id])) {
        s = null;
      }
      return s;
    },
    updateParallelProjection: function() {
      var r, a, e, f, mat = [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0]
      ];
      e = this.el_slide.Value();
      r = this.r;
      a = this.az_slide.Value();
      f = r * Math.sin(e);
      mat[1][1] = r * Math.cos(a);
      mat[1][2] = -r * Math.sin(a);
      mat[2][1] = f * Math.sin(a);
      mat[2][2] = f * Math.cos(a);
      mat[2][3] = Math.cos(e);
      return mat;
    },
    /**
     * @private
     * @returns {Array}
     */
    _updateCentralProjection: function() {
      var r, e, a, up, az, ax, ay, v, nrm, Tcam1, eye, d, foc = 1 / Math.tan(0.5 * type_default.evaluate(this.visProp.fov)), zf = 20, zn = 8, Pref = [
        0.5 * (this.bbox3D[0][0] + this.bbox3D[0][1]),
        0.5 * (this.bbox3D[0][0] + this.bbox3D[0][1]),
        0.5 * (this.bbox3D[0][0] + this.bbox3D[0][1])
      ], A = [
        [0, 0, 0, -1],
        [0, foc, 0, 0],
        [0, 0, foc, 0],
        [2 * zf * zn / (zn - zf), 0, 0, (zf + zn) / (zn - zf)]
      ], func_sphere;
      func_sphere = function(az2, el, r2) {
        return [
          r2 * Math.cos(az2) * Math.cos(el),
          -r2 * Math.sin(az2) * Math.cos(el),
          r2 * Math.sin(el)
        ];
      };
      a = this.az_slide.Value() + 3 * Math.PI * 0.5;
      e = this.el_slide.Value() * 2;
      r = type_default.evaluate(this.visProp.r);
      if (r === "auto") {
        r = Math.sqrt(
          Math.pow(this.bbox3D[0][0] - this.bbox3D[0][1], 2) + Math.pow(this.bbox3D[1][0] - this.bbox3D[1][1], 2) + Math.pow(this.bbox3D[2][0] - this.bbox3D[2][1], 2)
        ) * 1.01;
      }
      up = func_sphere(a, e + Math.PI / 2, 1);
      eye = func_sphere(a, e, r);
      d = [eye[0] - Pref[0], eye[1] - Pref[1], eye[2] - Pref[2]];
      nrm = math_default.norm(d, 3);
      az = [d[0] / nrm, d[1] / nrm, d[2] / nrm];
      nrm = math_default.norm(up, 3);
      v = [up[0] / nrm, up[1] / nrm, up[2] / nrm];
      ax = math_default.crossProduct(v, az);
      ay = math_default.crossProduct(az, ax);
      v = math_default.matVecMult([ax, ay, az], eye);
      Tcam1 = [
        [1, 0, 0, 0],
        [-v[0], ax[0], ax[1], ax[2]],
        [-v[1], ay[0], ay[1], ay[2]],
        [-v[2], az[0], az[1], az[2]]
      ];
      A = math_default.matMatMult(A, Tcam1);
      return A;
    },
    // Update 3D-to-2D transformation matrix with the actual azimuth and elevation angles.
    update: function() {
      var mat2D, shift, size2;
      if (!type_default.exists(this.el_slide) || !type_default.exists(this.az_slide) || !this.needsUpdate) {
        return this;
      }
      mat2D = [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]
      ];
      this.projectionType = type_default.evaluate(this.visProp.projection).toLowerCase();
      switch (this.projectionType) {
        case "central":
          this.matrix3D = this._updateCentralProjection();
          size2 = 0.4;
          mat2D[1][1] = this.size[0] / (2 * size2);
          mat2D[2][2] = this.size[1] / (2 * size2);
          mat2D[1][0] = this.llftCorner[0] + mat2D[1][1] * 0.5 * (2 * size2);
          mat2D[2][0] = this.llftCorner[1] + mat2D[2][2] * 0.5 * (2 * size2);
          this.viewPortTransform = mat2D;
          break;
        case "parallel":
        default:
          shift = [
            [1, 0, 0, 0],
            [-0.5 * (this.bbox3D[0][0] + this.bbox3D[0][1]), 1, 0, 0],
            [-0.5 * (this.bbox3D[1][0] + this.bbox3D[1][1]), 0, 1, 0],
            [-0.5 * (this.bbox3D[2][0] + this.bbox3D[2][1]), 0, 0, 1]
          ];
          mat2D[1][1] = this.size[0] / (this.bbox3D[0][1] - this.bbox3D[0][0]);
          mat2D[2][2] = this.size[1] / (this.bbox3D[1][1] - this.bbox3D[1][0]);
          mat2D[1][0] = this.llftCorner[0] + mat2D[1][1] * 0.5 * (this.bbox3D[0][1] - this.bbox3D[0][0]);
          mat2D[2][0] = this.llftCorner[1] + mat2D[2][2] * 0.5 * (this.bbox3D[1][1] - this.bbox3D[1][0]);
          this.matrix3D = this.updateParallelProjection();
          this.matrix3D = math_default.matMatMult(mat2D, math_default.matMatMult(this.matrix3D, shift));
      }
      return this;
    },
    updateRenderer: function() {
      this.needsUpdate = false;
      return this;
    },
    removeObject: function(object, saveMethod) {
      var i2;
      if (type_default.isArray(object)) {
        for (i2 = 0; i2 < object.length; i2++) {
          this.removeObject(object[i2]);
        }
        return this;
      }
      object = this.select(object);
      if (!type_default.exists(object) || type_default.isString(object)) {
        return this;
      }
      try {
        delete this.objects[object.id];
      } catch (e) {
        jxg_default.debug("View3D " + object.id + ": Could not be removed: " + e);
      }
      this.board.removeObject(object, saveMethod);
      return this;
    },
    /**
     * Project 3D coordinates to 2D board coordinates
     * The 3D coordinates are provides as three numbers x, y, z or one array of length 3.
     *
     * @param  {Number|Array} x
     * @param  {Number[]} y
     * @param  {Number[]} z
     * @returns {Array} Array of length 3 containing the projection on to the board
     * in homogeneous user coordinates.
     */
    project3DTo2D: function(x, y, z) {
      var vec, w;
      if (arguments.length === 3) {
        vec = [1, x, y, z];
      } else {
        if (x.length === 3) {
          vec = [1].concat(x);
        } else {
          vec = x;
        }
      }
      w = math_default.matVecMult(this.matrix3D, vec);
      switch (this.projectionType) {
        case "central":
          w[1] /= w[0];
          w[2] /= w[0];
          w[3] /= w[0];
          w[0] /= w[0];
          return math_default.matVecMult(this.viewPortTransform, w.slice(0, 3));
        case "parallel":
        default:
          return w;
      }
    },
    /**
     * Project a 2D coordinate to the plane defined by point "foot"
     * and the normal vector `normal`.
     *
     * @param  {JXG.Point} point2d
     * @param  {Array} normal
     * @param  {Array} foot
     * @returns {Array} of length 4 containing the projected
     * point in homogeneous coordinates.
     */
    project2DTo3DPlane: function(point2d, normal, foot) {
      var mat, rhs, d, le, n = normal.slice(1), sol;
      foot = foot || [1, 0, 0, 0];
      le = math_default.norm(n, 3);
      d = math_default.innerProduct(foot.slice(1), n, 3) / le;
      mat = this.matrix3D.slice(0, 3);
      mat.push([0].concat(n));
      rhs = point2d.coords.usrCoords.concat([d]);
      try {
        if (mat[2][3] === 1) {
          mat[2][1] = mat[2][2] = math_default.eps * 1e-3;
        }
        sol = math_default.Numerics.Gauss(mat, rhs);
      } catch (err) {
        sol = [0, NaN, NaN, NaN];
      }
      return sol;
    },
    /**
     * Project a 2D coordinate to a new 3D position by keeping
     * the 3D x, y coordinates and changing only the z coordinate.
     * All horizontal moves of the 2D point are ignored.
     *
     * @param {JXG.Point} point2d
     * @param {Array} coords3D
     * @returns {Array} of length 4 containing the projected
     * point in homogeneous coordinates.
     */
    project2DTo3DVertical: function(point2d, coords3D) {
      var m3D = this.matrix3D[2], b = m3D[3], rhs = point2d.coords.usrCoords[2];
      rhs -= m3D[0] * coords3D[0] + m3D[1] * coords3D[1] + m3D[2] * coords3D[2];
      if (Math.abs(b) < math_default.eps) {
        return coords3D;
      } else {
        return coords3D.slice(0, 3).concat([rhs / b]);
      }
    },
    /**
     * Limit 3D coordinates to the bounding cube.
     *
     * @param {Array} c3d 3D coordinates [x,y,z]
     * @returns Array with updated 3D coordinates.
     */
    project3DToCube: function(c3d) {
      var cube = this.bbox3D;
      if (c3d[1] < cube[0][0]) {
        c3d[1] = cube[0][0];
      }
      if (c3d[1] > cube[0][1]) {
        c3d[1] = cube[0][1];
      }
      if (c3d[2] < cube[1][0]) {
        c3d[2] = cube[1][0];
      }
      if (c3d[2] > cube[1][1]) {
        c3d[2] = cube[1][1];
      }
      if (c3d[3] < cube[2][0]) {
        c3d[3] = cube[2][0];
      }
      if (c3d[3] > cube[2][1]) {
        c3d[3] = cube[2][1];
      }
      return c3d;
    },
    /**
     * Intersect a ray with the bounding cube of the 3D view.
     * @param {Array} p 3D coordinates [x,y,z]
     * @param {Array} d 3D direction vector of the line (array of length 3)
     * @param {Number} r direction of the ray (positive if r > 0, negative if r < 0).
     * @returns Affine ratio of the intersection of the line with the cube.
     */
    intersectionLineCube: function(p, d, r) {
      var rnew, i2, r0, r1;
      rnew = r;
      for (i2 = 0; i2 < 3; i2++) {
        if (d[i2] !== 0) {
          r0 = (this.bbox3D[i2][0] - p[i2]) / d[i2];
          r1 = (this.bbox3D[i2][1] - p[i2]) / d[i2];
          if (r < 0) {
            rnew = Math.max(rnew, Math.min(r0, r1));
          } else {
            rnew = Math.min(rnew, Math.max(r0, r1));
          }
        }
      }
      return rnew;
    },
    /**
     * Test if coordinates are inside of the bounding cube.
     * @param {array} q 3D coordinates [x,y,z] of a point.
     * @returns Boolean
     */
    isInCube: function(q) {
      return q[0] > this.bbox3D[0][0] - math_default.eps && q[0] < this.bbox3D[0][1] + math_default.eps && q[1] > this.bbox3D[1][0] - math_default.eps && q[1] < this.bbox3D[1][1] + math_default.eps && q[2] > this.bbox3D[2][0] - math_default.eps && q[2] < this.bbox3D[2][1] + math_default.eps;
    },
    /**
     *
     * @param {JXG.Plane3D} plane1
     * @param {JXG.Plane3D} plane2
     * @param {JXG.Plane3D} d
     * @returns {Array} of length 2 containing the coordinates of the defining points of
     * of the intersection segment.
     */
    intersectionPlanePlane: function(plane1, plane2, d) {
      var ret = [[], []], p, dir, r, q;
      d = d || plane2.d;
      p = math_default.Geometry.meet3Planes(
        plane1.normal,
        plane1.d,
        plane2.normal,
        d,
        math_default.crossProduct(plane1.normal, plane2.normal),
        0
      );
      dir = math_default.Geometry.meetPlanePlane(
        plane1.vec1,
        plane1.vec2,
        plane2.vec1,
        plane2.vec2
      );
      r = this.intersectionLineCube(p, dir, Infinity);
      q = math_default.axpy(r, dir, p);
      if (this.isInCube(q)) {
        ret[0] = q;
      }
      r = this.intersectionLineCube(p, dir, -Infinity);
      q = math_default.axpy(r, dir, p);
      if (this.isInCube(q)) {
        ret[1] = q;
      }
      return ret;
    },
    /**
     * Generate mesh for a surface / plane.
     * Returns array [dataX, dataY] for a JSXGraph curve's updateDataArray function.
     * @param {Array|Function} func
     * @param {Array} interval_u
     * @param {Array} interval_v
     * @returns Array
     * @private
     *
     * @example
     *  var el = view.create('curve', [[], []]);
     *  el.updateDataArray = function () {
     *      var steps_u = Type.evaluate(this.visProp.stepsu),
     *           steps_v = Type.evaluate(this.visProp.stepsv),
     *           r_u = Type.evaluate(this.range_u),
     *           r_v = Type.evaluate(this.range_v),
     *           func, ret;
     *
     *      if (this.F !== null) {
     *          func = this.F;
     *      } else {
     *          func = [this.X, this.Y, this.Z];
     *      }
     *      ret = this.view.getMesh(func,
     *          r_u.concat([steps_u]),
     *          r_v.concat([steps_v]));
     *
     *      this.dataX = ret[0];
     *      this.dataY = ret[1];
     *  };
     *
     */
    getMesh: function(func, interval_u, interval_v) {
      var i_u, i_v, u, v, c2d, delta_u, delta_v, p = [0, 0, 0], steps_u = interval_u[2], steps_v = interval_v[2], dataX = [], dataY = [];
      delta_u = (type_default.evaluate(interval_u[1]) - type_default.evaluate(interval_u[0])) / steps_u;
      delta_v = (type_default.evaluate(interval_v[1]) - type_default.evaluate(interval_v[0])) / steps_v;
      for (i_u = 0; i_u <= steps_u; i_u++) {
        u = interval_u[0] + delta_u * i_u;
        for (i_v = 0; i_v <= steps_v; i_v++) {
          v = interval_v[0] + delta_v * i_v;
          if (type_default.isFunction(func)) {
            p = func(u, v);
          } else {
            p = [func[0](u, v), func[1](u, v), func[2](u, v)];
          }
          c2d = this.project3DTo2D(p);
          dataX.push(c2d[1]);
          dataY.push(c2d[2]);
        }
        dataX.push(NaN);
        dataY.push(NaN);
      }
      for (i_v = 0; i_v <= steps_v; i_v++) {
        v = interval_v[0] + delta_v * i_v;
        for (i_u = 0; i_u <= steps_u; i_u++) {
          u = interval_u[0] + delta_u * i_u;
          if (type_default.isFunction(func)) {
            p = func(u, v);
          } else {
            p = [func[0](u, v), func[1](u, v), func[2](u, v)];
          }
          c2d = this.project3DTo2D(p);
          dataX.push(c2d[1]);
          dataY.push(c2d[2]);
        }
        dataX.push(NaN);
        dataY.push(NaN);
      }
      return [dataX, dataY];
    },
    /**
     *
     */
    animateAzimuth: function() {
      var s = this.az_slide._smin, e = this.az_slide._smax, sdiff = e - s, newVal = this.az_slide.Value() + 0.1;
      this.az_slide.position = (newVal - s) / sdiff;
      if (this.az_slide.position > 1) {
        this.az_slide.position = 0;
      }
      this.board.update();
      this.timeoutAzimuth = setTimeout(function() {
        this.animateAzimuth();
      }.bind(this), 200);
    },
    /**
     *
     */
    stopAzimuth: function() {
      clearTimeout(this.timeoutAzimuth);
      this.timeoutAzimuth = null;
    },
    /**
     * Check if vertical dragging is enabled and which action is needed.
     * Default is shiftKey.
     *
     * @returns Boolean
     * @private
     */
    isVerticalDrag: function() {
      var b = this.board, key;
      if (!type_default.evaluate(this.visProp.verticaldrag.enabled)) {
        return false;
      }
      key = "_" + type_default.evaluate(this.visProp.verticaldrag.key) + "Key";
      return b[key];
    },
    /**
     * Sets camera view to the given values.
     *
     * @param {Number} az Value of azimuth.
     * @param {Number} el Value of elevation.
     * @param {Number} [r] Value of radius.
     *
     * @returns {Object} Reference to the view.
     */
    setView: function(az, el, r) {
      r = r || this.r;
      this.az_slide.setValue(az);
      this.el_slide.setValue(el);
      this.r = r;
      this.board.update();
      return this;
    },
    /**
     * Changes view to the next view stored in the attribute `values`.
     *
     * @see View3D#values
     *
     * @returns {Object} Reference to the view.
     */
    nextView: function() {
      var views = type_default.evaluate(this.visProp.values), n = this.visProp._currentview;
      n = (n + 1) % views.length;
      this.setCurrentView(n);
      return this;
    },
    /**
     * Changes view to the previous view stored in the attribute `values`.
     *
     * @see View3D#values
     *
     * @returns {Object} Reference to the view.
     */
    previousView: function() {
      var views = type_default.evaluate(this.visProp.values), n = this.visProp._currentview;
      n = (n + views.length - 1) % views.length;
      this.setCurrentView(n);
      return this;
    },
    /**
     * Changes view to the determined view stored in the attribute `values`.
     *
     * @see View3D#values
     *
     * @param {Number} n Index of view in attribute `values`.
     * @returns {Object} Reference to the view.
     */
    setCurrentView: function(n) {
      var views = type_default.evaluate(this.visProp.values);
      if (n < 0 || n >= views.length) {
        n = (n % views.length + views.length) % views.length;
      }
      this.setView(views[n][0], views[n][1], views[n][2]);
      this.visProp._currentview = n;
      return this;
    },
    /**
     * Controls the navigation in az direction using either the keyboard or a pointer.
     *
     * @private
     *
     * @param {event} event either the keydown or the pointer event
     * @returns view
     */
    _azEventHandler: function(event) {
      var smax = this.az_slide._smax, smin = this.az_slide._smin, speed = (smax - smin) / this.board.canvasWidth * type_default.evaluate(this.visProp.az.pointer.speed), delta = event.movementX, az = this.az_slide.Value(), el = this.el_slide.Value();
      if (this.board.mode === this.board.BOARD_MODE_DRAG) {
        return this;
      }
      if (type_default.evaluate(this.visProp.az.keyboard.enabled)) {
        if (event.key === "ArrowRight") {
          az = az + type_default.evaluate(this.visProp.az.keyboard.step) * Math.PI / 180;
        } else if (event.key === "ArrowLeft") {
          az = az - type_default.evaluate(this.visProp.az.keyboard.step) * Math.PI / 180;
        }
      }
      if (type_default.evaluate(this.visProp.az.pointer.enabled) && delta !== 0 && event.key == null) {
        az += delta * speed;
      }
      if (type_default.evaluate(this.visProp.az.continuous)) {
        az = (az % smax + smax) % smax;
      } else {
        if (az > 0) {
          az = Math.min(smax, az);
        } else if (az < 0) {
          az = Math.max(smin, az);
        }
      }
      this.setView(az, el);
      return this;
    },
    /**
     * Controls the navigation in el direction using either the keyboard or a pointer.
     *
     * @private
     *
     * @param {event} event either the keydown or the pointer event
     * @returns view
     */
    _elEventHandler: function(event) {
      var smax = this.el_slide._smax, smin = this.el_slide._smin, speed = (smax - smin) / this.board.canvasHeight * type_default.evaluate(this.visProp.el.pointer.speed), delta = event.movementY, az = this.az_slide.Value(), el = this.el_slide.Value();
      if (this.board.mode === this.board.BOARD_MODE_DRAG) {
        return this;
      }
      if (type_default.evaluate(this.visProp.el.keyboard.enabled)) {
        if (event.key === "ArrowUp") {
          el = el - type_default.evaluate(this.visProp.el.keyboard.step) * Math.PI / 180;
        } else if (event.key === "ArrowDown") {
          el = el + type_default.evaluate(this.visProp.el.keyboard.step) * Math.PI / 180;
        }
      }
      if (type_default.evaluate(this.visProp.el.pointer.enabled) && delta !== 0 && event.key == null) {
        el += delta * speed;
      }
      if (type_default.evaluate(this.visProp.el.continuous)) {
        el = (el % smax + smax) % smax;
      } else {
        if (el > 0) {
          el = Math.min(smax, el);
        } else if (el < 0) {
          el = Math.max(smin, el);
        }
      }
      this.setView(az, el);
      return this;
    }
  }
);
jxg_default.createView3D = function(board, parents, attributes) {
  var view, attr, attr_az, attr_el, x, y, w, h, coords = parents[0], size2 = parents[1];
  attr = type_default.copyAttributes(attributes, board.options, "view3d");
  view = new jxg_default.View3D(board, parents, attr);
  view.defaultAxes = view.create("axes3d", parents, attributes);
  x = coords[0];
  y = coords[1];
  w = size2[0];
  h = size2[1];
  attr_az = type_default.copyAttributes(attributes, board.options, "view3d", "az", "slider");
  attr_az.name = "az";
  attr_el = type_default.copyAttributes(attributes, board.options, "view3d", "el", "slider");
  attr_el.name = "el";
  view.az_slide = board.create(
    "slider",
    [
      [x - 1, y - 2],
      [x + w + 1, y - 2],
      [
        type_default.evaluate(attr_az.min),
        type_default.evaluate(attr_az.start),
        type_default.evaluate(attr_az.max)
      ]
    ],
    attr_az
  );
  view.el_slide = board.create(
    "slider",
    [
      [x - 1, y],
      [x - 1, y + h],
      [
        type_default.evaluate(attr_el.min),
        type_default.evaluate(attr_el.start),
        type_default.evaluate(attr_el.max)
      ]
    ],
    attr_el
  );
  view.board.highlightInfobox = function(x2, y2, el) {
    var d, i2, c3d, foot, pre = '<span style="color:black; font-size:200%">\u21C4 &nbsp;</span>', brd = el.board, arr, infobox, p = null;
    if (view.isVerticalDrag()) {
      pre = '<span style="color:black; font-size:200%">\u21C5 &nbsp;</span>';
    }
    for (i2 = 0; i2 < el.parents.length; i2++) {
      p = brd.objects[el.parents[i2]];
      if (p.is3D) {
        break;
      }
    }
    if (p) {
      foot = [1, 0, 0, p.coords[3]];
      c3d = view.project2DTo3DPlane(p.element2D, [1, 0, 0, 1], foot);
      if (!view.isInCube(c3d)) {
        view.board.highlightCustomInfobox("", p);
        return;
      }
      d = type_default.evaluate(p.visProp.infoboxdigits);
      infobox = view.board.infobox;
      if (d === "auto") {
        if (infobox.useLocale()) {
          arr = [pre, "(", infobox.formatNumberLocale(p.X()), " | ", infobox.formatNumberLocale(p.Y()), " | ", infobox.formatNumberLocale(p.Z()), ")"];
        } else {
          arr = [pre, "(", type_default.autoDigits(p.X()), " | ", type_default.autoDigits(p.Y()), " | ", type_default.autoDigits(p.Z()), ")"];
        }
      } else {
        if (infobox.useLocale()) {
          arr = [pre, "(", infobox.formatNumberLocale(p.X(), d), " | ", infobox.formatNumberLocale(p.Y(), d), " | ", infobox.formatNumberLocale(p.Z(), d), ")"];
        } else {
          arr = [pre, "(", type_default.toFixed(p.X(), d), " | ", type_default.toFixed(p.Y(), d), " | ", type_default.toFixed(p.Z(), d), ")"];
        }
      }
      view.board.highlightCustomInfobox(arr.join(""), p);
    } else {
      view.board.highlightCustomInfobox("(" + x2 + ", " + y2 + ")", el);
    }
  };
  view.BOARD_MODE_NONE = 0;
  env_default.addEvent(board.containerObj, "keydown", function(event) {
    var neededKey;
    if (type_default.evaluate(view.visProp.el.keyboard.enabled) && (event.key === "ArrowUp" || event.key === "ArrowDown")) {
      neededKey = type_default.evaluate(view.visProp.el.keyboard.key);
      if (neededKey === "none" || neededKey.indexOf("shift") > -1 && event.shiftKey || neededKey.indexOf("ctrl") > -1 && event.ctrlKey) {
        view._elEventHandler(event);
      }
    }
    if (type_default.evaluate(view.visProp.el.keyboard.enabled) && (event.key === "ArrowLeft" || event.key === "ArrowRight")) {
      neededKey = type_default.evaluate(view.visProp.az.keyboard.key);
      if (neededKey === "none" || neededKey.indexOf("shift") > -1 && event.shiftKey || neededKey.indexOf("ctrl") > -1 && event.ctrlKey) {
        view._azEventHandler(event);
      }
    }
    if (event.key === "PageUp") {
      view.nextView();
    } else if (event.key === "PageDown") {
      view.previousView();
    }
    event.preventDefault();
  }, view);
  board.containerObj.addEventListener("pointerdown", function(event) {
    var neededButton, neededKey, target;
    if (type_default.evaluate(view.visProp.az.pointer.enabled)) {
      neededButton = type_default.evaluate(view.visProp.az.pointer.button);
      neededKey = type_default.evaluate(view.visProp.az.pointer.key);
      if ((neededButton === -1 || neededButton === event.button) && (neededKey === "none" || neededKey.indexOf("shift") > -1 && event.shiftKey || neededKey.indexOf("ctrl") > -1 && event.ctrlKey)) {
        if (type_default.evaluate(view.visProp.az.pointer.outside)) {
          target = document;
        } else {
          target = board.containerObj;
        }
        env_default.addEvent(target, "pointermove", view._azEventHandler, view);
        view._hasMoveAz = true;
      }
    }
    if (type_default.evaluate(view.visProp.el.pointer.enabled)) {
      neededButton = type_default.evaluate(view.visProp.el.pointer.button);
      neededKey = type_default.evaluate(view.visProp.el.pointer.key);
      if ((neededButton === -1 || neededButton === event.button) && (neededKey === "none" || neededKey.indexOf("shift") > -1 && event.shiftKey || neededKey.indexOf("ctrl") > -1 && event.ctrlKey)) {
        if (type_default.evaluate(view.visProp.el.pointer.outside)) {
          target = document;
        } else {
          target = board.containerObj;
        }
        env_default.addEvent(target, "pointermove", view._elEventHandler, view);
        view._hasMoveEl = true;
      }
    }
    function handlePointerUp() {
      var target2;
      if (view._hasMoveAz) {
        if (type_default.evaluate(view.visProp.az.pointer.outside)) {
          target2 = document;
        } else {
          target2 = view.board.containerObj;
        }
        env_default.removeEvent(target2, "pointermove", view._azEventHandler, view);
        view._hasMoveAz = false;
      }
      if (view._hasMoveEl) {
        if (type_default.evaluate(view.visProp.el.pointer.outside)) {
          target2 = document;
        } else {
          target2 = view.board.containerObj;
        }
        env_default.removeEvent(target2, "pointermove", view._elEventHandler, view);
        view._hasMoveEl = false;
      }
      env_default.removeEvent(document, "pointerup", handlePointerUp, view);
    }
    env_default.addEvent(document, "pointerup", handlePointerUp, view);
  });
  view.board.update();
  return view;
};
jxg_default.registerElement("view3d", jxg_default.createView3D);
var view3d_default = jxg_default.View3D;

// node_modules/jsxgraph/src/3d/element3d.js
jxg_default.GeometryElement3D = function(view, elType) {
  this.elType = elType;
  this.id = this.board.setId(this, elType);
  this.view = view;
  this.element2D = null;
  this.is3D = true;
  this.view.objects[this.id] = this;
  if (this.name !== "") {
    this.view.elementsByName[this.name] = this;
  }
};
jxg_default.extend(jxg_default.GeometryElement3D.prototype, {
  setAttr2D: function(attr3D) {
    var attr2D = attr3D;
    attr2D.name = this.name;
    return attr2D;
  },
  // Documented in element.js
  setAttribute: function(attr) {
    var i2, key, value, arg, pair, attributes = {};
    for (i2 = 0; i2 < arguments.length; i2++) {
      arg = arguments[i2];
      if (type_default.isString(arg)) {
        pair = arg.split(":");
        attributes[type_default.trim(pair[0])] = type_default.trim(pair[1]);
      } else if (!type_default.isArray(arg)) {
        jxg_default.extend(attributes, arg);
      } else {
        attributes[arg[0]] = arg[1];
      }
    }
    for (i2 in attributes) {
      if (attributes.hasOwnProperty(i2)) {
        key = i2.replace(/\s+/g, "").toLowerCase();
        value = attributes[i2];
        switch (key) {
          case "numberpointshigh":
          case "stepsu":
          case "stepsv":
            if (type_default.exists(this.visProp[key]) && (!jxg_default.Validator[key] || jxg_default.Validator[key] && jxg_default.Validator[key](value) || jxg_default.Validator[key] && type_default.isFunction(value) && jxg_default.Validator[key](value()))) {
              value = value.toLowerCase && value.toLowerCase() === "false" ? false : value;
              this._set(key, value);
            }
            break;
          default:
            if (type_default.exists(this.element2D)) {
              this.element2D.setAttribute(attributes);
            }
        }
      }
    }
  },
  // Documented in element.js
  getAttribute: function(key) {
    var result;
    key = key.toLowerCase();
    switch (key) {
      case "numberpointshigh":
      case "stepsu":
      case "stepsv":
        result = this.visProp[key];
        break;
      default:
        if (type_default.exists(this.element2D)) {
          result = this.element2D.getAttribute(key);
        }
        break;
    }
    return result;
  },
  // Documented in element.js
  getAttributes: function() {
    var attr = {}, i2, key, attr3D = ["numberpointshigh", "stepsu", "stepsv"], le = attr3D.length;
    if (type_default.exists(this.element2D)) {
      attr = type_default.merge(this.element2D.getAttributes());
    }
    for (i2 = 0; i2 < le; i2++) {
      key = attr3D[i2];
      if (type_default.exists(this.visProp[key])) {
        attr[key] = this.visProp[key];
      }
    }
    return attr;
  },
  remove: function() {
  }
});
var element3d_default = jxg_default.GeometryElement3D;

// node_modules/jsxgraph/src/3d/box3d.js
jxg_default.createAxes3D = function(board, parents, attributes) {
  var view = parents[0], directions = ["x", "y", "z"], suffixAxis = "Axis", sides = ["Rear", "Front"], rear = [0, 0, 0], front = [0, 0, 0], i2, j, k, i1, i22, attr, pos, dir, dir1, from, to, vec1, vec2, range1, range2, na, na_parent, ticks_attr, axes = {};
  if (type_default.exists(view.bbox3D)) {
    for (i2 = 0; i2 < directions.length; i2++) {
      rear[i2] = view.bbox3D[i2][0];
      front[i2] = view.bbox3D[i2][1];
    }
  } else {
    for (i2 = 0; i2 < directions.length; i2++) {
      rear[i2] = parents[1][i2];
      front[i2] = parents[2][1];
    }
  }
  attr = type_default.copyAttributes(attributes, board.options, "axes3d");
  pos = attr.axesposition;
  for (i2 = 0; i2 < directions.length; i2++) {
    dir = directions[i2];
    na = dir + suffixAxis;
    if (pos === "center") {
      from = [0, 0, 0];
      to = [0, 0, 0];
      to[i2] = front[i2];
      axes[na] = view.create("axis3d", [from, to], attr[na.toLowerCase()]);
    } else {
      na += "Border";
      from = rear.slice();
      to = front.slice();
      if (i2 === 2) {
        from[1] = front[1];
        to[0] = rear[0];
      } else {
        from[i2] = front[i2];
        to[2] = rear[2];
      }
      to[i2] = front[i2];
      attr[na.toLowerCase()].lastArrow = false;
      axes[na] = view.create("axis3d", [from, to], attr[na.toLowerCase()]);
      ticks_attr = {
        visible: true,
        // Für z-Ticks wird path nicht berechnet
        minorTicks: 0,
        tickEndings: [0, 1],
        drawLabels: false
      };
      if (i2 === 2) {
        ticks_attr.tickEndings = [1, 0];
      }
      axes[na + "Ticks"] = view.create("ticks", [axes[na], 1], ticks_attr);
    }
  }
  axes.O = view.create(
    "intersection",
    [axes[directions[0] + suffixAxis], axes[directions[1] + suffixAxis]],
    {
      name: "",
      visible: false,
      withLabel: false
    }
  );
  for (i2 = 0; i2 < directions.length; i2++) {
    i1 = (i2 + 1) % 3;
    i22 = (i2 + 2) % 3;
    dir = directions[i2];
    for (j = 0; j < sides.length; j++) {
      from = [0, 0, 0];
      from[i2] = j === 0 ? rear[i2] : front[i2];
      vec1 = [0, 0, 0];
      vec2 = [0, 0, 0];
      vec1[i1] = 1;
      vec2[i22] = 1;
      range1 = [rear[i1], front[i1]];
      range2 = [rear[i22], front[i22]];
      na = dir + "Plane" + sides[j];
      attr = type_default.copyAttributes(attributes, board.options, "axes3d", na);
      axes[na] = view.create("plane3d", [from, vec1, vec2, range1, range2], attr);
      axes[na].elType = "axisplane3d";
    }
  }
  for (i2 = 0; i2 < directions.length; i2++) {
    dir = directions[i2];
    for (j = 0; j < sides.length; j++) {
      for (k = 1; k <= 2; k++) {
        i1 = (i2 + k) % 3;
        dir1 = directions[i1];
        na = dir + "Plane" + sides[j] + dir1.toUpperCase() + "Axis";
        na_parent = dir + "Plane" + sides[j];
        from = [0, 0, 0];
        to = [0, 0, 0];
        from[i2] = to[i2] = j === 0 ? rear[i2] : front[i2];
        from[i1] = rear[i1];
        to[i1] = front[i1];
        attr = type_default.copyAttributes(attributes, board.options, "axes3d", na);
        axes[na] = view.create("axis3d", [from, to], attr);
        axes[na_parent].addChild(axes[na]);
        axes[na_parent].element2D.inherits.push(axes[na]);
      }
    }
  }
  return axes;
};
jxg_default.registerElement("axes3d", jxg_default.createAxes3D);
jxg_default.createAxis3D = function(board, parents, attributes) {
  var view = parents[0], attr, start = parents[1], end = parents[2], el_start, el_end, el;
  attr = type_default.copyAttributes(attributes.point1, board.options, "axis3d", "point1");
  el_start = view.create(
    "point",
    [
      function(xx, yy, zz) {
        return function() {
          return view.project3DTo2D(xx, yy, zz)[1];
        };
      }(start[0], start[1], start[2]),
      function(xx, yy, zz) {
        return function() {
          return view.project3DTo2D(xx, yy, zz)[2];
        };
      }(start[0], start[1], start[2])
    ],
    attr
  );
  attr = type_default.copyAttributes(attributes.point2, board.options, "axis3d", "point2");
  el_end = view.create(
    "point",
    [
      function(xx, yy, zz) {
        return function() {
          return view.project3DTo2D(xx, yy, zz)[1];
        };
      }(end[0], end[1], end[2]),
      function(xx, yy, zz) {
        return function() {
          return view.project3DTo2D(xx, yy, zz)[2];
        };
      }(end[0], end[1], end[2])
    ],
    attr
  );
  attr = type_default.copyAttributes(attributes, board.options, "axis3d");
  el = view.create("arrow", [el_start, el_end], attr);
  return el;
};
jxg_default.registerElement("axis3d", jxg_default.createAxis3D);
jxg_default.createMesh3D = function(board, parents, attr) {
  var view = parents[0], point = parents[1], dir1 = parents[2], range1 = parents[3], dir2 = parents[4], range2 = parents[5], el;
  el = view.create("curve", [[], []], attr);
  el.updateDataArray = function() {
    var s1 = range1[0], e1 = range1[1], s2 = range2[0], e2 = range2[1], l1, l2, res, i2, sol, v1 = [0, 0, 0], v2 = [0, 0, 0], step = 1, q = [0, 0, 0];
    this.dataX = [];
    this.dataY = [];
    if (type_default.isFunction(point)) {
      q = point().slice(1);
    } else {
      for (i2 = 0; i2 < 3; i2++) {
        q[i2] = type_default.evaluate(point[i2]);
      }
    }
    for (i2 = 0; i2 < 3; i2++) {
      v1[i2] = type_default.evaluate(dir1[i2]);
      v2[i2] = type_default.evaluate(dir2[i2]);
    }
    l1 = jxg_default.Math.norm(v1, 3);
    l2 = jxg_default.Math.norm(v2, 3);
    for (i2 = 0; i2 < 3; i2++) {
      v1[i2] /= l1;
      v2[i2] /= l2;
    }
    res = view.getMesh(
      [
        function(u, v) {
          return q[0] + u * v1[0] + v * v2[0];
        },
        function(u, v) {
          return q[1] + u * v1[1] + v * v2[1];
        },
        function(u, v) {
          return q[2] + u * v1[2] + v * v2[2];
        }
      ],
      [Math.ceil(s1), Math.floor(e1), (Math.ceil(e1) - Math.floor(s1)) / step],
      [Math.ceil(s2), Math.floor(e2), (Math.ceil(e2) - Math.floor(s2)) / step]
    );
    this.dataX = res[0];
    this.dataY = res[1];
  };
  return el;
};
jxg_default.registerElement("mesh3d", jxg_default.createMesh3D);

// node_modules/jsxgraph/src/3d/point3d.js
jxg_default.Point3D = function(view, F, slide, attributes) {
  this.constructor(view.board, attributes, constants_default.OBJECT_TYPE_POINT3D, constants_default.OBJECT_CLASS_3D);
  this.constructor3D(view, "point3d");
  this.board.finalizeAdding(this);
  this.coords = [0, 0, 0, 0];
  this.F = F;
  this.slide = slide;
  this.X = function() {
    return this.coords[1];
  };
  this.Y = function() {
    return this.coords[2];
  };
  this.Z = function() {
    return this.coords[3];
  };
  this._params = null;
  this._c2d = null;
  this.methodMap = type_default.deepCopy(this.methodMap, {
    // TODO
  });
};
jxg_default.Point3D.prototype = new jxg_default.GeometryElement();
type_default.copyPrototypeMethods(jxg_default.Point3D, jxg_default.GeometryElement3D, "constructor3D");
jxg_default.extend(
  jxg_default.Point3D.prototype,
  /** @lends JXG.Point3D.prototype */
  {
    /**
     * Update the homogeneous coords array.
     *
     * @name updateCoords
     * @memberOf Point3D
     * @function
     * @returns {Object} Reference to the Point3D object
     * @private
     * @example
     *    p.updateCoords();
     */
    updateCoords: function() {
      var i2;
      if (type_default.isFunction(this.F)) {
        this.coords = [1].concat(type_default.evaluate(this.F));
      } else {
        this.coords[0] = 1;
        for (i2 = 0; i2 < 3; i2++) {
          if (type_default.isFunction(this.F[i2])) {
            this.coords[i2 + 1] = type_default.evaluate(this.F[i2]);
          }
        }
      }
      return this;
    },
    /**
     * Initialize the coords array.
     *
     * @private
     * @returns {Object} Reference to the Point3D object
     */
    initCoords: function() {
      var i2;
      if (type_default.isFunction(this.F)) {
        this.coords = [1].concat(type_default.evaluate(this.F));
      } else {
        this.coords[0] = 1;
        for (i2 = 0; i2 < 3; i2++) {
          this.coords[i2 + 1] = type_default.evaluate(this.F[i2]);
        }
      }
      return this;
    },
    /**
     * Normalize homogeneous coordinates such the the first coordinate (the w-coordinate is equal to 1 or 0)-
     *
     * @name normalizeCoords
     * @memberOf Point3D
     * @function
     * @returns {Object} Reference to the Point3D object
     * @private
     * @example
     *    p.normalizeCoords();
     */
    normalizeCoords: function() {
      if (Math.abs(this.coords[0]) > math_default.eps) {
        this.coords[1] /= this.coords[0];
        this.coords[2] /= this.coords[0];
        this.coords[3] /= this.coords[0];
        this.coords[0] = 1;
      }
      return this;
    },
    /**
     * Set the position of a 3D point.
     *
     * @name setPosition
     * @memberOf Point3D
     * @function
     * @param {Array} coords 3D coordinates. Either of the form [x,y,z] (Euclidean) or [w,x,y,z] (homogeneous).
     * @param {Boolean} [noevent] If true, no events are triggered.
     * @returns {Object} Reference to the Point3D object
     *
     * @example
     *    p.setPosition([1, 3, 4]);
     */
    setPosition: function(coords, noevent) {
      var c = this.coords, oc = this.coords.slice();
      if (coords.length === 3) {
        c[0] = 1;
        c[1] = coords[0];
        c[2] = coords[1];
        c[3] = coords[2];
      } else {
        c[0] = coords[0];
        c[1] = coords[1];
        c[2] = coords[2];
        c[3] = coords[2];
        this.normalizeCoords();
      }
      return this;
    },
    update: function(drag) {
      var c3d, foot;
      if (this.element2D.draggable() && geometry_default.distance(this._c2d, this.element2D.coords.usrCoords) !== 0) {
        if (this.slide) {
          this.projectCoords2Surface();
        } else {
          if (this.view.isVerticalDrag()) {
            c3d = this.view.project2DTo3DVertical(this.element2D, this.coords);
          } else {
            foot = [1, 0, 0, this.coords[3]];
            c3d = this.view.project2DTo3DPlane(this.element2D, [1, 0, 0, 1], foot);
          }
          if (c3d[0] !== 0) {
            this.coords = this.view.project3DToCube(c3d);
          }
        }
      } else {
        this.updateCoords();
        this.element2D.coords.setCoordinates(
          constants_default.COORDS_BY_USER,
          this.view.project3DTo2D([1, this.X(), this.Y(), this.Z()])
        );
      }
      this._c2d = this.element2D.coords.usrCoords.slice();
      return this;
    },
    updateRenderer: function() {
      this.needsUpdate = false;
      return this;
    },
    projectCoords2Surface: function() {
      var n = 2, m = 2, x = [0, 0], rhobeg = 5, rhoend = 1e-6, iprint = 0, maxfun = 200, surface = this.slide, that2 = this, r, c3d, c2d, _minFunc;
      if (surface === null) {
        return;
      }
      _minFunc = function(n2, m2, x2, con) {
        var c3d2 = [
          1,
          surface.X(x2[0], x2[1]),
          surface.Y(x2[0], x2[1]),
          surface.Z(x2[0], x2[1])
        ], c2d2 = that2.view.project3DTo2D(c3d2);
        con[0] = that2.element2D.X() - c2d2[1];
        con[1] = that2.element2D.Y() - c2d2[2];
        return con[0] * con[0] + con[1] * con[1];
      };
      if (type_default.exists(this._params)) {
        x = this._params.slice();
      }
      r = math_default.Nlp.FindMinimum(_minFunc, n, m, x, rhobeg, rhoend, iprint, maxfun);
      c3d = [1, surface.X(x[0], x[1]), surface.Y(x[0], x[1]), surface.Z(x[0], x[1])];
      c2d = this.view.project3DTo2D(c3d);
      this._params = x;
      this.coords = c3d;
      this.element2D.coords.setCoordinates(constants_default.COORDS_BY_USER, c2d);
      this._c2d = c2d;
    },
    // Not yet working
    __evt__update3D: function(oc) {
    }
  }
);
jxg_default.createPoint3D = function(board, parents, attributes) {
  var view = parents[0], attr, F, slide, c2d, el;
  if (parents.length > 2 && type_default.exists(parents[parents.length - 1].is3D)) {
    slide = parents.pop();
  } else {
    slide = null;
  }
  if (parents.length === 2) {
    F = parents[1];
  } else if (parents.length === 4) {
    F = parents.slice(1);
  } else {
    throw new Error(
      "JSXGraph: Can't create point3d with parent types '" + typeof parents[0] + "' and '" + typeof parents[1] + "'.\nPossible parent types: [[x,y,z]], [x,y,z]"
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "point3d");
  el = new jxg_default.Point3D(view, F, slide, attr);
  el.initCoords();
  c2d = view.project3DTo2D(el.coords);
  attr = el.setAttr2D(attr);
  el.element2D = view.create("point", c2d, attr);
  el.addChild(el.element2D);
  el.inherits.push(el.element2D);
  el.element2D.setParents(el);
  el._c2d = el.element2D.coords.usrCoords.slice();
  return el;
};
jxg_default.registerElement("point3d", jxg_default.createPoint3D);

// node_modules/jsxgraph/src/3d/curve3d.js
jxg_default.Curve3D = function(view, F, X, Y, Z, range, attributes) {
  this.constructor(view.board, attributes, constants_default.OBJECT_TYPE_CURVE3D, constants_default.OBJECT_CLASS_3D);
  this.constructor3D(view, "curve3d");
  this.board.finalizeAdding(this);
  this.F = F;
  this.X = X;
  this.Y = Y;
  this.Z = Z;
  this.dataX = null;
  this.dataY = null;
  this.dataZ = null;
  if (this.F !== null) {
    this.X = function(u) {
      return this.F(u)[0];
    };
    this.Y = function(u) {
      return this.F(u)[1];
    };
    this.Z = function(u) {
      return this.F(u)[2];
    };
  }
  this.range = range;
  this.methodMap = type_default.deepCopy(this.methodMap, {
    // TODO
  });
};
jxg_default.Curve3D.prototype = new jxg_default.GeometryElement();
type_default.copyPrototypeMethods(jxg_default.Curve3D, jxg_default.GeometryElement3D, "constructor3D");
jxg_default.extend(
  jxg_default.Curve3D.prototype,
  /** @lends JXG.Curve3D.prototype */
  {
    updateDataArray2D: function() {
      var steps = type_default.evaluate(this.visProp.numberpointshigh), r, s, e, delta, c2d, u, dataX, dataY, i2, p = [0, 0, 0];
      dataX = [];
      dataY = [];
      if (type_default.exists(this.dataX)) {
        steps = this.dataX.length;
        for (u = 0; u < steps; u++) {
          p = [this.dataX[u], this.dataY[u], this.dataZ[u]];
          c2d = this.view.project3DTo2D(p);
          dataX.push(c2d[1]);
          dataY.push(c2d[2]);
        }
      } else if (type_default.isArray(this.X)) {
        steps = this.X.length;
        for (u = 0; u < steps; u++) {
          p = [this.X[u], this.Y[u], this.Z[u]];
          c2d = this.view.project3DTo2D(p);
          dataX.push(c2d[1]);
          dataY.push(c2d[2]);
        }
      } else {
        r = type_default.evaluate(this.range);
        s = type_default.evaluate(r[0]);
        e = type_default.evaluate(r[1]);
        delta = (e - s) / (steps - 1);
        for (i2 = 0, u = s; i2 < steps && u <= e; i2++, u += delta) {
          if (this.F !== null) {
            p = this.F(u);
          } else {
            p = [this.X(u), this.Y(u), this.Z(u)];
          }
          c2d = this.view.project3DTo2D(p);
          dataX.push(c2d[1]);
          dataY.push(c2d[2]);
        }
      }
      return { X: dataX, Y: dataY };
    },
    updateDataArray: function() {
    },
    update: function() {
      this.updateDataArray();
      return this;
    },
    updateRenderer: function() {
      this.needsUpdate = false;
      return this;
    }
  }
);
jxg_default.createCurve3D = function(board, parents, attributes) {
  var view = parents[0], F, X, Y, Z, range, attr, el;
  if (parents.length === 3) {
    F = parents[1];
    range = parents[2];
    X = null;
    Y = null;
    Z = null;
  } else {
    X = parents[1];
    Y = parents[2];
    Z = parents[3];
    range = parents[4];
    F = null;
  }
  attr = type_default.copyAttributes(attributes, board.options, "curve3d");
  el = new jxg_default.Curve3D(view, F, X, Y, Z, range, attr);
  attr = el.setAttr2D(attr);
  el.element2D = view.create("curve", [[], []], attr);
  el.element2D.updateDataArray = function() {
    var ret = el.updateDataArray2D();
    this.dataX = ret.X;
    this.dataY = ret.Y;
  };
  el.addChild(el.element2D);
  el.inherits.push(el.element2D);
  el.element2D.setParents(el);
  el.element2D.prepareUpdate().update();
  if (!board.isSuspendedUpdate) {
    el.element2D.updateVisibility().updateRenderer();
  }
  return el;
};
jxg_default.registerElement("curve3d", jxg_default.createCurve3D);
jxg_default.createVectorfield3D = function(board, parents, attributes) {
  var view = parents[0], el, attr;
  if (!(parents.length >= 5 && (type_default.isArray(parents[1]) || type_default.isFunction(parents[0]) || type_default.isString(parents[0])) && (type_default.isArray(parents[2]) && parents[1].length === 3) && (type_default.isArray(parents[3]) && parents[2].length === 3) && (type_default.isArray(parents[4]) && parents[3].length === 3))) {
    throw new Error(
      "JSXGraph: Can't create vector field 3D with parent types '" + typeof parents[0] + "', '" + typeof parents[1] + "', '" + typeof parents[2] + "'.'" + typeof parents[1] + "', "
    );
  }
  attr = type_default.copyAttributes(attributes, board.options, "vectorfield3d");
  el = view.create("curve3d", [[], [], []], attr);
  el.setF = function(func, varnames) {
    var f0, f1, f2;
    if (type_default.isArray(func)) {
      f0 = type_default.createFunction(func[0], this.board, varnames);
      f1 = type_default.createFunction(func[1], this.board, varnames);
      f2 = type_default.createFunction(func[2], this.board, varnames);
      this.F = function(x, y, z) {
        return [f0(x, y, z), f1(x, y, z), f2(x, y, z)];
      };
    } else {
      this.F = type_default.createFunction(func, el.board, varnames);
    }
    return this;
  };
  el.setF(parents[1], "x, y, z");
  el.xData = parents[2];
  el.yData = parents[3];
  el.zData = parents[4];
  el.updateDataArray = function() {
    var k, i2, j, v, nrm, x, y, z, scale = type_default.evaluate(this.visProp.scale), start = [
      type_default.evaluate(this.xData[0]),
      type_default.evaluate(this.yData[0]),
      type_default.evaluate(this.zData[0])
    ], steps = [
      type_default.evaluate(this.xData[1]),
      type_default.evaluate(this.yData[1]),
      type_default.evaluate(this.zData[1])
    ], end = [
      type_default.evaluate(this.xData[2]),
      type_default.evaluate(this.yData[2]),
      type_default.evaluate(this.zData[2])
    ], delta = [
      (end[0] - start[0]) / steps[0],
      (end[1] - start[1]) / steps[1],
      (end[2] - start[2]) / steps[2]
    ], phi, theta1, theta2, theta, showArrow = type_default.evaluate(this.visProp.arrowhead.enabled), leg, leg_x, leg_y, leg_z, alpha;
    if (showArrow) {
      leg = type_default.evaluate(this.visProp.arrowhead.size);
      alpha = type_default.evaluate(this.visProp.arrowhead.angle);
      leg_x = leg / board.unitX;
      leg_y = leg / board.unitY;
      leg_z = leg / Math.sqrt(board.unitX * board.unitY);
    }
    this.dataX = [];
    this.dataY = [];
    this.dataZ = [];
    for (i2 = 0, x = start[0]; i2 <= steps[0]; x += delta[0], i2++) {
      for (j = 0, y = start[1]; j <= steps[1]; y += delta[1], j++) {
        for (k = 0, z = start[2]; k <= steps[2]; z += delta[2], k++) {
          v = this.F(x, y, z);
          nrm = math_default.norm(v);
          if (nrm < Number.EPSILON) {
            continue;
          }
          v[0] *= scale;
          v[1] *= scale;
          v[2] *= scale;
          this.dataX = this.dataX.concat([x, x + v[0], NaN]);
          this.dataY = this.dataY.concat([y, y + v[1], NaN]);
          this.dataZ = this.dataZ.concat([z, z + v[2], NaN]);
          if (showArrow) {
            nrm *= scale;
            phi = Math.atan2(v[1], v[0]);
            theta = Math.asin(v[2] / nrm);
            theta1 = theta - alpha;
            theta2 = theta + alpha;
            this.dataX = this.dataX.concat([
              x + v[0] - leg_x * Math.cos(phi) * Math.cos(theta1),
              x + v[0],
              x + v[0] - leg_x * Math.cos(phi) * Math.cos(theta2),
              NaN
            ]);
            this.dataY = this.dataY.concat([
              y + v[1] - leg_y * Math.sin(phi) * Math.cos(theta1),
              y + v[1],
              y + v[1] - leg_y * Math.sin(phi) * Math.cos(theta2),
              NaN
            ]);
            this.dataZ = this.dataZ.concat([
              z + v[2] - leg_z * Math.sin(theta2),
              z + v[2],
              z + v[2] - leg_z * Math.sin(theta1),
              NaN
            ]);
          }
        }
      }
    }
  };
  el.methodMap = type_default.deepCopy(el.methodMap, {
    setF: "setF"
  });
  return el;
};
jxg_default.registerElement("vectorfield3D", jxg_default.createVectorfield3D);

// node_modules/jsxgraph/src/3d/linspace3d.js
jxg_default.Line3D = function(view, point, direction, range, attributes) {
  this.constructor(view.board, attributes, constants_default.OBJECT_TYPE_LINE3D, constants_default.OBJECT_CLASS_3D);
  this.constructor3D(view, "line3d");
  this.board.finalizeAdding(this);
  this.point = point;
  this.direction = direction;
  this.range = range || [-Infinity, Infinity];
  this.point1 = null;
  this.point2 = null;
  this.methodMap = type_default.deepCopy(this.methodMap, {
    // TODO
  });
};
jxg_default.Line3D.prototype = new jxg_default.GeometryElement();
type_default.copyPrototypeMethods(jxg_default.Line3D, jxg_default.GeometryElement3D, "constructor3D");
jxg_default.extend(
  jxg_default.Line3D.prototype,
  /** @lends JXG.Line3D.prototype */
  {
    /**
     * Determine one end point of a 3D line from point, direction and range.
     *
     * @param {Number|function} r
     * @private
     * @returns Array
     */
    getPointCoords: function(r) {
      var p = [], d = [], i2, r0;
      p = [this.point.X(), this.point.Y(), this.point.Z()];
      if (type_default.isFunction(this.direction)) {
        d = this.direction();
      } else {
        for (i2 = 1; i2 < 4; i2++) {
          d.push(type_default.evaluate(this.direction[i2]));
        }
      }
      r0 = type_default.evaluate(r);
      if (Math.abs(r0) === Infinity) {
        r = this.view.intersectionLineCube(p, d, r0);
      }
      return [p[0] + d[0] * r0, p[1] + d[1] * r0, p[2] + d[2] * r0];
    },
    update: function() {
      return this;
    },
    updateRenderer: function() {
      this.needsUpdate = false;
      return this;
    }
  }
);
jxg_default.createLine3D = function(board, parents, attributes) {
  var view = parents[0], attr, points, point, direction, range, point1, point2, el;
  attr = type_default.copyAttributes(attributes, board.options, "line3d");
  if (type_default.isPoint3D(parents[2]) || parents.length === 3 && (type_default.isArray(parents[2]) || type_default.isFunction(parents[2]))) {
    point1 = type_default.providePoints3D(view, [parents[1]], attributes, "line3d", ["point1"])[0];
    point2 = type_default.providePoints3D(view, [parents[2]], attributes, "line3d", ["point2"])[0];
    direction = function() {
      return [point2.X() - point1.X(), point2.Y() - point1.Y(), point2.Z() - point1.Z()];
    };
    range = [0, 1];
    el = new jxg_default.Line3D(view, point1, direction, range, attr);
  } else {
    point = type_default.providePoints3D(view, [parents[1]], attributes, "line3d", ["point"])[0];
    if (type_default.isFunction(parents[2])) {
      direction = parents[2];
    } else if (parents[2].length === 3) {
      direction = [1].concat(parents[2]);
    } else if (parents[2].length === 4) {
      direction = parents[2];
    } else {
    }
    range = parents[3];
    points = type_default.providePoints3D(
      view,
      [
        [0, 0, 0],
        [0, 0, 0]
      ],
      attributes,
      "line3d",
      ["point1", "point2"]
    );
    el = new jxg_default.Line3D(view, point, direction, range, attr);
    points[0].F = function() {
      return el.getPointCoords(type_default.evaluate(el.range[0]));
    };
    points[0].prepareUpdate().update();
    point1 = points[0];
    points[1].F = function() {
      return el.getPointCoords(type_default.evaluate(el.range[1]));
    };
    points[1].prepareUpdate().update();
    point2 = points[1];
  }
  attr = el.setAttr2D(attr);
  el.element2D = view.create("segment", [point1.element2D, point2.element2D], attr);
  el.addChild(el.element2D);
  el.inherits.push(el.element2D);
  el.element2D.setParents(el);
  el.point1 = point1;
  el.point2 = point2;
  if (el.point1._is_new) {
    el.addChild(el.point1);
    delete el.point1._is_new;
  } else {
    el.point1.addChild(el);
  }
  if (el.point2._is_new) {
    el.addChild(el.point2);
    delete el.point2._is_new;
  } else {
    el.point2.addChild(el);
  }
  if (type_default.exists(point)) {
    if (point._is_new) {
      el.addChild(point);
      delete point._is_new;
    } else {
      point.addChild(el);
    }
  }
  el.update();
  el.element2D.prepareUpdate().update().updateRenderer();
  return el;
};
jxg_default.registerElement("line3d", jxg_default.createLine3D);
jxg_default.Plane3D = function(view, point, dir1, range1, dir2, range2, attributes) {
  this.constructor(view.board, attributes, constants_default.OBJECT_TYPE_PLANE3D, constants_default.OBJECT_CLASS_3D);
  this.constructor3D(view, "plane3d");
  this.board.finalizeAdding(this);
  this.point = point;
  this.direction1 = dir1;
  this.direction2 = dir2;
  this.range1 = range1 || [-Infinity, Infinity];
  this.range2 = range2 || [-Infinity, Infinity];
  this.vec1 = [0, 0, 0];
  this.vec2 = [0, 0, 0];
  this.grid = null;
  this.normal = [0, 0, 0];
  this.d = 0;
  this.updateNormal();
  this.methodMap = type_default.deepCopy(this.methodMap, {
    // TODO
  });
};
jxg_default.Plane3D.prototype = new jxg_default.GeometryElement();
type_default.copyPrototypeMethods(jxg_default.Plane3D, jxg_default.GeometryElement3D, "constructor3D");
jxg_default.extend(
  jxg_default.Plane3D.prototype,
  /** @lends JXG.Plane3D.prototype */
  {
    /**
     * Update the Hesse normal form of the plane, i.e. update normal vector and right hand side.
     * Updates also {@link vec1} and {@link vec2}.
     *
     * @name JXG.Plane3D#updateNormal
     * @function
     * @returns {Object} Reference to the Plane3D object
     * @private
     * @example
     *    plane.updateNormal();
     *
     */
    updateNormal: function() {
      var i2, len;
      for (i2 = 0; i2 < 3; i2++) {
        this.vec1[i2] = type_default.evaluate(this.direction1[i2]);
        this.vec2[i2] = type_default.evaluate(this.direction2[i2]);
      }
      this.normal = math_default.crossProduct(this.vec1, this.vec2);
      len = math_default.norm(this.normal);
      if (Math.abs(len) > math_default.eps) {
        for (i2 = 0; i2 < 3; i2++) {
          this.normal[i2] /= len;
        }
      }
      this.d = math_default.innerProduct(this.point.coords.slice(1), this.normal, 3);
      return this;
    },
    updateDataArray: function() {
      var s1, e1, s2, e2, c2d, l1, l2, planes = ["xPlaneRear", "yPlaneRear", "zPlaneRear"], points = [], v1 = [0, 0, 0], v2 = [0, 0, 0], q = [0, 0, 0], p = [0, 0, 0], d, i2, j, a, b, first, pos, pos_akt, view = this.view;
      this.dataX = [];
      this.dataY = [];
      this.updateNormal();
      if (this.elType !== "axisplane3d" && view.defaultAxes && type_default.evaluate(this.range1[0]) === -Infinity && type_default.evaluate(this.range1[1]) === Infinity && type_default.evaluate(this.range2[0]) === -Infinity && type_default.evaluate(this.range2[1]) === Infinity) {
        for (j = 0; j < planes.length; j++) {
          p = view.intersectionPlanePlane(this, view.defaultAxes[planes[j]]);
          if (p[0].length === 3 && p[1].length === 3) {
            for (i2 = 0; i2 < points.length; i2++) {
              if (geometry_default.distance(p[0], points[i2][0], 3) < math_default.eps && geometry_default.distance(p[1], points[i2][1], 3) < math_default.eps || geometry_default.distance(p[0], points[i2][1], 3) < math_default.eps && geometry_default.distance(p[1], points[i2][0], 3) < math_default.eps) {
                break;
              }
            }
            if (i2 === points.length) {
              points.push(p.slice());
            }
          }
          p = [0, 0, 0];
          p[j] = view.bbox3D[j][1];
          d = math_default.innerProduct(p, view.defaultAxes[planes[j]].normal, 3);
          p = view.intersectionPlanePlane(this, view.defaultAxes[planes[j]], d);
          if (p[0].length === 3 && p[1].length === 3) {
            for (i2 = 0; i2 < points.length; i2++) {
              if (geometry_default.distance(p[0], points[i2][0], 3) < math_default.eps && geometry_default.distance(p[1], points[i2][1], 3) < math_default.eps || geometry_default.distance(p[0], points[i2][1], 3) < math_default.eps && geometry_default.distance(p[1], points[i2][0], 3) < math_default.eps) {
                break;
              }
            }
            if (i2 === points.length) {
              points.push(p.slice());
            }
          }
        }
        first = 0;
        pos = first;
        i2 = 0;
        do {
          p = points[pos][i2];
          if (p.length === 3) {
            c2d = view.project3DTo2D(p);
            this.dataX.push(c2d[1]);
            this.dataY.push(c2d[2]);
          }
          i2 = (i2 + 1) % 2;
          p = points[pos][i2];
          pos_akt = pos;
          for (j = 0; j < points.length; j++) {
            if (j !== pos && geometry_default.distance(p, points[j][0]) < math_default.eps) {
              pos = j;
              i2 = 0;
              break;
            }
            if (j !== pos && geometry_default.distance(p, points[j][1]) < math_default.eps) {
              pos = j;
              i2 = 1;
              break;
            }
          }
          if (pos === pos_akt) {
            console.log("Error: update plane3d: did not find next", pos);
            break;
          }
        } while (pos !== first);
        c2d = view.project3DTo2D(points[first][0]);
        this.dataX.push(c2d[1]);
        this.dataY.push(c2d[2]);
      } else {
        s1 = type_default.evaluate(this.range1[0]);
        e1 = type_default.evaluate(this.range1[1]);
        s2 = type_default.evaluate(this.range2[0]);
        e2 = type_default.evaluate(this.range2[1]);
        q = this.point.coords.slice(1);
        v1 = this.vec1.slice();
        v2 = this.vec2.slice();
        l1 = math_default.norm(v1, 3);
        l2 = math_default.norm(v2, 3);
        for (i2 = 0; i2 < 3; i2++) {
          v1[i2] /= l1;
          v2[i2] /= l2;
        }
        for (j = 0; j < 4; j++) {
          switch (j) {
            case 0:
              a = s1;
              b = s2;
              break;
            case 1:
              a = e1;
              b = s2;
              break;
            case 2:
              a = e1;
              b = e2;
              break;
            case 3:
              a = s1;
              b = e2;
          }
          for (i2 = 0; i2 < 3; i2++) {
            p[i2] = q[i2] + a * v1[i2] + b * v2[i2];
          }
          c2d = view.project3DTo2D(p);
          this.dataX.push(c2d[1]);
          this.dataY.push(c2d[2]);
        }
        this.dataX.push(this.dataX[0]);
        this.dataY.push(this.dataY[0]);
      }
      return { X: this.dataX, Y: this.dataY };
    },
    update: function() {
      return this;
    },
    updateRenderer: function() {
      this.needsUpdate = false;
      return this;
    }
  }
);
jxg_default.createPlane3D = function(board, parents, attributes) {
  var view = parents[0], attr, point, dir1 = parents[2], dir2 = parents[3], range1 = parents[4] || [-Infinity, Infinity], range2 = parents[5] || [-Infinity, Infinity], el, grid;
  point = type_default.providePoints3D(view, [parents[1]], attributes, "plane3d", ["point"])[0];
  if (point === false) {
  }
  attr = type_default.copyAttributes(attributes, board.options, "plane3d");
  el = new jxg_default.Plane3D(view, point, dir1, range1, dir2, range2, attr);
  point.addChild(el);
  attr = el.setAttr2D(attr);
  el.element2D = view.create("curve", [[], []], attr);
  el.element2D.updateDataArray = function() {
    var ret = el.updateDataArray();
    this.dataX = ret.X;
    this.dataY = ret.Y;
  };
  el.addChild(el.element2D);
  el.inherits.push(el.element2D);
  el.element2D.setParents(el);
  attr = type_default.copyAttributes(attributes.mesh3d, board.options, "mesh3d");
  if (Math.abs(el.range1[0]) !== Infinity && Math.abs(el.range1[1]) !== Infinity && Math.abs(el.range2[0]) !== Infinity && Math.abs(el.range2[1]) !== Infinity) {
    grid = view.create(
      "mesh3d",
      [
        function() {
          return point.coords;
        },
        dir1,
        range1,
        dir2,
        range2
      ],
      attr
    );
    el.grid = grid;
    el.addChild(grid);
    el.inherits.push(grid);
    grid.setParents(el);
  }
  el.element2D.prepareUpdate().update();
  if (!board.isSuspendedUpdate) {
    el.element2D.updateVisibility().updateRenderer();
  }
  return el;
};
jxg_default.registerElement("plane3d", jxg_default.createPlane3D);

// node_modules/jsxgraph/src/3d/surface3d.js
jxg_default.Surface3D = function(view, F, X, Y, Z, range_u, range_v, attributes) {
  this.constructor(
    view.board,
    attributes,
    constants_default.OBJECT_TYPE_SURFACE3D,
    constants_default.OBJECT_CLASS_3D
  );
  this.constructor3D(view, "surface3d");
  this.board.finalizeAdding(this);
  this.F = F;
  this.X = X;
  this.Y = Y;
  this.Z = Z;
  if (this.F !== null) {
    this.X = function(u, v) {
      return this.F(u, v)[0];
    };
    this.Y = function(u, v) {
      return this.F(u, v)[1];
    };
    this.Z = function(u, v) {
      return this.F(u, v)[2];
    };
  }
  this.range_u = range_u;
  this.range_v = range_v;
  this.methodMap = type_default.deepCopy(this.methodMap, {
    // TODO
  });
};
jxg_default.Surface3D.prototype = new jxg_default.GeometryElement();
type_default.copyPrototypeMethods(jxg_default.Surface3D, jxg_default.GeometryElement3D, "constructor3D");
jxg_default.extend(
  jxg_default.Surface3D.prototype,
  /** @lends JXG.Surface3D.prototype */
  {
    /**
     * @class
     * @ignore
     */
    updateDataArray: function() {
      var steps_u = type_default.evaluate(this.visProp.stepsu), steps_v = type_default.evaluate(this.visProp.stepsv), r_u = type_default.evaluate(this.range_u), r_v = type_default.evaluate(this.range_v), func, res;
      if (this.F !== null) {
        func = this.F;
      } else {
        func = [this.X, this.Y, this.Z];
      }
      res = this.view.getMesh(func, r_u.concat([steps_u]), r_v.concat([steps_v]));
      return { X: res[0], Y: res[1] };
    },
    update: function() {
      return this;
    },
    updateRenderer: function() {
      this.needsUpdate = false;
      return this;
    }
  }
);
jxg_default.createParametricSurface3D = function(board, parents, attributes) {
  var view = parents[0], F, X, Y, Z, range_u, range_v, attr, el;
  if (parents.length === 4) {
    F = parents[1];
    range_u = parents[2];
    range_v = parents[3];
    X = null;
    Y = null;
    Z = null;
  } else {
    X = parents[1];
    Y = parents[2];
    Z = parents[3];
    range_u = parents[4];
    range_v = parents[5];
    F = null;
  }
  attr = type_default.copyAttributes(attributes, board.options, "surface3d");
  el = new jxg_default.Surface3D(view, F, X, Y, Z, range_u, range_v, attr);
  attr = el.setAttr2D(attr);
  el.element2D = view.create("curve", [[], []], attr);
  el.element2D.updateDataArray = function() {
    var ret = el.updateDataArray();
    this.dataX = ret.X;
    this.dataY = ret.Y;
  };
  el.addChild(el.element2D);
  el.inherits.push(el.element2D);
  el.element2D.setParents(el);
  el.element2D.prepareUpdate().update();
  if (!board.isSuspendedUpdate) {
    el.element2D.updateVisibility().updateRenderer();
  }
  return el;
};
jxg_default.registerElement("parametricsurface3d", jxg_default.createParametricSurface3D);
jxg_default.createFunctiongraph3D = function(board, parents, attributes) {
  var view = parents[0], X = function(u, v) {
    return u;
  }, Y = function(u, v) {
    return v;
  }, Z = parents[1], range_u = parents[2], range_v = parents[3];
  return view.create("parametricsurface3d", [X, Y, Z, range_u, range_v], attributes);
};
jxg_default.registerElement("functiongraph3d", jxg_default.createFunctiongraph3D);

// node_modules/jsxgraph/src/themes/mono_thin.js
var size = 0.75;
var color = "#000";
jxg_default.themes["mono_thin"] = {
  board: {
    showInfobox: false,
    showCopyright: true,
    defaultAxes: {
      x: {
        ticks: {
          minorTicks: 0,
          majorHeight: 10,
          majorTickEndings: [1, 0]
        }
      },
      y: {
        ticks: {
          minorTicks: 0,
          majorHeight: 10,
          majorTickEndings: [0, 1]
        }
      }
    }
  },
  navbar: {
    strokeColor: "#bbb",
    fillColor: "none"
  },
  elements: {
    strokeColor: color,
    highlightStrokeColor: color,
    fillColor: "none",
    highlightFillColor: "none",
    strokeOpacity: 0.6,
    highlightStrokeOpacity: 1
  },
  angle: {
    strokeColor: color,
    fillColor: "#aaaaaa55",
    fillOpacity: 0.3,
    highlightFillColor: "#aaaaaa33",
    highlightFillOpacity: 0.3,
    label: {
      strokeColor: color
    }
  },
  arc: {
    strokeColor: color,
    strokeWidth: size,
    highlightStrokeColor: color,
    highlightStrokeWidth: size
  },
  axis: {
    // ticks: {
    //     strokeColor: '#bbb'
    // }
  },
  boxplot: {
    strokeWidth: size,
    strokeColor: color,
    fillColor: color,
    fillOpacity: 0.2,
    highlightStrokeWidth: size,
    highlightStrokeColor: color,
    highlightFillColor: color,
    highlightFillOpacity: 0.1
  },
  circle: {
    strokeWidth: size,
    highlightStrokeWidth: 1.5 * size,
    strokeColor: color,
    highlightFillColor: "none",
    highlightStrokeColor: color,
    center: {
      size,
      fillColor: color,
      strokeColor: color,
      highlightStrokeWidth: 4 * size,
      highlightFillColor: color,
      highlightStrokeColor: color
    },
    point2: {
      size,
      fillColor: color,
      strokeColor: color,
      highlightStrokeWidth: 4 * size,
      highlightFillColor: color,
      highlightStrokeColor: color
    }
  },
  circumcircle: {
    strokeWidth: size,
    highlightStrokeWidth: 1.5 * size,
    strokeColor: color,
    highlightFillColor: "none",
    highlightStrokeColor: color,
    center: {
      size,
      fillColor: color,
      strokeColor: color,
      highlightStrokeWidth: 4 * size,
      highlightFillColor: color,
      highlightStrokeColor: color
    }
  },
  circumcirclearc: {
    strokeColor: color,
    strokeWidth: size,
    highlightStrokeColor: color,
    highlightStrokeWidth: size
  },
  circumcirclesector: {
    strokeColor: color,
    fillColor: "#aaaaaa55",
    fillOpacity: 0.3,
    highlightFillColor: "#aaaaaa33",
    highlightFillOpacity: 0.3
  },
  comb: {
    strokeColor: color,
    strokeWidth: size
  },
  conic: {
    strokeWidth: size,
    highlightStrokeWidth: 1.5 * size,
    strokeColor: color,
    highlightStrokeColor: color,
    fillColor: "none",
    highlightFillColor: "none"
  },
  curve: {
    strokeColor: color,
    strokeWidth: size,
    highlightStrokeColor: color,
    highlightStrokeWidth: size
  },
  grid: {
    strokeWidth: size
  },
  hatch: {
    strokeColor: color,
    strokeWidth: size
  },
  incircle: {
    strokeWidth: size,
    highlightStrokeWidth: 1.5 * size,
    strokeColor: color,
    highlightFillColor: "none",
    highlightStrokeColor: color,
    center: {
      size,
      fillColor: color,
      strokeColor: color,
      highlightStrokeWidth: 4 * size,
      highlightFillColor: color,
      highlightStrokeColor: color
    }
  },
  inequality: {
    fillColor: "#aaaaaa55",
    fillOpacity: 0.2
  },
  label: {
    strokeColor: color
  },
  line: {
    strokeColor: color,
    strokeWidth: size,
    highlightStrokeColor: color,
    highlightStrokeWidth: size,
    point1: {
      size,
      fillColor: color,
      strokeColor: color,
      highlightStrokeWidth: 4 * size,
      highlightFillColor: color,
      highlightStrokeColor: color
    },
    point2: {
      size,
      fillColor: color,
      strokeColor: color,
      highlightStrokeWidth: 4 * size,
      highlightFillColor: color,
      highlightStrokeColor: color
    }
  },
  normal: {
    strokeColor: color
  },
  parallel: {
    strokeColor: color
  },
  perpendicular: {
    strokeColor: color
  },
  perpendicularsegment: {
    strokeColor: color
  },
  point: {
    size,
    fillColor: color,
    strokeColor: color,
    highlightStrokeWidth: 4 * size,
    highlightFillColor: color,
    highlightStrokeColor: color
  },
  polygon: {
    fillColor: "#aaaaaa55",
    highlightFillColor: "#aaaaaa33",
    fillOpacity: 0.3,
    highlightFillOpacity: 0.3,
    vertices: {
      size,
      fillColor: color,
      strokeColor: color,
      highlightStrokeWidth: 4 * size,
      highlightFillColor: color,
      highlightStrokeColor: color
    },
    borders: {
      strokeColor: color,
      strokeWidth: size,
      highlightStrokeColor: color,
      highlightStrokeWidth: size
    }
  },
  sector: {
    strokeColor: color,
    fillColor: "#aaaaaa55",
    fillOpacity: 0.3,
    highlightFillColor: "#aaaaaa33",
    highlightFillOpacity: 0.3
  },
  semicircle: {
    center: {
      size,
      fillColor: color,
      strokeColor: color,
      highlightStrokeWidth: 4 * size,
      highlightFillColor: color,
      highlightStrokeColor: color
    }
  },
  slider: {
    size,
    fillColor: color,
    strokeColor: color,
    highlightStrokeWidth: 4 * size,
    highlightFillColor: color,
    highlightStrokeColor: color,
    baseline: {
      strokeWidth: size,
      strokeColor: color,
      highlightStrokeColor: color
    },
    label: {
      strokeColor: color
    },
    highline: {
      strokeWidth: 3 * size,
      name: "",
      strokeColor: color,
      highlightStrokeColor: color
    },
    ticks: {
      strokeColor: color
    }
  },
  slopefield: {
    strokeWidth: 0.75 * size,
    highlightStrokeWidth: size,
    highlightStrokeColor: color,
    highlightStrokeOpacity: 0.8
  },
  tapemeasure: {
    strokeColor: color,
    strokeWidth: size,
    highlightStrokeColor: color,
    highlightStrokeWidth: size,
    point1: {
      size,
      fillColor: color,
      strokeColor: color,
      highlightStrokeWidth: 4 * size,
      highlightFillColor: color,
      highlightStrokeColor: color
    },
    point2: {
      size,
      fillColor: color,
      strokeColor: color,
      highlightStrokeWidth: 4 * size,
      highlightFillColor: color,
      highlightStrokeColor: color
    },
    ticks: {
      strokeWidth: size
    }
  },
  text: {
    strokeColor: color
  },
  tracecurve: {
    strokeColor: color
  },
  turtle: {
    strokeWidth: size,
    strokeColor: color,
    arrow: {
      strokeWidth: 2 * size,
      strokeColor: "#aaaaaa55"
    }
  },
  vectorfield: {
    strokeWidth: 0.75 * size,
    highlightStrokeWidth: size,
    highlightStrokeColor: color,
    highlightStrokeOpacity: 0.8
  }
  // });
};

// node_modules/jsxgraph/src/index.js
var COORDS_BY_SCREEN = jxg_default.COORDS_BY_SCREEN;
var COORDS_BY_USER = jxg_default.COORDS_BY_USER;
var Dump = jxg_default.Dump;
var Expect = jxg_default.Expect;
var JSXGraph = jxg_default.JSXGraph;
var Mat = jxg_default.Math;
var Options = jxg_default.Options;
var boards = jxg_default.boards;
var elements = jxg_default.elements;
var palette = jxg_default.palette;
var paletteWong = jxg_default.paletteWong;
var Board = jxg_default.Board;
var Chart = jxg_default.Chart;
var Circle = jxg_default.Circle;
var Complex = jxg_default.Complex;
var Composition = jxg_default.Composition;
var Coords = jxg_default.Coords;
var CoordsElement = jxg_default.CoordsElement;
var Curve = jxg_default.Curve;
var GeometryElement = jxg_default.GeometryElement;
var Group = jxg_default.Group;
var Image2 = jxg_default.Image;
var JessieCode = jxg_default.JessieCode;
var Prefix = jxg_default.PrefixParser;
var Line = jxg_default.Line;
var Point = jxg_default.Point;
var Polygon = jxg_default.Polygon;
var Text = jxg_default.Text;
var Ticks = jxg_default.Ticks;
var Transformation = jxg_default.Transformation;
var Turtle = jxg_default.Turtle;
var View3D = jxg_default.View3D;
var LMS2rgb = jxg_default.LMS2rgb;
var addEvent = jxg_default.addEvent;
var autoDigits = jxg_default.autoDigits;
var autoHighlight = jxg_default.autoHighlight;
var bind = jxg_default.bind;
var capitalize = jxg_default.capitalize;
var clearVisPropOld = jxg_default.clearVisPropOld;
var clone = jxg_default.clone;
var cloneAndCopy = jxg_default.cloneAndCopy;
var cmpArrays = jxg_default.cmpArrays;
var coordsArrayToMatrix = jxg_default.coordsArrayToMatrix;
var copyAttributes = jxg_default.copyAttributes;
var createEvalFunction = jxg_default.createEvalFunction;
var createFunction = jxg_default.createFunction;
var createHTMLSlider = jxg_default.createHTMLSlider;
var darkenColor = jxg_default.darkenColor;
var debug = jxg_default.debug;
var debugInt = jxg_default.debugInt;
var debugLine = jxg_default.debugLine;
var debugWST = jxg_default.debugWST;
var deepCopy = jxg_default.deepCopy;
var def = jxg_default.def;
var deprecated = jxg_default.deprecated;
var eliminateDuplicates = jxg_default.eliminateDuplicates;
var escapeHTML = jxg_default.escapeHTML;
var evalSlider = jxg_default.evalSlider;
var evaluate = jxg_default.evaluate;
var filterElements = jxg_default.filterElements;
var getBoardByContainerId = jxg_default.getBoardByContainerId;
var getCSSTransformMatrix = jxg_default.getCSSTransformMatrix;
var getCSSTransform = jxg_default.getCSSTransform;
var getDimensions = jxg_default.getDimensions;
var getOffset = jxg_default.getOffset;
var getPosition = jxg_default.getPosition;
var getProp = jxg_default.getProp;
var hex2rgb = jxg_default.hex2rgb;
var hsv2rgb = jxg_default.hsv2rgb;
var isAndroid = jxg_default.isAndroid;
var isApple = jxg_default.isApple;
var isArray = jxg_default.isArray;
var isDesktop = jxg_default.isDesktop;
var isInArray = jxg_default.isInArray;
var isInObject = jxg_default.isInObject;
var isMetroApp = jxg_default.isMetroApp;
var isMobile = jxg_default.isMobile;
var isMozilla = jxg_default.isMozilla;
var isBoard = jxg_default.isBoard;
var isName = jxg_default.isName;
var isNode = jxg_default.isNode;
var isNumber = jxg_default.isNumber;
var isObject = jxg_default.isObject;
var isPointType = jxg_default.isPointType;
var isString = jxg_default.isString;
var isTouchDevice = jxg_default.isTouchDevice;
var isTransformationOrArray = jxg_default.isTransformationOrArray;
var isWebWorker = jxg_default.isWebWorker;
var isWebkitAndroid = jxg_default.isWebkitAndroid;
var isWebkitApple = jxg_default.isWebkitApple;
var keys = jxg_default.keys;
var lightenColor = jxg_default.lightenColor;
var merge = jxg_default.merge;
var normalizePointFace = jxg_default.normalizePointFace;
var providePoints = jxg_default.providePoints;
var registerElement = jxg_default.registerElement;
var registerReader = jxg_default.registerReader;
var removeAllEvents = jxg_default.removeAllEvents;
var removeElementFromArray = jxg_default.removeElementFromArray;
var removeEvent = jxg_default.removeEvent;
var rgb2LMS = jxg_default.rgb2LMS;
var rgb2bw = jxg_default.rgb2bw;
var rgb2cb = jxg_default.rgb2cb;
var rgb2css = jxg_default.rgb2css;
var rgb2hex = jxg_default.rgb2hex;
var rgb2hsv = jxg_default.rgb2hsv;
var rgbParser = jxg_default.rgbParser;
var rgb2rgbo = jxg_default.rgba2rgbo;
var rgb2rgba = jxg_default.rgbo2rgba;
var sanitizeHTML = jxg_default.sanitizeHTML;
var shortcut = jxg_default.shortcut;
var strBool = jxg_default.str2Bool;
var supportsCanvas = jxg_default.supportsCanvas;
var supportsPointerEvents = jxg_default.supportsPointerEvents;
var supportsSVG = jxg_default.supportsSVG;
var supportsVML = jxg_default.supportsVML;
var swap = jxg_default.swap;
var timeChunk = jxg_default.timedChunk;
var toFixed = jxg_default.toFixed;
var toFullscreen = jxg_default.toFullscreen;
var toJSON = jxg_default.toJSON;
var trim = jxg_default.trim;
var trimNumber = jxg_default.trimNumber;
var truncate = jxg_default.truncate;
var unescapeHTML = jxg_default.unescapeHTML;
var uniqueArray = jxg_default.uniqueArray;
var useBlackWhiteOptions = jxg_default.useBlackWhiteOptions;
var useStandardOptions = jxg_default.useStandardOptions;
var warn = jxg_default.warn;
if (env_default.isBrowser) {
  window.JXG = jxg_default;
} else if (env_default.isWebWorker()) {
  self.JXG = jxg_default;
}

// src/error.ts
function renderError(error, element) {
  const div = element.createEl("div");
  const span = div.createEl("span");
  span.innerText = error;
}

// src/utils.ts
var import_obsidian = require("obsidian");
var args = {};
var argsArray = Object.getOwnPropertyNames(Math);
var mathFunctions = [];
function setMathFunctions() {
  for (const name of Object.getOwnPropertyNames(Math)) {
    mathFunctions.push(Math[name]);
  }
}
function parseCodeBlock(source) {
  let graph = {
    bounds: [0, 0, 0, 0],
    maxBoundingBox: JXG.Options.board.maxBoundingBox,
    keepAspectRatio: false,
    drag: true,
    showNavigation: true,
    axis: true,
    defaultAxes: JXG.Options.board.defaultAxes,
    elements: []
  };
  if (source == null || source == "") {
    return graph;
  }
  try {
    graph = (0, import_obsidian.parseYaml)(source);
    if (graph.maxBoundingBox == void 0) {
      graph.maxBoundingBox = JXG.Options.board.maxBoundingBox;
    }
    if (graph.showNavigation == void 0) {
      graph.showNavigation = true;
    }
    if (graph.axis == void 0) {
      graph.axis = true;
    }
    if (graph.defaultAxes == void 0) {
      graph.defaultAxes = JXG.Options.board.defaultAxes;
    }
    if (graph.drag == void 0) {
      graph.drag = true;
    }
    return graph;
  } catch (e) {
    throw new SyntaxError(e);
  }
}
function createBoard(graphDiv, graphInfo) {
  if (graphInfo.bounds == void 0 && graphInfo.elements == void 0 && graphInfo.keepAspectRatio == void 0) {
    throw new SyntaxError("No info is defined");
  }
  validateBounds(graphInfo.bounds);
  const graph = JSXGraph.initBoard(graphDiv, {
    boundingBox: graphInfo.bounds,
    maxBoundingBox: graphInfo.maxBoundingBox,
    drag: { enabled: graphInfo.drag },
    axis: graphInfo.axis,
    showNavigation: graphInfo.showNavigation,
    defaultAxes: graphInfo.defaultAxes,
    //@ts-ignore
    theme: "obsidian",
    keepAspectRatio: graphInfo.keepAspectRatio
  });
  return graph;
}
function validateBounds(bounds) {
  const xmin = bounds[0];
  const xmax = bounds[2];
  const ymin = bounds[3];
  const ymax = bounds[1];
  if (bounds.length != 4) {
    throw new SyntaxError("The amount of bounds given is incorrect");
  }
  if (xmin >= xmax) {
    throw new SyntaxError("Bounds Xmin is greater than or equal to Xmax");
  }
  if (ymin >= ymax) {
    throw new SyntaxError("Bounds Ymin is greater than or equal to Ymax");
  }
}
function addElement(board, element, createdElements) {
  validateElement(element, createdElements);
  if (element.att == void 0) {
    const createdElement = board.create(element.type, element.def);
    createdElements.push({ name: element.type, element: createdElement });
  } else {
    const createdElement = board.create(element.type, element.def, element.att);
    createdElements.push({ name: element.type, element: createdElement });
  }
}
function validateElement(element, createdElements) {
  if (element.type == void 0 && element.def == void 0) {
    throw new SyntaxError("Element " + createdElements.length + " type and def is not defined");
  }
  if (element.type == void 0) {
    throw new SyntaxError("Element " + createdElements.length + " type is not defined");
  }
  if (element.def == void 0) {
    throw new SyntaxError("Element " + createdElements.length + " def is not defined");
  }
  validateDef(element, createdElements);
  validateAtt(element, createdElements);
}
function validateDef(element, createdElements) {
  for (let i2 = 0; i2 < element.def.length; i2++) {
    element.def[i2] = checkComposedElements(element.def[i2], createdElements);
    element.def[i2] = checkFunction(element.def[i2], createdElements);
  }
}
function checkComposedElements(item, createdElements) {
  const re = new RegExp("^e[0-9]+$");
  if (typeof item === "string" && re.test(item)) {
    const index = Number.parseInt(item.substring(1, item.length));
    if (index >= createdElements.length) {
      throw new SyntaxError("Element has invalid composed elements in def.");
    }
    return createdElements[index].element;
  } else if (Array.isArray(item)) {
    for (let i2 = 0; i2 < item.length; i2++) {
      item[i2] = checkComposedElements(item[i2], createdElements);
    }
  }
  return item;
}
function validateAtt(element, createdElements) {
  const re = new RegExp("^e[0-9]+$");
  if (element.att != void 0) {
    if (typeof element.att.anchor === "string" && re.test(element.att.anchor)) {
      const index = Number.parseInt(element.att.anchor.substring(1, element.att.anchor.length));
      if (index >= createdElements.length) {
        throw new SyntaxError("Element " + element.type + " has invalid composed elements in att.");
      } else {
        element.att.anchor = createdElements[index].element;
      }
    }
    if (typeof element.att.fillColor === "string") {
      element.att.fillColor = changeColorValue(element.att.fillColor);
    }
    if (typeof element.att.strokeColor === "string") {
      element.att.strokeColor = changeColorValue(element.att.strokeColor);
    }
    if (typeof element.att.highlightFillColor === "string") {
      element.att.highlightFillColor = changeColorValue(element.att.highlightFillColor);
    }
    if (typeof element.att.highlightStrokeColor === "string") {
      element.att.highlightStrokeColor = changeColorValue(element.att.highlightStrokeColor);
    }
  }
}
function changeColorValue(value) {
  switch (value) {
    case "red":
      return "var(--color-red)";
    case "orange":
      return "var(--color-orange)";
    case "yellow":
      return "var(--color-yellow)";
    case "green":
      return "var(--color-green)";
    case "cyan":
      return "var(--color-cyan)";
    case "blue":
      return "var(--color-blue)";
    case "purple":
      return "var(--color-purple)";
    case "pink":
      return "var(--color-pink)";
    default:
      return value;
  }
}
function checkFunction(item, createdElements) {
  const f = RegExp("f:");
  if (typeof item === "string" && f.test(item)) {
    const re = RegExp(/e[0-9]+/);
    item = item.replace("f:", "");
    if (typeof item === "string" && re.test(item)) {
      let composed = re.exec(item);
      while (composed != null) {
        const index = Number.parseInt(composed[0].replace("e", ""));
        if (index < 0 || index >= createdElements.length) {
          throw new SyntaxError("Element has invalid composed elements in function.");
        }
        if (createdElements[index].name == "slider" /* Slider */ || createdElements[index].name == "riemannsum" /* Riemannsum */ || createdElements[index].name == "integral" /* Integral */) {
          item = item.replace(re, "createdElements[" + index + "].element.Value()");
        } else {
          item = item.replace(re, "createdElements[" + index + "].element");
        }
        composed = re.exec(item);
      }
    }
    const equation = item;
    return new Function(...argsArray, "createdElements", "x", "y", "return " + equation + ";").bind(args, ...mathFunctions, createdElements);
  } else if (Array.isArray(item)) {
    for (let i2 = 0; i2 < item.length; i2++) {
      item[i2] = checkFunction(item[i2], createdElements);
    }
  }
  return item;
}

// src/theme/obsidian.ts
var interactiveAccent = "var(--interactive-accent)";
var interactiveAccentHover = "var(--interactive-accent-hover)";
var textNormal = "var(--text-normal)";
var textMuted = "var(--text-muted)";
JXG.themes["obsidian"] = {
  board: {
    showInfobox: true,
    showCopyright: false,
    browserPan: true,
    pan: { needTwoFingers: true }
  },
  navbar: {
    strokeColor: textMuted
  },
  elements: {
    strokeColor: interactiveAccent,
    highlightStrokeColor: interactiveAccentHover
  },
  ellipse: {
    strokeColor: interactiveAccent,
    fillColor: interactiveAccent
  },
  angle: {
    strokeColor: interactiveAccent,
    fillColor: interactiveAccent,
    highlightFillColor: interactiveAccentHover,
    label: {
      strokeColor: textNormal
    }
  },
  arc: {
    strokeColor: interactiveAccent,
    highlightStrokeColor: interactiveAccentHover
  },
  axis: {
    strokeColor: textNormal,
    highlightStrokeColor: textMuted,
    ticks: {
      strokeColor: textNormal,
      highlightStrokeColor: textMuted,
      label: {
        useMathJax: false
      }
    },
    label: {
      strokeColor: textNormal,
      highlightStrokeColor: textMuted
    }
  },
  boxplot: {
    strokeColor: interactiveAccent,
    fillColor: interactiveAccent,
    highlightStrokeColor: interactiveAccentHover,
    highlightFillColor: interactiveAccentHover
  },
  circle: {
    strokeColor: interactiveAccent,
    highlightFillColor: "none",
    highlightStrokeColor: interactiveAccentHover,
    center: {
      fillColor: interactiveAccent,
      strokeColor: interactiveAccent,
      highlightFillColor: interactiveAccentHover,
      highlightStrokeColor: interactiveAccentHover
    },
    point2: {
      fillColor: interactiveAccent,
      strokeColor: textNormal,
      highlightFillColor: interactiveAccentHover,
      highlightStrokeColor: textMuted
    }
  },
  circumcircle: {
    strokeColor: interactiveAccent,
    highlightFillColor: interactiveAccentHover,
    highlightStrokeColor: interactiveAccentHover,
    center: {
      fillColor: interactiveAccent,
      strokeColor: interactiveAccent,
      highlightFillColor: interactiveAccentHover,
      highlightStrokeColor: interactiveAccentHover
    }
  },
  circumcirclearc: {
    strokeColor: interactiveAccent,
    highlightStrokeColor: interactiveAccentHover
  },
  circumcirclesector: {
    strokeColor: interactiveAccent,
    fillColor: interactiveAccent,
    highlightFillColor: interactiveAccentHover
  },
  comb: {
    strokeColor: interactiveAccent
  },
  conic: {
    strokeColor: interactiveAccent,
    highlightStrokeColor: interactiveAccentHover,
    fillColor: "none",
    highlightFillColor: "none"
  },
  curve: {
    strokeColor: interactiveAccent,
    highlightStrokeColor: interactiveAccentHover
  },
  grid: {
    strokeColor: textMuted,
    highlightStrokeColor: textMuted
  },
  hatch: {
    strokeColor: interactiveAccent,
    highlightStrokeColor: interactiveAccentHover
  },
  incircle: {
    highlightFillColor: "none",
    highlightStrokeColor: interactiveAccentHover,
    center: {
      fillColor: interactiveAccent,
      strokeColor: interactiveAccent,
      highlightFillColor: interactiveAccentHover,
      highlightStrokeColor: interactiveAccentHover
    }
  },
  inequality: {
    fillColor: interactiveAccent
  },
  label: {
    strokeColor: textNormal,
    highlightStrokeColor: textMuted,
    useMathJax: true,
    display: "html",
    parse: false
  },
  line: {
    strokeColor: interactiveAccent,
    highlightStrokeColor: interactiveAccentHover,
    point1: {
      fillColor: interactiveAccent,
      strokeColor: textNormal,
      highlightFillColor: interactiveAccentHover,
      highlightStrokeColor: textMuted
    },
    point2: {
      fillColor: interactiveAccent,
      strokeColor: textNormal,
      highlightFillColor: interactiveAccentHover,
      highlightStrokeColor: textMuted
    }
  },
  normal: {
    strokeColor: interactiveAccent
  },
  parallel: {
    strokeColor: interactiveAccent
  },
  perpendicular: {
    strokeColor: interactiveAccent
  },
  perpendicularsegment: {
    strokeColor: interactiveAccent
  },
  point: {
    fillColor: interactiveAccent,
    strokeColor: textNormal,
    highlightFillColor: interactiveAccentHover,
    highlightStrokeColor: textMuted,
    showInfobox: true
  },
  polygon: {
    fillColor: interactiveAccent,
    highlightFillColor: interactiveAccentHover,
    vertices: {
      fillColor: interactiveAccent,
      strokeColor: textNormal,
      highlightFillColor: interactiveAccentHover,
      highlightStrokeColor: textMuted
    },
    borders: {
      strokeColor: interactiveAccent,
      highlightStrokeColor: interactiveAccentHover
    }
  },
  regularpolygon: {
    fillColor: interactiveAccent,
    highlightFillColor: interactiveAccentHover,
    vertices: {
      fillColor: interactiveAccent,
      strokeColor: textNormal,
      highlightFillColor: interactiveAccentHover,
      highlightStrokeColor: textMuted
    },
    borders: {
      strokeColor: interactiveAccent,
      highlightStrokeColor: interactiveAccentHover
    }
  },
  riemannsum: {
    fillColor: interactiveAccent,
    highlightFillColor: interactiveAccentHover
  },
  sector: {
    strokeColor: interactiveAccent,
    fillColor: interactiveAccent,
    highlightFillColor: interactiveAccentHover
  },
  semicircle: {
    center: {
      fillColor: interactiveAccent,
      strokeColor: interactiveAccent,
      highlightStrokeColor: interactiveAccentHover
    }
  },
  slider: {
    fillColor: interactiveAccent,
    strokeColor: textNormal,
    highlightFillColor: interactiveAccentHover,
    highlightStrokeColor: textMuted,
    baseline: {
      strokeColor: textNormal,
      fillColor: textNormal,
      highlightStrokeColor: textMuted,
      highlightFillColor: textMuted
    },
    label: {
      strokeColor: textNormal,
      fillColor: textNormal,
      highlightStrokeColor: textMuted,
      highlightFillColor: textMuted
    },
    highline: {
      strokeColor: textNormal,
      fillColor: textNormal,
      highlightStrokeColor: textMuted,
      highlightFillColor: textMuted
    },
    ticks: {
      strokeColor: textNormal,
      fillColor: textNormal,
      highlightStrokeColor: textMuted,
      highlightFillColor: textMuted
    }
  },
  slopefield: {
    highlightStrokeColor: interactiveAccentHover
  },
  tapemeasure: {
    strokeColor: interactiveAccent,
    highlightStrokeColor: interactiveAccentHover,
    point1: {
      fillColor: interactiveAccent,
      strokeColor: textNormal,
      highlightFillColor: interactiveAccentHover,
      highlightStrokeColor: textMuted
    },
    point2: {
      fillColor: interactiveAccent,
      strokeColor: textNormal,
      highlightFillColor: interactiveAccentHover,
      highlightStrokeColor: textMuted
    },
    ticks: {
      strokeColor: interactiveAccent,
      highlightStrokeColor: interactiveAccentHover
    }
  },
  text: {
    strokeColor: textNormal,
    highlightStrokeColor: textMuted,
    useMathJax: true,
    display: "html",
    parse: false
  },
  tracecurve: {
    strokeColor: interactiveAccent
  },
  turtle: {
    strokeColor: interactiveAccent,
    arrow: {
      strokeColor: interactiveAccent
    }
  },
  integral: {
    color: interactiveAccent,
    strokeColor: interactiveAccent,
    fillColor: interactiveAccent,
    highlightFillColor: interactiveAccentHover,
    highlightStrokeColor: interactiveAccentHover,
    curveLeft: {
      color: interactiveAccent
    },
    curveRight: {
      color: interactiveAccent
    }
  },
  vectorfield: {
    highlightStrokeColor: interactiveAccentHover
  },
  slopetriangle: {
    fillColor: interactiveAccent,
    highlightFillColor: interactiveAccentHover
  }
};
var obsidian_default = JXG;

// main.ts
var ObsidianGraphs = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.count = 0;
  }
  async onload() {
    await (0, import_obsidian2.loadMathJax)();
    if (typeof MathJax !== "undefined") {
      MathJax.config.tex.inlineMath = [["$", "$"]];
      MathJax.config.tex.processEscapes = true;
      MathJax.config.chtml.adaptiveCSS = false;
      await MathJax.startup.getComponents();
    }
    setMathFunctions();
    this.app.workspace.on("file-open", () => {
      const currentFile = this.app.workspace.getActiveFile();
      if (currentFile) {
        this.currentFileName = currentFile.name.substring(0, currentFile.name.indexOf("."));
        this.currentFileName = this.currentFileName.replace(/\s/g, "");
      }
      const activeFileNames = [];
      const files = this.app.workspace.getLeavesOfType("markdown");
      files.forEach((file) => activeFileNames.push(file.getDisplayText().replace(/\s/g, "")));
      for (const key in boards) {
        let active = false;
        const div = boards[key].containerObj;
        for (const name of activeFileNames) {
          if (div.hasClass(name)) {
            active = true;
            break;
          }
        }
        if (!active) {
          boards[key].containerObj.remove();
          JSXGraph.freeBoard(boards[key]);
        }
      }
    });
    this.registerMarkdownCodeBlockProcessor("graph", (source, element, context) => {
      let graphInfo;
      try {
        graphInfo = parseCodeBlock(source);
      } catch (e) {
        renderError(e, element);
        return;
      }
      let board;
      if (this.currentFileName == void 0) {
        const currentFile = this.app.workspace.getActiveFile();
        if (currentFile) {
          this.currentFileName = currentFile.name.substring(0, currentFile.name.indexOf("."));
          this.currentFileName = this.currentFileName.replace(/\s/g, "");
        }
      }
      const graphDiv = element.createEl("div", { cls: "jxgbox " + this.currentFileName });
      graphDiv.id = "graph" + this.count;
      this.count++;
      try {
        board = createBoard(graphDiv, graphInfo);
      } catch (e) {
        renderError(e, element);
        return;
      }
      const createdElements = [];
      if (graphInfo.elements != void 0) {
        for (let i2 = 0; i2 < graphInfo.elements.length; i2++) {
          try {
            addElement(board, graphInfo.elements[i2], createdElements);
          } catch (e) {
            renderError(e, element);
            return;
          }
        }
      }
    });
  }
  onunload() {
    for (const key in boards) {
      const div = boards[key].containerObj;
      JSXGraph.freeBoard(boards[key]);
      div.remove();
    }
  }
};
